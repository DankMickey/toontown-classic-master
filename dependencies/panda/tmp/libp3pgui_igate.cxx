/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/pgui -Ipanda/src/pgui -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3pgui_igate.cxx -od built/pandac/input/libp3pgui.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/pgui -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3pgui config_pgui.h p3pgui_composite1.cxx p3pgui_composite2.cxx pgButton.h pgButtonNotify.h pgCullTraverser.h pgEntry.h pgFrameStyle.h pgItem.h pgItemNotify.h pgMouseWatcherBackground.h pgMouseWatcherGroup.h pgMouseWatcherParameter.h pgMouseWatcherRegion.h pgScrollFrame.h pgSliderBar.h pgSliderBarNotify.h pgTop.h pgVirtualFrame.h pgWaitBar.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3pgui
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableDouble.h"
#include "config_pgui.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pgButton.h"
#include "pgButtonNotify.h"
#include "pgCullTraverser.h"
#include "pgEntry.h"
#include "pgFrameStyle.h"
#include "pgItem.h"
#include "pgItemNotify.h"
#include "pgMouseWatcherBackground.h"
#include "pgMouseWatcherGroup.h"
#include "pgMouseWatcherParameter.h"
#include "pgMouseWatcherRegion.h"
#include "pgScrollFrame.h"
#include "pgSliderBar.h"
#include "pgSliderBarNotify.h"
#include "pgTop.h"
#include "pgVirtualFrame.h"
#include "pgWaitBar.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class PGFrameStyle
 */
typedef PGFrameStyle PGFrameStyle_localtype;
Define_Module_Class(panda3d.core, PGFrameStyle, PGFrameStyle_localtype, PGFrameStyle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PGFrameStyle = &Dtool_PGFrameStyle;
static void Dtool_PyModuleClassInit_PGFrameStyle(PyObject *module);

/**
 * Forward declarations for top-level class PGItem
 */
typedef PGItem PGItem_localtype;
Define_Module_ClassRef(panda3d.core, PGItem, PGItem_localtype, PGItem);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PGItem = &Dtool_PGItem;
static void Dtool_PyModuleClassInit_PGItem(PyObject *module);
bool Dtool_ConstCoerce_PGItem(PyObject *args, CPT(PGItem) &coerced);
bool Dtool_Coerce_PGItem(PyObject *args, PT(PGItem) &coerced);

/**
 * Forward declarations for top-level class PGButton
 */
typedef PGButton PGButton_localtype;
Define_Module_ClassRef(panda3d.core, PGButton, PGButton_localtype, PGButton);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PGButton = &Dtool_PGButton;
static void Dtool_PyModuleClassInit_PGButton(PyObject *module);
bool Dtool_ConstCoerce_PGButton(PyObject *args, CPT(PGButton) &coerced);
bool Dtool_Coerce_PGButton(PyObject *args, PT(PGButton) &coerced);

/**
 * Forward declarations for top-level class PGTop
 */
typedef PGTop PGTop_localtype;
Define_Module_ClassRef(panda3d.core, PGTop, PGTop_localtype, PGTop);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PGTop = &Dtool_PGTop;
static void Dtool_PyModuleClassInit_PGTop(PyObject *module);
bool Dtool_ConstCoerce_PGTop(PyObject *args, CPT(PGTop) &coerced);
bool Dtool_Coerce_PGTop(PyObject *args, PT(PGTop) &coerced);

/**
 * Forward declarations for top-level class PGEntry
 */
typedef PGEntry PGEntry_localtype;
Define_Module_ClassRef(panda3d.core, PGEntry, PGEntry_localtype, PGEntry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PGEntry = &Dtool_PGEntry;
static void Dtool_PyModuleClassInit_PGEntry(PyObject *module);
bool Dtool_ConstCoerce_PGEntry(PyObject *args, CPT(PGEntry) &coerced);
bool Dtool_Coerce_PGEntry(PyObject *args, PT(PGEntry) &coerced);

/**
 * Forward declarations for top-level class PGMouseWatcherParameter
 */
typedef PGMouseWatcherParameter PGMouseWatcherParameter_localtype;
Define_Module_ClassRef(panda3d.core, PGMouseWatcherParameter, PGMouseWatcherParameter_localtype, PGMouseWatcherParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PGMouseWatcherParameter = &Dtool_PGMouseWatcherParameter;
static void Dtool_PyModuleClassInit_PGMouseWatcherParameter(PyObject *module);

/**
 * Forward declarations for top-level class PGMouseWatcherBackground
 */
typedef PGMouseWatcherBackground PGMouseWatcherBackground_localtype;
Define_Module_ClassRef(panda3d.core, PGMouseWatcherBackground, PGMouseWatcherBackground_localtype, PGMouseWatcherBackground);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PGMouseWatcherBackground = &Dtool_PGMouseWatcherBackground;
static void Dtool_PyModuleClassInit_PGMouseWatcherBackground(PyObject *module);

/**
 * Forward declarations for top-level class PGVirtualFrame
 */
typedef PGVirtualFrame PGVirtualFrame_localtype;
Define_Module_ClassRef(panda3d.core, PGVirtualFrame, PGVirtualFrame_localtype, PGVirtualFrame);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PGVirtualFrame = &Dtool_PGVirtualFrame;
static void Dtool_PyModuleClassInit_PGVirtualFrame(PyObject *module);
bool Dtool_ConstCoerce_PGVirtualFrame(PyObject *args, CPT(PGVirtualFrame) &coerced);
bool Dtool_Coerce_PGVirtualFrame(PyObject *args, PT(PGVirtualFrame) &coerced);

/**
 * Forward declarations for top-level class PGSliderBar
 */
typedef PGSliderBar PGSliderBar_localtype;
Define_Module_ClassRef(panda3d.core, PGSliderBar, PGSliderBar_localtype, PGSliderBar);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PGSliderBar = &Dtool_PGSliderBar;
static void Dtool_PyModuleClassInit_PGSliderBar(PyObject *module);
bool Dtool_ConstCoerce_PGSliderBar(PyObject *args, CPT(PGSliderBar) &coerced);
bool Dtool_Coerce_PGSliderBar(PyObject *args, PT(PGSliderBar) &coerced);

/**
 * Forward declarations for top-level class PGScrollFrame
 */
typedef PGScrollFrame PGScrollFrame_localtype;
Define_Module_ClassRef(panda3d.core, PGScrollFrame, PGScrollFrame_localtype, PGScrollFrame);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PGScrollFrame = &Dtool_PGScrollFrame;
static void Dtool_PyModuleClassInit_PGScrollFrame(PyObject *module);
bool Dtool_ConstCoerce_PGScrollFrame(PyObject *args, CPT(PGScrollFrame) &coerced);
bool Dtool_Coerce_PGScrollFrame(PyObject *args, PT(PGScrollFrame) &coerced);

/**
 * Forward declarations for top-level class PGWaitBar
 */
typedef PGWaitBar PGWaitBar_localtype;
Define_Module_ClassRef(panda3d.core, PGWaitBar, PGWaitBar_localtype, PGWaitBar);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PGWaitBar = &Dtool_PGWaitBar;
static void Dtool_PyModuleClassInit_PGWaitBar(PyObject *module);
bool Dtool_ConstCoerce_PGWaitBar(PyObject *args, CPT(PGWaitBar) &coerced);
bool Dtool_Coerce_PGWaitBar(PyObject *args, PT(PGWaitBar) &coerced);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2f;
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3f;
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != NULL, NULL);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// ButtonHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ButtonHandle;
inline static ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced) {
  nassertr(Dtool_Ptr_ButtonHandle != NULL, NULL);
  nassertr(Dtool_Ptr_ButtonHandle->_Dtool_Coerce != NULL, NULL);
  return ((ButtonHandle *(*)(PyObject *, ButtonHandle &))Dtool_Ptr_ButtonHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ButtonHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonHandle = &Dtool_ButtonHandle;
extern ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced);
#endif
// MouseWatcherRegion
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MouseWatcherRegion;
inline static bool Dtool_ConstCoerce_MouseWatcherRegion(PyObject *args, CPT(MouseWatcherRegion) &coerced) {
  nassertr(Dtool_Ptr_MouseWatcherRegion != NULL, false);
  nassertr(Dtool_Ptr_MouseWatcherRegion->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(MouseWatcherRegion) &))Dtool_Ptr_MouseWatcherRegion->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_MouseWatcherRegion(PyObject *args, PT(MouseWatcherRegion) &coerced) {
  nassertr(Dtool_Ptr_MouseWatcherRegion != NULL, false);
  nassertr(Dtool_Ptr_MouseWatcherRegion->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(MouseWatcherRegion) &))Dtool_Ptr_MouseWatcherRegion->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_MouseWatcherRegion;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseWatcherRegion = &Dtool_MouseWatcherRegion;
extern bool Dtool_ConstCoerce_MouseWatcherRegion(PyObject *args, CPT(MouseWatcherRegion) &coerced);
extern bool Dtool_Coerce_MouseWatcherRegion(PyObject *args, PT(MouseWatcherRegion) &coerced);
#endif
// Texture
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Texture;
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// TransformState
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TransformState;
#else
extern struct Dtool_PyTypedObject Dtool_TransformState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformState = &Dtool_TransformState;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// TextProperties
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TextProperties;
#else
extern struct Dtool_PyTypedObject Dtool_TextProperties;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextProperties = &Dtool_TextProperties;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// AudioSound
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_AudioSound;
#else
extern struct Dtool_PyTypedObject Dtool_AudioSound;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioSound = &Dtool_AudioSound;
#endif
// MouseWatcherGroup
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MouseWatcherGroup;
#else
extern struct Dtool_PyTypedObject Dtool_MouseWatcherGroup;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseWatcherGroup = &Dtool_MouseWatcherGroup;
#endif
// TextGraphic
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TextGraphic;
inline static bool Dtool_ConstCoerce_TextGraphic(PyObject *args, TextGraphic const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_TextGraphic != NULL, false);
  nassertr(Dtool_Ptr_TextGraphic->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, TextGraphic const *&, bool&))Dtool_Ptr_TextGraphic->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_TextGraphic(PyObject *args, TextGraphic *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_TextGraphic != NULL, false);
  nassertr(Dtool_Ptr_TextGraphic->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, TextGraphic *&, bool&))Dtool_Ptr_TextGraphic->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_TextGraphic;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextGraphic = &Dtool_TextGraphic;
extern bool Dtool_ConstCoerce_TextGraphic(PyObject *args, TextGraphic const *&coerced, bool &manage);
extern bool Dtool_Coerce_TextGraphic(PyObject *args, TextGraphic *&coerced, bool &manage);
#endif
// TextNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TextNode;
inline static bool Dtool_ConstCoerce_TextNode(PyObject *args, CPT(TextNode) &coerced) {
  nassertr(Dtool_Ptr_TextNode != NULL, false);
  nassertr(Dtool_Ptr_TextNode->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(TextNode) &))Dtool_Ptr_TextNode->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_TextNode(PyObject *args, PT(TextNode) &coerced) {
  nassertr(Dtool_Ptr_TextNode != NULL, false);
  nassertr(Dtool_Ptr_TextNode->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(TextNode) &))Dtool_Ptr_TextNode->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TextNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextNode = &Dtool_TextNode;
extern bool Dtool_ConstCoerce_TextNode(PyObject *args, CPT(TextNode) &coerced);
extern bool Dtool_Coerce_TextNode(PyObject *args, PT(TextNode) &coerced);
#endif
// MouseWatcherParameter
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MouseWatcherParameter;
#else
extern struct Dtool_PyTypedObject Dtool_MouseWatcherParameter;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseWatcherParameter = &Dtool_MouseWatcherParameter;
#endif
// MouseWatcher
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MouseWatcher;
inline static bool Dtool_ConstCoerce_MouseWatcher(PyObject *args, CPT(MouseWatcher) &coerced) {
  nassertr(Dtool_Ptr_MouseWatcher != NULL, false);
  nassertr(Dtool_Ptr_MouseWatcher->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(MouseWatcher) &))Dtool_Ptr_MouseWatcher->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_MouseWatcher(PyObject *args, PT(MouseWatcher) &coerced) {
  nassertr(Dtool_Ptr_MouseWatcher != NULL, false);
  nassertr(Dtool_Ptr_MouseWatcher->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(MouseWatcher) &))Dtool_Ptr_MouseWatcher->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_MouseWatcher;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseWatcher = &Dtool_MouseWatcher;
extern bool Dtool_ConstCoerce_MouseWatcher(PyObject *args, CPT(MouseWatcher) &coerced);
extern bool Dtool_Coerce_MouseWatcher(PyObject *args, PT(MouseWatcher) &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class PGFrameStyle
 */
/**
 * Python function wrapper for:
 * inline void PGFrameStyle::operator =(PGFrameStyle const &copy)
 */
static PyObject *Dtool_PGFrameStyle_operator_3(PyObject *self, PyObject *arg) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGFrameStyle, (void **)&local_this, "PGFrameStyle.assign")) {
    return NULL;
  }
  // 1-inline void PGFrameStyle::operator =(PGFrameStyle const &copy)
  PGFrameStyle const *arg_this = (PGFrameStyle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PGFrameStyle, 1, "PGFrameStyle.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    PGFrameStyle *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PGFrameStyle, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PGFrameStyle self, const PGFrameStyle copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_operator_3_comment =
  "C++ Interface:\n"
  "assign(const PGFrameStyle self, const PGFrameStyle copy)\n";
#else
static const char *Dtool_PGFrameStyle_operator_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGFrameStyle::set_type(PGFrameStyle::Type type)
 */
static PyObject *Dtool_PGFrameStyle_set_type_6(PyObject *self, PyObject *arg) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGFrameStyle, (void **)&local_this, "PGFrameStyle.set_type")) {
    return NULL;
  }
  // 1-inline void PGFrameStyle::set_type(PGFrameStyle::Type type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_type((PGFrameStyle::Type)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_type(const PGFrameStyle self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_set_type_6_comment =
  "C++ Interface:\n"
  "set_type(const PGFrameStyle self, int type)\n"
  "\n"
  "/**\n"
  " * Sets the basic type of frame.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_set_type_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PGFrameStyle::Type PGFrameStyle::get_type(void) const
 */
static PyObject *Dtool_PGFrameStyle_get_type_7(PyObject *self, PyObject *) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGFrameStyle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PGFrameStyle::Type PGFrameStyle::get_type(void) const
  PGFrameStyle::Type return_value = (*(const PGFrameStyle*)local_this).get_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_get_type_7_comment =
  "C++ Interface:\n"
  "get_type(PGFrameStyle self)\n"
  "\n"
  "/**\n"
  " * Returns the basic type of frame.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_get_type_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGFrameStyle::set_color(LColor const &color)
 * inline void PGFrameStyle::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
 */
static PyObject *Dtool_PGFrameStyle_set_color_8(PyObject *self, PyObject *args, PyObject *kwds) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGFrameStyle, (void **)&local_this, "PGFrameStyle.set_color")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "color");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'color' (pos 1) not found");
      }
      // 1-inline void PGFrameStyle::set_color(LColor const &color)
      LVecBase4f arg_local;
      LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PGFrameStyle.set_color", "LVecBase4f");
      }
      (*local_this).set_color(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void PGFrameStyle::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"r", "g", "b", "a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_color((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const PGFrameStyle self, const LVecBase4f color)\n"
      "set_color(const PGFrameStyle self, float r, float g, float b, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_set_color_8_comment =
  "C++ Interface:\n"
  "set_color(const PGFrameStyle self, const LVecBase4f color)\n"
  "set_color(const PGFrameStyle self, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " * Sets the dominant color of the frame.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the dominant color of the frame.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_set_color_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor PGFrameStyle::get_color(void) const
 */
static PyObject *Dtool_PGFrameStyle_get_color_9(PyObject *self, PyObject *) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGFrameStyle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor PGFrameStyle::get_color(void) const
  LColor *return_value = new LColor((*(const PGFrameStyle*)local_this).get_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_get_color_9_comment =
  "C++ Interface:\n"
  "get_color(PGFrameStyle self)\n"
  "\n"
  "/**\n"
  " * Returns the dominant color of the frame.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_get_color_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGFrameStyle::set_texture(Texture *texture)
 */
static PyObject *Dtool_PGFrameStyle_set_texture_10(PyObject *self, PyObject *arg) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGFrameStyle, (void **)&local_this, "PGFrameStyle.set_texture")) {
    return NULL;
  }
  // 1-inline void PGFrameStyle::set_texture(Texture *texture)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "PGFrameStyle.set_texture", false, true);
  if (arg_this != NULL) {
    (*local_this).set_texture(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture(const PGFrameStyle self, Texture texture)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_set_texture_10_comment =
  "C++ Interface:\n"
  "set_texture(const PGFrameStyle self, Texture texture)\n"
  "\n"
  "/**\n"
  " * Specifies a texture that should be applied to the frame.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_set_texture_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGFrameStyle::has_texture(void) const
 */
static PyObject *Dtool_PGFrameStyle_has_texture_11(PyObject *self, PyObject *) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGFrameStyle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGFrameStyle::has_texture(void) const
  bool return_value = (*(const PGFrameStyle*)local_this).has_texture();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_has_texture_11_comment =
  "C++ Interface:\n"
  "has_texture(PGFrameStyle self)\n"
  "\n"
  "/**\n"
  " * Returns true if a texture has been applied to the frame.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_has_texture_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Texture *PGFrameStyle::get_texture(void) const
 */
static PyObject *Dtool_PGFrameStyle_get_texture_12(PyObject *self, PyObject *) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGFrameStyle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Texture *PGFrameStyle::get_texture(void) const
  Texture *return_value = (*(const PGFrameStyle*)local_this).get_texture();
  if (return_value != (Texture *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Texture *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_get_texture_12_comment =
  "C++ Interface:\n"
  "get_texture(PGFrameStyle self)\n"
  "\n"
  "/**\n"
  " * Returns the texture that has been applied to the frame, or NULL if no\n"
  " * texture has been applied.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_get_texture_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGFrameStyle::clear_texture(void)
 */
static PyObject *Dtool_PGFrameStyle_clear_texture_13(PyObject *self, PyObject *) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGFrameStyle, (void **)&local_this, "PGFrameStyle.clear_texture")) {
    return NULL;
  }
  // 1-inline void PGFrameStyle::clear_texture(void)
  (*local_this).clear_texture();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_clear_texture_13_comment =
  "C++ Interface:\n"
  "clear_texture(const PGFrameStyle self)\n"
  "\n"
  "/**\n"
  " * Removes the texture from the frame.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_clear_texture_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGFrameStyle::set_width(LVecBase2 const &width)
 * inline void PGFrameStyle::set_width(PN_stdfloat x, PN_stdfloat y)
 */
static PyObject *Dtool_PGFrameStyle_set_width_14(PyObject *self, PyObject *args, PyObject *kwds) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGFrameStyle, (void **)&local_this, "PGFrameStyle.set_width")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "width");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'width' (pos 1) not found");
      }
      // 1-inline void PGFrameStyle::set_width(LVecBase2 const &width)
      LVecBase2f arg_local;
      LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PGFrameStyle.set_width", "LVecBase2f");
      }
      (*local_this).set_width(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-inline void PGFrameStyle::set_width(PN_stdfloat x, PN_stdfloat y)
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_width", (char **)keyword_list, &param1, &param2)) {
        (*local_this).set_width((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_width() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_width(const PGFrameStyle self, const LVecBase2f width)\n"
      "set_width(const PGFrameStyle self, float x, float y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_set_width_14_comment =
  "C++ Interface:\n"
  "set_width(const PGFrameStyle self, const LVecBase2f width)\n"
  "set_width(const PGFrameStyle self, float x, float y)\n"
  "\n"
  "/**\n"
  " * Sets the width parameter, which has meaning only for certain frame types.\n"
  " * For instance, this is the width of the bevel for T_bevel_in or T_bevel_out.\n"
  " * The units are in screen units.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the width parameter, which has meaning only for certain frame types.\n"
  " * For instance, this is the width of the bevel for T_bevel_in or T_bevel_out.\n"
  " * The units are in screen units.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_set_width_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 const &PGFrameStyle::get_width(void) const
 */
static PyObject *Dtool_PGFrameStyle_get_width_15(PyObject *self, PyObject *) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGFrameStyle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2 const &PGFrameStyle::get_width(void) const
  LVecBase2 const *return_value = &((*(const PGFrameStyle*)local_this).get_width());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_get_width_15_comment =
  "C++ Interface:\n"
  "get_width(PGFrameStyle self)\n"
  "\n"
  "/**\n"
  " * Returns the width parameter, which has meaning only for certain frame\n"
  " * types.  For instance, this is the width of the bevel for T_bevel_in or\n"
  " * T_bevel_out.  The units are in screen units.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_get_width_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGFrameStyle::set_uv_width(LVecBase2 const &uv_width)
 * inline void PGFrameStyle::set_uv_width(PN_stdfloat u, PN_stdfloat v)
 */
static PyObject *Dtool_PGFrameStyle_set_uv_width_16(PyObject *self, PyObject *args, PyObject *kwds) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGFrameStyle, (void **)&local_this, "PGFrameStyle.set_uv_width")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "uv_width");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'uv_width' (pos 1) not found");
      }
      // 1-inline void PGFrameStyle::set_uv_width(LVecBase2 const &uv_width)
      LVecBase2f arg_local;
      LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PGFrameStyle.set_uv_width", "LVecBase2f");
      }
      (*local_this).set_uv_width(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-inline void PGFrameStyle::set_uv_width(PN_stdfloat u, PN_stdfloat v)
      float param1;
      float param2;
      static const char *keyword_list[] = {"u", "v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_uv_width", (char **)keyword_list, &param1, &param2)) {
        (*local_this).set_uv_width((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_uv_width() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_width(const PGFrameStyle self, const LVecBase2f uv_width)\n"
      "set_uv_width(const PGFrameStyle self, float u, float v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_set_uv_width_16_comment =
  "C++ Interface:\n"
  "set_uv_width(const PGFrameStyle self, const LVecBase2f uv_width)\n"
  "set_uv_width(const PGFrameStyle self, float u, float v)\n"
  "\n"
  "/**\n"
  " * Sets the uv_width parameter, which indicates the amount of the texture that\n"
  " * is consumed by the inner bevel--the width in texture space of the amount\n"
  " * indicated by set_width.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the uv_width parameter, which indicates the amount of the texture that\n"
  " * is consumed by the inner bevel--the width in texture space of the amount\n"
  " * indicated by set_width.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_set_uv_width_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 const &PGFrameStyle::get_uv_width(void) const
 */
static PyObject *Dtool_PGFrameStyle_get_uv_width_17(PyObject *self, PyObject *) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGFrameStyle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2 const &PGFrameStyle::get_uv_width(void) const
  LVecBase2 const *return_value = &((*(const PGFrameStyle*)local_this).get_uv_width());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_get_uv_width_17_comment =
  "C++ Interface:\n"
  "get_uv_width(PGFrameStyle self)\n"
  "\n"
  "/**\n"
  " * See set_uv_width().\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_get_uv_width_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGFrameStyle::set_visible_scale(LVecBase2 const &visible_scale)
 * inline void PGFrameStyle::set_visible_scale(PN_stdfloat x, PN_stdfloat y)
 */
static PyObject *Dtool_PGFrameStyle_set_visible_scale_18(PyObject *self, PyObject *args, PyObject *kwds) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGFrameStyle, (void **)&local_this, "PGFrameStyle.set_visible_scale")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "visible_scale");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'visible_scale' (pos 1) not found");
      }
      // 1-inline void PGFrameStyle::set_visible_scale(LVecBase2 const &visible_scale)
      LVecBase2f arg_local;
      LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PGFrameStyle.set_visible_scale", "LVecBase2f");
      }
      (*local_this).set_visible_scale(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-inline void PGFrameStyle::set_visible_scale(PN_stdfloat x, PN_stdfloat y)
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_visible_scale", (char **)keyword_list, &param1, &param2)) {
        (*local_this).set_visible_scale((PN_stdfloat)param1, (PN_stdfloat)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_visible_scale() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_visible_scale(const PGFrameStyle self, const LVecBase2f visible_scale)\n"
      "set_visible_scale(const PGFrameStyle self, float x, float y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_set_visible_scale_18_comment =
  "C++ Interface:\n"
  "set_visible_scale(const PGFrameStyle self, const LVecBase2f visible_scale)\n"
  "set_visible_scale(const PGFrameStyle self, float x, float y)\n"
  "\n"
  "/**\n"
  " * Sets a scale factor on the visible representation of the frame, in the X\n"
  " * and Y directions.  If this scale factor is other than 1, it will affect the\n"
  " * size of the visible frame representation within the actual frame border.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets a scale factor on the visible representation of the frame, in the X\n"
  " * and Y directions.  If this scale factor is other than 1, it will affect the\n"
  " * size of the visible frame representation within the actual frame border.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_set_visible_scale_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2 const &PGFrameStyle::get_visible_scale(void) const
 */
static PyObject *Dtool_PGFrameStyle_get_visible_scale_19(PyObject *self, PyObject *) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGFrameStyle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2 const &PGFrameStyle::get_visible_scale(void) const
  LVecBase2 const *return_value = &((*(const PGFrameStyle*)local_this).get_visible_scale());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_get_visible_scale_19_comment =
  "C++ Interface:\n"
  "get_visible_scale(PGFrameStyle self)\n"
  "\n"
  "/**\n"
  " * Returns the scale factor on the visible representation of the frame, in the\n"
  " * X and Y directions.  If this scale factor is other than 1, it will affect\n"
  " * the size of the visible frame representation within the actual frame\n"
  " * border.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_get_visible_scale_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase4 PGFrameStyle::get_internal_frame(LVecBase4 const &frame) const
 */
static PyObject *Dtool_PGFrameStyle_get_internal_frame_20(PyObject *self, PyObject *arg) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGFrameStyle, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVecBase4 PGFrameStyle::get_internal_frame(LVecBase4 const &frame) const
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGFrameStyle.get_internal_frame", "LVecBase4f");
  }
  LVecBase4 *return_value = new LVecBase4((*(const PGFrameStyle*)local_this).get_internal_frame(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_internal_frame(PGFrameStyle self, const LVecBase4f frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_get_internal_frame_20_comment =
  "C++ Interface:\n"
  "get_internal_frame(PGFrameStyle self, const LVecBase4f frame)\n"
  "\n"
  "/**\n"
  " * Computes the size of the internal frame, given the indicated external\n"
  " * frame, appropriate for this kind of frame style.  This simply subtracts the\n"
  " * border width for those frame styles that include a border.\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_get_internal_frame_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGFrameStyle::output(ostream &out) const
 */
static PyObject *Dtool_PGFrameStyle_output_21(PyObject *self, PyObject *arg) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGFrameStyle, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PGFrameStyle::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PGFrameStyle.output", false, true);
  if (arg_this != NULL) {
    (*(const PGFrameStyle*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PGFrameStyle self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGFrameStyle_output_21_comment =
  "C++ Interface:\n"
  "output(PGFrameStyle self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PGFrameStyle_output_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PGFrameStyle::PGFrameStyle(void)
 * inline PGFrameStyle::PGFrameStyle(PGFrameStyle const &copy)
 */
static int Dtool_Init_PGFrameStyle(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PGFrameStyle::PGFrameStyle(void)
      PGFrameStyle *return_value = new PGFrameStyle();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGFrameStyle, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline PGFrameStyle::PGFrameStyle(PGFrameStyle const &copy)
      PGFrameStyle const *arg_this = (PGFrameStyle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PGFrameStyle, 0, "PGFrameStyle.PGFrameStyle", true, true);
      if (arg_this != NULL) {
        PGFrameStyle *return_value = new PGFrameStyle(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGFrameStyle, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PGFrameStyle() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PGFrameStyle()\n"
      "PGFrameStyle(const PGFrameStyle copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PGFrameStyle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PGFrameStyle) {
    printf("PGFrameStyle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PGFrameStyle *local_this = (PGFrameStyle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PGFrameStyle) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PGFrameStyle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PGFrameStyle) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PGItem
 */
/**
 * Python function wrapper for:
 * inline void PGItem::set_name(std::string const &name)
 */
static PyObject *Dtool_PGItem_set_name_25(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.set_name")) {
    return NULL;
  }
  // 1-inline void PGItem::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const PGItem self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_set_name_25_comment =
  "C++ Interface:\n"
  "set_name(const PGItem self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PGItem_set_name_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGItem::set_frame(LVecBase4 const &frame)
 * inline void PGItem::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_PGItem_set_frame_26(PyObject *self, PyObject *args, PyObject *kwds) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.set_frame")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "frame");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'frame' (pos 1) not found");
      }
      // 1-inline void PGItem::set_frame(LVecBase4 const &frame)
      LVecBase4f arg_local;
      LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PGItem.set_frame", "LVecBase4f");
      }
      (*local_this).set_frame(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void PGItem::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"left", "right", "bottom", "top", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_frame", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_frame((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_frame() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame(const PGItem self, const LVecBase4f frame)\n"
      "set_frame(const PGItem self, float left, float right, float bottom, float top)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_set_frame_26_comment =
  "C++ Interface:\n"
  "set_frame(const PGItem self, const LVecBase4f frame)\n"
  "set_frame(const PGItem self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Sets the bounding rectangle of the item, in local coordinates.  This is the\n"
  " * region on screen within which the mouse will be considered to be within the\n"
  " * item.  Normally, it should correspond to the bounding rectangle of the\n"
  " * visible geometry of the item.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the bounding rectangle of the item, in local coordinates.  This is the\n"
  " * region on screen within which the mouse will be considered to be within the\n"
  " * item.  Normally, it should correspond to the bounding rectangle of the\n"
  " * visible geometry of the item.\n"
  " */";
#else
static const char *Dtool_PGItem_set_frame_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &PGItem::get_frame(void) const
 */
static PyObject *Dtool_PGItem_get_frame_27(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4 const &PGItem::get_frame(void) const
  LVecBase4 const *return_value = &((*(const PGItem*)local_this).get_frame());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_frame_27_comment =
  "C++ Interface:\n"
  "get_frame(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns the bounding rectangle of the item.  See set_frame().  It is an\n"
  " * error to call this if has_frame() returns false.\n"
  " */";
#else
static const char *Dtool_PGItem_get_frame_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGItem::has_frame(void) const
 */
static PyObject *Dtool_PGItem_has_frame_28(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGItem::has_frame(void) const
  bool return_value = (*(const PGItem*)local_this).has_frame();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_has_frame_28_comment =
  "C++ Interface:\n"
  "has_frame(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns true if the item has a bounding rectangle; see set_frame().\n"
  " */";
#else
static const char *Dtool_PGItem_has_frame_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGItem::clear_frame(void)
 */
static PyObject *Dtool_PGItem_clear_frame_29(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.clear_frame")) {
    return NULL;
  }
  // 1-inline void PGItem::clear_frame(void)
  (*local_this).clear_frame();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGItem_clear_frame_29_comment =
  "C++ Interface:\n"
  "clear_frame(const PGItem self)\n"
  "\n"
  "/**\n"
  " * Removes the bounding rectangle from the item.  It will no longer be\n"
  " * possible to position the mouse within the item; see set_frame().\n"
  " */";
#else
static const char *Dtool_PGItem_clear_frame_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGItem::set_state(int state)
 */
static PyObject *Dtool_PGItem_set_state_30(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.set_state")) {
    return NULL;
  }
  // 1-inline void PGItem::set_state(int state)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_state((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_state(const PGItem self, int state)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_set_state_30_comment =
  "C++ Interface:\n"
  "set_state(const PGItem self, int state)\n"
  "\n"
  "/**\n"
  " * Sets the \"state\" of this particular PGItem.\n"
  " *\n"
  " * The PGItem node will render as if it were the subgraph assigned to the\n"
  " * corresponding index via set_state_def().\n"
  " */";
#else
static const char *Dtool_PGItem_set_state_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PGItem::get_state(void) const
 */
static PyObject *Dtool_PGItem_get_state_31(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PGItem::get_state(void) const
  int return_value = (*(const PGItem*)local_this).get_state();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_state_31_comment =
  "C++ Interface:\n"
  "get_state(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns the \"state\" of this particular PGItem.  See set_state().\n"
  " */";
#else
static const char *Dtool_PGItem_get_state_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PGItem::set_active(bool active)
 */
static PyObject *Dtool_PGItem_set_active_32(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.set_active")) {
    return NULL;
  }
  // 1-virtual void PGItem::set_active(bool active)
  (*local_this).set_active((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const PGItem self, bool active)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_set_active_32_comment =
  "C++ Interface:\n"
  "set_active(const PGItem self, bool active)\n"
  "\n"
  "/**\n"
  " * Sets whether the PGItem is active for mouse watching.  This is not\n"
  " * necessarily related to the active/inactive appearance of the item, which is\n"
  " * controlled by set_state(), but it does affect whether it responds to mouse\n"
  " * events.\n"
  " */";
#else
static const char *Dtool_PGItem_set_active_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGItem::get_active(void) const
 */
static PyObject *Dtool_PGItem_get_active_33(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGItem::get_active(void) const
  bool return_value = (*(const PGItem*)local_this).get_active();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_active_33_comment =
  "C++ Interface:\n"
  "get_active(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns whether the PGItem is currently active for mouse events.  See\n"
  " * set_active().\n"
  " */";
#else
static const char *Dtool_PGItem_get_active_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PGItem::set_focus(bool focus)
 */
static PyObject *Dtool_PGItem_set_focus_34(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.set_focus")) {
    return NULL;
  }
  // 1-virtual void PGItem::set_focus(bool focus)
  (*local_this).set_focus((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_focus(const PGItem self, bool focus)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_set_focus_34_comment =
  "C++ Interface:\n"
  "set_focus(const PGItem self, bool focus)\n"
  "\n"
  "/**\n"
  " * Sets whether the PGItem currently has keyboard focus.  This simply means\n"
  " * that the item may respond to keyboard events as well as to mouse events;\n"
  " * precisely what this means is up to the individual item.\n"
  " *\n"
  " * Only one PGItem in the world is allowed to have focus at any given time.\n"
  " * Setting the focus on any other item automatically disables the focus from\n"
  " * the previous item.\n"
  " */";
#else
static const char *Dtool_PGItem_set_focus_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGItem::get_focus(void) const
 */
static PyObject *Dtool_PGItem_get_focus_35(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGItem::get_focus(void) const
  bool return_value = (*(const PGItem*)local_this).get_focus();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_focus_35_comment =
  "C++ Interface:\n"
  "get_focus(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns whether the PGItem currently has focus for keyboard events.  See\n"
  " * set_focus().\n"
  " */";
#else
static const char *Dtool_PGItem_get_focus_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGItem::set_background_focus(bool focus)
 */
static PyObject *Dtool_PGItem_set_background_focus_36(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.set_background_focus")) {
    return NULL;
  }
  // 1-void PGItem::set_background_focus(bool focus)
  (*local_this).set_background_focus((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_background_focus(const PGItem self, bool focus)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_set_background_focus_36_comment =
  "C++ Interface:\n"
  "set_background_focus(const PGItem self, bool focus)\n"
  "\n"
  "/**\n"
  " * Sets the background_focus flag for this item.  When background_focus is\n"
  " * enabled, the item will receive keypress events even if it is not in focus;\n"
  " * in fact, even if it is not onscreen.  Unlike normal focus, many items may\n"
  " * have background_focus simultaneously.\n"
  " */";
#else
static const char *Dtool_PGItem_set_background_focus_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGItem::get_background_focus(void) const
 */
static PyObject *Dtool_PGItem_get_background_focus_37(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGItem::get_background_focus(void) const
  bool return_value = (*(const PGItem*)local_this).get_background_focus();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_background_focus_37_comment =
  "C++ Interface:\n"
  "get_background_focus(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns whether background_focus is currently enabled.  See\n"
  " * set_background_focus().\n"
  " */";
#else
static const char *Dtool_PGItem_get_background_focus_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGItem::set_suppress_flags(int suppress_flags)
 */
static PyObject *Dtool_PGItem_set_suppress_flags_38(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.set_suppress_flags")) {
    return NULL;
  }
  // 1-inline void PGItem::set_suppress_flags(int suppress_flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_suppress_flags((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_suppress_flags(const PGItem self, int suppress_flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_set_suppress_flags_38_comment =
  "C++ Interface:\n"
  "set_suppress_flags(const PGItem self, int suppress_flags)\n"
  "\n"
  "/**\n"
  " * This is just an interface to set the suppress flags on the underlying\n"
  " * MouseWatcherRegion.  See MouseWatcherRegion::set_suppress_flags().\n"
  " */";
#else
static const char *Dtool_PGItem_set_suppress_flags_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PGItem::get_suppress_flags(void) const
 */
static PyObject *Dtool_PGItem_get_suppress_flags_39(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PGItem::get_suppress_flags(void) const
  int return_value = (*(const PGItem*)local_this).get_suppress_flags();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_suppress_flags_39_comment =
  "C++ Interface:\n"
  "get_suppress_flags(PGItem self)\n"
  "\n"
  "/**\n"
  " * This is just an interface to get the suppress flags on the underlying\n"
  " * MouseWatcherRegion.  See MouseWatcherRegion::get_suppress_flags().\n"
  " */";
#else
static const char *Dtool_PGItem_get_suppress_flags_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int PGItem::get_num_state_defs(void) const
 */
static PyObject *Dtool_PGItem_get_num_state_defs_40(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-int PGItem::get_num_state_defs(void) const
  int return_value = (*(const PGItem*)local_this).get_num_state_defs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_num_state_defs_40_comment =
  "C++ Interface:\n"
  "get_num_state_defs(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns one more than the highest-numbered state def that was ever assigned\n"
  " * to the PGItem.  The complete set of state defs assigned may then be\n"
  " * retrieved by indexing from 0 to (get_num_state_defs() - 1).\n"
  " *\n"
  " * This is only an upper limit on the actual number of state defs, since there\n"
  " * may be holes in the list.\n"
  " */";
#else
static const char *Dtool_PGItem_get_num_state_defs_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGItem::clear_state_def(int state)
 */
static PyObject *Dtool_PGItem_clear_state_def_41(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.clear_state_def")) {
    return NULL;
  }
  // 1-void PGItem::clear_state_def(int state)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).clear_state_def((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_state_def(const PGItem self, int state)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_clear_state_def_41_comment =
  "C++ Interface:\n"
  "clear_state_def(const PGItem self, int state)\n"
  "\n"
  "/**\n"
  " * Resets the NodePath assigned to the indicated state to its initial default,\n"
  " * with only a frame representation if appropriate.\n"
  " */";
#else
static const char *Dtool_PGItem_clear_state_def_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PGItem::has_state_def(int state) const
 */
static PyObject *Dtool_PGItem_has_state_def_42(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PGItem::has_state_def(int state) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const PGItem*)local_this).has_state_def((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_state_def(PGItem self, int state)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_has_state_def_42_comment =
  "C++ Interface:\n"
  "has_state_def(PGItem self, int state)\n"
  "\n"
  "/**\n"
  " * Returns true if get_state_def() has ever been called for the indicated\n"
  " * state (thus defining a render subgraph for this state index), false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PGItem_has_state_def_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath &PGItem::get_state_def(int state)
 */
static PyObject *Dtool_PGItem_get_state_def_43(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.get_state_def")) {
    return NULL;
  }
  // 1-NodePath &PGItem::get_state_def(int state)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = &((*local_this).get_state_def((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_state_def(const PGItem self, int state)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_state_def_43_comment =
  "C++ Interface:\n"
  "get_state_def(const PGItem self, int state)\n"
  "\n"
  "/**\n"
  " * Returns the Node that is the root of the subgraph that will be drawn when\n"
  " * the PGItem is in the indicated state.  The first time this is called for a\n"
  " * particular state index, it may create the Node.\n"
  " */";
#else
static const char *Dtool_PGItem_get_state_def_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath PGItem::instance_to_state_def(int state, NodePath const &path)
 */
static PyObject *Dtool_PGItem_instance_to_state_def_45(PyObject *self, PyObject *args, PyObject *kwds) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.instance_to_state_def")) {
    return NULL;
  }
  // 1-NodePath PGItem::instance_to_state_def(int state, NodePath const &path)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"state", "path", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:instance_to_state_def", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "PGItem.instance_to_state_def", true, true);
    if (param2_this != NULL) {
      NodePath *return_value = new NodePath((*local_this).instance_to_state_def((int)param1, *param2_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "instance_to_state_def(const PGItem self, int state, const NodePath path)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_instance_to_state_def_45_comment =
  "C++ Interface:\n"
  "instance_to_state_def(const PGItem self, int state, const NodePath path)\n"
  "\n"
  "/**\n"
  " * Parents an instance of the bottom node of the indicated NodePath to the\n"
  " * indicated state index.\n"
  " */";
#else
static const char *Dtool_PGItem_instance_to_state_def_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGFrameStyle PGItem::get_frame_style(int state)
 */
static PyObject *Dtool_PGItem_get_frame_style_46(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.get_frame_style")) {
    return NULL;
  }
  // 1-PGFrameStyle PGItem::get_frame_style(int state)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PGFrameStyle *return_value = new PGFrameStyle((*local_this).get_frame_style((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PGFrameStyle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_frame_style(const PGItem self, int state)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_frame_style_46_comment =
  "C++ Interface:\n"
  "get_frame_style(const PGItem self, int state)\n"
  "\n"
  "/**\n"
  " * Returns the kind of frame that will be drawn behind the item when it is in\n"
  " * the indicated state.\n"
  " */";
#else
static const char *Dtool_PGItem_get_frame_style_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGItem::set_frame_style(int state, PGFrameStyle const &style)
 */
static PyObject *Dtool_PGItem_set_frame_style_47(PyObject *self, PyObject *args, PyObject *kwds) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.set_frame_style")) {
    return NULL;
  }
  // 1-void PGItem::set_frame_style(int state, PGFrameStyle const &style)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"state", "style", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_frame_style", (char **)keyword_list, &param1, &param2)) {
    PGFrameStyle const *param2_this = (PGFrameStyle *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PGFrameStyle, 2, "PGItem.set_frame_style", true, true);
    if (param2_this != NULL) {
      (*local_this).set_frame_style((int)param1, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_style(const PGItem self, int state, const PGFrameStyle style)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_set_frame_style_47_comment =
  "C++ Interface:\n"
  "set_frame_style(const PGItem self, int state, const PGFrameStyle style)\n"
  "\n"
  "/**\n"
  " * Changes the kind of frame that will be drawn behind the item when it is in\n"
  " * the indicated state.\n"
  " */";
#else
static const char *Dtool_PGItem_set_frame_style_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &PGItem::get_id(void) const
 */
static PyObject *Dtool_PGItem_get_id_48(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &PGItem::get_id(void) const
  std::string const &return_value = (*(const PGItem*)local_this).get_id();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_id_48_comment =
  "C++ Interface:\n"
  "get_id(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns the unique ID assigned to this PGItem.  This will be assigned to\n"
  " * the region created with the MouseWatcher, and will thus be used to generate\n"
  " * event names.\n"
  " */";
#else
static const char *Dtool_PGItem_get_id_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGItem::set_id(std::string const &id)
 */
static PyObject *Dtool_PGItem_set_id_49(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.set_id")) {
    return NULL;
  }
  // 1-inline void PGItem::set_id(std::string const &id)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_id(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_id(const PGItem self, str id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_set_id_49_comment =
  "C++ Interface:\n"
  "set_id(const PGItem self, str id)\n"
  "\n"
  "/**\n"
  " * Set the unique ID assigned to this PGItem.  It is the user's responsibility\n"
  " * to ensure that this ID is unique.\n"
  " *\n"
  " * Normally, this should not need to be called, as the PGItem will assign\n"
  " * itself an ID when it is created, but this function allows the user to\n"
  " * decide to redefine the ID to be something possibly more meaningful.\n"
  " */";
#else
static const char *Dtool_PGItem_set_id_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGItem::get_enter_prefix(void)
 */
static PyObject *Dtool_PGItem_get_enter_prefix_50(PyObject *, PyObject *) {
  // 1-static inline std::string PGItem::get_enter_prefix(void)
  std::string return_value = PGItem::get_enter_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_enter_prefix_50_comment =
  "C++ Interface:\n"
  "get_enter_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the enter event for all PGItems.\n"
  " * The enter event is the concatenation of this string followed by get_id().\n"
  " */";
#else
static const char *Dtool_PGItem_get_enter_prefix_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGItem::get_exit_prefix(void)
 */
static PyObject *Dtool_PGItem_get_exit_prefix_51(PyObject *, PyObject *) {
  // 1-static inline std::string PGItem::get_exit_prefix(void)
  std::string return_value = PGItem::get_exit_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_exit_prefix_51_comment =
  "C++ Interface:\n"
  "get_exit_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the exit event for all PGItems.\n"
  " * The exit event is the concatenation of this string followed by get_id().\n"
  " */";
#else
static const char *Dtool_PGItem_get_exit_prefix_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGItem::get_within_prefix(void)
 */
static PyObject *Dtool_PGItem_get_within_prefix_52(PyObject *, PyObject *) {
  // 1-static inline std::string PGItem::get_within_prefix(void)
  std::string return_value = PGItem::get_within_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_within_prefix_52_comment =
  "C++ Interface:\n"
  "get_within_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the within event for all PGItems.\n"
  " * The within event is the concatenation of this string followed by get_id().\n"
  " */";
#else
static const char *Dtool_PGItem_get_within_prefix_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGItem::get_without_prefix(void)
 */
static PyObject *Dtool_PGItem_get_without_prefix_53(PyObject *, PyObject *) {
  // 1-static inline std::string PGItem::get_without_prefix(void)
  std::string return_value = PGItem::get_without_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_without_prefix_53_comment =
  "C++ Interface:\n"
  "get_without_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the without event for all\n"
  " * PGItems.  The without event is the concatenation of this string followed by\n"
  " * get_id().\n"
  " */";
#else
static const char *Dtool_PGItem_get_without_prefix_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGItem::get_focus_in_prefix(void)
 */
static PyObject *Dtool_PGItem_get_focus_in_prefix_54(PyObject *, PyObject *) {
  // 1-static inline std::string PGItem::get_focus_in_prefix(void)
  std::string return_value = PGItem::get_focus_in_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_focus_in_prefix_54_comment =
  "C++ Interface:\n"
  "get_focus_in_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the focus_in event for all\n"
  " * PGItems.  The focus_in event is the concatenation of this string followed\n"
  " * by get_id().\n"
  " *\n"
  " * Unlike most item events, this event is thrown with no parameters.\n"
  " */";
#else
static const char *Dtool_PGItem_get_focus_in_prefix_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGItem::get_focus_out_prefix(void)
 */
static PyObject *Dtool_PGItem_get_focus_out_prefix_55(PyObject *, PyObject *) {
  // 1-static inline std::string PGItem::get_focus_out_prefix(void)
  std::string return_value = PGItem::get_focus_out_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_focus_out_prefix_55_comment =
  "C++ Interface:\n"
  "get_focus_out_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the focus_out event for all\n"
  " * PGItems.  The focus_out event is the concatenation of this string followed\n"
  " * by get_id().\n"
  " *\n"
  " * Unlike most item events, this event is thrown with no parameters.\n"
  " */";
#else
static const char *Dtool_PGItem_get_focus_out_prefix_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGItem::get_press_prefix(void)
 */
static PyObject *Dtool_PGItem_get_press_prefix_56(PyObject *, PyObject *) {
  // 1-static inline std::string PGItem::get_press_prefix(void)
  std::string return_value = PGItem::get_press_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_press_prefix_56_comment =
  "C++ Interface:\n"
  "get_press_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the press event for all PGItems.\n"
  " * The press event is the concatenation of this string followed by a button\n"
  " * name, followed by a hyphen and get_id().\n"
  " */";
#else
static const char *Dtool_PGItem_get_press_prefix_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGItem::get_repeat_prefix(void)
 */
static PyObject *Dtool_PGItem_get_repeat_prefix_57(PyObject *, PyObject *) {
  // 1-static inline std::string PGItem::get_repeat_prefix(void)
  std::string return_value = PGItem::get_repeat_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_repeat_prefix_57_comment =
  "C++ Interface:\n"
  "get_repeat_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the repeat event for all PGItems.\n"
  " * The repeat event is the concatenation of this string followed by a button\n"
  " * name, followed by a hyphen and get_id().\n"
  " */";
#else
static const char *Dtool_PGItem_get_repeat_prefix_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGItem::get_release_prefix(void)
 */
static PyObject *Dtool_PGItem_get_release_prefix_58(PyObject *, PyObject *) {
  // 1-static inline std::string PGItem::get_release_prefix(void)
  std::string return_value = PGItem::get_release_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_release_prefix_58_comment =
  "C++ Interface:\n"
  "get_release_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the release event for all\n"
  " * PGItems.  The release event is the concatenation of this string followed by\n"
  " * a button name, followed by a hyphen and get_id().\n"
  " */";
#else
static const char *Dtool_PGItem_get_release_prefix_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGItem::get_keystroke_prefix(void)
 */
static PyObject *Dtool_PGItem_get_keystroke_prefix_59(PyObject *, PyObject *) {
  // 1-static inline std::string PGItem::get_keystroke_prefix(void)
  std::string return_value = PGItem::get_keystroke_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_keystroke_prefix_59_comment =
  "C++ Interface:\n"
  "get_keystroke_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the keystroke event for all\n"
  " * PGItems.  The keystroke event is the concatenation of this string followed\n"
  " * by a hyphen and get_id().\n"
  " */";
#else
static const char *Dtool_PGItem_get_keystroke_prefix_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGItem::get_enter_event(void) const
 */
static PyObject *Dtool_PGItem_get_enter_event_60(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGItem::get_enter_event(void) const
  std::string return_value = (*(const PGItem*)local_this).get_enter_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_enter_event_60_comment =
  "C++ Interface:\n"
  "get_enter_event(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the item is active and the\n"
  " * mouse enters its frame, but not any nested frames.\n"
  " */";
#else
static const char *Dtool_PGItem_get_enter_event_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGItem::get_exit_event(void) const
 */
static PyObject *Dtool_PGItem_get_exit_event_61(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGItem::get_exit_event(void) const
  std::string return_value = (*(const PGItem*)local_this).get_exit_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_exit_event_61_comment =
  "C++ Interface:\n"
  "get_exit_event(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the item is active and the\n"
  " * mouse exits its frame, or enters a nested frame.\n"
  " */";
#else
static const char *Dtool_PGItem_get_exit_event_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGItem::get_within_event(void) const
 */
static PyObject *Dtool_PGItem_get_within_event_62(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGItem::get_within_event(void) const
  std::string return_value = (*(const PGItem*)local_this).get_within_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_within_event_62_comment =
  "C++ Interface:\n"
  "get_within_event(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the item is active and the\n"
  " * mouse moves within the boundaries of the frame.  This is different from the\n"
  " * enter_event in that the mouse is considered within the frame even if it is\n"
  " * also within a nested frame.\n"
  " */";
#else
static const char *Dtool_PGItem_get_within_event_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGItem::get_without_event(void) const
 */
static PyObject *Dtool_PGItem_get_without_event_63(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGItem::get_without_event(void) const
  std::string return_value = (*(const PGItem*)local_this).get_without_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_without_event_63_comment =
  "C++ Interface:\n"
  "get_without_event(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the item is active and the\n"
  " * mouse moves completely outside the boundaries of the frame.  This is\n"
  " * different from the exit_event in that the mouse is considered within the\n"
  " * frame even if it is also within a nested frame.\n"
  " */";
#else
static const char *Dtool_PGItem_get_without_event_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGItem::get_focus_in_event(void) const
 */
static PyObject *Dtool_PGItem_get_focus_in_event_64(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGItem::get_focus_in_event(void) const
  std::string return_value = (*(const PGItem*)local_this).get_focus_in_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_focus_in_event_64_comment =
  "C++ Interface:\n"
  "get_focus_in_event(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the item gets the keyboard\n"
  " * focus.\n"
  " */";
#else
static const char *Dtool_PGItem_get_focus_in_event_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGItem::get_focus_out_event(void) const
 */
static PyObject *Dtool_PGItem_get_focus_out_event_65(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGItem::get_focus_out_event(void) const
  std::string return_value = (*(const PGItem*)local_this).get_focus_out_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_focus_out_event_65_comment =
  "C++ Interface:\n"
  "get_focus_out_event(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the item loses the keyboard\n"
  " * focus.\n"
  " */";
#else
static const char *Dtool_PGItem_get_focus_out_event_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGItem::get_press_event(ButtonHandle const &button) const
 */
static PyObject *Dtool_PGItem_get_press_event_66(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGItem::get_press_event(ButtonHandle const &button) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGItem.get_press_event", "ButtonHandle");
  }
  std::string return_value = (*(const PGItem*)local_this).get_press_event(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_press_event(PGItem self, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_press_event_66_comment =
  "C++ Interface:\n"
  "get_press_event(PGItem self, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the item is active and the\n"
  " * indicated mouse or keyboard button is depressed while the mouse is within\n"
  " * the frame.\n"
  " */";
#else
static const char *Dtool_PGItem_get_press_event_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGItem::get_repeat_event(ButtonHandle const &button) const
 */
static PyObject *Dtool_PGItem_get_repeat_event_67(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGItem::get_repeat_event(ButtonHandle const &button) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGItem.get_repeat_event", "ButtonHandle");
  }
  std::string return_value = (*(const PGItem*)local_this).get_repeat_event(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_repeat_event(PGItem self, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_repeat_event_67_comment =
  "C++ Interface:\n"
  "get_repeat_event(PGItem self, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the item is active and the\n"
  " * indicated mouse or keyboard button is continuously held down while the\n"
  " * mouse is within the frame.\n"
  " */";
#else
static const char *Dtool_PGItem_get_repeat_event_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGItem::get_release_event(ButtonHandle const &button) const
 */
static PyObject *Dtool_PGItem_get_release_event_68(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGItem::get_release_event(ButtonHandle const &button) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGItem.get_release_event", "ButtonHandle");
  }
  std::string return_value = (*(const PGItem*)local_this).get_release_event(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_release_event(PGItem self, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_release_event_68_comment =
  "C++ Interface:\n"
  "get_release_event(PGItem self, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the item is active and the\n"
  " * indicated mouse or keyboard button, formerly clicked down is within the\n"
  " * frame, is released.\n"
  " */";
#else
static const char *Dtool_PGItem_get_release_event_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGItem::get_keystroke_event(void) const
 */
static PyObject *Dtool_PGItem_get_keystroke_event_69(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGItem::get_keystroke_event(void) const
  std::string return_value = (*(const PGItem*)local_this).get_keystroke_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_keystroke_event_69_comment =
  "C++ Interface:\n"
  "get_keystroke_event(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the item is active and any\n"
  " * key is pressed by the user.\n"
  " */";
#else
static const char *Dtool_PGItem_get_keystroke_event_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 PGItem::get_frame_inv_xform(void) const
 */
static PyObject *Dtool_PGItem_get_frame_inv_xform_70(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4 PGItem::get_frame_inv_xform(void) const
  LMatrix4 *return_value = new LMatrix4((*(const PGItem*)local_this).get_frame_inv_xform());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_frame_inv_xform_70_comment =
  "C++ Interface:\n"
  "get_frame_inv_xform(PGItem self)\n"
  "\n"
  "/**\n"
  " * Returns the inverse of the frame transform matrix\n"
  " */";
#else
static const char *Dtool_PGItem_get_frame_inv_xform_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGItem::set_sound(std::string const &event, AudioSound *sound)
 */
static PyObject *Dtool_PGItem_set_sound_71(PyObject *self, PyObject *args, PyObject *kwds) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.set_sound")) {
    return NULL;
  }
  // 1-void PGItem::set_sound(std::string const &event, AudioSound *sound)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"event", "sound", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_sound", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    AudioSound *param2_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_AudioSound, 2, "PGItem.set_sound", false, true);
    if (param2_this != NULL) {
      (*local_this).set_sound(std::string(param1_str, param1_len), param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sound(const PGItem self, str event, AudioSound sound)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_set_sound_71_comment =
  "C++ Interface:\n"
  "set_sound(const PGItem self, str event, AudioSound sound)\n"
  "\n"
  "/**\n"
  " * Sets the sound that will be played whenever the indicated event occurs.\n"
  " */";
#else
static const char *Dtool_PGItem_set_sound_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGItem::clear_sound(std::string const &event)
 */
static PyObject *Dtool_PGItem_clear_sound_72(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.clear_sound")) {
    return NULL;
  }
  // 1-void PGItem::clear_sound(std::string const &event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).clear_sound(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_sound(const PGItem self, str event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_clear_sound_72_comment =
  "C++ Interface:\n"
  "clear_sound(const PGItem self, str event)\n"
  "\n"
  "/**\n"
  " * Removes the sound associated with the indicated event.\n"
  " */";
#else
static const char *Dtool_PGItem_clear_sound_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AudioSound *PGItem::get_sound(std::string const &event) const
 */
static PyObject *Dtool_PGItem_get_sound_73(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-AudioSound *PGItem::get_sound(std::string const &event) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    AudioSound *return_value = (*(const PGItem*)local_this).get_sound(std::string(param1_str, param1_len));
    if (return_value != (AudioSound *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AudioSound *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AudioSound, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sound(PGItem self, str event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_sound_73_comment =
  "C++ Interface:\n"
  "get_sound(PGItem self, str event)\n"
  "\n"
  "/**\n"
  " * Returns the sound associated with the indicated event, or NULL if there is\n"
  " * no associated sound.\n"
  " */";
#else
static const char *Dtool_PGItem_get_sound_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PGItem::has_sound(std::string const &event) const
 */
static PyObject *Dtool_PGItem_has_sound_74(PyObject *self, PyObject *arg) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PGItem::has_sound(std::string const &event) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const PGItem*)local_this).has_sound(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_sound(PGItem self, str event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_has_sound_74_comment =
  "C++ Interface:\n"
  "has_sound(PGItem self, str event)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a sound associated with the indicated event, or\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_PGItem_has_sound_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TextNode *PGItem::get_text_node(void)
 */
static PyObject *Dtool_PGItem_get_text_node_75(PyObject *, PyObject *) {
  // 1-static TextNode *PGItem::get_text_node(void)
  TextNode *return_value = PGItem::get_text_node();
  if (return_value != (TextNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (TextNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_text_node_75_comment =
  "C++ Interface:\n"
  "get_text_node()\n"
  "\n"
  "/**\n"
  " * Returns the TextNode object that will be used by all PGItems to generate\n"
  " * default labels given a string.  This can be loaded with the default font,\n"
  " * etc.\n"
  " */";
#else
static const char *Dtool_PGItem_get_text_node_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void PGItem::set_text_node(TextNode *node)
 */
static PyObject *Dtool_PGItem_set_text_node_76(PyObject *, PyObject *arg) {
  // 1-static inline void PGItem::set_text_node(TextNode *node)
  PT(TextNode) arg_this;
  if (!Dtool_Coerce_TextNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "PGItem.set_text_node", "TextNode");
  }
  PGItem::set_text_node(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text_node(TextNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGItem_set_text_node_76_comment =
  "C++ Interface:\n"
  "set_text_node(TextNode node)\n"
  "\n"
  "/**\n"
  " * Changes the TextNode object that will be used by all PGItems to generate\n"
  " * default labels given a string.  This can be loaded with the default font,\n"
  " * etc.\n"
  " */";
#else
static const char *Dtool_PGItem_set_text_node_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline PGItem *PGItem::get_focus_item(void)
 */
static PyObject *Dtool_PGItem_get_focus_item_77(PyObject *, PyObject *) {
  // 1-static inline PGItem *PGItem::get_focus_item(void)
  PGItem *return_value = PGItem::get_focus_item();
  if (return_value != (PGItem *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PGItem *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PGItem, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_focus_item_77_comment =
  "C++ Interface:\n"
  "get_focus_item()\n"
  "\n"
  "/**\n"
  " * Returns the one PGItem in the world that currently has keyboard focus, if\n"
  " * any, or NULL if no item has keyboard focus.  Use PGItem::set_focus() to\n"
  " * activate or deactivate keyboard focus on a particular item.\n"
  " */";
#else
static const char *Dtool_PGItem_get_focus_item_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PGItem::get_class_type(void)
 */
static PyObject *Dtool_PGItem_get_class_type_78(PyObject *, PyObject *) {
  // 1-static TypeHandle PGItem::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PGItem::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGItem_get_class_type_78_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PGItem_get_class_type_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGSliderBar *PGItem::downcast_to_PGSliderBar(void)
 */
static PyObject *Dtool_PGItem_downcast_to_PGSliderBar_183(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGItem, (void **)&local_this, "PGItem.downcast_to_PGSliderBar")) {
    return NULL;
  }
  // 1-PGSliderBar *PGItem::downcast_to_PGSliderBar(void)
  PGSliderBar *return_value = (PGSliderBar *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PGSliderBar, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGItem_downcast_to_PGSliderBar_183_comment =
  "C++ Interface:\n"
  "downcast_to_PGSliderBar(const PGItem self)\n"
  "\n"
  "downcast from PGItem to PGSliderBar";
#else
static const char *Dtool_PGItem_downcast_to_PGSliderBar_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGItem::PGItem(std::string const &name)
 */
static int Dtool_Init_PGItem(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PGItem() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-PGItem::PGItem(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    PGItem *return_value = new PGItem(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGItem, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PGItem(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PGItem(PyObject *args, CPT(PGItem) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGItem, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGItem::PGItem(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGItem *return_value = new PGItem(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PGItem(PyObject *args, PT(PGItem) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGItem, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGItem::PGItem(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGItem *return_value = new PGItem(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PGItem_get_state_defs(PyObject *self, PyObject *) {
  PGItem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGItem, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_state_defs();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PGItem_get_state_def_43(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PGItem(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PGItem) {
    printf("PGItem ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PGItem *local_this = (PGItem *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PGItem) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PGItem(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PGItem) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PGItem*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PGItem*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PGItem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PGItem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PGItem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PGItem*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PGButton
 */
/**
 * Python function wrapper for:
 * inline void PGButton::setup(NodePath const &ready)
 * inline void PGButton::setup(NodePath const &ready, NodePath const &depressed)
 * inline void PGButton::setup(NodePath const &ready, NodePath const &depressed, NodePath const &rollover)
 * void PGButton::setup(NodePath const &ready, NodePath const &depressed, NodePath const &rollover, NodePath const &inactive)
 * void PGButton::setup(std::string const &label, PN_stdfloat bevel = 0.1)
 */
static PyObject *Dtool_PGButton_setup_82(PyObject *self, PyObject *args, PyObject *kwds) {
  PGButton *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGButton, (void **)&local_this, "PGButton.setup")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 void PGButton::setup(std::string const &label, PN_stdfloat bevel)
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        static const char *keyword_list[] = {"label", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:setup", (char **)keyword_list, &param1_str, &param1_len)) {
          (*local_this).setup(std::string(param1_str, param1_len));
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void PGButton::setup(NodePath const &ready)
        PyObject *param1;
        static const char *keyword_list[] = {"ready", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:setup", (char **)keyword_list, &param1)) {
          NodePath const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_NodePath, (void **)&param1_this);
          if (param1_this != NULL) {
            (*local_this).setup(*param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: void PGButton::setup(std::string const &label, PN_stdfloat bevel)
      // No coercion possible: inline void PGButton::setup(NodePath const &ready)
    }
    break;
  case 2:
    {
      {
        // -2 inline void PGButton::setup(NodePath const &ready, NodePath const &depressed)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"ready", "depressed", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:setup", (char **)keyword_list, &param1, &param2)) {
          NodePath const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_NodePath, (void **)&param1_this);
          NodePath const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_NodePath, (void **)&param2_this);
          if (param1_this != NULL && param2_this != NULL) {
            (*local_this).setup(*param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void PGButton::setup(std::string const &label, PN_stdfloat bevel)
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        float param2;
        static const char *keyword_list[] = {"label", "bevel", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#f:setup", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          (*local_this).setup(std::string(param1_str, param1_len), (PN_stdfloat)param2);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void PGButton::setup(NodePath const &ready, NodePath const &depressed)
      // No coercion possible: void PGButton::setup(std::string const &label, PN_stdfloat bevel)
    }
    break;
  case 3:
    {
      // 1-inline void PGButton::setup(NodePath const &ready, NodePath const &depressed, NodePath const &rollover)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"ready", "depressed", "rollover", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:setup", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "PGButton.setup", true, true);
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "PGButton.setup", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "PGButton.setup", true, true);
        if (param1_this != NULL && param2_this != NULL && param3_this != NULL) {
          (*local_this).setup(*param1_this, *param2_this, *param3_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 4:
    {
      // 1-void PGButton::setup(NodePath const &ready, NodePath const &depressed, NodePath const &rollover, NodePath const &inactive)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"ready", "depressed", "rollover", "inactive", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:setup", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "PGButton.setup", true, true);
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "PGButton.setup", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "PGButton.setup", true, true);
        NodePath const *param4_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_NodePath, 4, "PGButton.setup", true, true);
        if (param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL) {
          (*local_this).setup(*param1_this, *param2_this, *param3_this, *param4_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "setup() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup(const PGButton self, str label)\n"
      "setup(const PGButton self, const NodePath ready)\n"
      "setup(const PGButton self, const NodePath ready, const NodePath depressed)\n"
      "setup(const PGButton self, str label, float bevel)\n"
      "setup(const PGButton self, const NodePath ready, const NodePath depressed, const NodePath rollover)\n"
      "setup(const PGButton self, const NodePath ready, const NodePath depressed, const NodePath rollover, const NodePath inactive)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGButton_setup_82_comment =
  "C++ Interface:\n"
  "setup(const PGButton self, str label)\n"
  "setup(const PGButton self, const NodePath ready)\n"
  "setup(const PGButton self, const NodePath ready, const NodePath depressed)\n"
  "setup(const PGButton self, str label, float bevel)\n"
  "setup(const PGButton self, const NodePath ready, const NodePath depressed, const NodePath rollover)\n"
  "setup(const PGButton self, const NodePath ready, const NodePath depressed, const NodePath rollover, const NodePath inactive)\n"
  "\n"
  "/**\n"
  " * Sets up the button using the indicated NodePath as arbitrary geometry.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the button using the indicated NodePath as arbitrary geometry.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the button using the indicated NodePath as arbitrary geometry.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the button as a default text button using the indicated label\n"
  " * string.  The TextNode defined by PGItem::get_text_node() will be used to\n"
  " * create the label geometry.  This automatically sets up the frame according\n"
  " * to the size of the text.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the button using the indicated NodePath as arbitrary geometry.\n"
  " */";
#else
static const char *Dtool_PGButton_setup_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PGButton::add_click_button(ButtonHandle const &button)
 */
static PyObject *Dtool_PGButton_add_click_button_83(PyObject *self, PyObject *arg) {
  PGButton *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGButton, (void **)&local_this, "PGButton.add_click_button")) {
    return NULL;
  }
  // 1-bool PGButton::add_click_button(ButtonHandle const &button)
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGButton.add_click_button", "ButtonHandle");
  }
  bool return_value = (*local_this).add_click_button(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_click_button(const PGButton self, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGButton_add_click_button_83_comment =
  "C++ Interface:\n"
  "add_click_button(const PGButton self, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Adds the indicated button to the set of buttons that can effectively\n"
  " * \"click\" the PGButton.  Normally, this is just MouseButton::one().  Returns\n"
  " * true if the button was added, or false if it was already there.\n"
  " */";
#else
static const char *Dtool_PGButton_add_click_button_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PGButton::remove_click_button(ButtonHandle const &button)
 */
static PyObject *Dtool_PGButton_remove_click_button_84(PyObject *self, PyObject *arg) {
  PGButton *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGButton, (void **)&local_this, "PGButton.remove_click_button")) {
    return NULL;
  }
  // 1-bool PGButton::remove_click_button(ButtonHandle const &button)
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGButton.remove_click_button", "ButtonHandle");
  }
  bool return_value = (*local_this).remove_click_button(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_click_button(const PGButton self, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGButton_remove_click_button_84_comment =
  "C++ Interface:\n"
  "remove_click_button(const PGButton self, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Removes the indicated button from the set of buttons that can effectively\n"
  " * \"click\" the PGButton.  Normally, this is just MouseButton::one().  Returns\n"
  " * true if the button was removed, or false if it was not in the set.\n"
  " */";
#else
static const char *Dtool_PGButton_remove_click_button_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PGButton::has_click_button(ButtonHandle const &button)
 */
static PyObject *Dtool_PGButton_has_click_button_85(PyObject *self, PyObject *arg) {
  PGButton *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGButton, (void **)&local_this, "PGButton.has_click_button")) {
    return NULL;
  }
  // 1-bool PGButton::has_click_button(ButtonHandle const &button)
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGButton.has_click_button", "ButtonHandle");
  }
  bool return_value = (*local_this).has_click_button(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_click_button(const PGButton self, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGButton_has_click_button_85_comment =
  "C++ Interface:\n"
  "has_click_button(const PGButton self, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button is on the set of buttons that can\n"
  " * effectively \"click\" the PGButton.  Normally, this is just\n"
  " * MouseButton::one().\n"
  " */";
#else
static const char *Dtool_PGButton_has_click_button_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGButton::is_button_down(void)
 */
static PyObject *Dtool_PGButton_is_button_down_86(PyObject *self, PyObject *) {
  PGButton *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGButton, (void **)&local_this, "PGButton.is_button_down")) {
    return NULL;
  }
  // 1-inline bool PGButton::is_button_down(void)
  bool return_value = (*local_this).is_button_down();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGButton_is_button_down_86_comment =
  "C++ Interface:\n"
  "is_button_down(const PGButton self)\n"
  "\n"
  "/**\n"
  " * Returns true if the user is currently holding the mouse button down on the\n"
  " * button, false otherwise.\n"
  " */";
#else
static const char *Dtool_PGButton_is_button_down_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGButton::get_click_prefix(void)
 */
static PyObject *Dtool_PGButton_get_click_prefix_87(PyObject *, PyObject *) {
  // 1-static inline std::string PGButton::get_click_prefix(void)
  std::string return_value = PGButton::get_click_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGButton_get_click_prefix_87_comment =
  "C++ Interface:\n"
  "get_click_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the click event for all\n"
  " * PGButtons.  The click event is the concatenation of this string followed by\n"
  " * get_id().\n"
  " */";
#else
static const char *Dtool_PGButton_get_click_prefix_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGButton::get_click_event(ButtonHandle const &button) const
 */
static PyObject *Dtool_PGButton_get_click_event_88(PyObject *self, PyObject *arg) {
  PGButton *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGButton, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGButton::get_click_event(ButtonHandle const &button) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGButton.get_click_event", "ButtonHandle");
  }
  std::string return_value = (*(const PGButton*)local_this).get_click_event(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_click_event(PGButton self, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGButton_get_click_event_88_comment =
  "C++ Interface:\n"
  "get_click_event(PGButton self, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the button is clicked\n"
  " * normally.\n"
  " */";
#else
static const char *Dtool_PGButton_get_click_event_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PGButton::get_class_type(void)
 */
static PyObject *Dtool_PGButton_get_class_type_89(PyObject *, PyObject *) {
  // 1-static TypeHandle PGButton::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PGButton::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGButton_get_class_type_89_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PGButton_get_class_type_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGButton::PGButton(std::string const &name)
 */
static int Dtool_Init_PGButton(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PGButton() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-PGButton::PGButton(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    PGButton *return_value = new PGButton(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGButton, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PGButton(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PGButton(PyObject *args, CPT(PGButton) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGButton, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGButton::PGButton(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGButton *return_value = new PGButton(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PGButton(PyObject *args, PT(PGButton) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGButton, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGButton::PGButton(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGButton *return_value = new PGButton(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_PGButton(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PGButton) {
    printf("PGButton ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PGButton *local_this = (PGButton *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PGButton) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_PGItem) {
    return (PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PGButton(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PGButton) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PGButton*)other_this;
  }
  if (from_type == Dtool_Ptr_PGItem) {
    PGItem* other_this = (PGItem*)from_this;
    return (PGButton*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PGButton*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PGButton*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PGButton*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PGButton*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PGButton*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PGTop
 */
/**
 * Python function wrapper for:
 * void PGTop::set_mouse_watcher(MouseWatcher *watcher)
 */
static PyObject *Dtool_PGTop_set_mouse_watcher_92(PyObject *self, PyObject *arg) {
  PGTop *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGTop, (void **)&local_this, "PGTop.set_mouse_watcher")) {
    return NULL;
  }
  // 1-void PGTop::set_mouse_watcher(MouseWatcher *watcher)
  PT(MouseWatcher) arg_this;
  if (!Dtool_Coerce_MouseWatcher(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGTop.set_mouse_watcher", "MouseWatcher");
  }
  (*local_this).set_mouse_watcher(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mouse_watcher(const PGTop self, MouseWatcher watcher)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGTop_set_mouse_watcher_92_comment =
  "C++ Interface:\n"
  "set_mouse_watcher(const PGTop self, MouseWatcher watcher)\n"
  "\n"
  "/**\n"
  " * Sets the MouseWatcher pointer that the PGTop object registers its PG items\n"
  " * with.  This must be set before the PG items are active.\n"
  " */";
#else
static const char *Dtool_PGTop_set_mouse_watcher_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MouseWatcher *PGTop::get_mouse_watcher(void) const
 */
static PyObject *Dtool_PGTop_get_mouse_watcher_93(PyObject *self, PyObject *) {
  PGTop *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGTop, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline MouseWatcher *PGTop::get_mouse_watcher(void) const
  MouseWatcher *return_value = (*(const PGTop*)local_this).get_mouse_watcher();
  if (return_value != (MouseWatcher *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (MouseWatcher *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_MouseWatcher, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGTop_get_mouse_watcher_93_comment =
  "C++ Interface:\n"
  "get_mouse_watcher(PGTop self)\n"
  "\n"
  "/**\n"
  " * Returns the MouseWatcher pointer that the PGTop object registers its PG\n"
  " * items with, or NULL if the MouseWatcher has not yet been set.\n"
  " */";
#else
static const char *Dtool_PGTop_get_mouse_watcher_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MouseWatcherGroup *PGTop::get_group(void) const
 */
static PyObject *Dtool_PGTop_get_group_94(PyObject *self, PyObject *) {
  PGTop *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGTop, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline MouseWatcherGroup *PGTop::get_group(void) const
  MouseWatcherGroup *return_value = (*(const PGTop*)local_this).get_group();
  if (return_value != (MouseWatcherGroup *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (MouseWatcherGroup *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MouseWatcherGroup, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGTop_get_group_94_comment =
  "C++ Interface:\n"
  "get_group(PGTop self)\n"
  "\n"
  "/**\n"
  " * Returns the MouseWatcherGroup pointer that the PGTop object registers its\n"
  " * PG items with, or NULL if the MouseWatcher has not yet been set.\n"
  " */";
#else
static const char *Dtool_PGTop_get_group_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGTop::set_start_sort(int start_sort)
 */
static PyObject *Dtool_PGTop_set_start_sort_95(PyObject *self, PyObject *arg) {
  PGTop *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGTop, (void **)&local_this, "PGTop.set_start_sort")) {
    return NULL;
  }
  // 1-inline void PGTop::set_start_sort(int start_sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_start_sort((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_sort(const PGTop self, int start_sort)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGTop_set_start_sort_95_comment =
  "C++ Interface:\n"
  "set_start_sort(const PGTop self, int start_sort)\n"
  "\n"
  "/**\n"
  " * Specifies the sort index that is assigned during the traversal to the first\n"
  " * PGItem that is discovered during traversal.  Subsequent PGItems will be\n"
  " * assigned consecutively higher sort indexes.\n"
  " *\n"
  " * This number is used by the MouseWatcher system to rank the clickable mouse\n"
  " * regions in the same order in which the items are rendered, so that items on\n"
  " * top will receive mouse priority.\n"
  " *\n"
  " * Normally, it makes the most sense to leave this initial value at its\n"
  " * default value of 0, unless you need the PGItems to have a particular sort\n"
  " * value with respect to some other objects in the scene (particularly with a\n"
  " * second PGTop node).\n"
  " */";
#else
static const char *Dtool_PGTop_set_start_sort_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PGTop::get_start_sort(void) const
 */
static PyObject *Dtool_PGTop_get_start_sort_96(PyObject *self, PyObject *) {
  PGTop *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGTop, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PGTop::get_start_sort(void) const
  int return_value = (*(const PGTop*)local_this).get_start_sort();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGTop_get_start_sort_96_comment =
  "C++ Interface:\n"
  "get_start_sort(PGTop self)\n"
  "\n"
  "/**\n"
  " * Returns the sort index that is assigned during the traversal to the first\n"
  " * PGItem that is discovered during traversal.  See set_start_sort().\n"
  " */";
#else
static const char *Dtool_PGTop_get_start_sort_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PGTop::get_class_type(void)
 */
static PyObject *Dtool_PGTop_get_class_type_97(PyObject *, PyObject *) {
  // 1-static TypeHandle PGTop::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PGTop::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGTop_get_class_type_97_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PGTop_get_class_type_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGTop::PGTop(std::string const &name)
 */
static int Dtool_Init_PGTop(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PGTop() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-PGTop::PGTop(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    PGTop *return_value = new PGTop(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGTop, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PGTop(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PGTop(PyObject *args, CPT(PGTop) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGTop, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGTop::PGTop(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGTop *return_value = new PGTop(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PGTop(PyObject *args, PT(PGTop) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGTop, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGTop::PGTop(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGTop *return_value = new PGTop(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_PGTop(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PGTop) {
    printf("PGTop ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PGTop *local_this = (PGTop *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PGTop) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PGTop(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PGTop) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PGTop*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PGTop*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PGTop*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PGTop*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PGTop*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PGTop*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PGEntry
 */
/**
 * Python function wrapper for:
 * void PGEntry::setup(PN_stdfloat width, int num_lines)
 */
static PyObject *Dtool_PGEntry_setup_101(PyObject *self, PyObject *args, PyObject *kwds) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.setup")) {
    return NULL;
  }
  // 1-void PGEntry::setup(PN_stdfloat width, int num_lines)
  float param1;
  int param2;
  static const char *keyword_list[] = {"width", "num_lines", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fi:setup", (char **)keyword_list, &param1, &param2)) {
    (*local_this).setup((PN_stdfloat)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup(const PGEntry self, float width, int num_lines)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_setup_101_comment =
  "C++ Interface:\n"
  "setup(const PGEntry self, float width, int num_lines)\n"
  "\n"
  "/**\n"
  " * Sets up the entry for normal use.  The width is the maximum width of\n"
  " * characters that will be typed, and num_lines is the integer number of lines\n"
  " * of text of the entry.  Both of these together determine the size of the\n"
  " * entry, based on the TextNode in effect.\n"
  " */";
#else
static const char *Dtool_PGEntry_setup_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGEntry::setup_minimal(PN_stdfloat width, int num_lines)
 */
static PyObject *Dtool_PGEntry_setup_minimal_102(PyObject *self, PyObject *args, PyObject *kwds) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.setup_minimal")) {
    return NULL;
  }
  // 1-void PGEntry::setup_minimal(PN_stdfloat width, int num_lines)
  float param1;
  int param2;
  static const char *keyword_list[] = {"width", "num_lines", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fi:setup_minimal", (char **)keyword_list, &param1, &param2)) {
    (*local_this).setup_minimal((PN_stdfloat)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_minimal(const PGEntry self, float width, int num_lines)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_setup_minimal_102_comment =
  "C++ Interface:\n"
  "setup_minimal(const PGEntry self, float width, int num_lines)\n"
  "\n"
  "/**\n"
  " * Sets up the entry without creating any frame or other decoration.\n"
  " */";
#else
static const char *Dtool_PGEntry_setup_minimal_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGEntry::set_text(std::string const &text)
 */
static PyObject *Dtool_PGEntry_set_text_103(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_text")) {
    return NULL;
  }
  // 1-inline bool PGEntry::set_text(std::string const &text)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).set_text(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text(const PGEntry self, str text)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_text_103_comment =
  "C++ Interface:\n"
  "set_text(const PGEntry self, str text)\n"
  "\n"
  "/**\n"
  " * Changes the text currently displayed within the entry.  This uses the\n"
  " * Unicode encoding currently specified for the \"focus\" TextNode; therefore,\n"
  " * the TextNode must exist before calling set_text().\n"
  " *\n"
  " * The return value is true if all the text is accepted, or false if some was\n"
  " * truncated (see set_max_width(), etc.).\n"
  " */";
#else
static const char *Dtool_PGEntry_set_text_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGEntry::get_plain_text(void) const
 */
static PyObject *Dtool_PGEntry_get_plain_text_104(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGEntry::get_plain_text(void) const
  std::string return_value = (*(const PGEntry*)local_this).get_plain_text();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_plain_text_104_comment =
  "C++ Interface:\n"
  "get_plain_text(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the text currently displayed within the entry, without any embedded\n"
  " * properties characters.\n"
  " *\n"
  " * This uses the Unicode encoding currently specified for the \"focus\"\n"
  " * TextNode; therefore, the TextNode must exist before calling get_text().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_plain_text_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGEntry::get_text(void) const
 */
static PyObject *Dtool_PGEntry_get_text_105(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGEntry::get_text(void) const
  std::string return_value = (*(const PGEntry*)local_this).get_text();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_text_105_comment =
  "C++ Interface:\n"
  "get_text(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the text currently displayed within the entry.  This uses the\n"
  " * Unicode encoding currently specified for the \"focus\" TextNode; therefore,\n"
  " * the TextNode must exist before calling get_text().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_text_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PGEntry::get_num_characters(void) const
 */
static PyObject *Dtool_PGEntry_get_num_characters_106(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PGEntry::get_num_characters(void) const
  int return_value = (*(const PGEntry*)local_this).get_num_characters();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_num_characters_106_comment =
  "C++ Interface:\n"
  "get_num_characters(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the number of characters of text in the entry.  This is the actual\n"
  " * number of visible characters, not counting implicit newlines due to\n"
  " * wordwrapping, or formatted characters for text properties changes.  If\n"
  " * there is an embedded TextGraphic object, it counts as one character.\n"
  " *\n"
  " * This is also the length of the string returned by get_plain_text().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_num_characters_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline wchar_t PGEntry::get_character(int n) const
 */
static PyObject *Dtool_PGEntry_get_character_107(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline wchar_t PGEntry::get_character(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    wchar_t return_value = (*(const PGEntry*)local_this).get_character((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_character(PGEntry self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_character_107_comment =
  "C++ Interface:\n"
  "get_character(PGEntry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the character at the indicated position in the entry.  If the\n"
  " * object at this position is a graphic object instead of a character, returns\n"
  " * 0.\n"
  " */";
#else
static const char *Dtool_PGEntry_get_character_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TextGraphic const *PGEntry::get_graphic(int n) const
 */
static PyObject *Dtool_PGEntry_get_graphic_108(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TextGraphic const *PGEntry::get_graphic(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TextGraphic const *return_value = (*(const PGEntry*)local_this).get_graphic((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextGraphic, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_graphic(PGEntry self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_graphic_108_comment =
  "C++ Interface:\n"
  "get_graphic(PGEntry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the graphic object at the indicated position in the pre-wordwrapped\n"
  " * string.  If the object at this position is a character instead of a graphic\n"
  " * object, returns NULL.\n"
  " */";
#else
static const char *Dtool_PGEntry_get_graphic_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TextProperties const &PGEntry::get_properties(int n) const
 */
static PyObject *Dtool_PGEntry_get_properties_109(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TextProperties const &PGEntry::get_properties(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TextProperties const *return_value = &((*(const PGEntry*)local_this).get_properties((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextProperties, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_properties(PGEntry self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_properties_109_comment =
  "C++ Interface:\n"
  "get_properties(PGEntry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the TextProperties in effect for the object at the indicated\n"
  " * position in the pre-wordwrapped string.\n"
  " */";
#else
static const char *Dtool_PGEntry_get_properties_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::set_cursor_position(int position)
 */
static PyObject *Dtool_PGEntry_set_cursor_position_110(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_cursor_position")) {
    return NULL;
  }
  // 1-inline void PGEntry::set_cursor_position(int position)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_cursor_position((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cursor_position(const PGEntry self, int position)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_cursor_position_110_comment =
  "C++ Interface:\n"
  "set_cursor_position(const PGEntry self, int position)\n"
  "\n"
  "/**\n"
  " * Sets the current position of the cursor.  This is the position within the\n"
  " * text at which the next letter typed by the user will be inserted; normally\n"
  " * it is the same as the length of the text.\n"
  " */";
#else
static const char *Dtool_PGEntry_set_cursor_position_110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PGEntry::get_cursor_position(void) const
 */
static PyObject *Dtool_PGEntry_get_cursor_position_111(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PGEntry::get_cursor_position(void) const
  int return_value = (*(const PGEntry*)local_this).get_cursor_position();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_cursor_position_111_comment =
  "C++ Interface:\n"
  "get_cursor_position(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the current position of the cursor.\n"
  " */";
#else
static const char *Dtool_PGEntry_get_cursor_position_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGEntry::get_cursor_X(void) const
 */
static PyObject *Dtool_PGEntry_get_cursor_X_112(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGEntry::get_cursor_X(void) const
  PN_stdfloat return_value = (*(const PGEntry*)local_this).get_cursor_X();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_cursor_X_112_comment =
  "C++ Interface:\n"
  "get_cursor_X(PGEntry self)\n";
#else
static const char *Dtool_PGEntry_get_cursor_X_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGEntry::get_cursor_Y(void) const
 */
static PyObject *Dtool_PGEntry_get_cursor_Y_113(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGEntry::get_cursor_Y(void) const
  PN_stdfloat return_value = (*(const PGEntry*)local_this).get_cursor_Y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_cursor_Y_113_comment =
  "C++ Interface:\n"
  "get_cursor_Y(PGEntry self)\n";
#else
static const char *Dtool_PGEntry_get_cursor_Y_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::set_max_chars(int max_chars)
 */
static PyObject *Dtool_PGEntry_set_max_chars_114(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_max_chars")) {
    return NULL;
  }
  // 1-inline void PGEntry::set_max_chars(int max_chars)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_max_chars((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_chars(const PGEntry self, int max_chars)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_max_chars_114_comment =
  "C++ Interface:\n"
  "set_max_chars(const PGEntry self, int max_chars)\n"
  "\n"
  "/**\n"
  " * Sets the maximum number of characters that may be typed into the entry.\n"
  " * This is a limit on the number of characters, as opposed to the width of the\n"
  " * entry; see also set_max_width().\n"
  " *\n"
  " * If this is 0, there is no limit.\n"
  " */";
#else
static const char *Dtool_PGEntry_set_max_chars_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PGEntry::get_max_chars(void) const
 */
static PyObject *Dtool_PGEntry_get_max_chars_115(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PGEntry::get_max_chars(void) const
  int return_value = (*(const PGEntry*)local_this).get_max_chars();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_max_chars_115_comment =
  "C++ Interface:\n"
  "get_max_chars(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the current maximum number of characters that may be typed into the\n"
  " * entry, or 0 if there is no limit.  See set_max_chars().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_max_chars_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::set_max_width(PN_stdfloat max_width)
 */
static PyObject *Dtool_PGEntry_set_max_width_116(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_max_width")) {
    return NULL;
  }
  // 1-inline void PGEntry::set_max_width(PN_stdfloat max_width)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_width((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_width(const PGEntry self, float max_width)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_max_width_116_comment =
  "C++ Interface:\n"
  "set_max_width(const PGEntry self, float max_width)\n"
  "\n"
  "/**\n"
  " * Sets the maximum width of all characters that may be typed into the entry.\n"
  " * This is a limit on the width of the formatted text, not a fixed limit on\n"
  " * the number of characters; also set_max_chars().\n"
  " *\n"
  " * If this is 0, there is no limit.\n"
  " *\n"
  " * If _num_lines is more than 1, rather than being a fixed width on the whole\n"
  " * entry, this becomes instead the wordwrap width (and the width limit on the\n"
  " * entry is essentially _max_width * _num_lines).\n"
  " */";
#else
static const char *Dtool_PGEntry_set_max_width_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGEntry::get_max_width(void) const
 */
static PyObject *Dtool_PGEntry_get_max_width_117(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGEntry::get_max_width(void) const
  PN_stdfloat return_value = (*(const PGEntry*)local_this).get_max_width();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_max_width_117_comment =
  "C++ Interface:\n"
  "get_max_width(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the current maximum width of the characters that may be typed into\n"
  " * the entry, or 0 if there is no limit.  See set_max_width().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_max_width_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::set_num_lines(int num_lines)
 */
static PyObject *Dtool_PGEntry_set_num_lines_118(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_num_lines")) {
    return NULL;
  }
  // 1-inline void PGEntry::set_num_lines(int num_lines)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_lines((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_lines(const PGEntry self, int num_lines)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_num_lines_118_comment =
  "C++ Interface:\n"
  "set_num_lines(const PGEntry self, int num_lines)\n"
  "\n"
  "/**\n"
  " * Sets the number of lines of text the PGEntry will use.  This only has\n"
  " * meaning if _max_width is not 0; _max_width indicates the wordwrap width of\n"
  " * each line.\n"
  " */";
#else
static const char *Dtool_PGEntry_set_num_lines_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PGEntry::get_num_lines(void) const
 */
static PyObject *Dtool_PGEntry_get_num_lines_119(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PGEntry::get_num_lines(void) const
  int return_value = (*(const PGEntry*)local_this).get_num_lines();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_num_lines_119_comment =
  "C++ Interface:\n"
  "get_num_lines(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the number of lines of text the PGEntry will use, if _max_width is\n"
  " * not 0.  See set_num_lines().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_num_lines_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::set_blink_rate(PN_stdfloat blink_rate)
 */
static PyObject *Dtool_PGEntry_set_blink_rate_120(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_blink_rate")) {
    return NULL;
  }
  // 1-inline void PGEntry::set_blink_rate(PN_stdfloat blink_rate)
  if (PyNumber_Check(arg)) {
    (*local_this).set_blink_rate((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blink_rate(const PGEntry self, float blink_rate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_blink_rate_120_comment =
  "C++ Interface:\n"
  "set_blink_rate(const PGEntry self, float blink_rate)\n"
  "\n"
  "/**\n"
  " * Sets the number of times per second the cursor will blink while the entry\n"
  " * has keyboard focus.\n"
  " *\n"
  " * If this is 0, the cursor does not blink, but is held steady.\n"
  " */";
#else
static const char *Dtool_PGEntry_set_blink_rate_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGEntry::get_blink_rate(void) const
 */
static PyObject *Dtool_PGEntry_get_blink_rate_121(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGEntry::get_blink_rate(void) const
  PN_stdfloat return_value = (*(const PGEntry*)local_this).get_blink_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_blink_rate_121_comment =
  "C++ Interface:\n"
  "get_blink_rate(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the number of times per second the cursor will blink, or 0 if the\n"
  " * cursor is not to blink.\n"
  " */";
#else
static const char *Dtool_PGEntry_get_blink_rate_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PGEntry::get_cursor_def(void)
 */
static PyObject *Dtool_PGEntry_get_cursor_def_122(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.get_cursor_def")) {
    return NULL;
  }
  // 1-inline NodePath PGEntry::get_cursor_def(void)
  NodePath *return_value = new NodePath((*local_this).get_cursor_def());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_cursor_def_122_comment =
  "C++ Interface:\n"
  "get_cursor_def(const PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the Node that will be rendered to represent the cursor.  You can\n"
  " * attach suitable cursor geometry to this node.\n"
  " */";
#else
static const char *Dtool_PGEntry_get_cursor_def_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::clear_cursor_def(void)
 */
static PyObject *Dtool_PGEntry_clear_cursor_def_123(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.clear_cursor_def")) {
    return NULL;
  }
  // 1-inline void PGEntry::clear_cursor_def(void)
  (*local_this).clear_cursor_def();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_clear_cursor_def_123_comment =
  "C++ Interface:\n"
  "clear_cursor_def(const PGEntry self)\n"
  "\n"
  "/**\n"
  " * Removes all the children from the cursor_def node, in preparation for\n"
  " * adding a new definition.\n"
  " */";
#else
static const char *Dtool_PGEntry_clear_cursor_def_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::set_cursor_keys_active(bool flag)
 */
static PyObject *Dtool_PGEntry_set_cursor_keys_active_124(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_cursor_keys_active")) {
    return NULL;
  }
  // 1-inline void PGEntry::set_cursor_keys_active(bool flag)
  (*local_this).set_cursor_keys_active((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cursor_keys_active(const PGEntry self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_cursor_keys_active_124_comment =
  "C++ Interface:\n"
  "set_cursor_keys_active(const PGEntry self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets whether the arrow keys (and home/end) control movement of the cursor.\n"
  " * If true, they are active; if false, they are ignored.\n"
  " */";
#else
static const char *Dtool_PGEntry_set_cursor_keys_active_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGEntry::get_cursor_keys_active(void) const
 */
static PyObject *Dtool_PGEntry_get_cursor_keys_active_125(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGEntry::get_cursor_keys_active(void) const
  bool return_value = (*(const PGEntry*)local_this).get_cursor_keys_active();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_cursor_keys_active_125_comment =
  "C++ Interface:\n"
  "get_cursor_keys_active(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns whether the arrow keys are currently set to control movement of the\n"
  " * cursor; see set_cursor_keys_active().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_cursor_keys_active_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::set_obscure_mode(bool flag)
 */
static PyObject *Dtool_PGEntry_set_obscure_mode_126(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_obscure_mode")) {
    return NULL;
  }
  // 1-inline void PGEntry::set_obscure_mode(bool flag)
  (*local_this).set_obscure_mode((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_obscure_mode(const PGEntry self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_obscure_mode_126_comment =
  "C++ Interface:\n"
  "set_obscure_mode(const PGEntry self, bool flag)\n"
  "\n"
  "/**\n"
  " * Specifies whether obscure mode should be enabled.  In obscure mode, a\n"
  " * string of asterisks is displayed instead of the literal text, e.g.  for\n"
  " * entering passwords.\n"
  " *\n"
  " * In obscure mode, the width of the text is computed based on the width of\n"
  " * the string of asterisks, not on the width of the actual text.  This has\n"
  " * implications on the maximum length of text that may be entered if max_width\n"
  " * is in effect.\n"
  " */";
#else
static const char *Dtool_PGEntry_set_obscure_mode_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGEntry::get_obscure_mode(void) const
 */
static PyObject *Dtool_PGEntry_get_obscure_mode_127(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGEntry::get_obscure_mode(void) const
  bool return_value = (*(const PGEntry*)local_this).get_obscure_mode();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_obscure_mode_127_comment =
  "C++ Interface:\n"
  "get_obscure_mode(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Specifies whether obscure mode is enabled.  See set_obscure_mode().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_obscure_mode_127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::set_overflow_mode(bool flag)
 */
static PyObject *Dtool_PGEntry_set_overflow_mode_128(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_overflow_mode")) {
    return NULL;
  }
  // 1-inline void PGEntry::set_overflow_mode(bool flag)
  (*local_this).set_overflow_mode((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_overflow_mode(const PGEntry self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_overflow_mode_128_comment =
  "C++ Interface:\n"
  "set_overflow_mode(const PGEntry self, bool flag)\n"
  "\n"
  "/**\n"
  " * Specifies whether overflow mode should be enabled.  In overflow mode, text\n"
  " * can overflow the boundaries of the Entry element horizontally.\n"
  " *\n"
  " * Overflow mode only works when the number of lines is 1.\n"
  " */";
#else
static const char *Dtool_PGEntry_set_overflow_mode_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGEntry::get_overflow_mode(void) const
 */
static PyObject *Dtool_PGEntry_get_overflow_mode_129(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGEntry::get_overflow_mode(void) const
  bool return_value = (*(const PGEntry*)local_this).get_overflow_mode();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_overflow_mode_129_comment =
  "C++ Interface:\n"
  "get_overflow_mode(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Specifies whether overflow mode is enabled.  See set_overflow_mode().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_overflow_mode_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::set_candidate_active(std::string const &candidate_active)
 */
static PyObject *Dtool_PGEntry_set_candidate_active_130(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_candidate_active")) {
    return NULL;
  }
  // 1-inline void PGEntry::set_candidate_active(std::string const &candidate_active)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_candidate_active(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_candidate_active(const PGEntry self, str candidate_active)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_candidate_active_130_comment =
  "C++ Interface:\n"
  "set_candidate_active(const PGEntry self, str candidate_active)\n"
  "\n"
  "/**\n"
  " * Specifies the name of the TextProperties structure added to the\n"
  " * TextPropertiesManager that will be used to render candidate strings from\n"
  " * the IME, used for typing characters in east Asian languages.  Each\n"
  " * candidate string represents one possible way to interpret the sequence of\n"
  " * keys the user has just entered; it should not be considered typed yet, but\n"
  " * it is important for the user to be able to see what he is considering\n"
  " * entering.\n"
  " *\n"
  " * This particular method sets the properties for the subset of the current\n"
  " * candidate string that the user can actively scroll through.\n"
  " */";
#else
static const char *Dtool_PGEntry_set_candidate_active_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &PGEntry::get_candidate_active(void) const
 */
static PyObject *Dtool_PGEntry_get_candidate_active_131(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &PGEntry::get_candidate_active(void) const
  std::string const &return_value = (*(const PGEntry*)local_this).get_candidate_active();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_candidate_active_131_comment =
  "C++ Interface:\n"
  "get_candidate_active(PGEntry self)\n"
  "\n"
  "/**\n"
  " * See set_candidate_active().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_candidate_active_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::set_candidate_inactive(std::string const &candidate_inactive)
 */
static PyObject *Dtool_PGEntry_set_candidate_inactive_132(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_candidate_inactive")) {
    return NULL;
  }
  // 1-inline void PGEntry::set_candidate_inactive(std::string const &candidate_inactive)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_candidate_inactive(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_candidate_inactive(const PGEntry self, str candidate_inactive)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_candidate_inactive_132_comment =
  "C++ Interface:\n"
  "set_candidate_inactive(const PGEntry self, str candidate_inactive)\n"
  "\n"
  "/**\n"
  " * Specifies the name of the TextProperties structure added to the\n"
  " * TextPropertiesManager that will be used to render candidate strings from\n"
  " * the IME, used for typing characters in east Asian languages.  Each\n"
  " * candidate string represents one possible way to interpret the sequence of\n"
  " * keys the user has just entered; it should not be considered typed yet, but\n"
  " * it is important for the user to be able to see what he is considering\n"
  " * entering.\n"
  " *\n"
  " * This particular method sets the properties for the subset of the current\n"
  " * candidate string that the user is not actively scrolling through.\n"
  " */";
#else
static const char *Dtool_PGEntry_set_candidate_inactive_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &PGEntry::get_candidate_inactive(void) const
 */
static PyObject *Dtool_PGEntry_get_candidate_inactive_133(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &PGEntry::get_candidate_inactive(void) const
  std::string const &return_value = (*(const PGEntry*)local_this).get_candidate_inactive();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_candidate_inactive_133_comment =
  "C++ Interface:\n"
  "get_candidate_inactive(PGEntry self)\n"
  "\n"
  "/**\n"
  " * See set_candidate_inactive().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_candidate_inactive_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGEntry::set_text_def(int state, TextNode *node)
 */
static PyObject *Dtool_PGEntry_set_text_def_134(PyObject *self, PyObject *args, PyObject *kwds) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_text_def")) {
    return NULL;
  }
  // 1-void PGEntry::set_text_def(int state, TextNode *node)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"state", "node", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_text_def", (char **)keyword_list, &param1, &param2)) {
    PT(TextNode) param2_this;
    if (!Dtool_Coerce_TextNode(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PGEntry.set_text_def", "TextNode");
    }
    (*local_this).set_text_def((int)param1, MOVE(param2_this));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text_def(const PGEntry self, int state, TextNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_text_def_134_comment =
  "C++ Interface:\n"
  "set_text_def(const PGEntry self, int state, TextNode node)\n"
  "\n"
  "/**\n"
  " * Changes the TextNode that will be used to render the text within the entry\n"
  " * when the entry is in the indicated state.  The default if nothing is\n"
  " * specified is the same TextNode returned by PGItem::get_text_node().\n"
  " */";
#else
static const char *Dtool_PGEntry_set_text_def_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TextNode *PGEntry::get_text_def(int state) const
 */
static PyObject *Dtool_PGEntry_get_text_def_135(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-TextNode *PGEntry::get_text_def(int state) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TextNode *return_value = (*(const PGEntry*)local_this).get_text_def((int)arg_val);
    if (return_value != (TextNode *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (TextNode *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_text_def(PGEntry self, int state)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_text_def_135_comment =
  "C++ Interface:\n"
  "get_text_def(PGEntry self, int state)\n"
  "\n"
  "/**\n"
  " * Returns the TextNode that will be used to render the text within the entry\n"
  " * when the entry is in the indicated state.  See set_text_def().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_text_def_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGEntry::get_accept_prefix(void)
 */
static PyObject *Dtool_PGEntry_get_accept_prefix_136(PyObject *, PyObject *) {
  // 1-static inline std::string PGEntry::get_accept_prefix(void)
  std::string return_value = PGEntry::get_accept_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_accept_prefix_136_comment =
  "C++ Interface:\n"
  "get_accept_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the accept event for all\n"
  " * PGEntries.  The accept event is the concatenation of this string followed\n"
  " * by get_id().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_accept_prefix_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGEntry::get_accept_failed_prefix(void)
 */
static PyObject *Dtool_PGEntry_get_accept_failed_prefix_137(PyObject *, PyObject *) {
  // 1-static inline std::string PGEntry::get_accept_failed_prefix(void)
  std::string return_value = PGEntry::get_accept_failed_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_accept_failed_prefix_137_comment =
  "C++ Interface:\n"
  "get_accept_failed_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the accept failed event for all\n"
  " * PGEntries.  This event is the concatenation of this string followed by\n"
  " * get_id().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_accept_failed_prefix_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGEntry::get_overflow_prefix(void)
 */
static PyObject *Dtool_PGEntry_get_overflow_prefix_138(PyObject *, PyObject *) {
  // 1-static inline std::string PGEntry::get_overflow_prefix(void)
  std::string return_value = PGEntry::get_overflow_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_overflow_prefix_138_comment =
  "C++ Interface:\n"
  "get_overflow_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the overflow event for all\n"
  " * PGEntries.  The overflow event is the concatenation of this string followed\n"
  " * by get_id().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_overflow_prefix_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGEntry::get_type_prefix(void)
 */
static PyObject *Dtool_PGEntry_get_type_prefix_139(PyObject *, PyObject *) {
  // 1-static inline std::string PGEntry::get_type_prefix(void)
  std::string return_value = PGEntry::get_type_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_type_prefix_139_comment =
  "C++ Interface:\n"
  "get_type_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the type event for all PGEntries.\n"
  " * The type event is the concatenation of this string followed by get_id().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_type_prefix_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGEntry::get_erase_prefix(void)
 */
static PyObject *Dtool_PGEntry_get_erase_prefix_140(PyObject *, PyObject *) {
  // 1-static inline std::string PGEntry::get_erase_prefix(void)
  std::string return_value = PGEntry::get_erase_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_erase_prefix_140_comment =
  "C++ Interface:\n"
  "get_erase_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the erase event for all\n"
  " * PGEntries.  The erase event is the concatenation of this string followed by\n"
  " * get_id().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_erase_prefix_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGEntry::get_cursormove_prefix(void)
 */
static PyObject *Dtool_PGEntry_get_cursormove_prefix_141(PyObject *, PyObject *) {
  // 1-static inline std::string PGEntry::get_cursormove_prefix(void)
  std::string return_value = PGEntry::get_cursormove_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_cursormove_prefix_141_comment =
  "C++ Interface:\n"
  "get_cursormove_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the cursor event for all\n"
  " * PGEntries.  The cursor event is the concatenation of this string followed\n"
  " * by get_id().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_cursormove_prefix_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGEntry::get_accept_event(ButtonHandle const &button) const
 */
static PyObject *Dtool_PGEntry_get_accept_event_142(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGEntry::get_accept_event(ButtonHandle const &button) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGEntry.get_accept_event", "ButtonHandle");
  }
  std::string return_value = (*(const PGEntry*)local_this).get_accept_event(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_accept_event(PGEntry self, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_accept_event_142_comment =
  "C++ Interface:\n"
  "get_accept_event(PGEntry self, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the entry is accepted\n"
  " * normally.\n"
  " */";
#else
static const char *Dtool_PGEntry_get_accept_event_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGEntry::get_accept_failed_event(ButtonHandle const &button) const
 */
static PyObject *Dtool_PGEntry_get_accept_failed_event_143(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGEntry::get_accept_failed_event(ButtonHandle const &button) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGEntry.get_accept_failed_event", "ButtonHandle");
  }
  std::string return_value = (*(const PGEntry*)local_this).get_accept_failed_event(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_accept_failed_event(PGEntry self, const ButtonHandle button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_accept_failed_event_143_comment =
  "C++ Interface:\n"
  "get_accept_failed_event(PGEntry self, const ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the entry cannot accept an\n"
  " * input\n"
  " */";
#else
static const char *Dtool_PGEntry_get_accept_failed_event_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGEntry::get_overflow_event(void) const
 */
static PyObject *Dtool_PGEntry_get_overflow_event_144(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGEntry::get_overflow_event(void) const
  std::string return_value = (*(const PGEntry*)local_this).get_overflow_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_overflow_event_144_comment =
  "C++ Interface:\n"
  "get_overflow_event(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when too much text is attempted\n"
  " * to be entered into the PGEntry, exceeding either the limit set via\n"
  " * set_max_chars() or via set_max_width().\n"
  " */";
#else
static const char *Dtool_PGEntry_get_overflow_event_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGEntry::get_type_event(void) const
 */
static PyObject *Dtool_PGEntry_get_type_event_145(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGEntry::get_type_event(void) const
  std::string return_value = (*(const PGEntry*)local_this).get_type_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_type_event_145_comment =
  "C++ Interface:\n"
  "get_type_event(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown whenever the user extends the\n"
  " * text by typing.\n"
  " */";
#else
static const char *Dtool_PGEntry_get_type_event_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGEntry::get_erase_event(void) const
 */
static PyObject *Dtool_PGEntry_get_erase_event_146(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGEntry::get_erase_event(void) const
  std::string return_value = (*(const PGEntry*)local_this).get_erase_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_erase_event_146_comment =
  "C++ Interface:\n"
  "get_erase_event(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown whenever the user erases\n"
  " * characters in the text.\n"
  " */";
#else
static const char *Dtool_PGEntry_get_erase_event_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGEntry::get_cursormove_event(void) const
 */
static PyObject *Dtool_PGEntry_get_cursormove_event_147(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGEntry::get_cursormove_event(void) const
  std::string return_value = (*(const PGEntry*)local_this).get_cursormove_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_cursormove_event_147_comment =
  "C++ Interface:\n"
  "get_cursormove_event(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown whenever the cursor moves\n"
  " */";
#else
static const char *Dtool_PGEntry_get_cursormove_event_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGEntry::set_wtext(std::wstring const &wtext)
 */
static PyObject *Dtool_PGEntry_set_wtext_148(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_wtext")) {
    return NULL;
  }
  // 1-inline bool PGEntry::set_wtext(std::wstring const &wtext)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:set_wtext", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    bool return_value = (*local_this).set_wtext(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wtext(const PGEntry self, unicode wtext)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_wtext_148_comment =
  "C++ Interface:\n"
  "set_wtext(const PGEntry self, unicode wtext)\n"
  "\n"
  "/**\n"
  " * Changes the text currently displayed within the entry.\n"
  " *\n"
  " * The return value is true if all the text is accepted, or false if some was\n"
  " * truncated (see set_max_width(), etc.).\n"
  " */";
#else
static const char *Dtool_PGEntry_set_wtext_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring PGEntry::get_plain_wtext(void) const
 */
static PyObject *Dtool_PGEntry_get_plain_wtext_149(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::wstring PGEntry::get_plain_wtext(void) const
  std::wstring return_value = (*(const PGEntry*)local_this).get_plain_wtext();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_plain_wtext_149_comment =
  "C++ Interface:\n"
  "get_plain_wtext(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the text currently displayed within the entry, without any embedded\n"
  " * properties characters.\n"
  " */";
#else
static const char *Dtool_PGEntry_get_plain_wtext_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring PGEntry::get_wtext(void) const
 */
static PyObject *Dtool_PGEntry_get_wtext_150(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::wstring PGEntry::get_wtext(void) const
  std::wstring return_value = (*(const PGEntry*)local_this).get_wtext();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_wtext_150_comment =
  "C++ Interface:\n"
  "get_wtext(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the text currently displayed within the entry.\n"
  " */";
#else
static const char *Dtool_PGEntry_get_wtext_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGEntry::set_accept_enabled(bool enabled)
 */
static PyObject *Dtool_PGEntry_set_accept_enabled_151(PyObject *self, PyObject *arg) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGEntry, (void **)&local_this, "PGEntry.set_accept_enabled")) {
    return NULL;
  }
  // 1-inline void PGEntry::set_accept_enabled(bool enabled)
  (*local_this).set_accept_enabled((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_accept_enabled(const PGEntry self, bool enabled)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_set_accept_enabled_151_comment =
  "C++ Interface:\n"
  "set_accept_enabled(const PGEntry self, bool enabled)\n"
  "\n"
  "/**\n"
  " * Sets whether the input may be accepted--use to disable submission by the\n"
  " * user\n"
  " */";
#else
static const char *Dtool_PGEntry_set_accept_enabled_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PGEntry::is_wtext(void) const
 */
static PyObject *Dtool_PGEntry_is_wtext_152(PyObject *self, PyObject *) {
  PGEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PGEntry::is_wtext(void) const
  bool return_value = (*(const PGEntry*)local_this).is_wtext();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_is_wtext_152_comment =
  "C++ Interface:\n"
  "is_wtext(PGEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if any of the characters in the string returned by get_wtext()\n"
  " * are out of the range of an ASCII character (and, therefore, get_wtext()\n"
  " * should be called in preference to get_text()).\n"
  " */";
#else
static const char *Dtool_PGEntry_is_wtext_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PGEntry::get_class_type(void)
 */
static PyObject *Dtool_PGEntry_get_class_type_153(PyObject *, PyObject *) {
  // 1-static TypeHandle PGEntry::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PGEntry::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGEntry_get_class_type_153_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PGEntry_get_class_type_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGEntry::PGEntry(std::string const &name)
 */
static int Dtool_Init_PGEntry(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PGEntry() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-PGEntry::PGEntry(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    PGEntry *return_value = new PGEntry(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGEntry, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PGEntry(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PGEntry(PyObject *args, CPT(PGEntry) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGEntry, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGEntry::PGEntry(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGEntry *return_value = new PGEntry(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PGEntry(PyObject *args, PT(PGEntry) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGEntry, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGEntry::PGEntry(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGEntry *return_value = new PGEntry(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_PGEntry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PGEntry) {
    printf("PGEntry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PGEntry *local_this = (PGEntry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PGEntry) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_PGItem) {
    return (PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PGEntry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PGEntry) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PGEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_PGItem) {
    PGItem* other_this = (PGItem*)from_this;
    return (PGEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PGEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PGEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PGEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PGEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PGEntry*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PGMouseWatcherParameter
 */
/**
 * Python function wrapper for:
 * void PGMouseWatcherParameter::output(ostream &out) const
 */
static PyObject *Dtool_PGMouseWatcherParameter_output_162(PyObject *self, PyObject *arg) {
  PGMouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGMouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PGMouseWatcherParameter::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PGMouseWatcherParameter.output", false, true);
  if (arg_this != NULL) {
    (*(const PGMouseWatcherParameter*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PGMouseWatcherParameter self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGMouseWatcherParameter_output_162_comment =
  "C++ Interface:\n"
  "output(PGMouseWatcherParameter self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PGMouseWatcherParameter_output_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PGMouseWatcherParameter::get_class_type(void)
 */
static PyObject *Dtool_PGMouseWatcherParameter_get_class_type_163(PyObject *, PyObject *) {
  // 1-static TypeHandle PGMouseWatcherParameter::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PGMouseWatcherParameter::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGMouseWatcherParameter_get_class_type_163_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PGMouseWatcherParameter_get_class_type_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *PGMouseWatcherParameter::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_156(PyObject *self, PyObject *) {
  PGMouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGMouseWatcherParameter, (void **)&local_this, "PGMouseWatcherParameter.upcast_to_TypedWritableReferenceCount")) {
    return NULL;
  }
  // 1-TypedWritableReferenceCount *PGMouseWatcherParameter::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_156_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const PGMouseWatcherParameter self)\n"
  "\n"
  "upcast from PGMouseWatcherParameter to TypedWritableReferenceCount";
#else
static const char *Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MouseWatcherParameter *PGMouseWatcherParameter::upcast_to_MouseWatcherParameter(void)
 */
static PyObject *Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_159(PyObject *self, PyObject *) {
  PGMouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGMouseWatcherParameter, (void **)&local_this, "PGMouseWatcherParameter.upcast_to_MouseWatcherParameter")) {
    return NULL;
  }
  // 1-MouseWatcherParameter *PGMouseWatcherParameter::upcast_to_MouseWatcherParameter(void)
  MouseWatcherParameter *return_value = (MouseWatcherParameter *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MouseWatcherParameter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_159_comment =
  "C++ Interface:\n"
  "upcast_to_MouseWatcherParameter(const PGMouseWatcherParameter self)\n"
  "\n"
  "upcast from PGMouseWatcherParameter to MouseWatcherParameter";
#else
static const char *Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PGMouseWatcherParameter::PGMouseWatcherParameter(PGMouseWatcherParameter const &) = default
 */
static int Dtool_Init_PGMouseWatcherParameter(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PGMouseWatcherParameter() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline PGMouseWatcherParameter::PGMouseWatcherParameter(PGMouseWatcherParameter const &) = default
  PGMouseWatcherParameter const *arg_this = (PGMouseWatcherParameter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PGMouseWatcherParameter, 0, "PGMouseWatcherParameter.PGMouseWatcherParameter", true, true);
  if (arg_this != NULL) {
    PGMouseWatcherParameter *return_value = new PGMouseWatcherParameter(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGMouseWatcherParameter, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PGMouseWatcherParameter(const PGMouseWatcherParameter param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PGMouseWatcherParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PGMouseWatcherParameter) {
    printf("PGMouseWatcherParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PGMouseWatcherParameter *local_this = (PGMouseWatcherParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PGMouseWatcherParameter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MouseWatcherParameter) {
    return (MouseWatcherParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PGMouseWatcherParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PGMouseWatcherParameter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MouseWatcherParameter) {
    MouseWatcherParameter* other_this = (MouseWatcherParameter*)from_this;
    return (PGMouseWatcherParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PGMouseWatcherParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PGMouseWatcherParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PGMouseWatcherParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PGMouseWatcherParameter*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PGMouseWatcherBackground
 */
/**
 * Python function wrapper for:
 * static TypeHandle PGMouseWatcherBackground::get_class_type(void)
 */
static PyObject *Dtool_PGMouseWatcherBackground_get_class_type_168(PyObject *, PyObject *) {
  // 1-static TypeHandle PGMouseWatcherBackground::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PGMouseWatcherBackground::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGMouseWatcherBackground_get_class_type_168_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PGMouseWatcherBackground_get_class_type_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGMouseWatcherBackground::PGMouseWatcherBackground(void)
 * inline PGMouseWatcherBackground::PGMouseWatcherBackground(PGMouseWatcherBackground const &) = default
 */
static int Dtool_Init_PGMouseWatcherBackground(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PGMouseWatcherBackground::PGMouseWatcherBackground(void)
      PGMouseWatcherBackground *return_value = new PGMouseWatcherBackground();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGMouseWatcherBackground, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline PGMouseWatcherBackground::PGMouseWatcherBackground(PGMouseWatcherBackground const &) = default
      PGMouseWatcherBackground const *arg_this = (PGMouseWatcherBackground *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PGMouseWatcherBackground, 0, "PGMouseWatcherBackground.PGMouseWatcherBackground", true, true);
      if (arg_this != NULL) {
        PGMouseWatcherBackground *return_value = new PGMouseWatcherBackground(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGMouseWatcherBackground, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PGMouseWatcherBackground() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PGMouseWatcherBackground()\n"
      "PGMouseWatcherBackground(const PGMouseWatcherBackground param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PGMouseWatcherBackground(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PGMouseWatcherBackground) {
    printf("PGMouseWatcherBackground ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PGMouseWatcherBackground *local_this = (PGMouseWatcherBackground *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PGMouseWatcherBackground) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MouseWatcherRegion) {
    return (MouseWatcherRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(MouseWatcherRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MouseWatcherRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MouseWatcherRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MouseWatcherRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MouseWatcherRegion *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PGMouseWatcherBackground(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PGMouseWatcherBackground) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MouseWatcherRegion) {
    MouseWatcherRegion* other_this = (MouseWatcherRegion*)from_this;
    return (PGMouseWatcherBackground*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PGMouseWatcherBackground*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PGMouseWatcherBackground*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PGMouseWatcherBackground*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PGMouseWatcherBackground*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PGMouseWatcherBackground*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PGVirtualFrame
 */
/**
 * Python function wrapper for:
 * void PGVirtualFrame::setup(PN_stdfloat width, PN_stdfloat height)
 */
static PyObject *Dtool_PGVirtualFrame_setup_171(PyObject *self, PyObject *args, PyObject *kwds) {
  PGVirtualFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGVirtualFrame, (void **)&local_this, "PGVirtualFrame.setup")) {
    return NULL;
  }
  // 1-void PGVirtualFrame::setup(PN_stdfloat width, PN_stdfloat height)
  float param1;
  float param2;
  static const char *keyword_list[] = {"width", "height", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:setup", (char **)keyword_list, &param1, &param2)) {
    (*local_this).setup((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup(const PGVirtualFrame self, float width, float height)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGVirtualFrame_setup_171_comment =
  "C++ Interface:\n"
  "setup(const PGVirtualFrame self, float width, float height)\n"
  "\n"
  "/**\n"
  " * Creates a PGVirtualFrame with the indicated dimensions.\n"
  " */";
#else
static const char *Dtool_PGVirtualFrame_setup_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGVirtualFrame::set_clip_frame(LVecBase4 const &clip_frame)
 * inline void PGVirtualFrame::set_clip_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_PGVirtualFrame_set_clip_frame_172(PyObject *self, PyObject *args, PyObject *kwds) {
  PGVirtualFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGVirtualFrame, (void **)&local_this, "PGVirtualFrame.set_clip_frame")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "clip_frame");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'clip_frame' (pos 1) not found");
      }
      // 1-void PGVirtualFrame::set_clip_frame(LVecBase4 const &clip_frame)
      LVecBase4f arg_local;
      LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PGVirtualFrame.set_clip_frame", "LVecBase4f");
      }
      (*local_this).set_clip_frame(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void PGVirtualFrame::set_clip_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"left", "right", "bottom", "top", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_clip_frame", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_clip_frame((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_clip_frame() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clip_frame(const PGVirtualFrame self, const LVecBase4f clip_frame)\n"
      "set_clip_frame(const PGVirtualFrame self, float left, float right, float bottom, float top)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGVirtualFrame_set_clip_frame_172_comment =
  "C++ Interface:\n"
  "set_clip_frame(const PGVirtualFrame self, const LVecBase4f clip_frame)\n"
  "set_clip_frame(const PGVirtualFrame self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Sets the bounding rectangle of the clip frame.  This is the size of the\n"
  " * small window through which we can see the virtual canvas.  Normally, this\n"
  " * is the same size as the actual frame or smaller (typically it is smaller by\n"
  " * the size of the bevel, or to make room for scroll bars).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the bounding rectangle of the clip frame.  This is the size of the\n"
  " * small window through which we can see the virtual canvas.  Normally, this\n"
  " * is the same size as the actual frame or smaller (typically it is smaller by\n"
  " * the size of the bevel, or to make room for scroll bars).\n"
  " */";
#else
static const char *Dtool_PGVirtualFrame_set_clip_frame_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &PGVirtualFrame::get_clip_frame(void) const
 */
static PyObject *Dtool_PGVirtualFrame_get_clip_frame_173(PyObject *self, PyObject *) {
  PGVirtualFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGVirtualFrame, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4 const &PGVirtualFrame::get_clip_frame(void) const
  LVecBase4 const *return_value = &((*(const PGVirtualFrame*)local_this).get_clip_frame());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PGVirtualFrame_get_clip_frame_173_comment =
  "C++ Interface:\n"
  "get_clip_frame(PGVirtualFrame self)\n"
  "\n"
  "/**\n"
  " * Returns the bounding rectangle of the clip frame.  See set_clip_frame().\n"
  " * If has_clip_frame() is false, this returns the item's actual frame.\n"
  " */";
#else
static const char *Dtool_PGVirtualFrame_get_clip_frame_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGVirtualFrame::has_clip_frame(void) const
 */
static PyObject *Dtool_PGVirtualFrame_has_clip_frame_174(PyObject *self, PyObject *) {
  PGVirtualFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGVirtualFrame, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGVirtualFrame::has_clip_frame(void) const
  bool return_value = (*(const PGVirtualFrame*)local_this).has_clip_frame();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGVirtualFrame_has_clip_frame_174_comment =
  "C++ Interface:\n"
  "has_clip_frame(PGVirtualFrame self)\n"
  "\n"
  "/**\n"
  " * Returns true if the clip frame has been set; see set_clip_frame().  If it\n"
  " * has not been set, objects in the virtual frame will not be clipped.\n"
  " */";
#else
static const char *Dtool_PGVirtualFrame_has_clip_frame_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGVirtualFrame::clear_clip_frame(void)
 */
static PyObject *Dtool_PGVirtualFrame_clear_clip_frame_175(PyObject *self, PyObject *) {
  PGVirtualFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGVirtualFrame, (void **)&local_this, "PGVirtualFrame.clear_clip_frame")) {
    return NULL;
  }
  // 1-void PGVirtualFrame::clear_clip_frame(void)
  (*local_this).clear_clip_frame();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGVirtualFrame_clear_clip_frame_175_comment =
  "C++ Interface:\n"
  "clear_clip_frame(const PGVirtualFrame self)\n"
  "\n"
  "/**\n"
  " * Removes the clip frame from the item.  This disables clipping.\n"
  " */";
#else
static const char *Dtool_PGVirtualFrame_clear_clip_frame_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGVirtualFrame::set_canvas_transform(TransformState const *transform)
 */
static PyObject *Dtool_PGVirtualFrame_set_canvas_transform_176(PyObject *self, PyObject *arg) {
  PGVirtualFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGVirtualFrame, (void **)&local_this, "PGVirtualFrame.set_canvas_transform")) {
    return NULL;
  }
  // 1-inline void PGVirtualFrame::set_canvas_transform(TransformState const *transform)
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "PGVirtualFrame.set_canvas_transform", true, true);
  if (arg_this != NULL) {
    (*local_this).set_canvas_transform(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_canvas_transform(const PGVirtualFrame self, const TransformState transform)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGVirtualFrame_set_canvas_transform_176_comment =
  "C++ Interface:\n"
  "set_canvas_transform(const PGVirtualFrame self, const TransformState transform)\n"
  "\n"
  "/**\n"
  " * Changes the transform of the virtual canvas.  This transform is applied to\n"
  " * all child nodes of the canvas_node.\n"
  " */";
#else
static const char *Dtool_PGVirtualFrame_set_canvas_transform_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *PGVirtualFrame::get_canvas_transform(void) const
 */
static PyObject *Dtool_PGVirtualFrame_get_canvas_transform_177(PyObject *self, PyObject *) {
  PGVirtualFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGVirtualFrame, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TransformState const *PGVirtualFrame::get_canvas_transform(void) const
  TransformState const *return_value = (*(const PGVirtualFrame*)local_this).get_canvas_transform();
  if (return_value != (TransformState const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (TransformState const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TransformState, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGVirtualFrame_get_canvas_transform_177_comment =
  "C++ Interface:\n"
  "get_canvas_transform(PGVirtualFrame self)\n"
  "\n"
  "/**\n"
  " * Returns the transform of the virtual canvas.  This transform is applied to\n"
  " * all child nodes of the canvas_node.\n"
  " */";
#else
static const char *Dtool_PGVirtualFrame_get_canvas_transform_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *PGVirtualFrame::get_canvas_node(void) const
 */
static PyObject *Dtool_PGVirtualFrame_get_canvas_node_178(PyObject *self, PyObject *) {
  PGVirtualFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGVirtualFrame, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PandaNode *PGVirtualFrame::get_canvas_node(void) const
  PandaNode *return_value = (*(const PGVirtualFrame*)local_this).get_canvas_node();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGVirtualFrame_get_canvas_node_178_comment =
  "C++ Interface:\n"
  "get_canvas_node(PGVirtualFrame self)\n"
  "\n"
  "/**\n"
  " * Returns the special node that holds all of the children that appear in the\n"
  " * virtual canvas.\n"
  " */";
#else
static const char *Dtool_PGVirtualFrame_get_canvas_node_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *PGVirtualFrame::get_canvas_parent(void) const
 */
static PyObject *Dtool_PGVirtualFrame_get_canvas_parent_179(PyObject *self, PyObject *) {
  PGVirtualFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGVirtualFrame, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PandaNode *PGVirtualFrame::get_canvas_parent(void) const
  PandaNode *return_value = (*(const PGVirtualFrame*)local_this).get_canvas_parent();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGVirtualFrame_get_canvas_parent_179_comment =
  "C++ Interface:\n"
  "get_canvas_parent(PGVirtualFrame self)\n"
  "\n"
  "/**\n"
  " * Returns the parent node of the canvas_node.\n"
  " */";
#else
static const char *Dtool_PGVirtualFrame_get_canvas_parent_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PGVirtualFrame::get_class_type(void)
 */
static PyObject *Dtool_PGVirtualFrame_get_class_type_180(PyObject *, PyObject *) {
  // 1-static TypeHandle PGVirtualFrame::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PGVirtualFrame::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGVirtualFrame_get_class_type_180_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PGVirtualFrame_get_class_type_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGScrollFrame *PGVirtualFrame::downcast_to_PGScrollFrame(void)
 */
static PyObject *Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_226(PyObject *self, PyObject *) {
  PGVirtualFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGVirtualFrame, (void **)&local_this, "PGVirtualFrame.downcast_to_PGScrollFrame")) {
    return NULL;
  }
  // 1-PGScrollFrame *PGVirtualFrame::downcast_to_PGScrollFrame(void)
  PGScrollFrame *return_value = (PGScrollFrame *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PGScrollFrame, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_226_comment =
  "C++ Interface:\n"
  "downcast_to_PGScrollFrame(const PGVirtualFrame self)\n"
  "\n"
  "downcast from PGVirtualFrame to PGScrollFrame";
#else
static const char *Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGVirtualFrame::PGVirtualFrame(std::string const &name = "")
 */
static int Dtool_Init_PGVirtualFrame(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-PGVirtualFrame::PGVirtualFrame(std::string const &name = "")
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:PGVirtualFrame", (char **)keyword_list, &param0_str, &param0_len)) {
    PGVirtualFrame *return_value = new PGVirtualFrame(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGVirtualFrame, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PGVirtualFrame(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PGVirtualFrame(PyObject *args, CPT(PGVirtualFrame) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGVirtualFrame, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGVirtualFrame::PGVirtualFrame(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGVirtualFrame *return_value = new PGVirtualFrame(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PGVirtualFrame(PyObject *args, PT(PGVirtualFrame) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGVirtualFrame, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGVirtualFrame::PGVirtualFrame(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGVirtualFrame *return_value = new PGVirtualFrame(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_PGVirtualFrame(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PGVirtualFrame) {
    printf("PGVirtualFrame ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PGVirtualFrame *local_this = (PGVirtualFrame *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PGVirtualFrame) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_PGItem) {
    return (PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PGVirtualFrame(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PGVirtualFrame) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PGVirtualFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_PGItem) {
    PGItem* other_this = (PGItem*)from_this;
    return (PGVirtualFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PGVirtualFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PGVirtualFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PGVirtualFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PGVirtualFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PGVirtualFrame*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PGSliderBar
 */
/**
 * Python function wrapper for:
 * void PGSliderBar::setup_scroll_bar(bool vertical, PN_stdfloat length, PN_stdfloat width, PN_stdfloat bevel)
 */
static PyObject *Dtool_PGSliderBar_setup_scroll_bar_189(PyObject *self, PyObject *args, PyObject *kwds) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.setup_scroll_bar")) {
    return NULL;
  }
  // 1-void PGSliderBar::setup_scroll_bar(bool vertical, PN_stdfloat length, PN_stdfloat width, PN_stdfloat bevel)
  PyObject *param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"vertical", "length", "width", "bevel", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:setup_scroll_bar", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).setup_scroll_bar((PyObject_IsTrue(param1) != 0), (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_scroll_bar(const PGSliderBar self, bool vertical, float length, float width, float bevel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_setup_scroll_bar_189_comment =
  "C++ Interface:\n"
  "setup_scroll_bar(const PGSliderBar self, bool vertical, float length, float width, float bevel)\n"
  "\n"
  "/**\n"
  " * Creates PGSliderBar that represents a vertical or horizontal scroll bar (if\n"
  " * vertical is true or false, respectively), with additional buttons for\n"
  " * scrolling, and a range of 0 .. 1.\n"
  " *\n"
  " * length here is the measurement along the scroll bar, and width is the\n"
  " * measurement across the scroll bar, whether it is vertical or horizontal (so\n"
  " * for a horizontal scroll bar, the length is actually the x dimension, and\n"
  " * the width is the y dimension).\n"
  " */";
#else
static const char *Dtool_PGSliderBar_setup_scroll_bar_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGSliderBar::setup_slider(bool vertical, PN_stdfloat length, PN_stdfloat width, PN_stdfloat bevel)
 */
static PyObject *Dtool_PGSliderBar_setup_slider_190(PyObject *self, PyObject *args, PyObject *kwds) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.setup_slider")) {
    return NULL;
  }
  // 1-void PGSliderBar::setup_slider(bool vertical, PN_stdfloat length, PN_stdfloat width, PN_stdfloat bevel)
  PyObject *param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"vertical", "length", "width", "bevel", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:setup_slider", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).setup_slider((PyObject_IsTrue(param1) != 0), (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_slider(const PGSliderBar self, bool vertical, float length, float width, float bevel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_setup_slider_190_comment =
  "C++ Interface:\n"
  "setup_slider(const PGSliderBar self, bool vertical, float length, float width, float bevel)\n"
  "\n"
  "/**\n"
  " * Creates PGSliderBar that represents a slider that the user can use to\n"
  " * control an analog quantity.\n"
  " *\n"
  " * This is functionally the same as a scroll bar, but it has a distinctive\n"
  " * look.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_setup_slider_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::set_axis(LVector3 const &axis)
 */
static PyObject *Dtool_PGSliderBar_set_axis_191(PyObject *self, PyObject *arg) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_axis")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::set_axis(LVector3 const &axis)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGSliderBar.set_axis", "LVector3f");
  }
  (*local_this).set_axis(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis(const PGSliderBar self, const LVector3f axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_axis_191_comment =
  "C++ Interface:\n"
  "set_axis(const PGSliderBar self, const LVector3f axis)\n"
  "\n"
  "/**\n"
  " * Specifies the axis of the slider bar's motion.  This should be only one of\n"
  " * four vectors: (1, 0, 0), (0, 0, 1), (-1, 0, 0), or (0, 0, -1).\n"
  " *\n"
  " * This specifies the vector in which the thumb moves when it is moving from\n"
  " * the minimum to the maximum value.\n"
  " *\n"
  " * The axis must be parallel to one of the screen axes, and it must be\n"
  " * normalized.  Hence, it may only be one of the above four possibilities;\n"
  " * anything else is an error and will result in indeterminate behavior.\n"
  " *\n"
  " * Normally, you should not try to set the axis directly.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_axis_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &PGSliderBar::get_axis(void) const
 */
static PyObject *Dtool_PGSliderBar_get_axis_192(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 const &PGSliderBar::get_axis(void) const
  LVector3 const *return_value = &((*(const PGSliderBar*)local_this).get_axis());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_axis_192_comment =
  "C++ Interface:\n"
  "get_axis(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the axis of the slider bar's motion.  See set_axis().\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_axis_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::set_range(PN_stdfloat min_value, PN_stdfloat max_value)
 */
static PyObject *Dtool_PGSliderBar_set_range_193(PyObject *self, PyObject *args, PyObject *kwds) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_range")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::set_range(PN_stdfloat min_value, PN_stdfloat max_value)
  float param1;
  float param2;
  static const char *keyword_list[] = {"min_value", "max_value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_range", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_range((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const PGSliderBar self, float min_value, float max_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_range_193_comment =
  "C++ Interface:\n"
  "set_range(const PGSliderBar self, float min_value, float max_value)\n"
  "\n"
  "/**\n"
  " * Sets the minimum and maxmimum value for the slider.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_range_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGSliderBar::get_min_value(void) const
 */
static PyObject *Dtool_PGSliderBar_get_min_value_194(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGSliderBar::get_min_value(void) const
  PN_stdfloat return_value = (*(const PGSliderBar*)local_this).get_min_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_min_value_194_comment =
  "C++ Interface:\n"
  "get_min_value(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the value when the slider is all the way to the left.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_min_value_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGSliderBar::get_max_value(void) const
 */
static PyObject *Dtool_PGSliderBar_get_max_value_195(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGSliderBar::get_max_value(void) const
  PN_stdfloat return_value = (*(const PGSliderBar*)local_this).get_max_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_max_value_195_comment =
  "C++ Interface:\n"
  "get_max_value(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the value when the slider is all the way to the right.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_max_value_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::set_scroll_size(PN_stdfloat scroll_size)
 */
static PyObject *Dtool_PGSliderBar_set_scroll_size_196(PyObject *self, PyObject *arg) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_scroll_size")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::set_scroll_size(PN_stdfloat scroll_size)
  if (PyNumber_Check(arg)) {
    (*local_this).set_scroll_size((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scroll_size(const PGSliderBar self, float scroll_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_scroll_size_196_comment =
  "C++ Interface:\n"
  "set_scroll_size(const PGSliderBar self, float scroll_size)\n"
  "\n"
  "/**\n"
  " * Specifies the amount the slider will move when the user clicks on the left\n"
  " * or right buttons.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_scroll_size_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGSliderBar::get_scroll_size(void) const
 */
static PyObject *Dtool_PGSliderBar_get_scroll_size_197(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGSliderBar::get_scroll_size(void) const
  PN_stdfloat return_value = (*(const PGSliderBar*)local_this).get_scroll_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_scroll_size_197_comment =
  "C++ Interface:\n"
  "get_scroll_size(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the value last set by set_scroll_size().\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_scroll_size_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::set_page_size(PN_stdfloat page_size)
 */
static PyObject *Dtool_PGSliderBar_set_page_size_198(PyObject *self, PyObject *arg) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_page_size")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::set_page_size(PN_stdfloat page_size)
  if (PyNumber_Check(arg)) {
    (*local_this).set_page_size((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_page_size(const PGSliderBar self, float page_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_page_size_198_comment =
  "C++ Interface:\n"
  "set_page_size(const PGSliderBar self, float page_size)\n"
  "\n"
  "/**\n"
  " * Specifies the amount of data contained in a single page.  This indicates\n"
  " * how much the thumb will jump when the trough is directly clicked; and if\n"
  " * resize_thumb is true, it also controls the visible size of the thumb\n"
  " * button.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_page_size_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGSliderBar::get_page_size(void) const
 */
static PyObject *Dtool_PGSliderBar_get_page_size_199(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGSliderBar::get_page_size(void) const
  PN_stdfloat return_value = (*(const PGSliderBar*)local_this).get_page_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_page_size_199_comment =
  "C++ Interface:\n"
  "get_page_size(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the value last set by set_page_size().\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_page_size_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::set_value(PN_stdfloat value)
 */
static PyObject *Dtool_PGSliderBar_set_value_200(PyObject *self, PyObject *arg) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_value")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::set_value(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_value((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const PGSliderBar self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_value_200_comment =
  "C++ Interface:\n"
  "set_value(const PGSliderBar self, float value)\n"
  "\n"
  "/**\n"
  " * Sets the current value of the slider programmatically.  This should range\n"
  " * between get_min_value() and get_max_value().\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_value_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGSliderBar::get_value(void) const
 */
static PyObject *Dtool_PGSliderBar_get_value_201(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGSliderBar::get_value(void) const
  PN_stdfloat return_value = (*(const PGSliderBar*)local_this).get_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_value_201_comment =
  "C++ Interface:\n"
  "get_value(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the current value of the slider.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_value_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::set_ratio(PN_stdfloat ratio)
 */
static PyObject *Dtool_PGSliderBar_set_ratio_202(PyObject *self, PyObject *arg) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_ratio")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::set_ratio(PN_stdfloat ratio)
  if (PyNumber_Check(arg)) {
    (*local_this).set_ratio((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ratio(const PGSliderBar self, float ratio)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_ratio_202_comment =
  "C++ Interface:\n"
  "set_ratio(const PGSliderBar self, float ratio)\n"
  "\n"
  "/**\n"
  " * Sets the current value of the slider, expressed in the range 0 .. 1.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_ratio_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGSliderBar::get_ratio(void) const
 */
static PyObject *Dtool_PGSliderBar_get_ratio_203(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGSliderBar::get_ratio(void) const
  PN_stdfloat return_value = (*(const PGSliderBar*)local_this).get_ratio();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_ratio_203_comment =
  "C++ Interface:\n"
  "get_ratio(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the current value of the slider, expressed in the range 0 .. 1.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_ratio_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGSliderBar::is_button_down(void) const
 */
static PyObject *Dtool_PGSliderBar_is_button_down_204(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGSliderBar::is_button_down(void) const
  bool return_value = (*(const PGSliderBar*)local_this).is_button_down();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_is_button_down_204_comment =
  "C++ Interface:\n"
  "is_button_down(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns true if the user is currently holding down the mouse button to\n"
  " * manipulate the slider.  When true, calls to set_ratio() or set_value() will\n"
  " * have no effect.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_is_button_down_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::set_resize_thumb(bool resize_thumb)
 */
static PyObject *Dtool_PGSliderBar_set_resize_thumb_205(PyObject *self, PyObject *arg) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_resize_thumb")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::set_resize_thumb(bool resize_thumb)
  (*local_this).set_resize_thumb((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_resize_thumb(const PGSliderBar self, bool resize_thumb)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_resize_thumb_205_comment =
  "C++ Interface:\n"
  "set_resize_thumb(const PGSliderBar self, bool resize_thumb)\n"
  "\n"
  "/**\n"
  " * Sets the resize_thumb flag.  When this is true, the thumb button's frame\n"
  " * will be adjusted so that its width visually represents the page size.  When\n"
  " * this is false, the thumb button will be left alone.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_resize_thumb_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGSliderBar::get_resize_thumb(void) const
 */
static PyObject *Dtool_PGSliderBar_get_resize_thumb_206(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGSliderBar::get_resize_thumb(void) const
  bool return_value = (*(const PGSliderBar*)local_this).get_resize_thumb();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_resize_thumb_206_comment =
  "C++ Interface:\n"
  "get_resize_thumb(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the resize_thumb flag.  See set_resize_thumb().\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_resize_thumb_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::set_manage_pieces(bool manage_pieces)
 */
static PyObject *Dtool_PGSliderBar_set_manage_pieces_207(PyObject *self, PyObject *arg) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_manage_pieces")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::set_manage_pieces(bool manage_pieces)
  (*local_this).set_manage_pieces((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_manage_pieces(const PGSliderBar self, bool manage_pieces)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_manage_pieces_207_comment =
  "C++ Interface:\n"
  "set_manage_pieces(const PGSliderBar self, bool manage_pieces)\n"
  "\n"
  "/**\n"
  " * Sets the manage_pieces flag.  When this is true, the sub-pieces of the\n"
  " * slider bar--that is, the thumb, and the left and right scroll buttons--are\n"
  " * automatically positioned and/or resized when the slider bar's overall frame\n"
  " * is changed.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_manage_pieces_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGSliderBar::get_manage_pieces(void) const
 */
static PyObject *Dtool_PGSliderBar_get_manage_pieces_208(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGSliderBar::get_manage_pieces(void) const
  bool return_value = (*(const PGSliderBar*)local_this).get_manage_pieces();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_manage_pieces_208_comment =
  "C++ Interface:\n"
  "get_manage_pieces(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the manage_pieces flag.  See set_manage_pieces().\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_manage_pieces_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::set_thumb_button(PGButton *thumb_button)
 */
static PyObject *Dtool_PGSliderBar_set_thumb_button_209(PyObject *self, PyObject *arg) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_thumb_button")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::set_thumb_button(PGButton *thumb_button)
  PT(PGButton) arg_this;
  if (!Dtool_Coerce_PGButton(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGSliderBar.set_thumb_button", "PGButton");
  }
  (*local_this).set_thumb_button(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_thumb_button(const PGSliderBar self, PGButton thumb_button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_thumb_button_209_comment =
  "C++ Interface:\n"
  "set_thumb_button(const PGSliderBar self, PGButton thumb_button)\n"
  "\n"
  "/**\n"
  " * Sets the PGButton object that will serve as the thumb for this slider.\n"
  " * This button visually represents the position of the slider, and can be\n"
  " * dragged left and right by the user.\n"
  " *\n"
  " * It is the responsibility of the caller to ensure that the button object is\n"
  " * parented to the PGSliderBar node.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_thumb_button_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::clear_thumb_button(void)
 */
static PyObject *Dtool_PGSliderBar_clear_thumb_button_210(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.clear_thumb_button")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::clear_thumb_button(void)
  (*local_this).clear_thumb_button();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_clear_thumb_button_210_comment =
  "C++ Interface:\n"
  "clear_thumb_button(const PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Removes the thumb button object from control of the frame.  It is your\n"
  " * responsibility to actually remove or hide the button itself.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_clear_thumb_button_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PGButton *PGSliderBar::get_thumb_button(void) const
 */
static PyObject *Dtool_PGSliderBar_get_thumb_button_211(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PGButton *PGSliderBar::get_thumb_button(void) const
  PGButton *return_value = (*(const PGSliderBar*)local_this).get_thumb_button();
  if (return_value != (PGButton *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PGButton *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PGButton, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_thumb_button_211_comment =
  "C++ Interface:\n"
  "get_thumb_button(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the PGButton that serves as the thumb for this slider, or NULL if\n"
  " * it is not set.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_thumb_button_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::set_left_button(PGButton *left_button)
 */
static PyObject *Dtool_PGSliderBar_set_left_button_212(PyObject *self, PyObject *arg) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_left_button")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::set_left_button(PGButton *left_button)
  PT(PGButton) arg_this;
  if (!Dtool_Coerce_PGButton(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGSliderBar.set_left_button", "PGButton");
  }
  (*local_this).set_left_button(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_left_button(const PGSliderBar self, PGButton left_button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_left_button_212_comment =
  "C++ Interface:\n"
  "set_left_button(const PGSliderBar self, PGButton left_button)\n"
  "\n"
  "/**\n"
  " * Sets the PGButton object that will serve as the left scroll button for this\n"
  " * slider.  This button is optional; if present, the user can click on it to\n"
  " * move scroll_size units at a time to the left.\n"
  " *\n"
  " * It is the responsibility of the caller to ensure that the button object is\n"
  " * parented to the PGSliderBar node.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_left_button_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::clear_left_button(void)
 */
static PyObject *Dtool_PGSliderBar_clear_left_button_213(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.clear_left_button")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::clear_left_button(void)
  (*local_this).clear_left_button();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_clear_left_button_213_comment =
  "C++ Interface:\n"
  "clear_left_button(const PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Removes the left button object from control of the frame.  It is your\n"
  " * responsibility to actually remove or hide the button itself.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_clear_left_button_213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PGButton *PGSliderBar::get_left_button(void) const
 */
static PyObject *Dtool_PGSliderBar_get_left_button_214(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PGButton *PGSliderBar::get_left_button(void) const
  PGButton *return_value = (*(const PGSliderBar*)local_this).get_left_button();
  if (return_value != (PGButton *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PGButton *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PGButton, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_left_button_214_comment =
  "C++ Interface:\n"
  "get_left_button(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the PGButton that serves as the left scroll button for this slider,\n"
  " * if any, or NULL if it is not set.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_left_button_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::set_right_button(PGButton *right_button)
 */
static PyObject *Dtool_PGSliderBar_set_right_button_215(PyObject *self, PyObject *arg) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_right_button")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::set_right_button(PGButton *right_button)
  PT(PGButton) arg_this;
  if (!Dtool_Coerce_PGButton(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGSliderBar.set_right_button", "PGButton");
  }
  (*local_this).set_right_button(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_right_button(const PGSliderBar self, PGButton right_button)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_right_button_215_comment =
  "C++ Interface:\n"
  "set_right_button(const PGSliderBar self, PGButton right_button)\n"
  "\n"
  "/**\n"
  " * Sets the PGButton object that will serve as the right scroll button for\n"
  " * this slider.  This button is optional; if present, the user can click on it\n"
  " * to move scroll_size units at a time to the right.\n"
  " *\n"
  " * It is the responsibility of the caller to ensure that the button object is\n"
  " * parented to the PGSliderBar node.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_right_button_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGSliderBar::clear_right_button(void)
 */
static PyObject *Dtool_PGSliderBar_clear_right_button_216(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.clear_right_button")) {
    return NULL;
  }
  // 1-inline void PGSliderBar::clear_right_button(void)
  (*local_this).clear_right_button();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_clear_right_button_216_comment =
  "C++ Interface:\n"
  "clear_right_button(const PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Removes the right button object from control of the frame.  It is your\n"
  " * responsibility to actually remove or hide the button itself.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_clear_right_button_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PGButton *PGSliderBar::get_right_button(void) const
 */
static PyObject *Dtool_PGSliderBar_get_right_button_217(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PGButton *PGSliderBar::get_right_button(void) const
  PGButton *return_value = (*(const PGSliderBar*)local_this).get_right_button();
  if (return_value != (PGButton *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PGButton *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PGButton, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_right_button_217_comment =
  "C++ Interface:\n"
  "get_right_button(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the PGButton that serves as the right scroll button for this\n"
  " * slider, if any, or NULL if it is not set.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_right_button_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string PGSliderBar::get_adjust_prefix(void)
 */
static PyObject *Dtool_PGSliderBar_get_adjust_prefix_218(PyObject *, PyObject *) {
  // 1-static inline std::string PGSliderBar::get_adjust_prefix(void)
  std::string return_value = PGSliderBar::get_adjust_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_adjust_prefix_218_comment =
  "C++ Interface:\n"
  "get_adjust_prefix()\n"
  "\n"
  "/**\n"
  " * Returns the prefix that is used to define the adjust event for all\n"
  " * PGSliderBars.  The adjust event is the concatenation of this string\n"
  " * followed by get_id().\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_adjust_prefix_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string PGSliderBar::get_adjust_event(void) const
 */
static PyObject *Dtool_PGSliderBar_get_adjust_event_219(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGSliderBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string PGSliderBar::get_adjust_event(void) const
  std::string return_value = (*(const PGSliderBar*)local_this).get_adjust_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_adjust_event_219_comment =
  "C++ Interface:\n"
  "get_adjust_event(PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the slider bar value is\n"
  " * adjusted by the user or programmatically.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_get_adjust_event_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PGSliderBar::set_active(bool active)
 */
static PyObject *Dtool_PGSliderBar_set_active_220(PyObject *self, PyObject *arg) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.set_active")) {
    return NULL;
  }
  // 1-virtual void PGSliderBar::set_active(bool active)
  (*local_this).set_active((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const PGSliderBar self, bool active)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_set_active_220_comment =
  "C++ Interface:\n"
  "set_active(const PGSliderBar self, bool active)\n"
  "\n"
  "/**\n"
  " * Sets whether the PGItem is active for mouse watching.  This is not\n"
  " * necessarily related to the active/inactive appearance of the item, which is\n"
  " * controlled by set_state(), but it does affect whether it responds to mouse\n"
  " * events.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_set_active_220_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGSliderBar::remanage(void)
 */
static PyObject *Dtool_PGSliderBar_remanage_221(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.remanage")) {
    return NULL;
  }
  // 1-void PGSliderBar::remanage(void)
  (*local_this).remanage();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_remanage_221_comment =
  "C++ Interface:\n"
  "remanage(const PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Manages the position and size of the scroll bars and the thumb.  Normally\n"
  " * this should not need to be called directly.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_remanage_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGSliderBar::recompute(void)
 */
static PyObject *Dtool_PGSliderBar_recompute_222(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.recompute")) {
    return NULL;
  }
  // 1-void PGSliderBar::recompute(void)
  (*local_this).recompute();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_recompute_222_comment =
  "C++ Interface:\n"
  "recompute(const PGSliderBar self)\n"
  "\n"
  "/**\n"
  " * Recomputes the position and size of the thumb.  Normally this should not\n"
  " * need to be called directly.\n"
  " */";
#else
static const char *Dtool_PGSliderBar_recompute_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PGSliderBar::get_class_type(void)
 */
static PyObject *Dtool_PGSliderBar_get_class_type_223(PyObject *, PyObject *) {
  // 1-static TypeHandle PGSliderBar::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PGSliderBar::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_get_class_type_223_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PGSliderBar_get_class_type_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGItem *PGSliderBar::upcast_to_PGItem(void)
 */
static PyObject *Dtool_PGSliderBar_upcast_to_PGItem_182(PyObject *self, PyObject *) {
  PGSliderBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGSliderBar, (void **)&local_this, "PGSliderBar.upcast_to_PGItem")) {
    return NULL;
  }
  // 1-PGItem *PGSliderBar::upcast_to_PGItem(void)
  PGItem *return_value = (PGItem *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PGItem, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGSliderBar_upcast_to_PGItem_182_comment =
  "C++ Interface:\n"
  "upcast_to_PGItem(const PGSliderBar self)\n"
  "\n"
  "upcast from PGSliderBar to PGItem";
#else
static const char *Dtool_PGSliderBar_upcast_to_PGItem_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGSliderBar::PGSliderBar(std::string const &name = "")
 */
static int Dtool_Init_PGSliderBar(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-PGSliderBar::PGSliderBar(std::string const &name = "")
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:PGSliderBar", (char **)keyword_list, &param0_str, &param0_len)) {
    PGSliderBar *return_value = new PGSliderBar(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGSliderBar, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PGSliderBar(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PGSliderBar(PyObject *args, CPT(PGSliderBar) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGSliderBar, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGSliderBar::PGSliderBar(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGSliderBar *return_value = new PGSliderBar(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PGSliderBar(PyObject *args, PT(PGSliderBar) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGSliderBar, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGSliderBar::PGSliderBar(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGSliderBar *return_value = new PGSliderBar(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_PGSliderBar(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PGSliderBar) {
    printf("PGSliderBar ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PGSliderBar *local_this = (PGSliderBar *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PGSliderBar) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_PGItem) {
    return (PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PGSliderBar(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PGSliderBar) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PGSliderBar*)other_this;
  }
  if (from_type == Dtool_Ptr_PGItem) {
    PGItem* other_this = (PGItem*)from_this;
    return (PGSliderBar*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PGSliderBar*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PGSliderBar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PGSliderBar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PGSliderBar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PGSliderBar*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PGScrollFrame
 */
/**
 * Python function wrapper for:
 * void PGScrollFrame::setup(PN_stdfloat width, PN_stdfloat height, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top, PN_stdfloat slider_width, PN_stdfloat bevel)
 */
static PyObject *Dtool_PGScrollFrame_setup_232(PyObject *self, PyObject *args, PyObject *kwds) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.setup")) {
    return NULL;
  }
  // 1-void PGScrollFrame::setup(PN_stdfloat width, PN_stdfloat height, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top, PN_stdfloat slider_width, PN_stdfloat bevel)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  static const char *keyword_list[] = {"width", "height", "left", "right", "bottom", "top", "slider_width", "bevel", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffff:setup", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    (*local_this).setup((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup(const PGScrollFrame self, float width, float height, float left, float right, float bottom, float top, float slider_width, float bevel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_setup_232_comment =
  "C++ Interface:\n"
  "setup(const PGScrollFrame self, float width, float height, float left, float right, float bottom, float top, float slider_width, float bevel)\n"
  "\n"
  "/**\n"
  " * Creates a PGScrollFrame with the indicated dimensions, and the indicated\n"
  " * virtual frame.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_setup_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGScrollFrame::set_virtual_frame(LVecBase4 const &virtual_frame)
 * inline void PGScrollFrame::set_virtual_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
 */
static PyObject *Dtool_PGScrollFrame_set_virtual_frame_233(PyObject *self, PyObject *args, PyObject *kwds) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.set_virtual_frame")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "virtual_frame");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'virtual_frame' (pos 1) not found");
      }
      // 1-inline void PGScrollFrame::set_virtual_frame(LVecBase4 const &virtual_frame)
      LVecBase4f arg_local;
      LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PGScrollFrame.set_virtual_frame", "LVecBase4f");
      }
      (*local_this).set_virtual_frame(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void PGScrollFrame::set_virtual_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"left", "right", "bottom", "top", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_virtual_frame", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).set_virtual_frame((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_virtual_frame() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_virtual_frame(const PGScrollFrame self, const LVecBase4f virtual_frame)\n"
      "set_virtual_frame(const PGScrollFrame self, float left, float right, float bottom, float top)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_set_virtual_frame_233_comment =
  "C++ Interface:\n"
  "set_virtual_frame(const PGScrollFrame self, const LVecBase4f virtual_frame)\n"
  "set_virtual_frame(const PGScrollFrame self, float left, float right, float bottom, float top)\n"
  "\n"
  "/**\n"
  " * Sets the bounding rectangle of the virtual frame.  This is the size of the\n"
  " * large, virtual canvas which we can see only a portion of at any given time.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the bounding rectangle of the virtual frame.  This is the size of the\n"
  " * large, virtual canvas which we can see only a portion of at any given time.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_set_virtual_frame_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &PGScrollFrame::get_virtual_frame(void) const
 */
static PyObject *Dtool_PGScrollFrame_get_virtual_frame_234(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGScrollFrame, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4 const &PGScrollFrame::get_virtual_frame(void) const
  LVecBase4 const *return_value = &((*(const PGScrollFrame*)local_this).get_virtual_frame());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_get_virtual_frame_234_comment =
  "C++ Interface:\n"
  "get_virtual_frame(PGScrollFrame self)\n"
  "\n"
  "/**\n"
  " * Returns the bounding rectangle of the virtual frame.  See\n"
  " * set_virtual_frame().  If has_virtual_frame() is false, this returns the\n"
  " * item's clip frame.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_get_virtual_frame_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGScrollFrame::has_virtual_frame(void) const
 */
static PyObject *Dtool_PGScrollFrame_has_virtual_frame_235(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGScrollFrame, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGScrollFrame::has_virtual_frame(void) const
  bool return_value = (*(const PGScrollFrame*)local_this).has_virtual_frame();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_has_virtual_frame_235_comment =
  "C++ Interface:\n"
  "has_virtual_frame(PGScrollFrame self)\n"
  "\n"
  "/**\n"
  " * Returns true if the virtual frame has a bounding rectangle; see\n"
  " * set_virtual_frame().  Most PGScrollFrame objects will have a virtual frame.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_has_virtual_frame_235_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGScrollFrame::clear_virtual_frame(void)
 */
static PyObject *Dtool_PGScrollFrame_clear_virtual_frame_236(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.clear_virtual_frame")) {
    return NULL;
  }
  // 1-inline void PGScrollFrame::clear_virtual_frame(void)
  (*local_this).clear_virtual_frame();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_clear_virtual_frame_236_comment =
  "C++ Interface:\n"
  "clear_virtual_frame(const PGScrollFrame self)\n"
  "\n"
  "/**\n"
  " * Removes the virtual frame from the item.  This effectively sets the virtual\n"
  " * frame to the same size as the clip frame.  Scrolling will no longer be\n"
  " * possible.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_clear_virtual_frame_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGScrollFrame::set_manage_pieces(bool manage_pieces)
 */
static PyObject *Dtool_PGScrollFrame_set_manage_pieces_237(PyObject *self, PyObject *arg) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.set_manage_pieces")) {
    return NULL;
  }
  // 1-inline void PGScrollFrame::set_manage_pieces(bool manage_pieces)
  (*local_this).set_manage_pieces((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_manage_pieces(const PGScrollFrame self, bool manage_pieces)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_set_manage_pieces_237_comment =
  "C++ Interface:\n"
  "set_manage_pieces(const PGScrollFrame self, bool manage_pieces)\n"
  "\n"
  "/**\n"
  " * Sets the manage_pieces flag.  When this is true, the sub-pieces of the\n"
  " * scroll frame--that is, the two scroll bars--are automatically positioned\n"
  " * and/or resized when the scroll frame's overall frame is changed.  They are\n"
  " * also automatically resized to fill in the gap when one or the other is\n"
  " * hidden.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_set_manage_pieces_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGScrollFrame::get_manage_pieces(void) const
 */
static PyObject *Dtool_PGScrollFrame_get_manage_pieces_238(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGScrollFrame, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGScrollFrame::get_manage_pieces(void) const
  bool return_value = (*(const PGScrollFrame*)local_this).get_manage_pieces();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_get_manage_pieces_238_comment =
  "C++ Interface:\n"
  "get_manage_pieces(PGScrollFrame self)\n"
  "\n"
  "/**\n"
  " * Returns the manage_pieces flag.  See set_manage_pieces().\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_get_manage_pieces_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGScrollFrame::set_auto_hide(bool auto_hide)
 */
static PyObject *Dtool_PGScrollFrame_set_auto_hide_239(PyObject *self, PyObject *arg) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.set_auto_hide")) {
    return NULL;
  }
  // 1-inline void PGScrollFrame::set_auto_hide(bool auto_hide)
  (*local_this).set_auto_hide((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_hide(const PGScrollFrame self, bool auto_hide)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_set_auto_hide_239_comment =
  "C++ Interface:\n"
  "set_auto_hide(const PGScrollFrame self, bool auto_hide)\n"
  "\n"
  "/**\n"
  " * Sets the auto_hide flag.  When this is true, the two scroll bars are\n"
  " * automatically hidden if they are not needed (that is, if the virtual frame\n"
  " * would fit within the clip frame without them), and they are automatically\n"
  " * shown when they are needed.\n"
  " *\n"
  " * Setting this flag true forces the manage_pieces flag to also be set true.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_set_auto_hide_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PGScrollFrame::get_auto_hide(void) const
 */
static PyObject *Dtool_PGScrollFrame_get_auto_hide_240(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGScrollFrame, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PGScrollFrame::get_auto_hide(void) const
  bool return_value = (*(const PGScrollFrame*)local_this).get_auto_hide();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_get_auto_hide_240_comment =
  "C++ Interface:\n"
  "get_auto_hide(PGScrollFrame self)\n"
  "\n"
  "/**\n"
  " * Returns the auto_hide flag.  See set_auto_hide().\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_get_auto_hide_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGScrollFrame::set_horizontal_slider(PGSliderBar *horizontal_slider)
 */
static PyObject *Dtool_PGScrollFrame_set_horizontal_slider_241(PyObject *self, PyObject *arg) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.set_horizontal_slider")) {
    return NULL;
  }
  // 1-inline void PGScrollFrame::set_horizontal_slider(PGSliderBar *horizontal_slider)
  PT(PGSliderBar) arg_this;
  if (!Dtool_Coerce_PGSliderBar(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGScrollFrame.set_horizontal_slider", "PGSliderBar");
  }
  (*local_this).set_horizontal_slider(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_horizontal_slider(const PGScrollFrame self, PGSliderBar horizontal_slider)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_set_horizontal_slider_241_comment =
  "C++ Interface:\n"
  "set_horizontal_slider(const PGScrollFrame self, PGSliderBar horizontal_slider)\n"
  "\n"
  "/**\n"
  " * Sets the PGSliderBar object that will serve as the horizontal scroll bar\n"
  " * for this frame.  It is your responsibility to parent this slider bar to the\n"
  " * frame and move it to the appropriate place.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_set_horizontal_slider_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGScrollFrame::clear_horizontal_slider(void)
 */
static PyObject *Dtool_PGScrollFrame_clear_horizontal_slider_242(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.clear_horizontal_slider")) {
    return NULL;
  }
  // 1-inline void PGScrollFrame::clear_horizontal_slider(void)
  (*local_this).clear_horizontal_slider();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_clear_horizontal_slider_242_comment =
  "C++ Interface:\n"
  "clear_horizontal_slider(const PGScrollFrame self)\n"
  "\n"
  "/**\n"
  " * Removes the horizontal scroll bar from control of the frame.  It is your\n"
  " * responsibility to actually remove or hide the object itself.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_clear_horizontal_slider_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PGSliderBar *PGScrollFrame::get_horizontal_slider(void) const
 */
static PyObject *Dtool_PGScrollFrame_get_horizontal_slider_243(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGScrollFrame, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PGSliderBar *PGScrollFrame::get_horizontal_slider(void) const
  PGSliderBar *return_value = (*(const PGScrollFrame*)local_this).get_horizontal_slider();
  if (return_value != (PGSliderBar *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PGSliderBar *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PGSliderBar, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_get_horizontal_slider_243_comment =
  "C++ Interface:\n"
  "get_horizontal_slider(PGScrollFrame self)\n"
  "\n"
  "/**\n"
  " * Returns the PGSliderBar that serves as the horizontal scroll bar for this\n"
  " * frame, if any, or NULL if it is not set.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_get_horizontal_slider_243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGScrollFrame::set_vertical_slider(PGSliderBar *vertical_slider)
 */
static PyObject *Dtool_PGScrollFrame_set_vertical_slider_244(PyObject *self, PyObject *arg) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.set_vertical_slider")) {
    return NULL;
  }
  // 1-inline void PGScrollFrame::set_vertical_slider(PGSliderBar *vertical_slider)
  PT(PGSliderBar) arg_this;
  if (!Dtool_Coerce_PGSliderBar(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PGScrollFrame.set_vertical_slider", "PGSliderBar");
  }
  (*local_this).set_vertical_slider(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertical_slider(const PGScrollFrame self, PGSliderBar vertical_slider)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_set_vertical_slider_244_comment =
  "C++ Interface:\n"
  "set_vertical_slider(const PGScrollFrame self, PGSliderBar vertical_slider)\n"
  "\n"
  "/**\n"
  " * Sets the PGSliderBar object that will serve as the vertical scroll bar for\n"
  " * this frame.  It is your responsibility to parent this slider bar to the\n"
  " * frame and move it to the appropriate place.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_set_vertical_slider_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGScrollFrame::clear_vertical_slider(void)
 */
static PyObject *Dtool_PGScrollFrame_clear_vertical_slider_245(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.clear_vertical_slider")) {
    return NULL;
  }
  // 1-inline void PGScrollFrame::clear_vertical_slider(void)
  (*local_this).clear_vertical_slider();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_clear_vertical_slider_245_comment =
  "C++ Interface:\n"
  "clear_vertical_slider(const PGScrollFrame self)\n"
  "\n"
  "/**\n"
  " * Removes the vertical scroll bar from control of the frame.  It is your\n"
  " * responsibility to actually remove or hide the object itself.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_clear_vertical_slider_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PGSliderBar *PGScrollFrame::get_vertical_slider(void) const
 */
static PyObject *Dtool_PGScrollFrame_get_vertical_slider_246(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGScrollFrame, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PGSliderBar *PGScrollFrame::get_vertical_slider(void) const
  PGSliderBar *return_value = (*(const PGScrollFrame*)local_this).get_vertical_slider();
  if (return_value != (PGSliderBar *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PGSliderBar *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PGSliderBar, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_get_vertical_slider_246_comment =
  "C++ Interface:\n"
  "get_vertical_slider(PGScrollFrame self)\n"
  "\n"
  "/**\n"
  " * Returns the PGSliderBar that serves as the vertical scroll bar for this\n"
  " * frame, if any, or NULL if it is not set.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_get_vertical_slider_246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PGScrollFrame::remanage(void)
 */
static PyObject *Dtool_PGScrollFrame_remanage_247(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.remanage")) {
    return NULL;
  }
  // 1-void PGScrollFrame::remanage(void)
  (*local_this).remanage();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_remanage_247_comment =
  "C++ Interface:\n"
  "remanage(const PGScrollFrame self)\n"
  "\n"
  "/**\n"
  " * Manages the position and size of the scroll bars.  Normally this should not\n"
  " * need to be called directly.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_remanage_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGScrollFrame::recompute(void)
 */
static PyObject *Dtool_PGScrollFrame_recompute_248(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.recompute")) {
    return NULL;
  }
  // 1-inline void PGScrollFrame::recompute(void)
  (*local_this).recompute();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_recompute_248_comment =
  "C++ Interface:\n"
  "recompute(const PGScrollFrame self)\n"
  "\n"
  "/**\n"
  " * Forces the PGScrollFrame to recompute itself right now.  Normally this\n"
  " * should not be required.\n"
  " */";
#else
static const char *Dtool_PGScrollFrame_recompute_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PGScrollFrame::get_class_type(void)
 */
static PyObject *Dtool_PGScrollFrame_get_class_type_249(PyObject *, PyObject *) {
  // 1-static TypeHandle PGScrollFrame::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PGScrollFrame::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_get_class_type_249_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PGScrollFrame_get_class_type_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGVirtualFrame *PGScrollFrame::upcast_to_PGVirtualFrame(void)
 */
static PyObject *Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_225(PyObject *self, PyObject *) {
  PGScrollFrame *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGScrollFrame, (void **)&local_this, "PGScrollFrame.upcast_to_PGVirtualFrame")) {
    return NULL;
  }
  // 1-PGVirtualFrame *PGScrollFrame::upcast_to_PGVirtualFrame(void)
  PGVirtualFrame *return_value = (PGVirtualFrame *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PGVirtualFrame, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_225_comment =
  "C++ Interface:\n"
  "upcast_to_PGVirtualFrame(const PGScrollFrame self)\n"
  "\n"
  "upcast from PGScrollFrame to PGVirtualFrame";
#else
static const char *Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGScrollFrame::PGScrollFrame(std::string const &name = "")
 */
static int Dtool_Init_PGScrollFrame(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-PGScrollFrame::PGScrollFrame(std::string const &name = "")
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:PGScrollFrame", (char **)keyword_list, &param0_str, &param0_len)) {
    PGScrollFrame *return_value = new PGScrollFrame(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGScrollFrame, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PGScrollFrame(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PGScrollFrame(PyObject *args, CPT(PGScrollFrame) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGScrollFrame, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGScrollFrame::PGScrollFrame(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGScrollFrame *return_value = new PGScrollFrame(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PGScrollFrame(PyObject *args, PT(PGScrollFrame) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGScrollFrame, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGScrollFrame::PGScrollFrame(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGScrollFrame *return_value = new PGScrollFrame(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_PGScrollFrame(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PGScrollFrame) {
    printf("PGScrollFrame ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PGScrollFrame *local_this = (PGScrollFrame *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PGScrollFrame) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(PGItem *)(PGVirtualFrame *) local_this;
  }
  if (requested_type == Dtool_Ptr_PGItem) {
    return (PGItem *)(PGVirtualFrame *) local_this;
  }
  if (requested_type == Dtool_Ptr_PGVirtualFrame) {
    return (PGVirtualFrame *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(PGItem *)(PGVirtualFrame *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *)(PGVirtualFrame *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *)(PGVirtualFrame *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *)(PGVirtualFrame *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(PGItem *)(PGVirtualFrame *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PGScrollFrame(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PGScrollFrame) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PGScrollFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_PGItem) {
    PGItem* other_this = (PGItem*)from_this;
    return (PGScrollFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_PGVirtualFrame) {
    PGVirtualFrame* other_this = (PGVirtualFrame*)from_this;
    return (PGScrollFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PGScrollFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PGScrollFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PGScrollFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PGScrollFrame*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PGScrollFrame*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PGWaitBar
 */
/**
 * Python function wrapper for:
 * void PGWaitBar::setup(PN_stdfloat width, PN_stdfloat height, PN_stdfloat range)
 */
static PyObject *Dtool_PGWaitBar_setup_252(PyObject *self, PyObject *args, PyObject *kwds) {
  PGWaitBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGWaitBar, (void **)&local_this, "PGWaitBar.setup")) {
    return NULL;
  }
  // 1-void PGWaitBar::setup(PN_stdfloat width, PN_stdfloat height, PN_stdfloat range)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"width", "height", "range", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:setup", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).setup((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup(const PGWaitBar self, float width, float height, float range)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGWaitBar_setup_252_comment =
  "C++ Interface:\n"
  "setup(const PGWaitBar self, float width, float height, float range)\n"
  "\n"
  "/**\n"
  " * Creates a PGWaitBar with the indicated dimensions, with the indicated\n"
  " * maximum range.\n"
  " */";
#else
static const char *Dtool_PGWaitBar_setup_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGWaitBar::set_range(PN_stdfloat range)
 */
static PyObject *Dtool_PGWaitBar_set_range_253(PyObject *self, PyObject *arg) {
  PGWaitBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGWaitBar, (void **)&local_this, "PGWaitBar.set_range")) {
    return NULL;
  }
  // 1-inline void PGWaitBar::set_range(PN_stdfloat range)
  if (PyNumber_Check(arg)) {
    (*local_this).set_range((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const PGWaitBar self, float range)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGWaitBar_set_range_253_comment =
  "C++ Interface:\n"
  "set_range(const PGWaitBar self, float range)\n"
  "\n"
  "/**\n"
  " * Sets the value at which the WaitBar indicates 100%.\n"
  " */";
#else
static const char *Dtool_PGWaitBar_set_range_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGWaitBar::get_range(void) const
 */
static PyObject *Dtool_PGWaitBar_get_range_254(PyObject *self, PyObject *) {
  PGWaitBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGWaitBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGWaitBar::get_range(void) const
  PN_stdfloat return_value = (*(const PGWaitBar*)local_this).get_range();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGWaitBar_get_range_254_comment =
  "C++ Interface:\n"
  "get_range(PGWaitBar self)\n"
  "\n"
  "/**\n"
  " * Returns the value at which the WaitBar indicates 100%.\n"
  " */";
#else
static const char *Dtool_PGWaitBar_get_range_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGWaitBar::set_value(PN_stdfloat value)
 */
static PyObject *Dtool_PGWaitBar_set_value_255(PyObject *self, PyObject *arg) {
  PGWaitBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGWaitBar, (void **)&local_this, "PGWaitBar.set_value")) {
    return NULL;
  }
  // 1-inline void PGWaitBar::set_value(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_value((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const PGWaitBar self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGWaitBar_set_value_255_comment =
  "C++ Interface:\n"
  "set_value(const PGWaitBar self, float value)\n"
  "\n"
  "/**\n"
  " * Sets the current value of the bar.  This should range between 0 and\n"
  " * get_range().\n"
  " */";
#else
static const char *Dtool_PGWaitBar_set_value_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGWaitBar::get_value(void) const
 */
static PyObject *Dtool_PGWaitBar_get_value_256(PyObject *self, PyObject *) {
  PGWaitBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGWaitBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGWaitBar::get_value(void) const
  PN_stdfloat return_value = (*(const PGWaitBar*)local_this).get_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGWaitBar_get_value_256_comment =
  "C++ Interface:\n"
  "get_value(PGWaitBar self)\n"
  "\n"
  "/**\n"
  " * Returns the current value of the bar.\n"
  " */";
#else
static const char *Dtool_PGWaitBar_get_value_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PGWaitBar::get_percent(void) const
 */
static PyObject *Dtool_PGWaitBar_get_percent_257(PyObject *self, PyObject *) {
  PGWaitBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGWaitBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PGWaitBar::get_percent(void) const
  PN_stdfloat return_value = (*(const PGWaitBar*)local_this).get_percent();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PGWaitBar_get_percent_257_comment =
  "C++ Interface:\n"
  "get_percent(PGWaitBar self)\n"
  "\n"
  "/**\n"
  " * Returns the percentage complete.\n"
  " */";
#else
static const char *Dtool_PGWaitBar_get_percent_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PGWaitBar::set_bar_style(PGFrameStyle const &style)
 */
static PyObject *Dtool_PGWaitBar_set_bar_style_258(PyObject *self, PyObject *arg) {
  PGWaitBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PGWaitBar, (void **)&local_this, "PGWaitBar.set_bar_style")) {
    return NULL;
  }
  // 1-inline void PGWaitBar::set_bar_style(PGFrameStyle const &style)
  PGFrameStyle const *arg_this = (PGFrameStyle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PGFrameStyle, 1, "PGWaitBar.set_bar_style", true, true);
  if (arg_this != NULL) {
    (*local_this).set_bar_style(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bar_style(const PGWaitBar self, const PGFrameStyle style)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PGWaitBar_set_bar_style_258_comment =
  "C++ Interface:\n"
  "set_bar_style(const PGWaitBar self, const PGFrameStyle style)\n"
  "\n"
  "/**\n"
  " * Sets the kind of frame that is drawn on top of the WaitBar to represent the\n"
  " * amount completed.\n"
  " */";
#else
static const char *Dtool_PGWaitBar_set_bar_style_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PGFrameStyle PGWaitBar::get_bar_style(void) const
 */
static PyObject *Dtool_PGWaitBar_get_bar_style_259(PyObject *self, PyObject *) {
  PGWaitBar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGWaitBar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PGFrameStyle PGWaitBar::get_bar_style(void) const
  PGFrameStyle *return_value = new PGFrameStyle((*(const PGWaitBar*)local_this).get_bar_style());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PGFrameStyle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGWaitBar_get_bar_style_259_comment =
  "C++ Interface:\n"
  "get_bar_style(PGWaitBar self)\n"
  "\n"
  "/**\n"
  " * Returns the kind of frame that is drawn on top of the WaitBar to represent\n"
  " * the amount completed.\n"
  " */";
#else
static const char *Dtool_PGWaitBar_get_bar_style_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PGWaitBar::get_class_type(void)
 */
static PyObject *Dtool_PGWaitBar_get_class_type_260(PyObject *, PyObject *) {
  // 1-static TypeHandle PGWaitBar::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PGWaitBar::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PGWaitBar_get_class_type_260_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PGWaitBar_get_class_type_260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PGWaitBar::PGWaitBar(std::string const &name = "")
 */
static int Dtool_Init_PGWaitBar(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-PGWaitBar::PGWaitBar(std::string const &name = "")
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:PGWaitBar", (char **)keyword_list, &param0_str, &param0_len)) {
    PGWaitBar *return_value = new PGWaitBar(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PGWaitBar, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PGWaitBar(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PGWaitBar(PyObject *args, CPT(PGWaitBar) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGWaitBar, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGWaitBar::PGWaitBar(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGWaitBar *return_value = new PGWaitBar(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PGWaitBar(PyObject *args, PT(PGWaitBar) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PGWaitBar, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PGWaitBar::PGWaitBar(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PGWaitBar *return_value = new PGWaitBar(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_PGWaitBar(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PGWaitBar) {
    printf("PGWaitBar ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PGWaitBar *local_this = (PGWaitBar *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PGWaitBar) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_PGItem) {
    return (PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(PGItem *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PGWaitBar(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PGWaitBar) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PGWaitBar*)other_this;
  }
  if (from_type == Dtool_Ptr_PGItem) {
    PGItem* other_this = (PGItem*)from_this;
    return (PGWaitBar*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PGWaitBar*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PGWaitBar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PGWaitBar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PGWaitBar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PGWaitBar*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for PGFrameStyle (PGFrameStyle)
 */
static PyMethodDef Dtool_Methods_PGFrameStyle[] = {
  {"assign", &Dtool_PGFrameStyle_operator_3, METH_O, (const char *)Dtool_PGFrameStyle_operator_3_comment},
  {"set_type", &Dtool_PGFrameStyle_set_type_6, METH_O, (const char *)Dtool_PGFrameStyle_set_type_6_comment},
  {"setType", &Dtool_PGFrameStyle_set_type_6, METH_O, (const char *)Dtool_PGFrameStyle_set_type_6_comment},
  {"get_type", &Dtool_PGFrameStyle_get_type_7, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_type_7_comment},
  {"getType", &Dtool_PGFrameStyle_get_type_7, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_type_7_comment},
  {"set_color", (PyCFunction) &Dtool_PGFrameStyle_set_color_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGFrameStyle_set_color_8_comment},
  {"setColor", (PyCFunction) &Dtool_PGFrameStyle_set_color_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGFrameStyle_set_color_8_comment},
  {"get_color", &Dtool_PGFrameStyle_get_color_9, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_color_9_comment},
  {"getColor", &Dtool_PGFrameStyle_get_color_9, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_color_9_comment},
  {"set_texture", &Dtool_PGFrameStyle_set_texture_10, METH_O, (const char *)Dtool_PGFrameStyle_set_texture_10_comment},
  {"setTexture", &Dtool_PGFrameStyle_set_texture_10, METH_O, (const char *)Dtool_PGFrameStyle_set_texture_10_comment},
  {"has_texture", &Dtool_PGFrameStyle_has_texture_11, METH_NOARGS, (const char *)Dtool_PGFrameStyle_has_texture_11_comment},
  {"hasTexture", &Dtool_PGFrameStyle_has_texture_11, METH_NOARGS, (const char *)Dtool_PGFrameStyle_has_texture_11_comment},
  {"get_texture", &Dtool_PGFrameStyle_get_texture_12, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_texture_12_comment},
  {"getTexture", &Dtool_PGFrameStyle_get_texture_12, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_texture_12_comment},
  {"clear_texture", &Dtool_PGFrameStyle_clear_texture_13, METH_NOARGS, (const char *)Dtool_PGFrameStyle_clear_texture_13_comment},
  {"clearTexture", &Dtool_PGFrameStyle_clear_texture_13, METH_NOARGS, (const char *)Dtool_PGFrameStyle_clear_texture_13_comment},
  {"set_width", (PyCFunction) &Dtool_PGFrameStyle_set_width_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGFrameStyle_set_width_14_comment},
  {"setWidth", (PyCFunction) &Dtool_PGFrameStyle_set_width_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGFrameStyle_set_width_14_comment},
  {"get_width", &Dtool_PGFrameStyle_get_width_15, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_width_15_comment},
  {"getWidth", &Dtool_PGFrameStyle_get_width_15, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_width_15_comment},
  {"set_uv_width", (PyCFunction) &Dtool_PGFrameStyle_set_uv_width_16, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGFrameStyle_set_uv_width_16_comment},
  {"setUvWidth", (PyCFunction) &Dtool_PGFrameStyle_set_uv_width_16, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGFrameStyle_set_uv_width_16_comment},
  {"get_uv_width", &Dtool_PGFrameStyle_get_uv_width_17, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_uv_width_17_comment},
  {"getUvWidth", &Dtool_PGFrameStyle_get_uv_width_17, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_uv_width_17_comment},
  {"set_visible_scale", (PyCFunction) &Dtool_PGFrameStyle_set_visible_scale_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGFrameStyle_set_visible_scale_18_comment},
  {"setVisibleScale", (PyCFunction) &Dtool_PGFrameStyle_set_visible_scale_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGFrameStyle_set_visible_scale_18_comment},
  {"get_visible_scale", &Dtool_PGFrameStyle_get_visible_scale_19, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_visible_scale_19_comment},
  {"getVisibleScale", &Dtool_PGFrameStyle_get_visible_scale_19, METH_NOARGS, (const char *)Dtool_PGFrameStyle_get_visible_scale_19_comment},
  {"get_internal_frame", &Dtool_PGFrameStyle_get_internal_frame_20, METH_O, (const char *)Dtool_PGFrameStyle_get_internal_frame_20_comment},
  {"getInternalFrame", &Dtool_PGFrameStyle_get_internal_frame_20, METH_O, (const char *)Dtool_PGFrameStyle_get_internal_frame_20_comment},
  {"output", &Dtool_PGFrameStyle_output_21, METH_O, (const char *)Dtool_PGFrameStyle_output_21_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PGFrameStyle
//////////////////
static PyObject *Dtool_Repr_PGFrameStyle(PyObject *self) {
  PGFrameStyle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGFrameStyle, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PGFrameStyle = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_PGFrameStyle = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PGFrameStyle",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PGFrameStyle,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PGFrameStyle,
    &Dtool_NumberMethods_PGFrameStyle,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PGFrameStyle,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PGFrameStyle,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PGFrameStyle,
    PyType_GenericAlloc,
    Dtool_new_PGFrameStyle,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PGFrameStyle,
  Dtool_UpcastInterface_PGFrameStyle,
  Dtool_DowncastInterface_PGFrameStyle,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PGFrameStyle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PGFrameStyle._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(15);
    Dtool_PGFrameStyle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PGFrameStyle::Type;
    PyDict_SetItemString(dict, "T_none", Dtool_WrapValue(PGFrameStyle::T_none));
    PyDict_SetItemString(dict, "TNone", Dtool_WrapValue(PGFrameStyle::T_none));
    PyDict_SetItemString(dict, "T_flat", Dtool_WrapValue(PGFrameStyle::T_flat));
    PyDict_SetItemString(dict, "TFlat", Dtool_WrapValue(PGFrameStyle::T_flat));
    PyDict_SetItemString(dict, "T_bevel_out", Dtool_WrapValue(PGFrameStyle::T_bevel_out));
    PyDict_SetItemString(dict, "TBevelOut", Dtool_WrapValue(PGFrameStyle::T_bevel_out));
    PyDict_SetItemString(dict, "T_bevel_in", Dtool_WrapValue(PGFrameStyle::T_bevel_in));
    PyDict_SetItemString(dict, "TBevelIn", Dtool_WrapValue(PGFrameStyle::T_bevel_in));
    PyDict_SetItemString(dict, "T_groove", Dtool_WrapValue(PGFrameStyle::T_groove));
    PyDict_SetItemString(dict, "TGroove", Dtool_WrapValue(PGFrameStyle::T_groove));
    PyDict_SetItemString(dict, "T_ridge", Dtool_WrapValue(PGFrameStyle::T_ridge));
    PyDict_SetItemString(dict, "TRidge", Dtool_WrapValue(PGFrameStyle::T_ridge));
    PyDict_SetItemString(dict, "T_texture_border", Dtool_WrapValue(PGFrameStyle::T_texture_border));
    PyDict_SetItemString(dict, "TTextureBorder", Dtool_WrapValue(PGFrameStyle::T_texture_border));
    if (PyType_Ready((PyTypeObject *)&Dtool_PGFrameStyle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PGFrameStyle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PGFrameStyle);
  }
}

/**
 * Python method tables for PGItem (PGItem)
 */
static PyMethodDef Dtool_Methods_PGItem[] = {
  {"set_name", &Dtool_PGItem_set_name_25, METH_O, (const char *)Dtool_PGItem_set_name_25_comment},
  {"setName", &Dtool_PGItem_set_name_25, METH_O, (const char *)Dtool_PGItem_set_name_25_comment},
  {"set_frame", (PyCFunction) &Dtool_PGItem_set_frame_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGItem_set_frame_26_comment},
  {"setFrame", (PyCFunction) &Dtool_PGItem_set_frame_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGItem_set_frame_26_comment},
  {"get_frame", &Dtool_PGItem_get_frame_27, METH_NOARGS, (const char *)Dtool_PGItem_get_frame_27_comment},
  {"getFrame", &Dtool_PGItem_get_frame_27, METH_NOARGS, (const char *)Dtool_PGItem_get_frame_27_comment},
  {"has_frame", &Dtool_PGItem_has_frame_28, METH_NOARGS, (const char *)Dtool_PGItem_has_frame_28_comment},
  {"hasFrame", &Dtool_PGItem_has_frame_28, METH_NOARGS, (const char *)Dtool_PGItem_has_frame_28_comment},
  {"clear_frame", &Dtool_PGItem_clear_frame_29, METH_NOARGS, (const char *)Dtool_PGItem_clear_frame_29_comment},
  {"clearFrame", &Dtool_PGItem_clear_frame_29, METH_NOARGS, (const char *)Dtool_PGItem_clear_frame_29_comment},
  {"set_state", &Dtool_PGItem_set_state_30, METH_O, (const char *)Dtool_PGItem_set_state_30_comment},
  {"setState", &Dtool_PGItem_set_state_30, METH_O, (const char *)Dtool_PGItem_set_state_30_comment},
  {"get_state", &Dtool_PGItem_get_state_31, METH_NOARGS, (const char *)Dtool_PGItem_get_state_31_comment},
  {"getState", &Dtool_PGItem_get_state_31, METH_NOARGS, (const char *)Dtool_PGItem_get_state_31_comment},
  {"set_active", &Dtool_PGItem_set_active_32, METH_O, (const char *)Dtool_PGItem_set_active_32_comment},
  {"setActive", &Dtool_PGItem_set_active_32, METH_O, (const char *)Dtool_PGItem_set_active_32_comment},
  {"get_active", &Dtool_PGItem_get_active_33, METH_NOARGS, (const char *)Dtool_PGItem_get_active_33_comment},
  {"getActive", &Dtool_PGItem_get_active_33, METH_NOARGS, (const char *)Dtool_PGItem_get_active_33_comment},
  {"set_focus", &Dtool_PGItem_set_focus_34, METH_O, (const char *)Dtool_PGItem_set_focus_34_comment},
  {"setFocus", &Dtool_PGItem_set_focus_34, METH_O, (const char *)Dtool_PGItem_set_focus_34_comment},
  {"get_focus", &Dtool_PGItem_get_focus_35, METH_NOARGS, (const char *)Dtool_PGItem_get_focus_35_comment},
  {"getFocus", &Dtool_PGItem_get_focus_35, METH_NOARGS, (const char *)Dtool_PGItem_get_focus_35_comment},
  {"set_background_focus", &Dtool_PGItem_set_background_focus_36, METH_O, (const char *)Dtool_PGItem_set_background_focus_36_comment},
  {"setBackgroundFocus", &Dtool_PGItem_set_background_focus_36, METH_O, (const char *)Dtool_PGItem_set_background_focus_36_comment},
  {"get_background_focus", &Dtool_PGItem_get_background_focus_37, METH_NOARGS, (const char *)Dtool_PGItem_get_background_focus_37_comment},
  {"getBackgroundFocus", &Dtool_PGItem_get_background_focus_37, METH_NOARGS, (const char *)Dtool_PGItem_get_background_focus_37_comment},
  {"set_suppress_flags", &Dtool_PGItem_set_suppress_flags_38, METH_O, (const char *)Dtool_PGItem_set_suppress_flags_38_comment},
  {"setSuppressFlags", &Dtool_PGItem_set_suppress_flags_38, METH_O, (const char *)Dtool_PGItem_set_suppress_flags_38_comment},
  {"get_suppress_flags", &Dtool_PGItem_get_suppress_flags_39, METH_NOARGS, (const char *)Dtool_PGItem_get_suppress_flags_39_comment},
  {"getSuppressFlags", &Dtool_PGItem_get_suppress_flags_39, METH_NOARGS, (const char *)Dtool_PGItem_get_suppress_flags_39_comment},
  {"get_num_state_defs", &Dtool_PGItem_get_num_state_defs_40, METH_NOARGS, (const char *)Dtool_PGItem_get_num_state_defs_40_comment},
  {"getNumStateDefs", &Dtool_PGItem_get_num_state_defs_40, METH_NOARGS, (const char *)Dtool_PGItem_get_num_state_defs_40_comment},
  {"clear_state_def", &Dtool_PGItem_clear_state_def_41, METH_O, (const char *)Dtool_PGItem_clear_state_def_41_comment},
  {"clearStateDef", &Dtool_PGItem_clear_state_def_41, METH_O, (const char *)Dtool_PGItem_clear_state_def_41_comment},
  {"has_state_def", &Dtool_PGItem_has_state_def_42, METH_O, (const char *)Dtool_PGItem_has_state_def_42_comment},
  {"hasStateDef", &Dtool_PGItem_has_state_def_42, METH_O, (const char *)Dtool_PGItem_has_state_def_42_comment},
  {"get_state_def", &Dtool_PGItem_get_state_def_43, METH_O, (const char *)Dtool_PGItem_get_state_def_43_comment},
  {"getStateDef", &Dtool_PGItem_get_state_def_43, METH_O, (const char *)Dtool_PGItem_get_state_def_43_comment},
  {"instance_to_state_def", (PyCFunction) &Dtool_PGItem_instance_to_state_def_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGItem_instance_to_state_def_45_comment},
  {"instanceToStateDef", (PyCFunction) &Dtool_PGItem_instance_to_state_def_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGItem_instance_to_state_def_45_comment},
  {"get_frame_style", &Dtool_PGItem_get_frame_style_46, METH_O, (const char *)Dtool_PGItem_get_frame_style_46_comment},
  {"getFrameStyle", &Dtool_PGItem_get_frame_style_46, METH_O, (const char *)Dtool_PGItem_get_frame_style_46_comment},
  {"set_frame_style", (PyCFunction) &Dtool_PGItem_set_frame_style_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGItem_set_frame_style_47_comment},
  {"setFrameStyle", (PyCFunction) &Dtool_PGItem_set_frame_style_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGItem_set_frame_style_47_comment},
  {"get_id", &Dtool_PGItem_get_id_48, METH_NOARGS, (const char *)Dtool_PGItem_get_id_48_comment},
  {"getId", &Dtool_PGItem_get_id_48, METH_NOARGS, (const char *)Dtool_PGItem_get_id_48_comment},
  {"set_id", &Dtool_PGItem_set_id_49, METH_O, (const char *)Dtool_PGItem_set_id_49_comment},
  {"setId", &Dtool_PGItem_set_id_49, METH_O, (const char *)Dtool_PGItem_set_id_49_comment},
  {"get_enter_prefix", &Dtool_PGItem_get_enter_prefix_50, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_enter_prefix_50_comment},
  {"getEnterPrefix", &Dtool_PGItem_get_enter_prefix_50, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_enter_prefix_50_comment},
  {"get_exit_prefix", &Dtool_PGItem_get_exit_prefix_51, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_exit_prefix_51_comment},
  {"getExitPrefix", &Dtool_PGItem_get_exit_prefix_51, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_exit_prefix_51_comment},
  {"get_within_prefix", &Dtool_PGItem_get_within_prefix_52, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_within_prefix_52_comment},
  {"getWithinPrefix", &Dtool_PGItem_get_within_prefix_52, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_within_prefix_52_comment},
  {"get_without_prefix", &Dtool_PGItem_get_without_prefix_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_without_prefix_53_comment},
  {"getWithoutPrefix", &Dtool_PGItem_get_without_prefix_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_without_prefix_53_comment},
  {"get_focus_in_prefix", &Dtool_PGItem_get_focus_in_prefix_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_focus_in_prefix_54_comment},
  {"getFocusInPrefix", &Dtool_PGItem_get_focus_in_prefix_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_focus_in_prefix_54_comment},
  {"get_focus_out_prefix", &Dtool_PGItem_get_focus_out_prefix_55, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_focus_out_prefix_55_comment},
  {"getFocusOutPrefix", &Dtool_PGItem_get_focus_out_prefix_55, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_focus_out_prefix_55_comment},
  {"get_press_prefix", &Dtool_PGItem_get_press_prefix_56, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_press_prefix_56_comment},
  {"getPressPrefix", &Dtool_PGItem_get_press_prefix_56, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_press_prefix_56_comment},
  {"get_repeat_prefix", &Dtool_PGItem_get_repeat_prefix_57, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_repeat_prefix_57_comment},
  {"getRepeatPrefix", &Dtool_PGItem_get_repeat_prefix_57, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_repeat_prefix_57_comment},
  {"get_release_prefix", &Dtool_PGItem_get_release_prefix_58, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_release_prefix_58_comment},
  {"getReleasePrefix", &Dtool_PGItem_get_release_prefix_58, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_release_prefix_58_comment},
  {"get_keystroke_prefix", &Dtool_PGItem_get_keystroke_prefix_59, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_keystroke_prefix_59_comment},
  {"getKeystrokePrefix", &Dtool_PGItem_get_keystroke_prefix_59, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_keystroke_prefix_59_comment},
  {"get_enter_event", &Dtool_PGItem_get_enter_event_60, METH_NOARGS, (const char *)Dtool_PGItem_get_enter_event_60_comment},
  {"getEnterEvent", &Dtool_PGItem_get_enter_event_60, METH_NOARGS, (const char *)Dtool_PGItem_get_enter_event_60_comment},
  {"get_exit_event", &Dtool_PGItem_get_exit_event_61, METH_NOARGS, (const char *)Dtool_PGItem_get_exit_event_61_comment},
  {"getExitEvent", &Dtool_PGItem_get_exit_event_61, METH_NOARGS, (const char *)Dtool_PGItem_get_exit_event_61_comment},
  {"get_within_event", &Dtool_PGItem_get_within_event_62, METH_NOARGS, (const char *)Dtool_PGItem_get_within_event_62_comment},
  {"getWithinEvent", &Dtool_PGItem_get_within_event_62, METH_NOARGS, (const char *)Dtool_PGItem_get_within_event_62_comment},
  {"get_without_event", &Dtool_PGItem_get_without_event_63, METH_NOARGS, (const char *)Dtool_PGItem_get_without_event_63_comment},
  {"getWithoutEvent", &Dtool_PGItem_get_without_event_63, METH_NOARGS, (const char *)Dtool_PGItem_get_without_event_63_comment},
  {"get_focus_in_event", &Dtool_PGItem_get_focus_in_event_64, METH_NOARGS, (const char *)Dtool_PGItem_get_focus_in_event_64_comment},
  {"getFocusInEvent", &Dtool_PGItem_get_focus_in_event_64, METH_NOARGS, (const char *)Dtool_PGItem_get_focus_in_event_64_comment},
  {"get_focus_out_event", &Dtool_PGItem_get_focus_out_event_65, METH_NOARGS, (const char *)Dtool_PGItem_get_focus_out_event_65_comment},
  {"getFocusOutEvent", &Dtool_PGItem_get_focus_out_event_65, METH_NOARGS, (const char *)Dtool_PGItem_get_focus_out_event_65_comment},
  {"get_press_event", &Dtool_PGItem_get_press_event_66, METH_O, (const char *)Dtool_PGItem_get_press_event_66_comment},
  {"getPressEvent", &Dtool_PGItem_get_press_event_66, METH_O, (const char *)Dtool_PGItem_get_press_event_66_comment},
  {"get_repeat_event", &Dtool_PGItem_get_repeat_event_67, METH_O, (const char *)Dtool_PGItem_get_repeat_event_67_comment},
  {"getRepeatEvent", &Dtool_PGItem_get_repeat_event_67, METH_O, (const char *)Dtool_PGItem_get_repeat_event_67_comment},
  {"get_release_event", &Dtool_PGItem_get_release_event_68, METH_O, (const char *)Dtool_PGItem_get_release_event_68_comment},
  {"getReleaseEvent", &Dtool_PGItem_get_release_event_68, METH_O, (const char *)Dtool_PGItem_get_release_event_68_comment},
  {"get_keystroke_event", &Dtool_PGItem_get_keystroke_event_69, METH_NOARGS, (const char *)Dtool_PGItem_get_keystroke_event_69_comment},
  {"getKeystrokeEvent", &Dtool_PGItem_get_keystroke_event_69, METH_NOARGS, (const char *)Dtool_PGItem_get_keystroke_event_69_comment},
  {"get_frame_inv_xform", &Dtool_PGItem_get_frame_inv_xform_70, METH_NOARGS, (const char *)Dtool_PGItem_get_frame_inv_xform_70_comment},
  {"getFrameInvXform", &Dtool_PGItem_get_frame_inv_xform_70, METH_NOARGS, (const char *)Dtool_PGItem_get_frame_inv_xform_70_comment},
  {"set_sound", (PyCFunction) &Dtool_PGItem_set_sound_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGItem_set_sound_71_comment},
  {"setSound", (PyCFunction) &Dtool_PGItem_set_sound_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGItem_set_sound_71_comment},
  {"clear_sound", &Dtool_PGItem_clear_sound_72, METH_O, (const char *)Dtool_PGItem_clear_sound_72_comment},
  {"clearSound", &Dtool_PGItem_clear_sound_72, METH_O, (const char *)Dtool_PGItem_clear_sound_72_comment},
  {"get_sound", &Dtool_PGItem_get_sound_73, METH_O, (const char *)Dtool_PGItem_get_sound_73_comment},
  {"getSound", &Dtool_PGItem_get_sound_73, METH_O, (const char *)Dtool_PGItem_get_sound_73_comment},
  {"has_sound", &Dtool_PGItem_has_sound_74, METH_O, (const char *)Dtool_PGItem_has_sound_74_comment},
  {"hasSound", &Dtool_PGItem_has_sound_74, METH_O, (const char *)Dtool_PGItem_has_sound_74_comment},
  {"get_text_node", &Dtool_PGItem_get_text_node_75, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_text_node_75_comment},
  {"getTextNode", &Dtool_PGItem_get_text_node_75, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_text_node_75_comment},
  {"set_text_node", &Dtool_PGItem_set_text_node_76, METH_O | METH_STATIC, (const char *)Dtool_PGItem_set_text_node_76_comment},
  {"setTextNode", &Dtool_PGItem_set_text_node_76, METH_O | METH_STATIC, (const char *)Dtool_PGItem_set_text_node_76_comment},
  {"get_focus_item", &Dtool_PGItem_get_focus_item_77, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_focus_item_77_comment},
  {"getFocusItem", &Dtool_PGItem_get_focus_item_77, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_focus_item_77_comment},
  {"get_class_type", &Dtool_PGItem_get_class_type_78, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_class_type_78_comment},
  {"getClassType", &Dtool_PGItem_get_class_type_78, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGItem_get_class_type_78_comment},
  {"downcast_to_PGSliderBar", &Dtool_PGItem_downcast_to_PGSliderBar_183, METH_NOARGS, (const char *)Dtool_PGItem_downcast_to_PGSliderBar_183_comment},
  {"downcastToPGSliderBar", &Dtool_PGItem_downcast_to_PGSliderBar_183, METH_NOARGS, (const char *)Dtool_PGItem_downcast_to_PGSliderBar_183_comment},
  {"get_state_defs", (PyCFunction) &MakeSeq_PGItem_get_state_defs, METH_NOARGS, NULL},
  { "getStateDefs", (PyCFunction) &MakeSeq_PGItem_get_state_defs, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PGItem = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PGItem = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PGItem = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PGItem = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PGItem = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PGItem",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PGItem,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PGItem,
    &Dtool_SequenceMethods_PGItem,
    &Dtool_MappingMethods_PGItem,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PGItem,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for all the various kinds of gui widget objects.\n"
    " *\n"
    " * It is a Node which corresponds to a rectangular region on the screen, and\n"
    " * it may have any number of \"state\" subgraphs, one of which is rendered at\n"
    " * any given time according to its current state.\n"
    " *\n"
    " * The PGItem node must be parented to the scene graph somewhere beneath a\n"
    " * PGTop node in order for this behavior to work.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PGItem,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PGItem,
    PyType_GenericAlloc,
    Dtool_new_PGItem,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PGItem,
  Dtool_UpcastInterface_PGItem,
  Dtool_DowncastInterface_PGItem,
  (CoerceFunction)Dtool_ConstCoerce_PGItem,
  (CoerceFunction)Dtool_Coerce_PGItem,
};

static void Dtool_PyModuleClassInit_PGItem(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_PGItem._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_PGItem._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PGItem) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PGItem)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PGItem);
  }
}

/**
 * Python method tables for PGButton (PGButton)
 */
static PyMethodDef Dtool_Methods_PGButton[] = {
  {"setup", (PyCFunction) &Dtool_PGButton_setup_82, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGButton_setup_82_comment},
  {"add_click_button", &Dtool_PGButton_add_click_button_83, METH_O, (const char *)Dtool_PGButton_add_click_button_83_comment},
  {"addClickButton", &Dtool_PGButton_add_click_button_83, METH_O, (const char *)Dtool_PGButton_add_click_button_83_comment},
  {"remove_click_button", &Dtool_PGButton_remove_click_button_84, METH_O, (const char *)Dtool_PGButton_remove_click_button_84_comment},
  {"removeClickButton", &Dtool_PGButton_remove_click_button_84, METH_O, (const char *)Dtool_PGButton_remove_click_button_84_comment},
  {"has_click_button", &Dtool_PGButton_has_click_button_85, METH_O, (const char *)Dtool_PGButton_has_click_button_85_comment},
  {"hasClickButton", &Dtool_PGButton_has_click_button_85, METH_O, (const char *)Dtool_PGButton_has_click_button_85_comment},
  {"is_button_down", &Dtool_PGButton_is_button_down_86, METH_NOARGS, (const char *)Dtool_PGButton_is_button_down_86_comment},
  {"isButtonDown", &Dtool_PGButton_is_button_down_86, METH_NOARGS, (const char *)Dtool_PGButton_is_button_down_86_comment},
  {"get_click_prefix", &Dtool_PGButton_get_click_prefix_87, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGButton_get_click_prefix_87_comment},
  {"getClickPrefix", &Dtool_PGButton_get_click_prefix_87, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGButton_get_click_prefix_87_comment},
  {"get_click_event", &Dtool_PGButton_get_click_event_88, METH_O, (const char *)Dtool_PGButton_get_click_event_88_comment},
  {"getClickEvent", &Dtool_PGButton_get_click_event_88, METH_O, (const char *)Dtool_PGButton_get_click_event_88_comment},
  {"get_class_type", &Dtool_PGButton_get_class_type_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGButton_get_class_type_89_comment},
  {"getClassType", &Dtool_PGButton_get_class_type_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGButton_get_class_type_89_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PGButton = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PGButton = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PGButton = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PGButton = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PGButton = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PGButton",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PGButton,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PGButton,
    &Dtool_SequenceMethods_PGButton,
    &Dtool_MappingMethods_PGButton,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PGButton,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a particular kind of PGItem that is specialized to behave like a\n"
    " * normal button object.  It keeps track of its own state, and handles mouse\n"
    " * events sensibly.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PGButton,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PGButton,
    PyType_GenericAlloc,
    Dtool_new_PGButton,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PGButton,
  Dtool_UpcastInterface_PGButton,
  Dtool_DowncastInterface_PGButton,
  (CoerceFunction)Dtool_ConstCoerce_PGButton,
  (CoerceFunction)Dtool_Coerce_PGButton,
};

static void Dtool_PyModuleClassInit_PGButton(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PGItem(NULL);
    Dtool_PGButton._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PGItem);
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_PGButton._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PGButton::State;
    PyDict_SetItemString(dict, "S_ready", Dtool_WrapValue(PGButton::S_ready));
    PyDict_SetItemString(dict, "SReady", Dtool_WrapValue(PGButton::S_ready));
    PyDict_SetItemString(dict, "S_depressed", Dtool_WrapValue(PGButton::S_depressed));
    PyDict_SetItemString(dict, "SDepressed", Dtool_WrapValue(PGButton::S_depressed));
    PyDict_SetItemString(dict, "S_rollover", Dtool_WrapValue(PGButton::S_rollover));
    PyDict_SetItemString(dict, "SRollover", Dtool_WrapValue(PGButton::S_rollover));
    PyDict_SetItemString(dict, "S_inactive", Dtool_WrapValue(PGButton::S_inactive));
    PyDict_SetItemString(dict, "SInactive", Dtool_WrapValue(PGButton::S_inactive));
    if (PyType_Ready((PyTypeObject *)&Dtool_PGButton) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PGButton)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PGButton);
  }
}

/**
 * Python method tables for PGTop (PGTop)
 */
static PyMethodDef Dtool_Methods_PGTop[] = {
  {"set_mouse_watcher", &Dtool_PGTop_set_mouse_watcher_92, METH_O, (const char *)Dtool_PGTop_set_mouse_watcher_92_comment},
  {"setMouseWatcher", &Dtool_PGTop_set_mouse_watcher_92, METH_O, (const char *)Dtool_PGTop_set_mouse_watcher_92_comment},
  {"get_mouse_watcher", &Dtool_PGTop_get_mouse_watcher_93, METH_NOARGS, (const char *)Dtool_PGTop_get_mouse_watcher_93_comment},
  {"getMouseWatcher", &Dtool_PGTop_get_mouse_watcher_93, METH_NOARGS, (const char *)Dtool_PGTop_get_mouse_watcher_93_comment},
  {"get_group", &Dtool_PGTop_get_group_94, METH_NOARGS, (const char *)Dtool_PGTop_get_group_94_comment},
  {"getGroup", &Dtool_PGTop_get_group_94, METH_NOARGS, (const char *)Dtool_PGTop_get_group_94_comment},
  {"set_start_sort", &Dtool_PGTop_set_start_sort_95, METH_O, (const char *)Dtool_PGTop_set_start_sort_95_comment},
  {"setStartSort", &Dtool_PGTop_set_start_sort_95, METH_O, (const char *)Dtool_PGTop_set_start_sort_95_comment},
  {"get_start_sort", &Dtool_PGTop_get_start_sort_96, METH_NOARGS, (const char *)Dtool_PGTop_get_start_sort_96_comment},
  {"getStartSort", &Dtool_PGTop_get_start_sort_96, METH_NOARGS, (const char *)Dtool_PGTop_get_start_sort_96_comment},
  {"get_class_type", &Dtool_PGTop_get_class_type_97, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGTop_get_class_type_97_comment},
  {"getClassType", &Dtool_PGTop_get_class_type_97, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGTop_get_class_type_97_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PGTop = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PGTop = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PGTop = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PGTop = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PGTop = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PGTop",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PGTop,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PGTop,
    &Dtool_SequenceMethods_PGTop,
    &Dtool_MappingMethods_PGTop,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PGTop,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The \"top\" node of the new Panda GUI system.  This node must be parented to\n"
    " * the 2-d scene graph, and all PG objects should be parented to this node or\n"
    " * somewhere below it.  PG objects not parented within this hierarchy will not\n"
    " * be clickable.\n"
    " *\n"
    " * This node begins the special traversal of the PG objects that registers\n"
    " * each node within the MouseWatcher and forces everything to render in a\n"
    " * depth-first, left-to-right order, appropriate for 2-d objects.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PGTop,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PGTop,
    PyType_GenericAlloc,
    Dtool_new_PGTop,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PGTop,
  Dtool_UpcastInterface_PGTop,
  Dtool_DowncastInterface_PGTop,
  (CoerceFunction)Dtool_ConstCoerce_PGTop,
  (CoerceFunction)Dtool_Coerce_PGTop,
};

static void Dtool_PyModuleClassInit_PGTop(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_PGTop._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_PGTop._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PGTop) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PGTop)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PGTop);
  }
}

/**
 * Python method tables for PGEntry (PGEntry)
 */
static PyMethodDef Dtool_Methods_PGEntry[] = {
  {"setup", (PyCFunction) &Dtool_PGEntry_setup_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGEntry_setup_101_comment},
  {"setup_minimal", (PyCFunction) &Dtool_PGEntry_setup_minimal_102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGEntry_setup_minimal_102_comment},
  {"setupMinimal", (PyCFunction) &Dtool_PGEntry_setup_minimal_102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGEntry_setup_minimal_102_comment},
  {"set_text", &Dtool_PGEntry_set_text_103, METH_O, (const char *)Dtool_PGEntry_set_text_103_comment},
  {"setText", &Dtool_PGEntry_set_text_103, METH_O, (const char *)Dtool_PGEntry_set_text_103_comment},
  {"get_plain_text", &Dtool_PGEntry_get_plain_text_104, METH_NOARGS, (const char *)Dtool_PGEntry_get_plain_text_104_comment},
  {"getPlainText", &Dtool_PGEntry_get_plain_text_104, METH_NOARGS, (const char *)Dtool_PGEntry_get_plain_text_104_comment},
  {"get_text", &Dtool_PGEntry_get_text_105, METH_NOARGS, (const char *)Dtool_PGEntry_get_text_105_comment},
  {"getText", &Dtool_PGEntry_get_text_105, METH_NOARGS, (const char *)Dtool_PGEntry_get_text_105_comment},
  {"get_num_characters", &Dtool_PGEntry_get_num_characters_106, METH_NOARGS, (const char *)Dtool_PGEntry_get_num_characters_106_comment},
  {"getNumCharacters", &Dtool_PGEntry_get_num_characters_106, METH_NOARGS, (const char *)Dtool_PGEntry_get_num_characters_106_comment},
  {"get_character", &Dtool_PGEntry_get_character_107, METH_O, (const char *)Dtool_PGEntry_get_character_107_comment},
  {"getCharacter", &Dtool_PGEntry_get_character_107, METH_O, (const char *)Dtool_PGEntry_get_character_107_comment},
  {"get_graphic", &Dtool_PGEntry_get_graphic_108, METH_O, (const char *)Dtool_PGEntry_get_graphic_108_comment},
  {"getGraphic", &Dtool_PGEntry_get_graphic_108, METH_O, (const char *)Dtool_PGEntry_get_graphic_108_comment},
  {"get_properties", &Dtool_PGEntry_get_properties_109, METH_O, (const char *)Dtool_PGEntry_get_properties_109_comment},
  {"getProperties", &Dtool_PGEntry_get_properties_109, METH_O, (const char *)Dtool_PGEntry_get_properties_109_comment},
  {"set_cursor_position", &Dtool_PGEntry_set_cursor_position_110, METH_O, (const char *)Dtool_PGEntry_set_cursor_position_110_comment},
  {"setCursorPosition", &Dtool_PGEntry_set_cursor_position_110, METH_O, (const char *)Dtool_PGEntry_set_cursor_position_110_comment},
  {"get_cursor_position", &Dtool_PGEntry_get_cursor_position_111, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursor_position_111_comment},
  {"getCursorPosition", &Dtool_PGEntry_get_cursor_position_111, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursor_position_111_comment},
  {"get_cursor_X", &Dtool_PGEntry_get_cursor_X_112, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursor_X_112_comment},
  {"getCursorX", &Dtool_PGEntry_get_cursor_X_112, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursor_X_112_comment},
  {"get_cursor_Y", &Dtool_PGEntry_get_cursor_Y_113, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursor_Y_113_comment},
  {"getCursorY", &Dtool_PGEntry_get_cursor_Y_113, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursor_Y_113_comment},
  {"set_max_chars", &Dtool_PGEntry_set_max_chars_114, METH_O, (const char *)Dtool_PGEntry_set_max_chars_114_comment},
  {"setMaxChars", &Dtool_PGEntry_set_max_chars_114, METH_O, (const char *)Dtool_PGEntry_set_max_chars_114_comment},
  {"get_max_chars", &Dtool_PGEntry_get_max_chars_115, METH_NOARGS, (const char *)Dtool_PGEntry_get_max_chars_115_comment},
  {"getMaxChars", &Dtool_PGEntry_get_max_chars_115, METH_NOARGS, (const char *)Dtool_PGEntry_get_max_chars_115_comment},
  {"set_max_width", &Dtool_PGEntry_set_max_width_116, METH_O, (const char *)Dtool_PGEntry_set_max_width_116_comment},
  {"setMaxWidth", &Dtool_PGEntry_set_max_width_116, METH_O, (const char *)Dtool_PGEntry_set_max_width_116_comment},
  {"get_max_width", &Dtool_PGEntry_get_max_width_117, METH_NOARGS, (const char *)Dtool_PGEntry_get_max_width_117_comment},
  {"getMaxWidth", &Dtool_PGEntry_get_max_width_117, METH_NOARGS, (const char *)Dtool_PGEntry_get_max_width_117_comment},
  {"set_num_lines", &Dtool_PGEntry_set_num_lines_118, METH_O, (const char *)Dtool_PGEntry_set_num_lines_118_comment},
  {"setNumLines", &Dtool_PGEntry_set_num_lines_118, METH_O, (const char *)Dtool_PGEntry_set_num_lines_118_comment},
  {"get_num_lines", &Dtool_PGEntry_get_num_lines_119, METH_NOARGS, (const char *)Dtool_PGEntry_get_num_lines_119_comment},
  {"getNumLines", &Dtool_PGEntry_get_num_lines_119, METH_NOARGS, (const char *)Dtool_PGEntry_get_num_lines_119_comment},
  {"set_blink_rate", &Dtool_PGEntry_set_blink_rate_120, METH_O, (const char *)Dtool_PGEntry_set_blink_rate_120_comment},
  {"setBlinkRate", &Dtool_PGEntry_set_blink_rate_120, METH_O, (const char *)Dtool_PGEntry_set_blink_rate_120_comment},
  {"get_blink_rate", &Dtool_PGEntry_get_blink_rate_121, METH_NOARGS, (const char *)Dtool_PGEntry_get_blink_rate_121_comment},
  {"getBlinkRate", &Dtool_PGEntry_get_blink_rate_121, METH_NOARGS, (const char *)Dtool_PGEntry_get_blink_rate_121_comment},
  {"get_cursor_def", &Dtool_PGEntry_get_cursor_def_122, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursor_def_122_comment},
  {"getCursorDef", &Dtool_PGEntry_get_cursor_def_122, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursor_def_122_comment},
  {"clear_cursor_def", &Dtool_PGEntry_clear_cursor_def_123, METH_NOARGS, (const char *)Dtool_PGEntry_clear_cursor_def_123_comment},
  {"clearCursorDef", &Dtool_PGEntry_clear_cursor_def_123, METH_NOARGS, (const char *)Dtool_PGEntry_clear_cursor_def_123_comment},
  {"set_cursor_keys_active", &Dtool_PGEntry_set_cursor_keys_active_124, METH_O, (const char *)Dtool_PGEntry_set_cursor_keys_active_124_comment},
  {"setCursorKeysActive", &Dtool_PGEntry_set_cursor_keys_active_124, METH_O, (const char *)Dtool_PGEntry_set_cursor_keys_active_124_comment},
  {"get_cursor_keys_active", &Dtool_PGEntry_get_cursor_keys_active_125, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursor_keys_active_125_comment},
  {"getCursorKeysActive", &Dtool_PGEntry_get_cursor_keys_active_125, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursor_keys_active_125_comment},
  {"set_obscure_mode", &Dtool_PGEntry_set_obscure_mode_126, METH_O, (const char *)Dtool_PGEntry_set_obscure_mode_126_comment},
  {"setObscureMode", &Dtool_PGEntry_set_obscure_mode_126, METH_O, (const char *)Dtool_PGEntry_set_obscure_mode_126_comment},
  {"get_obscure_mode", &Dtool_PGEntry_get_obscure_mode_127, METH_NOARGS, (const char *)Dtool_PGEntry_get_obscure_mode_127_comment},
  {"getObscureMode", &Dtool_PGEntry_get_obscure_mode_127, METH_NOARGS, (const char *)Dtool_PGEntry_get_obscure_mode_127_comment},
  {"set_overflow_mode", &Dtool_PGEntry_set_overflow_mode_128, METH_O, (const char *)Dtool_PGEntry_set_overflow_mode_128_comment},
  {"setOverflowMode", &Dtool_PGEntry_set_overflow_mode_128, METH_O, (const char *)Dtool_PGEntry_set_overflow_mode_128_comment},
  {"get_overflow_mode", &Dtool_PGEntry_get_overflow_mode_129, METH_NOARGS, (const char *)Dtool_PGEntry_get_overflow_mode_129_comment},
  {"getOverflowMode", &Dtool_PGEntry_get_overflow_mode_129, METH_NOARGS, (const char *)Dtool_PGEntry_get_overflow_mode_129_comment},
  {"set_candidate_active", &Dtool_PGEntry_set_candidate_active_130, METH_O, (const char *)Dtool_PGEntry_set_candidate_active_130_comment},
  {"setCandidateActive", &Dtool_PGEntry_set_candidate_active_130, METH_O, (const char *)Dtool_PGEntry_set_candidate_active_130_comment},
  {"get_candidate_active", &Dtool_PGEntry_get_candidate_active_131, METH_NOARGS, (const char *)Dtool_PGEntry_get_candidate_active_131_comment},
  {"getCandidateActive", &Dtool_PGEntry_get_candidate_active_131, METH_NOARGS, (const char *)Dtool_PGEntry_get_candidate_active_131_comment},
  {"set_candidate_inactive", &Dtool_PGEntry_set_candidate_inactive_132, METH_O, (const char *)Dtool_PGEntry_set_candidate_inactive_132_comment},
  {"setCandidateInactive", &Dtool_PGEntry_set_candidate_inactive_132, METH_O, (const char *)Dtool_PGEntry_set_candidate_inactive_132_comment},
  {"get_candidate_inactive", &Dtool_PGEntry_get_candidate_inactive_133, METH_NOARGS, (const char *)Dtool_PGEntry_get_candidate_inactive_133_comment},
  {"getCandidateInactive", &Dtool_PGEntry_get_candidate_inactive_133, METH_NOARGS, (const char *)Dtool_PGEntry_get_candidate_inactive_133_comment},
  {"set_text_def", (PyCFunction) &Dtool_PGEntry_set_text_def_134, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGEntry_set_text_def_134_comment},
  {"setTextDef", (PyCFunction) &Dtool_PGEntry_set_text_def_134, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGEntry_set_text_def_134_comment},
  {"get_text_def", &Dtool_PGEntry_get_text_def_135, METH_O, (const char *)Dtool_PGEntry_get_text_def_135_comment},
  {"getTextDef", &Dtool_PGEntry_get_text_def_135, METH_O, (const char *)Dtool_PGEntry_get_text_def_135_comment},
  {"get_accept_prefix", &Dtool_PGEntry_get_accept_prefix_136, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_accept_prefix_136_comment},
  {"getAcceptPrefix", &Dtool_PGEntry_get_accept_prefix_136, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_accept_prefix_136_comment},
  {"get_accept_failed_prefix", &Dtool_PGEntry_get_accept_failed_prefix_137, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_accept_failed_prefix_137_comment},
  {"getAcceptFailedPrefix", &Dtool_PGEntry_get_accept_failed_prefix_137, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_accept_failed_prefix_137_comment},
  {"get_overflow_prefix", &Dtool_PGEntry_get_overflow_prefix_138, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_overflow_prefix_138_comment},
  {"getOverflowPrefix", &Dtool_PGEntry_get_overflow_prefix_138, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_overflow_prefix_138_comment},
  {"get_type_prefix", &Dtool_PGEntry_get_type_prefix_139, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_type_prefix_139_comment},
  {"getTypePrefix", &Dtool_PGEntry_get_type_prefix_139, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_type_prefix_139_comment},
  {"get_erase_prefix", &Dtool_PGEntry_get_erase_prefix_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_erase_prefix_140_comment},
  {"getErasePrefix", &Dtool_PGEntry_get_erase_prefix_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_erase_prefix_140_comment},
  {"get_cursormove_prefix", &Dtool_PGEntry_get_cursormove_prefix_141, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_cursormove_prefix_141_comment},
  {"getCursormovePrefix", &Dtool_PGEntry_get_cursormove_prefix_141, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_cursormove_prefix_141_comment},
  {"get_accept_event", &Dtool_PGEntry_get_accept_event_142, METH_O, (const char *)Dtool_PGEntry_get_accept_event_142_comment},
  {"getAcceptEvent", &Dtool_PGEntry_get_accept_event_142, METH_O, (const char *)Dtool_PGEntry_get_accept_event_142_comment},
  {"get_accept_failed_event", &Dtool_PGEntry_get_accept_failed_event_143, METH_O, (const char *)Dtool_PGEntry_get_accept_failed_event_143_comment},
  {"getAcceptFailedEvent", &Dtool_PGEntry_get_accept_failed_event_143, METH_O, (const char *)Dtool_PGEntry_get_accept_failed_event_143_comment},
  {"get_overflow_event", &Dtool_PGEntry_get_overflow_event_144, METH_NOARGS, (const char *)Dtool_PGEntry_get_overflow_event_144_comment},
  {"getOverflowEvent", &Dtool_PGEntry_get_overflow_event_144, METH_NOARGS, (const char *)Dtool_PGEntry_get_overflow_event_144_comment},
  {"get_type_event", &Dtool_PGEntry_get_type_event_145, METH_NOARGS, (const char *)Dtool_PGEntry_get_type_event_145_comment},
  {"getTypeEvent", &Dtool_PGEntry_get_type_event_145, METH_NOARGS, (const char *)Dtool_PGEntry_get_type_event_145_comment},
  {"get_erase_event", &Dtool_PGEntry_get_erase_event_146, METH_NOARGS, (const char *)Dtool_PGEntry_get_erase_event_146_comment},
  {"getEraseEvent", &Dtool_PGEntry_get_erase_event_146, METH_NOARGS, (const char *)Dtool_PGEntry_get_erase_event_146_comment},
  {"get_cursormove_event", &Dtool_PGEntry_get_cursormove_event_147, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursormove_event_147_comment},
  {"getCursormoveEvent", &Dtool_PGEntry_get_cursormove_event_147, METH_NOARGS, (const char *)Dtool_PGEntry_get_cursormove_event_147_comment},
  {"set_wtext", &Dtool_PGEntry_set_wtext_148, METH_O, (const char *)Dtool_PGEntry_set_wtext_148_comment},
  {"setWtext", &Dtool_PGEntry_set_wtext_148, METH_O, (const char *)Dtool_PGEntry_set_wtext_148_comment},
  {"get_plain_wtext", &Dtool_PGEntry_get_plain_wtext_149, METH_NOARGS, (const char *)Dtool_PGEntry_get_plain_wtext_149_comment},
  {"getPlainWtext", &Dtool_PGEntry_get_plain_wtext_149, METH_NOARGS, (const char *)Dtool_PGEntry_get_plain_wtext_149_comment},
  {"get_wtext", &Dtool_PGEntry_get_wtext_150, METH_NOARGS, (const char *)Dtool_PGEntry_get_wtext_150_comment},
  {"getWtext", &Dtool_PGEntry_get_wtext_150, METH_NOARGS, (const char *)Dtool_PGEntry_get_wtext_150_comment},
  {"set_accept_enabled", &Dtool_PGEntry_set_accept_enabled_151, METH_O, (const char *)Dtool_PGEntry_set_accept_enabled_151_comment},
  {"setAcceptEnabled", &Dtool_PGEntry_set_accept_enabled_151, METH_O, (const char *)Dtool_PGEntry_set_accept_enabled_151_comment},
  {"is_wtext", &Dtool_PGEntry_is_wtext_152, METH_NOARGS, (const char *)Dtool_PGEntry_is_wtext_152_comment},
  {"isWtext", &Dtool_PGEntry_is_wtext_152, METH_NOARGS, (const char *)Dtool_PGEntry_is_wtext_152_comment},
  {"get_class_type", &Dtool_PGEntry_get_class_type_153, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_class_type_153_comment},
  {"getClassType", &Dtool_PGEntry_get_class_type_153, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGEntry_get_class_type_153_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PGEntry = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PGEntry = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PGEntry = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PGEntry = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PGEntry = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PGEntry",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PGEntry,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PGEntry,
    &Dtool_SequenceMethods_PGEntry,
    &Dtool_MappingMethods_PGEntry,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PGEntry,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a particular kind of PGItem that handles simple one-line or short\n"
    " * multi-line text entries, of the sort where the user can type any string.\n"
    " *\n"
    " * A PGEntry does all of its internal manipulation on a wide string, so it can\n"
    " * store the full Unicode character set.  The interface can support either the\n"
    " * wide string getters and setters, or the normal 8-bit string getters and\n"
    " * setters, which use whatever encoding method is specified by the associated\n"
    " * TextNode.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PGEntry,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PGEntry,
    PyType_GenericAlloc,
    Dtool_new_PGEntry,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PGEntry,
  Dtool_UpcastInterface_PGEntry,
  Dtool_DowncastInterface_PGEntry,
  (CoerceFunction)Dtool_ConstCoerce_PGEntry,
  (CoerceFunction)Dtool_Coerce_PGEntry,
};

static void Dtool_PyModuleClassInit_PGEntry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PGItem(NULL);
    Dtool_PGEntry._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PGItem);
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_PGEntry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PGEntry::State;
    PyDict_SetItemString(dict, "S_focus", Dtool_WrapValue(PGEntry::S_focus));
    PyDict_SetItemString(dict, "SFocus", Dtool_WrapValue(PGEntry::S_focus));
    PyDict_SetItemString(dict, "S_no_focus", Dtool_WrapValue(PGEntry::S_no_focus));
    PyDict_SetItemString(dict, "SNoFocus", Dtool_WrapValue(PGEntry::S_no_focus));
    PyDict_SetItemString(dict, "S_inactive", Dtool_WrapValue(PGEntry::S_inactive));
    PyDict_SetItemString(dict, "SInactive", Dtool_WrapValue(PGEntry::S_inactive));
    if (PyType_Ready((PyTypeObject *)&Dtool_PGEntry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PGEntry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PGEntry);
  }
}

/**
 * Python method tables for PGMouseWatcherParameter (PGMouseWatcherParameter)
 */
static PyMethodDef Dtool_Methods_PGMouseWatcherParameter[] = {
  {"output", &Dtool_PGMouseWatcherParameter_output_162, METH_O, (const char *)Dtool_PGMouseWatcherParameter_output_162_comment},
  {"get_class_type", &Dtool_PGMouseWatcherParameter_get_class_type_163, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGMouseWatcherParameter_get_class_type_163_comment},
  {"getClassType", &Dtool_PGMouseWatcherParameter_get_class_type_163, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGMouseWatcherParameter_get_class_type_163_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_156, METH_NOARGS, (const char *)Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_156_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_156, METH_NOARGS, (const char *)Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_156_comment},
  {"upcast_to_MouseWatcherParameter", &Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_159, METH_NOARGS, (const char *)Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_159_comment},
  {"upcastToMouseWatcherParameter", &Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_159, METH_NOARGS, (const char *)Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_159_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PGMouseWatcherParameter
//////////////////
static PyObject *Dtool_Repr_PGMouseWatcherParameter(PyObject *self) {
  PGMouseWatcherParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PGMouseWatcherParameter, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PGMouseWatcherParameter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PGMouseWatcherParameter = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PGMouseWatcherParameter = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PGMouseWatcherParameter = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PGMouseWatcherParameter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PGMouseWatcherParameter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PGMouseWatcherParameter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PGMouseWatcherParameter,
    &Dtool_NumberMethods_PGMouseWatcherParameter,
    &Dtool_SequenceMethods_PGMouseWatcherParameter,
    &Dtool_MappingMethods_PGMouseWatcherParameter,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PGMouseWatcherParameter,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PGMouseWatcherParameter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This specialization on MouseWatcherParameter allows us to tag on additional\n"
    " * elements to events for the gui system, and also inherits from\n"
    " * TypedWritableReferenceCount so we can attach this thing to an event.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PGMouseWatcherParameter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PGMouseWatcherParameter,
    PyType_GenericAlloc,
    Dtool_new_PGMouseWatcherParameter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PGMouseWatcherParameter,
  Dtool_UpcastInterface_PGMouseWatcherParameter,
  Dtool_DowncastInterface_PGMouseWatcherParameter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PGMouseWatcherParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != NULL);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_MouseWatcherParameter != NULL);
    assert(Dtool_Ptr_MouseWatcherParameter->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_MouseWatcherParameter->_Dtool_ModuleClassInit(NULL);
    Dtool_PGMouseWatcherParameter._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_MouseWatcherParameter);
    PyObject *dict = PyDict_New();
    Dtool_PGMouseWatcherParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PGMouseWatcherParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PGMouseWatcherParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PGMouseWatcherParameter);
  }
}

/**
 * Python method tables for PGMouseWatcherBackground (PGMouseWatcherBackground)
 */
static PyMethodDef Dtool_Methods_PGMouseWatcherBackground[] = {
  {"get_class_type", &Dtool_PGMouseWatcherBackground_get_class_type_168, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGMouseWatcherBackground_get_class_type_168_comment},
  {"getClassType", &Dtool_PGMouseWatcherBackground_get_class_type_168, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGMouseWatcherBackground_get_class_type_168_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PGMouseWatcherBackground = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PGMouseWatcherBackground = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PGMouseWatcherBackground = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PGMouseWatcherBackground = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PGMouseWatcherBackground = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PGMouseWatcherBackground",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PGMouseWatcherBackground,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PGMouseWatcherBackground,
    &Dtool_SequenceMethods_PGMouseWatcherBackground,
    &Dtool_MappingMethods_PGMouseWatcherBackground,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PGMouseWatcherBackground,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special kind of MouseWatcherRegion that doesn't have a rectangle\n"
    " * and is never active, but just quietly listens for keypresses and sends them\n"
    " * to all the PGItems with background focus.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PGMouseWatcherBackground,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PGMouseWatcherBackground,
    PyType_GenericAlloc,
    Dtool_new_PGMouseWatcherBackground,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PGMouseWatcherBackground,
  Dtool_UpcastInterface_PGMouseWatcherBackground,
  Dtool_DowncastInterface_PGMouseWatcherBackground,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PGMouseWatcherBackground(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_MouseWatcherRegion != NULL);
    assert(Dtool_Ptr_MouseWatcherRegion->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_MouseWatcherRegion->_Dtool_ModuleClassInit(NULL);
    Dtool_PGMouseWatcherBackground._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_MouseWatcherRegion);
    PyObject *dict = PyDict_New();
    Dtool_PGMouseWatcherBackground._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PGMouseWatcherBackground) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PGMouseWatcherBackground)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PGMouseWatcherBackground);
  }
}

/**
 * Python method tables for PGVirtualFrame (PGVirtualFrame)
 */
static PyMethodDef Dtool_Methods_PGVirtualFrame[] = {
  {"setup", (PyCFunction) &Dtool_PGVirtualFrame_setup_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGVirtualFrame_setup_171_comment},
  {"set_clip_frame", (PyCFunction) &Dtool_PGVirtualFrame_set_clip_frame_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGVirtualFrame_set_clip_frame_172_comment},
  {"setClipFrame", (PyCFunction) &Dtool_PGVirtualFrame_set_clip_frame_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGVirtualFrame_set_clip_frame_172_comment},
  {"get_clip_frame", &Dtool_PGVirtualFrame_get_clip_frame_173, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_get_clip_frame_173_comment},
  {"getClipFrame", &Dtool_PGVirtualFrame_get_clip_frame_173, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_get_clip_frame_173_comment},
  {"has_clip_frame", &Dtool_PGVirtualFrame_has_clip_frame_174, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_has_clip_frame_174_comment},
  {"hasClipFrame", &Dtool_PGVirtualFrame_has_clip_frame_174, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_has_clip_frame_174_comment},
  {"clear_clip_frame", &Dtool_PGVirtualFrame_clear_clip_frame_175, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_clear_clip_frame_175_comment},
  {"clearClipFrame", &Dtool_PGVirtualFrame_clear_clip_frame_175, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_clear_clip_frame_175_comment},
  {"set_canvas_transform", &Dtool_PGVirtualFrame_set_canvas_transform_176, METH_O, (const char *)Dtool_PGVirtualFrame_set_canvas_transform_176_comment},
  {"setCanvasTransform", &Dtool_PGVirtualFrame_set_canvas_transform_176, METH_O, (const char *)Dtool_PGVirtualFrame_set_canvas_transform_176_comment},
  {"get_canvas_transform", &Dtool_PGVirtualFrame_get_canvas_transform_177, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_get_canvas_transform_177_comment},
  {"getCanvasTransform", &Dtool_PGVirtualFrame_get_canvas_transform_177, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_get_canvas_transform_177_comment},
  {"get_canvas_node", &Dtool_PGVirtualFrame_get_canvas_node_178, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_get_canvas_node_178_comment},
  {"getCanvasNode", &Dtool_PGVirtualFrame_get_canvas_node_178, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_get_canvas_node_178_comment},
  {"get_canvas_parent", &Dtool_PGVirtualFrame_get_canvas_parent_179, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_get_canvas_parent_179_comment},
  {"getCanvasParent", &Dtool_PGVirtualFrame_get_canvas_parent_179, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_get_canvas_parent_179_comment},
  {"get_class_type", &Dtool_PGVirtualFrame_get_class_type_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGVirtualFrame_get_class_type_180_comment},
  {"getClassType", &Dtool_PGVirtualFrame_get_class_type_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGVirtualFrame_get_class_type_180_comment},
  {"downcast_to_PGScrollFrame", &Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_226, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_226_comment},
  {"downcastToPGScrollFrame", &Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_226, METH_NOARGS, (const char *)Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_226_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PGVirtualFrame = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PGVirtualFrame = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PGVirtualFrame = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PGVirtualFrame = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PGVirtualFrame = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PGVirtualFrame",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PGVirtualFrame,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PGVirtualFrame,
    &Dtool_SequenceMethods_PGVirtualFrame,
    &Dtool_MappingMethods_PGVirtualFrame,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PGVirtualFrame,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a frame that is rendered as a window onto another (possibly\n"
    " * much larger) canvas.  You can only see the portion of the canvas that is\n"
    " * below the window at any given time.\n"
    " *\n"
    " * This works simply by automatically defining a scissor effect to be applied\n"
    " * to a special child node, called the canvas_node, of the PGVirtualFrame\n"
    " * node.  Every object that is parented to the canvas_node will be clipped by\n"
    " * the scissor effect.  Also, you can modify the canvas_transform through\n"
    " * convenience methods here, which actually modifies the transform on the\n"
    " * canvas_node.\n"
    " *\n"
    " * The net effect is that the virtual canvas is arbitrarily large, and we can\n"
    " * peek at it through the scissor region, and scroll through different parts\n"
    " * of it by modifying the canvas_transform.\n"
    " *\n"
    " * See PGScrollFrame for a specialization of this class that handles the\n"
    " * traditional scrolling canvas, with scroll bars.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PGVirtualFrame,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PGVirtualFrame,
    PyType_GenericAlloc,
    Dtool_new_PGVirtualFrame,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PGVirtualFrame,
  Dtool_UpcastInterface_PGVirtualFrame,
  Dtool_DowncastInterface_PGVirtualFrame,
  (CoerceFunction)Dtool_ConstCoerce_PGVirtualFrame,
  (CoerceFunction)Dtool_Coerce_PGVirtualFrame,
};

static void Dtool_PyModuleClassInit_PGVirtualFrame(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PGItem(NULL);
    Dtool_PGVirtualFrame._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PGItem);
    PyObject *dict = PyDict_New();
    Dtool_PGVirtualFrame._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PGVirtualFrame) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PGVirtualFrame)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PGVirtualFrame);
  }
}

/**
 * Python method tables for PGSliderBar (PGSliderBar)
 */
static PyMethodDef Dtool_Methods_PGSliderBar[] = {
  {"setup_scroll_bar", (PyCFunction) &Dtool_PGSliderBar_setup_scroll_bar_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGSliderBar_setup_scroll_bar_189_comment},
  {"setupScrollBar", (PyCFunction) &Dtool_PGSliderBar_setup_scroll_bar_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGSliderBar_setup_scroll_bar_189_comment},
  {"setup_slider", (PyCFunction) &Dtool_PGSliderBar_setup_slider_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGSliderBar_setup_slider_190_comment},
  {"setupSlider", (PyCFunction) &Dtool_PGSliderBar_setup_slider_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGSliderBar_setup_slider_190_comment},
  {"set_axis", &Dtool_PGSliderBar_set_axis_191, METH_O, (const char *)Dtool_PGSliderBar_set_axis_191_comment},
  {"setAxis", &Dtool_PGSliderBar_set_axis_191, METH_O, (const char *)Dtool_PGSliderBar_set_axis_191_comment},
  {"get_axis", &Dtool_PGSliderBar_get_axis_192, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_axis_192_comment},
  {"getAxis", &Dtool_PGSliderBar_get_axis_192, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_axis_192_comment},
  {"set_range", (PyCFunction) &Dtool_PGSliderBar_set_range_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGSliderBar_set_range_193_comment},
  {"setRange", (PyCFunction) &Dtool_PGSliderBar_set_range_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGSliderBar_set_range_193_comment},
  {"get_min_value", &Dtool_PGSliderBar_get_min_value_194, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_min_value_194_comment},
  {"getMinValue", &Dtool_PGSliderBar_get_min_value_194, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_min_value_194_comment},
  {"get_max_value", &Dtool_PGSliderBar_get_max_value_195, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_max_value_195_comment},
  {"getMaxValue", &Dtool_PGSliderBar_get_max_value_195, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_max_value_195_comment},
  {"set_scroll_size", &Dtool_PGSliderBar_set_scroll_size_196, METH_O, (const char *)Dtool_PGSliderBar_set_scroll_size_196_comment},
  {"setScrollSize", &Dtool_PGSliderBar_set_scroll_size_196, METH_O, (const char *)Dtool_PGSliderBar_set_scroll_size_196_comment},
  {"get_scroll_size", &Dtool_PGSliderBar_get_scroll_size_197, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_scroll_size_197_comment},
  {"getScrollSize", &Dtool_PGSliderBar_get_scroll_size_197, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_scroll_size_197_comment},
  {"set_page_size", &Dtool_PGSliderBar_set_page_size_198, METH_O, (const char *)Dtool_PGSliderBar_set_page_size_198_comment},
  {"setPageSize", &Dtool_PGSliderBar_set_page_size_198, METH_O, (const char *)Dtool_PGSliderBar_set_page_size_198_comment},
  {"get_page_size", &Dtool_PGSliderBar_get_page_size_199, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_page_size_199_comment},
  {"getPageSize", &Dtool_PGSliderBar_get_page_size_199, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_page_size_199_comment},
  {"set_value", &Dtool_PGSliderBar_set_value_200, METH_O, (const char *)Dtool_PGSliderBar_set_value_200_comment},
  {"setValue", &Dtool_PGSliderBar_set_value_200, METH_O, (const char *)Dtool_PGSliderBar_set_value_200_comment},
  {"get_value", &Dtool_PGSliderBar_get_value_201, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_value_201_comment},
  {"getValue", &Dtool_PGSliderBar_get_value_201, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_value_201_comment},
  {"set_ratio", &Dtool_PGSliderBar_set_ratio_202, METH_O, (const char *)Dtool_PGSliderBar_set_ratio_202_comment},
  {"setRatio", &Dtool_PGSliderBar_set_ratio_202, METH_O, (const char *)Dtool_PGSliderBar_set_ratio_202_comment},
  {"get_ratio", &Dtool_PGSliderBar_get_ratio_203, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_ratio_203_comment},
  {"getRatio", &Dtool_PGSliderBar_get_ratio_203, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_ratio_203_comment},
  {"is_button_down", &Dtool_PGSliderBar_is_button_down_204, METH_NOARGS, (const char *)Dtool_PGSliderBar_is_button_down_204_comment},
  {"isButtonDown", &Dtool_PGSliderBar_is_button_down_204, METH_NOARGS, (const char *)Dtool_PGSliderBar_is_button_down_204_comment},
  {"set_resize_thumb", &Dtool_PGSliderBar_set_resize_thumb_205, METH_O, (const char *)Dtool_PGSliderBar_set_resize_thumb_205_comment},
  {"setResizeThumb", &Dtool_PGSliderBar_set_resize_thumb_205, METH_O, (const char *)Dtool_PGSliderBar_set_resize_thumb_205_comment},
  {"get_resize_thumb", &Dtool_PGSliderBar_get_resize_thumb_206, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_resize_thumb_206_comment},
  {"getResizeThumb", &Dtool_PGSliderBar_get_resize_thumb_206, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_resize_thumb_206_comment},
  {"set_manage_pieces", &Dtool_PGSliderBar_set_manage_pieces_207, METH_O, (const char *)Dtool_PGSliderBar_set_manage_pieces_207_comment},
  {"setManagePieces", &Dtool_PGSliderBar_set_manage_pieces_207, METH_O, (const char *)Dtool_PGSliderBar_set_manage_pieces_207_comment},
  {"get_manage_pieces", &Dtool_PGSliderBar_get_manage_pieces_208, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_manage_pieces_208_comment},
  {"getManagePieces", &Dtool_PGSliderBar_get_manage_pieces_208, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_manage_pieces_208_comment},
  {"set_thumb_button", &Dtool_PGSliderBar_set_thumb_button_209, METH_O, (const char *)Dtool_PGSliderBar_set_thumb_button_209_comment},
  {"setThumbButton", &Dtool_PGSliderBar_set_thumb_button_209, METH_O, (const char *)Dtool_PGSliderBar_set_thumb_button_209_comment},
  {"clear_thumb_button", &Dtool_PGSliderBar_clear_thumb_button_210, METH_NOARGS, (const char *)Dtool_PGSliderBar_clear_thumb_button_210_comment},
  {"clearThumbButton", &Dtool_PGSliderBar_clear_thumb_button_210, METH_NOARGS, (const char *)Dtool_PGSliderBar_clear_thumb_button_210_comment},
  {"get_thumb_button", &Dtool_PGSliderBar_get_thumb_button_211, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_thumb_button_211_comment},
  {"getThumbButton", &Dtool_PGSliderBar_get_thumb_button_211, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_thumb_button_211_comment},
  {"set_left_button", &Dtool_PGSliderBar_set_left_button_212, METH_O, (const char *)Dtool_PGSliderBar_set_left_button_212_comment},
  {"setLeftButton", &Dtool_PGSliderBar_set_left_button_212, METH_O, (const char *)Dtool_PGSliderBar_set_left_button_212_comment},
  {"clear_left_button", &Dtool_PGSliderBar_clear_left_button_213, METH_NOARGS, (const char *)Dtool_PGSliderBar_clear_left_button_213_comment},
  {"clearLeftButton", &Dtool_PGSliderBar_clear_left_button_213, METH_NOARGS, (const char *)Dtool_PGSliderBar_clear_left_button_213_comment},
  {"get_left_button", &Dtool_PGSliderBar_get_left_button_214, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_left_button_214_comment},
  {"getLeftButton", &Dtool_PGSliderBar_get_left_button_214, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_left_button_214_comment},
  {"set_right_button", &Dtool_PGSliderBar_set_right_button_215, METH_O, (const char *)Dtool_PGSliderBar_set_right_button_215_comment},
  {"setRightButton", &Dtool_PGSliderBar_set_right_button_215, METH_O, (const char *)Dtool_PGSliderBar_set_right_button_215_comment},
  {"clear_right_button", &Dtool_PGSliderBar_clear_right_button_216, METH_NOARGS, (const char *)Dtool_PGSliderBar_clear_right_button_216_comment},
  {"clearRightButton", &Dtool_PGSliderBar_clear_right_button_216, METH_NOARGS, (const char *)Dtool_PGSliderBar_clear_right_button_216_comment},
  {"get_right_button", &Dtool_PGSliderBar_get_right_button_217, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_right_button_217_comment},
  {"getRightButton", &Dtool_PGSliderBar_get_right_button_217, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_right_button_217_comment},
  {"get_adjust_prefix", &Dtool_PGSliderBar_get_adjust_prefix_218, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGSliderBar_get_adjust_prefix_218_comment},
  {"getAdjustPrefix", &Dtool_PGSliderBar_get_adjust_prefix_218, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGSliderBar_get_adjust_prefix_218_comment},
  {"get_adjust_event", &Dtool_PGSliderBar_get_adjust_event_219, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_adjust_event_219_comment},
  {"getAdjustEvent", &Dtool_PGSliderBar_get_adjust_event_219, METH_NOARGS, (const char *)Dtool_PGSliderBar_get_adjust_event_219_comment},
  {"set_active", &Dtool_PGSliderBar_set_active_220, METH_O, (const char *)Dtool_PGSliderBar_set_active_220_comment},
  {"setActive", &Dtool_PGSliderBar_set_active_220, METH_O, (const char *)Dtool_PGSliderBar_set_active_220_comment},
  {"remanage", &Dtool_PGSliderBar_remanage_221, METH_NOARGS, (const char *)Dtool_PGSliderBar_remanage_221_comment},
  {"recompute", &Dtool_PGSliderBar_recompute_222, METH_NOARGS, (const char *)Dtool_PGSliderBar_recompute_222_comment},
  {"get_class_type", &Dtool_PGSliderBar_get_class_type_223, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGSliderBar_get_class_type_223_comment},
  {"getClassType", &Dtool_PGSliderBar_get_class_type_223, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGSliderBar_get_class_type_223_comment},
  {"upcast_to_PGItem", &Dtool_PGSliderBar_upcast_to_PGItem_182, METH_NOARGS, (const char *)Dtool_PGSliderBar_upcast_to_PGItem_182_comment},
  {"upcastToPGItem", &Dtool_PGSliderBar_upcast_to_PGItem_182, METH_NOARGS, (const char *)Dtool_PGSliderBar_upcast_to_PGItem_182_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PGSliderBar = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PGSliderBar = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PGSliderBar = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PGSliderBar = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PGSliderBar = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PGSliderBar",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PGSliderBar,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PGSliderBar,
    &Dtool_SequenceMethods_PGSliderBar,
    &Dtool_MappingMethods_PGSliderBar,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PGSliderBar,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a particular kind of PGItem that draws a little bar with a slider\n"
    " * that moves from left to right indicating a value between the ranges.\n"
    " *\n"
    " * This is used as an implementation for both DirectSlider and for\n"
    " * DirectScrollBar.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PGSliderBar,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PGSliderBar,
    PyType_GenericAlloc,
    Dtool_new_PGSliderBar,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PGSliderBar,
  Dtool_UpcastInterface_PGSliderBar,
  Dtool_DowncastInterface_PGSliderBar,
  (CoerceFunction)Dtool_ConstCoerce_PGSliderBar,
  (CoerceFunction)Dtool_Coerce_PGSliderBar,
};

static void Dtool_PyModuleClassInit_PGSliderBar(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PGItem(NULL);
    Dtool_PGSliderBar._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PGItem);
    PyObject *dict = PyDict_New();
    Dtool_PGSliderBar._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PGSliderBar) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PGSliderBar)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PGSliderBar);
  }
}

/**
 * Python method tables for PGScrollFrame (PGScrollFrame)
 */
static PyMethodDef Dtool_Methods_PGScrollFrame[] = {
  {"setup", (PyCFunction) &Dtool_PGScrollFrame_setup_232, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGScrollFrame_setup_232_comment},
  {"set_virtual_frame", (PyCFunction) &Dtool_PGScrollFrame_set_virtual_frame_233, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGScrollFrame_set_virtual_frame_233_comment},
  {"setVirtualFrame", (PyCFunction) &Dtool_PGScrollFrame_set_virtual_frame_233, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGScrollFrame_set_virtual_frame_233_comment},
  {"get_virtual_frame", &Dtool_PGScrollFrame_get_virtual_frame_234, METH_NOARGS, (const char *)Dtool_PGScrollFrame_get_virtual_frame_234_comment},
  {"getVirtualFrame", &Dtool_PGScrollFrame_get_virtual_frame_234, METH_NOARGS, (const char *)Dtool_PGScrollFrame_get_virtual_frame_234_comment},
  {"has_virtual_frame", &Dtool_PGScrollFrame_has_virtual_frame_235, METH_NOARGS, (const char *)Dtool_PGScrollFrame_has_virtual_frame_235_comment},
  {"hasVirtualFrame", &Dtool_PGScrollFrame_has_virtual_frame_235, METH_NOARGS, (const char *)Dtool_PGScrollFrame_has_virtual_frame_235_comment},
  {"clear_virtual_frame", &Dtool_PGScrollFrame_clear_virtual_frame_236, METH_NOARGS, (const char *)Dtool_PGScrollFrame_clear_virtual_frame_236_comment},
  {"clearVirtualFrame", &Dtool_PGScrollFrame_clear_virtual_frame_236, METH_NOARGS, (const char *)Dtool_PGScrollFrame_clear_virtual_frame_236_comment},
  {"set_manage_pieces", &Dtool_PGScrollFrame_set_manage_pieces_237, METH_O, (const char *)Dtool_PGScrollFrame_set_manage_pieces_237_comment},
  {"setManagePieces", &Dtool_PGScrollFrame_set_manage_pieces_237, METH_O, (const char *)Dtool_PGScrollFrame_set_manage_pieces_237_comment},
  {"get_manage_pieces", &Dtool_PGScrollFrame_get_manage_pieces_238, METH_NOARGS, (const char *)Dtool_PGScrollFrame_get_manage_pieces_238_comment},
  {"getManagePieces", &Dtool_PGScrollFrame_get_manage_pieces_238, METH_NOARGS, (const char *)Dtool_PGScrollFrame_get_manage_pieces_238_comment},
  {"set_auto_hide", &Dtool_PGScrollFrame_set_auto_hide_239, METH_O, (const char *)Dtool_PGScrollFrame_set_auto_hide_239_comment},
  {"setAutoHide", &Dtool_PGScrollFrame_set_auto_hide_239, METH_O, (const char *)Dtool_PGScrollFrame_set_auto_hide_239_comment},
  {"get_auto_hide", &Dtool_PGScrollFrame_get_auto_hide_240, METH_NOARGS, (const char *)Dtool_PGScrollFrame_get_auto_hide_240_comment},
  {"getAutoHide", &Dtool_PGScrollFrame_get_auto_hide_240, METH_NOARGS, (const char *)Dtool_PGScrollFrame_get_auto_hide_240_comment},
  {"set_horizontal_slider", &Dtool_PGScrollFrame_set_horizontal_slider_241, METH_O, (const char *)Dtool_PGScrollFrame_set_horizontal_slider_241_comment},
  {"setHorizontalSlider", &Dtool_PGScrollFrame_set_horizontal_slider_241, METH_O, (const char *)Dtool_PGScrollFrame_set_horizontal_slider_241_comment},
  {"clear_horizontal_slider", &Dtool_PGScrollFrame_clear_horizontal_slider_242, METH_NOARGS, (const char *)Dtool_PGScrollFrame_clear_horizontal_slider_242_comment},
  {"clearHorizontalSlider", &Dtool_PGScrollFrame_clear_horizontal_slider_242, METH_NOARGS, (const char *)Dtool_PGScrollFrame_clear_horizontal_slider_242_comment},
  {"get_horizontal_slider", &Dtool_PGScrollFrame_get_horizontal_slider_243, METH_NOARGS, (const char *)Dtool_PGScrollFrame_get_horizontal_slider_243_comment},
  {"getHorizontalSlider", &Dtool_PGScrollFrame_get_horizontal_slider_243, METH_NOARGS, (const char *)Dtool_PGScrollFrame_get_horizontal_slider_243_comment},
  {"set_vertical_slider", &Dtool_PGScrollFrame_set_vertical_slider_244, METH_O, (const char *)Dtool_PGScrollFrame_set_vertical_slider_244_comment},
  {"setVerticalSlider", &Dtool_PGScrollFrame_set_vertical_slider_244, METH_O, (const char *)Dtool_PGScrollFrame_set_vertical_slider_244_comment},
  {"clear_vertical_slider", &Dtool_PGScrollFrame_clear_vertical_slider_245, METH_NOARGS, (const char *)Dtool_PGScrollFrame_clear_vertical_slider_245_comment},
  {"clearVerticalSlider", &Dtool_PGScrollFrame_clear_vertical_slider_245, METH_NOARGS, (const char *)Dtool_PGScrollFrame_clear_vertical_slider_245_comment},
  {"get_vertical_slider", &Dtool_PGScrollFrame_get_vertical_slider_246, METH_NOARGS, (const char *)Dtool_PGScrollFrame_get_vertical_slider_246_comment},
  {"getVerticalSlider", &Dtool_PGScrollFrame_get_vertical_slider_246, METH_NOARGS, (const char *)Dtool_PGScrollFrame_get_vertical_slider_246_comment},
  {"remanage", &Dtool_PGScrollFrame_remanage_247, METH_NOARGS, (const char *)Dtool_PGScrollFrame_remanage_247_comment},
  {"recompute", &Dtool_PGScrollFrame_recompute_248, METH_NOARGS, (const char *)Dtool_PGScrollFrame_recompute_248_comment},
  {"get_class_type", &Dtool_PGScrollFrame_get_class_type_249, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGScrollFrame_get_class_type_249_comment},
  {"getClassType", &Dtool_PGScrollFrame_get_class_type_249, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGScrollFrame_get_class_type_249_comment},
  {"upcast_to_PGVirtualFrame", &Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_225, METH_NOARGS, (const char *)Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_225_comment},
  {"upcastToPGVirtualFrame", &Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_225, METH_NOARGS, (const char *)Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_225_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PGScrollFrame = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PGScrollFrame = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PGScrollFrame = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PGScrollFrame = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PGScrollFrame = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PGScrollFrame",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PGScrollFrame,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PGScrollFrame,
    &Dtool_SequenceMethods_PGScrollFrame,
    &Dtool_MappingMethods_PGScrollFrame,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PGScrollFrame,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special kind of frame that pretends to be much larger than it\n"
    " * actually is.  You can scroll through the frame, as if you're looking\n"
    " * through a window at the larger frame beneath.  All children of this frame\n"
    " * node are scrolled and clipped as if they were children of the larger,\n"
    " * virtual frame.\n"
    " *\n"
    " * This is implemented as a specialization of PGVirtualFrame, which handles\n"
    " * the meat of the virtual canvas.  This class adds automatic support for\n"
    " * scroll bars, and restricts the virtual transform to translate only (no\n"
    " * scale or rotate).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PGScrollFrame,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PGScrollFrame,
    PyType_GenericAlloc,
    Dtool_new_PGScrollFrame,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PGScrollFrame,
  Dtool_UpcastInterface_PGScrollFrame,
  Dtool_DowncastInterface_PGScrollFrame,
  (CoerceFunction)Dtool_ConstCoerce_PGScrollFrame,
  (CoerceFunction)Dtool_Coerce_PGScrollFrame,
};

static void Dtool_PyModuleClassInit_PGScrollFrame(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PGVirtualFrame(NULL);
    Dtool_PGScrollFrame._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PGVirtualFrame);
    PyObject *dict = PyDict_New();
    Dtool_PGScrollFrame._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PGScrollFrame) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PGScrollFrame)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PGScrollFrame);
  }
}

/**
 * Python method tables for PGWaitBar (PGWaitBar)
 */
static PyMethodDef Dtool_Methods_PGWaitBar[] = {
  {"setup", (PyCFunction) &Dtool_PGWaitBar_setup_252, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PGWaitBar_setup_252_comment},
  {"set_range", &Dtool_PGWaitBar_set_range_253, METH_O, (const char *)Dtool_PGWaitBar_set_range_253_comment},
  {"setRange", &Dtool_PGWaitBar_set_range_253, METH_O, (const char *)Dtool_PGWaitBar_set_range_253_comment},
  {"get_range", &Dtool_PGWaitBar_get_range_254, METH_NOARGS, (const char *)Dtool_PGWaitBar_get_range_254_comment},
  {"getRange", &Dtool_PGWaitBar_get_range_254, METH_NOARGS, (const char *)Dtool_PGWaitBar_get_range_254_comment},
  {"set_value", &Dtool_PGWaitBar_set_value_255, METH_O, (const char *)Dtool_PGWaitBar_set_value_255_comment},
  {"setValue", &Dtool_PGWaitBar_set_value_255, METH_O, (const char *)Dtool_PGWaitBar_set_value_255_comment},
  {"get_value", &Dtool_PGWaitBar_get_value_256, METH_NOARGS, (const char *)Dtool_PGWaitBar_get_value_256_comment},
  {"getValue", &Dtool_PGWaitBar_get_value_256, METH_NOARGS, (const char *)Dtool_PGWaitBar_get_value_256_comment},
  {"get_percent", &Dtool_PGWaitBar_get_percent_257, METH_NOARGS, (const char *)Dtool_PGWaitBar_get_percent_257_comment},
  {"getPercent", &Dtool_PGWaitBar_get_percent_257, METH_NOARGS, (const char *)Dtool_PGWaitBar_get_percent_257_comment},
  {"set_bar_style", &Dtool_PGWaitBar_set_bar_style_258, METH_O, (const char *)Dtool_PGWaitBar_set_bar_style_258_comment},
  {"setBarStyle", &Dtool_PGWaitBar_set_bar_style_258, METH_O, (const char *)Dtool_PGWaitBar_set_bar_style_258_comment},
  {"get_bar_style", &Dtool_PGWaitBar_get_bar_style_259, METH_NOARGS, (const char *)Dtool_PGWaitBar_get_bar_style_259_comment},
  {"getBarStyle", &Dtool_PGWaitBar_get_bar_style_259, METH_NOARGS, (const char *)Dtool_PGWaitBar_get_bar_style_259_comment},
  {"get_class_type", &Dtool_PGWaitBar_get_class_type_260, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGWaitBar_get_class_type_260_comment},
  {"getClassType", &Dtool_PGWaitBar_get_class_type_260, METH_NOARGS | METH_STATIC, (const char *)Dtool_PGWaitBar_get_class_type_260_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PGWaitBar = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PGWaitBar = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PGWaitBar = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PGWaitBar = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PGWaitBar = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PGWaitBar",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PGWaitBar,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PGWaitBar,
    &Dtool_SequenceMethods_PGWaitBar,
    &Dtool_MappingMethods_PGWaitBar,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PGWaitBar,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a particular kind of PGItem that draws a little bar that fills from\n"
    " * left to right to indicate a slow process gradually completing, like a\n"
    " * traditional \"wait, loading\" bar.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PGWaitBar,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PGWaitBar,
    PyType_GenericAlloc,
    Dtool_new_PGWaitBar,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PGWaitBar,
  Dtool_UpcastInterface_PGWaitBar,
  Dtool_DowncastInterface_PGWaitBar,
  (CoerceFunction)Dtool_ConstCoerce_PGWaitBar,
  (CoerceFunction)Dtool_Coerce_PGWaitBar,
};

static void Dtool_PyModuleClassInit_PGWaitBar(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PGItem(NULL);
    Dtool_PGWaitBar._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PGItem);
    PyObject *dict = PyDict_New();
    Dtool_PGWaitBar._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PGWaitBar) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PGWaitBar)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PGWaitBar);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3pgui_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PGFrameStyle", Dtool_PGFrameStyle);
#endif
  Dtool_PGItem._type = PGItem::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PGItem);
  Dtool_PGButton._type = PGButton::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PGButton);
  Dtool_PGTop._type = PGTop::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PGTop);
  Dtool_PGEntry._type = PGEntry::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PGEntry);
  Dtool_PGMouseWatcherParameter._type = PGMouseWatcherParameter::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PGMouseWatcherParameter);
  Dtool_PGMouseWatcherBackground._type = PGMouseWatcherBackground::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PGMouseWatcherBackground);
  Dtool_PGVirtualFrame._type = PGVirtualFrame::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PGVirtualFrame);
  Dtool_PGSliderBar._type = PGSliderBar::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PGSliderBar);
  Dtool_PGScrollFrame._type = PGScrollFrame::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PGScrollFrame);
  Dtool_PGWaitBar._type = PGWaitBar::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PGWaitBar);
}

void Dtool_libp3pgui_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_LVecBase2f = LookupRuntimeTypedClass(LVecBase2f::get_class_type());
  Dtool_Ptr_LVector3f = LookupRuntimeTypedClass(LVector3f::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_ButtonHandle = LookupRuntimeTypedClass(ButtonHandle::get_class_type());
  Dtool_Ptr_MouseWatcherRegion = LookupRuntimeTypedClass(MouseWatcherRegion::get_class_type());
  Dtool_Ptr_Texture = LookupRuntimeTypedClass(Texture::get_class_type());
  Dtool_Ptr_TransformState = LookupRuntimeTypedClass(TransformState::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_TextProperties = LookupRuntimeTypedClass(TextProperties::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_AudioSound = LookupRuntimeTypedClass(AudioSound::get_class_type());
  Dtool_Ptr_MouseWatcherGroup = LookupRuntimeTypedClass(MouseWatcherGroup::get_class_type());
  Dtool_Ptr_TextGraphic = LookupNamedClass("TextGraphic");
  Dtool_Ptr_TextNode = LookupRuntimeTypedClass(TextNode::get_class_type());
  Dtool_Ptr_MouseWatcherParameter = LookupNamedClass("MouseWatcherParameter");
  Dtool_Ptr_MouseWatcher = LookupRuntimeTypedClass(MouseWatcher::get_class_type());
#endif
}

void Dtool_libp3pgui_BuildInstants(PyObject *module) {
  (void) module;
  // PGFrameStyle
  Dtool_PyModuleClassInit_PGFrameStyle(module);
  PyModule_AddObject(module, "PGFrameStyle", (PyObject *)&Dtool_PGFrameStyle);
  // PGItem
  Dtool_PyModuleClassInit_PGItem(module);
  PyModule_AddObject(module, "PGItem", (PyObject *)&Dtool_PGItem);
  // PGButton
  Dtool_PyModuleClassInit_PGButton(module);
  PyModule_AddObject(module, "PGButton", (PyObject *)&Dtool_PGButton);
  // PGTop
  Dtool_PyModuleClassInit_PGTop(module);
  PyModule_AddObject(module, "PGTop", (PyObject *)&Dtool_PGTop);
  // PGEntry
  Dtool_PyModuleClassInit_PGEntry(module);
  PyModule_AddObject(module, "PGEntry", (PyObject *)&Dtool_PGEntry);
  // PGMouseWatcherParameter
  Dtool_PyModuleClassInit_PGMouseWatcherParameter(module);
  PyModule_AddObject(module, "PGMouseWatcherParameter", (PyObject *)&Dtool_PGMouseWatcherParameter);
  // PGMouseWatcherBackground
  Dtool_PyModuleClassInit_PGMouseWatcherBackground(module);
  PyModule_AddObject(module, "PGMouseWatcherBackground", (PyObject *)&Dtool_PGMouseWatcherBackground);
  // PGVirtualFrame
  Dtool_PyModuleClassInit_PGVirtualFrame(module);
  PyModule_AddObject(module, "PGVirtualFrame", (PyObject *)&Dtool_PGVirtualFrame);
  // PGSliderBar
  Dtool_PyModuleClassInit_PGSliderBar(module);
  PyModule_AddObject(module, "PGSliderBar", (PyObject *)&Dtool_PGSliderBar);
  // PGScrollFrame
  Dtool_PyModuleClassInit_PGScrollFrame(module);
  PyModule_AddObject(module, "PGScrollFrame", (PyObject *)&Dtool_PGScrollFrame);
  // PGWaitBar
  Dtool_PyModuleClassInit_PGWaitBar(module);
  PyModule_AddObject(module, "PGWaitBar", (PyObject *)&Dtool_PGWaitBar);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3pgui_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478213578,  /* file_identifier */
  "libp3pgui",  /* library_name */
  "Q2_k",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3pgui.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  599  /* next_index */
};

Configure(_in_configure_libp3pgui);
ConfigureFn(_in_configure_libp3pgui) {
  interrogate_request_module(&_in_module_def);
}

