/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/pipeline -Ipanda/src/pipeline -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3pipeline_igate.cxx -od built/pandac/input/libp3pipeline.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/pipeline -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3pipeline asyncTaskBase.h blockerSimple.h conditionVar.h conditionVarDebug.h conditionVarDirect.h conditionVarDummyImpl.h conditionVarFull.h conditionVarFullDebug.h conditionVarFullDirect.h conditionVarFullWin32Impl.h conditionVarImpl.h conditionVarPosixImpl.h conditionVarSimpleImpl.h conditionVarSpinlockImpl.h conditionVarWin32Impl.h config_pipeline.h contextSwitch.h cycleData.h cycleDataLockedReader.h cycleDataLockedStageReader.h cycleDataReader.h cycleDataStageReader.h cycleDataStageWriter.h cycleDataWriter.h cyclerHolder.h externalThread.h genericThread.h lightMutex.h lightMutexDirect.h lightMutexHolder.h lightReMutex.h lightReMutexDirect.h lightReMutexHolder.h mainThread.h mutexDebug.h mutexDirect.h mutexHolder.h mutexSimpleImpl.h mutexTrueImpl.h p3pipeline_composite1.cxx p3pipeline_composite2.cxx pipeline.h pipelineCycler.h pipelineCyclerBase.h pipelineCyclerDummyImpl.h pipelineCyclerLinks.h pipelineCyclerTrivialImpl.h pipelineCyclerTrueImpl.h pmutex.h psemaphore.h pythonThread.h reMutex.h reMutexDirect.h reMutexHolder.h thread.h threadDummyImpl.h threadImpl.h threadPosixImpl.h threadPriority.h threadSimpleImpl.h threadSimpleManager.h threadWin32Impl.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3pipeline
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "asyncTaskBase.h"
#include "atomicAdjust.h"
#include "blockerSimple.h"
#include "conditionVar.h"
#include "conditionVarDebug.h"
#include "conditionVarDirect.h"
#include "conditionVarDummyImpl.h"
#include "conditionVarFull.h"
#include "conditionVarFullDebug.h"
#include "conditionVarFullDirect.h"
#include "conditionVarFullWin32Impl.h"
#include "conditionVarImpl.h"
#include "conditionVarPosixImpl.h"
#include "conditionVarSimpleImpl.h"
#include "conditionVarSpinlockImpl.h"
#include "conditionVarWin32Impl.h"
#include "config_pipeline.h"
#include "contextSwitch.h"
#include "cycleData.h"
#include "cycleDataLockedReader.h"
#include "cycleDataLockedStageReader.h"
#include "cycleDataReader.h"
#include "cycleDataStageReader.h"
#include "cycleDataStageWriter.h"
#include "cycleDataWriter.h"
#include "cyclerHolder.h"
#include "externalThread.h"
#include "genericThread.h"
#include "lightMutex.h"
#include "lightMutexDirect.h"
#include "lightMutexHolder.h"
#include "lightReMutex.h"
#include "lightReMutexDirect.h"
#include "lightReMutexHolder.h"
#include "mainThread.h"
#include "mutexDebug.h"
#include "mutexDirect.h"
#include "mutexHolder.h"
#include "mutexSimpleImpl.h"
#include "mutexTrueImpl.h"
#include "mutexWin32Impl.h"
#include "namable.h"
#include "nodeReferenceCount.h"
#include "pandabase.h"
#include "pipeline.h"
#include "pipelineCycler.h"
#include "pipelineCyclerBase.h"
#include "pipelineCyclerDummyImpl.h"
#include "pipelineCyclerLinks.h"
#include "pipelineCyclerTrivialImpl.h"
#include "pipelineCyclerTrueImpl.h"
#include "pmutex.h"
#include "pnotify.h"
#include "psemaphore.h"
#include "pythonThread.h"
#include "reMutex.h"
#include "reMutexDirect.h"
#include "reMutexHolder.h"
#include "selectThreadImpl.h"
#include "thread.h"
#include "threadDummyImpl.h"
#include "threadImpl.h"
#include "threadPosixImpl.h"
#include "threadPriority.h"
#include "threadSimpleImpl.h"
#include "threadSimpleManager.h"
#include "threadWin32Impl.h"
#include "typeHandle.h"
#include "typedReferenceCount.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class AsyncTaskBase
 */
typedef AsyncTaskBase AsyncTaskBase_localtype;
Define_Module_ClassRef(panda3d.core, AsyncTaskBase, AsyncTaskBase_localtype, AsyncTaskBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskBase = &Dtool_AsyncTaskBase;
static void Dtool_PyModuleClassInit_AsyncTaskBase(PyObject *module);

/**
 * Forward declarations for top-level class Thread
 */
typedef Thread Thread_localtype;
Define_Module_ClassRef(panda3d.core, Thread, Thread_localtype, Thread);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Thread = &Dtool_Thread;
static void Dtool_PyModuleClassInit_Thread(PyObject *module);

/**
 * Forward declarations for top-level class MutexDirect
 */
typedef MutexDirect MutexDirect_localtype;
Define_Module_Class_Private(panda3d.core, MutexDirect, MutexDirect_localtype, MutexDirect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MutexDirect = &Dtool_MutexDirect;
static void Dtool_PyModuleClassInit_MutexDirect(PyObject *module);

/**
 * Forward declarations for top-level class Mutex
 */
typedef Mutex Mutex_localtype;
Define_Module_Class(panda3d.core, Mutex, Mutex_localtype, Mutex);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Mutex = &Dtool_Mutex;
static void Dtool_PyModuleClassInit_Mutex(PyObject *module);
bool Dtool_ConstCoerce_Mutex(PyObject *args, Mutex const *&coerced, bool &manage);
bool Dtool_Coerce_Mutex(PyObject *args, Mutex *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ConditionVarDirect
 */
typedef ConditionVarDirect ConditionVarDirect_localtype;
Define_Module_Class(panda3d.core, ConditionVarDirect, ConditionVarDirect_localtype, ConditionVarDirect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConditionVarDirect = &Dtool_ConditionVarDirect;
static void Dtool_PyModuleClassInit_ConditionVarDirect(PyObject *module);

/**
 * Forward declarations for top-level class ConditionVar
 */
typedef ConditionVar ConditionVar_localtype;
Define_Module_Class(panda3d.core, ConditionVar, ConditionVar_localtype, ConditionVar);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConditionVar = &Dtool_ConditionVar;
static void Dtool_PyModuleClassInit_ConditionVar(PyObject *module);
bool Dtool_ConstCoerce_ConditionVar(PyObject *args, ConditionVar const *&coerced, bool &manage);
bool Dtool_Coerce_ConditionVar(PyObject *args, ConditionVar *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ConditionVarFullDirect
 */
typedef ConditionVarFullDirect ConditionVarFullDirect_localtype;
Define_Module_Class(panda3d.core, ConditionVarFullDirect, ConditionVarFullDirect_localtype, ConditionVarFullDirect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConditionVarFullDirect = &Dtool_ConditionVarFullDirect;
static void Dtool_PyModuleClassInit_ConditionVarFullDirect(PyObject *module);

/**
 * Forward declarations for top-level class ConditionVarFull
 */
typedef ConditionVarFull ConditionVarFull_localtype;
Define_Module_Class(panda3d.core, ConditionVarFull, ConditionVarFull_localtype, ConditionVarFull);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConditionVarFull = &Dtool_ConditionVarFull;
static void Dtool_PyModuleClassInit_ConditionVarFull(PyObject *module);
bool Dtool_ConstCoerce_ConditionVarFull(PyObject *args, ConditionVarFull const *&coerced, bool &manage);
bool Dtool_Coerce_ConditionVarFull(PyObject *args, ConditionVarFull *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ReMutexDirect
 */
typedef ReMutexDirect ReMutexDirect_localtype;
Define_Module_Class_Private(panda3d.core, ReMutexDirect, ReMutexDirect_localtype, ReMutexDirect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReMutexDirect = &Dtool_ReMutexDirect;
static void Dtool_PyModuleClassInit_ReMutexDirect(PyObject *module);

/**
 * Forward declarations for top-level class ReMutex
 */
typedef ReMutex ReMutex_localtype;
Define_Module_Class(panda3d.core, ReMutex, ReMutex_localtype, ReMutex);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReMutex = &Dtool_ReMutex;
static void Dtool_PyModuleClassInit_ReMutex(PyObject *module);
bool Dtool_ConstCoerce_ReMutex(PyObject *args, ReMutex const *&coerced, bool &manage);
bool Dtool_Coerce_ReMutex(PyObject *args, ReMutex *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ExternalThread
 */
typedef ExternalThread ExternalThread_localtype;
Define_Module_ClassRef(panda3d.core, ExternalThread, ExternalThread_localtype, ExternalThread);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ExternalThread = &Dtool_ExternalThread;
static void Dtool_PyModuleClassInit_ExternalThread(PyObject *module);

/**
 * Forward declarations for top-level class LightMutexDirect
 */
typedef LightMutexDirect LightMutexDirect_localtype;
Define_Module_Class_Private(panda3d.core, LightMutexDirect, LightMutexDirect_localtype, LightMutexDirect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightMutexDirect = &Dtool_LightMutexDirect;
static void Dtool_PyModuleClassInit_LightMutexDirect(PyObject *module);

/**
 * Forward declarations for top-level class LightMutex
 */
typedef LightMutex LightMutex_localtype;
Define_Module_Class(panda3d.core, LightMutex, LightMutex_localtype, LightMutex);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightMutex = &Dtool_LightMutex;
static void Dtool_PyModuleClassInit_LightMutex(PyObject *module);
bool Dtool_ConstCoerce_LightMutex(PyObject *args, LightMutex const *&coerced, bool &manage);
bool Dtool_Coerce_LightMutex(PyObject *args, LightMutex *&coerced, bool &manage);

/**
 * Forward declarations for top-level class LightReMutexDirect
 */
typedef LightReMutexDirect LightReMutexDirect_localtype;
Define_Module_Class_Private(panda3d.core, LightReMutexDirect, LightReMutexDirect_localtype, LightReMutexDirect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightReMutexDirect = &Dtool_LightReMutexDirect;
static void Dtool_PyModuleClassInit_LightReMutexDirect(PyObject *module);

/**
 * Forward declarations for top-level class LightReMutex
 */
typedef LightReMutex LightReMutex_localtype;
Define_Module_Class(panda3d.core, LightReMutex, LightReMutex_localtype, LightReMutex);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightReMutex = &Dtool_LightReMutex;
static void Dtool_PyModuleClassInit_LightReMutex(PyObject *module);
bool Dtool_ConstCoerce_LightReMutex(PyObject *args, LightReMutex const *&coerced, bool &manage);
bool Dtool_Coerce_LightReMutex(PyObject *args, LightReMutex *&coerced, bool &manage);

/**
 * Forward declarations for top-level class MainThread
 */
typedef MainThread MainThread_localtype;
Define_Module_ClassRef(panda3d.core, MainThread, MainThread_localtype, MainThread);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MainThread = &Dtool_MainThread;
static void Dtool_PyModuleClassInit_MainThread(PyObject *module);

/**
 * Forward declarations for top-level class PythonThread
 */
typedef PythonThread PythonThread_localtype;
Define_Module_ClassRef(panda3d.core, PythonThread, PythonThread_localtype, PythonThread);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PythonThread = &Dtool_PythonThread;
static void Dtool_PyModuleClassInit_PythonThread(PyObject *module);
bool Dtool_ConstCoerce_PythonThread(PyObject *args, CPT(PythonThread) &coerced);
bool Dtool_Coerce_PythonThread(PyObject *args, PT(PythonThread) &coerced);

/**
 * Forward declarations for top-level class Semaphore
 */
typedef Semaphore Semaphore_localtype;
Define_Module_Class(panda3d.core, Semaphore, Semaphore_localtype, Semaphore);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Semaphore = &Dtool_Semaphore;
static void Dtool_PyModuleClassInit_Semaphore(PyObject *module);
bool Dtool_ConstCoerce_Semaphore(PyObject *args, Semaphore const *&coerced, bool &manage);
bool Dtool_Coerce_Semaphore(PyObject *args, Semaphore *&coerced, bool &manage);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class AsyncTaskBase
 */
/**
 * Python function wrapper for:
 * static TypeHandle AsyncTaskBase::get_class_type(void)
 */
static PyObject *Dtool_AsyncTaskBase_get_class_type_9(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncTaskBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AsyncTaskBase::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskBase_get_class_type_9_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncTaskBase_get_class_type_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *AsyncTaskBase::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3(PyObject *self, PyObject *) {
  AsyncTaskBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskBase, (void **)&local_this, "AsyncTaskBase.upcast_to_TypedReferenceCount")) {
    return NULL;
  }
  // 1-TypedReferenceCount *AsyncTaskBase::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const AsyncTaskBase self)\n"
  "\n"
  "upcast from AsyncTaskBase to TypedReferenceCount";
#else
static const char *Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Namable *AsyncTaskBase::upcast_to_Namable(void)
 */
static PyObject *Dtool_AsyncTaskBase_upcast_to_Namable_6(PyObject *self, PyObject *) {
  AsyncTaskBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskBase, (void **)&local_this, "AsyncTaskBase.upcast_to_Namable")) {
    return NULL;
  }
  // 1-Namable *AsyncTaskBase::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskBase_upcast_to_Namable_6_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const AsyncTaskBase self)\n"
  "\n"
  "upcast from AsyncTaskBase to Namable";
#else
static const char *Dtool_AsyncTaskBase_upcast_to_Namable_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AsyncTaskBase::AsyncTaskBase(AsyncTaskBase const &) = default
 */
static int Dtool_Init_AsyncTaskBase(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AsyncTaskBase() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline AsyncTaskBase::AsyncTaskBase(AsyncTaskBase const &) = default
  AsyncTaskBase const *arg_this = (AsyncTaskBase *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskBase, 0, "AsyncTaskBase.AsyncTaskBase", true, true);
  if (arg_this != NULL) {
    AsyncTaskBase *return_value = new AsyncTaskBase(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskBase, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncTaskBase(const AsyncTaskBase param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AsyncTaskBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AsyncTaskBase) {
    printf("AsyncTaskBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AsyncTaskBase *local_this = (AsyncTaskBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AsyncTaskBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AsyncTaskBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AsyncTaskBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AsyncTaskBase*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncTaskBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncTaskBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncTaskBase*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Thread
 */
/**
 * Python function wrapper for:
 * static PointerTo< Thread > Thread::bind_thread(std::string const &name, std::string const &sync_name)
 */
static PyObject *Dtool_Thread_bind_thread_18(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< Thread > Thread::bind_thread(std::string const &name, std::string const &sync_name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"name", "sync_name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:bind_thread", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    PointerTo< Thread > return_value = Thread::bind_thread(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    Thread *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Thread, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bind_thread(str name, str sync_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Thread_bind_thread_18_comment =
  "C++ Interface:\n"
  "bind_thread(str name, str sync_name)\n"
  "\n"
  "/**\n"
  " * Returns a new Panda Thread object associated with the current thread (which\n"
  " * has been created externally). This can be used to bind a unique Panda\n"
  " * Thread object with an external thread, such as a new Python thread.\n"
  " *\n"
  " * It is particularly useful to bind a Panda Thread object to an external\n"
  " * thread for the purposes of PStats monitoring.  Without this call, each\n"
  " * external thread will be assigned the same global ExternalThread object,\n"
  " * which means they will all appear in the same PStats graph.\n"
  " *\n"
  " * It is the caller's responsibility to save the returned Thread pointer for\n"
  " * the lifetime of the external thread.  It is an error for the Thread pointer\n"
  " * to destruct while the external thread is still in the system.\n"
  " *\n"
  " * It is also an error to call this method from the main thread, or twice\n"
  " * within a given thread, unless it is given the same name each time (in which\n"
  " * case the same pointer will be returned each time).\n"
  " */";
#else
static const char *Dtool_Thread_bind_thread_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Thread::get_sync_name(void) const
 */
static PyObject *Dtool_Thread_get_sync_name_19(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &Thread::get_sync_name(void) const
  std::string const &return_value = (*(const Thread*)local_this).get_sync_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_sync_name_19_comment =
  "C++ Interface:\n"
  "get_sync_name(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the sync name of the thread.  This name collects threads into \"sync\n"
  " * groups\", which are expected to run synchronously.  This is mainly used for\n"
  " * the benefit of PStats; threads with the same sync name can be ticked all at\n"
  " * once via the thread_tick() call.\n"
  " */";
#else
static const char *Dtool_Thread_get_sync_name_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Thread::get_pstats_index(void) const
 */
static PyObject *Dtool_Thread_get_pstats_index_20(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int Thread::get_pstats_index(void) const
  int return_value = (*(const Thread*)local_this).get_pstats_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_pstats_index_20_comment =
  "C++ Interface:\n"
  "get_pstats_index(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the PStats index associated with this thread, or -1 if no index has\n"
  " * yet been associated with this thread.  This is used internally by the\n"
  " * PStatClient; you should not need to call this directly.\n"
  " */";
#else
static const char *Dtool_Thread_get_pstats_index_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string Thread::get_unique_id(void) const
 */
static PyObject *Dtool_Thread_get_unique_id_21(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string Thread::get_unique_id(void) const
  std::string return_value = (*(const Thread*)local_this).get_unique_id();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_unique_id_21_comment =
  "C++ Interface:\n"
  "get_unique_id(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns a string that is guaranteed to be unique to this thread, across all\n"
  " * processes on the machine, during at least the lifetime of this process.\n"
  " */";
#else
static const char *Dtool_Thread_get_unique_id_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Thread::get_pipeline_stage(void) const
 */
static PyObject *Dtool_Thread_get_pipeline_stage_22(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int Thread::get_pipeline_stage(void) const
  int return_value = (*(const Thread*)local_this).get_pipeline_stage();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_pipeline_stage_22_comment =
  "C++ Interface:\n"
  "get_pipeline_stage(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the Pipeline stage number associated with this thread.  The default\n"
  " * stage is 0 if no stage is specified otherwise.  See set_pipeline_stage().\n"
  " */";
#else
static const char *Dtool_Thread_get_pipeline_stage_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Thread::set_pipeline_stage(int pipeline_stage)
 */
static PyObject *Dtool_Thread_set_pipeline_stage_23(PyObject *self, PyObject *arg) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.set_pipeline_stage")) {
    return NULL;
  }
  // 1-void Thread::set_pipeline_stage(int pipeline_stage)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_pipeline_stage((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pipeline_stage(const Thread self, int pipeline_stage)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Thread_set_pipeline_stage_23_comment =
  "C++ Interface:\n"
  "set_pipeline_stage(const Thread self, int pipeline_stage)\n"
  "\n"
  "/**\n"
  " * Specifies the Pipeline stage number associated with this thread.  The\n"
  " * default stage is 0 if no stage is specified otherwise.\n"
  " *\n"
  " * This must be a value in the range [0 .. pipeline->get_num_stages() - 1].\n"
  " * It specifies the values that this thread observes for all pipelined data.\n"
  " * Typically, an application thread will leave this at 0, but a render thread\n"
  " * may set it to 1 or 2 (to operate on the previous frame's data, or the\n"
  " * second previous frame's data).\n"
  " */";
#else
static const char *Dtool_Thread_set_pipeline_stage_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Thread::set_min_pipeline_stage(int min_pipeline_stage)
 */
static PyObject *Dtool_Thread_set_min_pipeline_stage_24(PyObject *self, PyObject *arg) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.set_min_pipeline_stage")) {
    return NULL;
  }
  // 1-inline void Thread::set_min_pipeline_stage(int min_pipeline_stage)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_min_pipeline_stage((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_pipeline_stage(const Thread self, int min_pipeline_stage)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Thread_set_min_pipeline_stage_24_comment =
  "C++ Interface:\n"
  "set_min_pipeline_stage(const Thread self, int min_pipeline_stage)\n"
  "\n"
  "/**\n"
  " * Sets this thread's pipeline stage number to at least the indicated value,\n"
  " * unless it is already larger.  See set_pipeline_stage().\n"
  " */";
#else
static const char *Dtool_Thread_set_min_pipeline_stage_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline Thread *Thread::get_main_thread(void)
 */
static PyObject *Dtool_Thread_get_main_thread_25(PyObject *, PyObject *) {
  // 1-static inline Thread *Thread::get_main_thread(void)
  Thread *return_value = Thread::get_main_thread();
  if (return_value != (Thread *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Thread *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_main_thread_25_comment =
  "C++ Interface:\n"
  "get_main_thread()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the \"main\" Thread object--this is the Thread that\n"
  " * started the whole process.\n"
  " */";
#else
static const char *Dtool_Thread_get_main_thread_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline Thread *Thread::get_external_thread(void)
 */
static PyObject *Dtool_Thread_get_external_thread_26(PyObject *, PyObject *) {
  // 1-static inline Thread *Thread::get_external_thread(void)
  Thread *return_value = Thread::get_external_thread();
  if (return_value != (Thread *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Thread *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_external_thread_26_comment =
  "C++ Interface:\n"
  "get_external_thread()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the \"external\" Thread object--this is a special Thread\n"
  " * object that corresponds to any thread spawned outside of Panda's threading\n"
  " * interface.  Note that multiple different threads may share this same\n"
  " * pointer.\n"
  " */";
#else
static const char *Dtool_Thread_get_external_thread_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline Thread *Thread::get_current_thread(void)
 */
static PyObject *Dtool_Thread_get_current_thread_27(PyObject *, PyObject *) {
  // 1-static inline Thread *Thread::get_current_thread(void)
  Thread *return_value = Thread::get_current_thread();
  if (return_value != (Thread *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Thread *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_current_thread_27_comment =
  "C++ Interface:\n"
  "get_current_thread()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the currently-executing Thread object.  If this is\n"
  " * called from the main thread, this will return the same value as\n"
  " * get_main_thread().\n"
  " *\n"
  " * This will always return some valid Thread pointer.  It will never return\n"
  " * NULL, even if the current thread was spawned outside of Panda's threading\n"
  " * system, although all non-Panda threads will return the exact same Thread\n"
  " * pointer.\n"
  " */";
#else
static const char *Dtool_Thread_get_current_thread_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int Thread::get_current_pipeline_stage(void)
 */
static PyObject *Dtool_Thread_get_current_pipeline_stage_28(PyObject *, PyObject *) {
  // 1-static inline int Thread::get_current_pipeline_stage(void)
  int return_value = Thread::get_current_pipeline_stage();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_current_pipeline_stage_28_comment =
  "C++ Interface:\n"
  "get_current_pipeline_stage()\n"
  "\n"
  "/**\n"
  " * Returns the integer pipeline stage associated with the current thread.\n"
  " * This is the same thing as get_current_thread()->get_pipeline_stage(), but\n"
  " * it may be faster to retrieve in some contexts.\n"
  " */";
#else
static const char *Dtool_Thread_get_current_pipeline_stage_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool Thread::is_threading_supported(void)
 */
static PyObject *Dtool_Thread_is_threading_supported_29(PyObject *, PyObject *) {
  // 1-static inline bool Thread::is_threading_supported(void)
  bool return_value = Thread::is_threading_supported();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_is_threading_supported_29_comment =
  "C++ Interface:\n"
  "is_threading_supported()\n"
  "\n"
  "/**\n"
  " * Returns true if threading support has been compiled in and enabled, or\n"
  " * false if no threading is available (and Thread::start() will always fail).\n"
  " */";
#else
static const char *Dtool_Thread_is_threading_supported_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool Thread::is_true_threads(void)
 */
static PyObject *Dtool_Thread_is_true_threads_30(PyObject *, PyObject *) {
  // 1-static inline bool Thread::is_true_threads(void)
  bool return_value = Thread::is_true_threads();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_is_true_threads_30_comment =
  "C++ Interface:\n"
  "is_true_threads()\n"
  "\n"
  "/**\n"
  " * Returns true if a real threading library is available that supports actual\n"
  " * OS-implemented threads, or false if the only threading we can provide is\n"
  " * simulated user-space threading.\n"
  " */";
#else
static const char *Dtool_Thread_is_true_threads_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool Thread::is_simple_threads(void)
 */
static PyObject *Dtool_Thread_is_simple_threads_31(PyObject *, PyObject *) {
  // 1-static inline bool Thread::is_simple_threads(void)
  bool return_value = Thread::is_simple_threads();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_is_simple_threads_31_comment =
  "C++ Interface:\n"
  "is_simple_threads()\n"
  "\n"
  "/**\n"
  " * Returns true if Panda is currently compiled for \"simple threads\", which is\n"
  " * to say, cooperative context switching only, reducing the need for quite so\n"
  " * many critical section protections.  This is not necessarily the opposite of\n"
  " * \"true threads\", since one possible implementation of simple threads is via\n"
  " * true threads with mutex protection to ensure only one runs at a time.\n"
  " */";
#else
static const char *Dtool_Thread_is_simple_threads_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void Thread::sleep(double seconds)
 */
static PyObject *Dtool_Thread_sleep_32(PyObject *, PyObject *arg) {
  // 1-static inline void Thread::sleep(double seconds)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    Thread::sleep(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sleep(double seconds)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Thread_sleep_32_comment =
  "C++ Interface:\n"
  "sleep(double seconds)\n"
  "\n"
  "/**\n"
  " * Suspends the current thread for at least the indicated amount of time.  It\n"
  " * might be suspended for longer.\n"
  " */";
#else
static const char *Dtool_Thread_sleep_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void Thread::force_yield(void)
 */
static PyObject *Dtool_Thread_force_yield_33(PyObject *, PyObject *) {
  // 1-static inline void Thread::force_yield(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  Thread::force_yield();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Thread_force_yield_33_comment =
  "C++ Interface:\n"
  "force_yield()\n"
  "\n"
  "/**\n"
  " * Suspends the current thread for the rest of the current epoch.\n"
  " */";
#else
static const char *Dtool_Thread_force_yield_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void Thread::consider_yield(void)
 */
static PyObject *Dtool_Thread_consider_yield_34(PyObject *, PyObject *) {
  // 1-static inline void Thread::consider_yield(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  Thread::consider_yield();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Thread_consider_yield_34_comment =
  "C++ Interface:\n"
  "consider_yield()\n"
  "\n"
  "/**\n"
  " * Possibly suspends the current thread for the rest of the current epoch, if\n"
  " * it has run for enough this epoch.  This is especially important for the\n"
  " * simple thread implementation, which relies on cooperative yields like this.\n"
  " */";
#else
static const char *Dtool_Thread_consider_yield_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void Thread::output(ostream &out) const
 */
static PyObject *Dtool_Thread_output_35(PyObject *self, PyObject *arg) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void Thread::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Thread.output", false, true);
  if (arg_this != NULL) {
    (*(const Thread*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Thread self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Thread_output_35_comment =
  "C++ Interface:\n"
  "output(Thread self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Thread_output_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Thread::output_blocker(ostream &out) const
 */
static PyObject *Dtool_Thread_output_blocker_36(PyObject *self, PyObject *arg) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return NULL;
  }
  // 1-void Thread::output_blocker(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Thread.output_blocker", false, true);
  if (arg_this != NULL) {
    (*(const Thread*)local_this).output_blocker(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_blocker(Thread self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Thread_output_blocker_36_comment =
  "C++ Interface:\n"
  "output_blocker(Thread self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a description of the mutex or condition variable that this thread is\n"
  " * blocked on.  Writes nothing if there is no blocker, or if we are not in\n"
  " * DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_Thread_output_blocker_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void Thread::write_status(ostream &out)
 */
static PyObject *Dtool_Thread_write_status_37(PyObject *, PyObject *arg) {
  // 1-static void Thread::write_status(ostream &out)
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 0, "Thread.write_status", false, true);
  if (arg_this != NULL) {
    Thread::write_status(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_status(ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Thread_write_status_37_comment =
  "C++ Interface:\n"
  "write_status(ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Thread_write_status_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Thread::is_started(void) const
 */
static PyObject *Dtool_Thread_is_started_38(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Thread::is_started(void) const
  bool return_value = (*(const Thread*)local_this).is_started();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_is_started_38_comment =
  "C++ Interface:\n"
  "is_started(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns true if the thread has been started, false if it has not, or if\n"
  " * join() has already been called.\n"
  " */";
#else
static const char *Dtool_Thread_is_started_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Thread::is_joinable(void) const
 */
static PyObject *Dtool_Thread_is_joinable_39(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Thread::is_joinable(void) const
  bool return_value = (*(const Thread*)local_this).is_joinable();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_is_joinable_39_comment =
  "C++ Interface:\n"
  "is_joinable(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the value of joinable that was passed to the start() call.\n"
  " */";
#else
static const char *Dtool_Thread_is_joinable_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Thread::start(ThreadPriority priority, bool joinable)
 */
static PyObject *Dtool_Thread_start_40(PyObject *self, PyObject *args, PyObject *kwds) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.start")) {
    return NULL;
  }
  // 1-bool Thread::start(ThreadPriority priority, bool joinable)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"priority", "joinable", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:start", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*local_this).start((ThreadPriority)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "start(const Thread self, int priority, bool joinable)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Thread_start_40_comment =
  "C++ Interface:\n"
  "start(const Thread self, int priority, bool joinable)\n"
  "\n"
  "/**\n"
  " * Starts the thread executing.  It is only valid to call this once.\n"
  " *\n"
  " * The thread will begin executing its thread_main() function, and will\n"
  " * terminate when thread_main() returns.\n"
  " *\n"
  " * priority is intended as a hint to the relative importance of this thread.\n"
  " * This may be ignored by the thread implementation.\n"
  " *\n"
  " * joinable should be set true if you intend to call join() to wait for the\n"
  " * thread to terminate, or false if you don't care and you will never call\n"
  " * join(). Note that the reference count on the Thread object is incremented\n"
  " * while the thread itself is running, so if you just want to fire and forget\n"
  " * a thread, you may pass joinable = false, and never store the Thread object.\n"
  " * It will automatically destruct itself when it finishes.\n"
  " *\n"
  " * The return value is true if the thread is successfully started, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_Thread_start_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Thread::join(void)
 */
static PyObject *Dtool_Thread_join_41(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.join")) {
    return NULL;
  }
  // 1-inline void Thread::join(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).join();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Thread_join_41_comment =
  "C++ Interface:\n"
  "join(const Thread self)\n"
  "\n"
  "/**\n"
  " * Blocks the calling process until the thread terminates.  If the thread has\n"
  " * already terminated, this returns immediately.\n"
  " */";
#else
static const char *Dtool_Thread_join_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Thread::preempt(void)
 */
static PyObject *Dtool_Thread_preempt_42(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.preempt")) {
    return NULL;
  }
  // 1-inline void Thread::preempt(void)
  (*local_this).preempt();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Thread_preempt_42_comment =
  "C++ Interface:\n"
  "preempt(const Thread self)\n"
  "\n"
  "/**\n"
  " * Indicates that this thread should run as soon as possible, preemptying any\n"
  " * other threads that may be scheduled to run.  This may not be implemented on\n"
  " * every platform.\n"
  " */";
#else
static const char *Dtool_Thread_preempt_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Thread::set_python_data(PyObject *python_data)
 */
static PyObject *Dtool_Thread_set_python_data_43(PyObject *self, PyObject *arg) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.set_python_data")) {
    return NULL;
  }
  // 1-void Thread::set_python_data(PyObject *python_data)
  (*local_this).set_python_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_python_data(const Thread self, object python_data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Thread_set_python_data_43_comment =
  "C++ Interface:\n"
  "set_python_data(const Thread self, object python_data)\n"
  "\n"
  "/**\n"
  " * Sets an arbitrary Python object that may be associated with this thread\n"
  " * object.  This is just for the purposes of associated arbitrary Python data\n"
  " * with the C++ object; other than managing the reference count, the C++ code\n"
  " * does nothing with this object.\n"
  " */";
#else
static const char *Dtool_Thread_set_python_data_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *Thread::get_python_data(void) const
 */
static PyObject *Dtool_Thread_get_python_data_44(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *Thread::get_python_data(void) const
  PyObject *return_value = (*(const Thread*)local_this).get_python_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_python_data_44_comment =
  "C++ Interface:\n"
  "get_python_data(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the Python object that was set with set_python_data().\n"
  " */";
#else
static const char *Dtool_Thread_get_python_data_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AsyncTaskBase *Thread::get_current_task(void) const
 */
static PyObject *Dtool_Thread_get_current_task_45(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline AsyncTaskBase *Thread::get_current_task(void) const
  AsyncTaskBase *return_value = (*(const Thread*)local_this).get_current_task();
  if (return_value != (AsyncTaskBase *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (AsyncTaskBase *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskBase, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_current_task_45_comment =
  "C++ Interface:\n"
  "get_current_task(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the task currently executing on this thread (via the\n"
  " * AsyncTaskManager), if any, or NULL if the thread is not currently servicing\n"
  " * a task.\n"
  " */";
#else
static const char *Dtool_Thread_get_current_task_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void Thread::prepare_for_exit(void)
 */
static PyObject *Dtool_Thread_prepare_for_exit_46(PyObject *, PyObject *) {
  // 1-static inline void Thread::prepare_for_exit(void)
  Thread::prepare_for_exit();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Thread_prepare_for_exit_46_comment =
  "C++ Interface:\n"
  "prepare_for_exit()\n"
  "\n"
  "/**\n"
  " * Should be called by the main thread just before exiting the program, this\n"
  " * blocks until any remaining thread cleanup has finished.\n"
  " */";
#else
static const char *Dtool_Thread_prepare_for_exit_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Thread::get_class_type(void)
 */
static PyObject *Dtool_Thread_get_class_type_47(PyObject *, PyObject *) {
  // 1-static TypeHandle Thread::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Thread::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_class_type_47_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Thread_get_class_type_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *Thread::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_Thread_upcast_to_TypedReferenceCount_13(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.upcast_to_TypedReferenceCount")) {
    return NULL;
  }
  // 1-TypedReferenceCount *Thread::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Thread_upcast_to_TypedReferenceCount_13_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const Thread self)\n"
  "\n"
  "upcast from Thread to TypedReferenceCount";
#else
static const char *Dtool_Thread_upcast_to_TypedReferenceCount_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Namable *Thread::upcast_to_Namable(void)
 */
static PyObject *Dtool_Thread_upcast_to_Namable_15(PyObject *self, PyObject *) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.upcast_to_Namable")) {
    return NULL;
  }
  // 1-Namable *Thread::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Thread_upcast_to_Namable_15_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const Thread self)\n"
  "\n"
  "upcast from Thread to Namable";
#else
static const char *Dtool_Thread_upcast_to_Namable_15_comment = NULL;
#endif

static int Dtool_Init_Thread(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_Thread(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Thread) {
    printf("Thread ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Thread *local_this = (Thread *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Thread) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Thread(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Thread) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Thread*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Thread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Thread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (Thread*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MutexDirect
 */
/**
 * Python function wrapper for:
 * inline void MutexDirect::acquire(void) const
 */
static PyObject *Dtool_MutexDirect_acquire_49(PyObject *self, PyObject *) {
  MutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void MutexDirect::acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*(const MutexDirect*)local_this).acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_acquire_49_comment =
  "C++ Interface:\n"
  "acquire(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * Grabs the mutex if it is available.  If it is not available, blocks until\n"
  " * it becomes available, then grabs it.  In either case, the function does not\n"
  " * return until the mutex is held; you should then call unlock().\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * mutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " *\n"
  " * Also see MutexHolder.\n"
  " */";
#else
static const char *Dtool_MutexDirect_acquire_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MutexDirect::try_acquire(void) const
 */
static PyObject *Dtool_MutexDirect_try_acquire_50(PyObject *self, PyObject *) {
  MutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MutexDirect::try_acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*(const MutexDirect*)local_this).try_acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_try_acquire_50_comment =
  "C++ Interface:\n"
  "try_acquire(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * Returns immediately, with a true value indicating the mutex has been\n"
  " * acquired, and false indicating it has not.\n"
  " */";
#else
static const char *Dtool_MutexDirect_try_acquire_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MutexDirect::release(void) const
 */
static PyObject *Dtool_MutexDirect_release_51(PyObject *self, PyObject *) {
  MutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void MutexDirect::release(void) const
  (*(const MutexDirect*)local_this).release();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_release_51_comment =
  "C++ Interface:\n"
  "release(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * Releases the mutex.  It is an error to call this if the mutex was not\n"
  " * already locked.\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * mutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " */";
#else
static const char *Dtool_MutexDirect_release_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MutexDirect::debug_is_locked(void) const
 */
static PyObject *Dtool_MutexDirect_debug_is_locked_52(PyObject *self, PyObject *) {
  MutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MutexDirect::debug_is_locked(void) const
  bool return_value = (*(const MutexDirect*)local_this).debug_is_locked();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_debug_is_locked_52_comment =
  "C++ Interface:\n"
  "debug_is_locked(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * Returns true if the current thread has locked the Mutex, false otherwise.\n"
  " * This method is only intended for use in debugging, hence the method name;\n"
  " * in the MutexDirect case, it always returns true, since there's not a\n"
  " * reliable way to determine this otherwise.\n"
  " */";
#else
static const char *Dtool_MutexDirect_debug_is_locked_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MutexDirect::set_name(std::string const &name)
 */
static PyObject *Dtool_MutexDirect_set_name_53(PyObject *self, PyObject *arg) {
  MutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MutexDirect, (void **)&local_this, "MutexDirect.set_name")) {
    return NULL;
  }
  // 1-inline void MutexDirect::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const MutexDirect self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_set_name_53_comment =
  "C++ Interface:\n"
  "set_name(const MutexDirect self, str name)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_MutexDirect_set_name_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MutexDirect::clear_name(void)
 */
static PyObject *Dtool_MutexDirect_clear_name_54(PyObject *self, PyObject *) {
  MutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MutexDirect, (void **)&local_this, "MutexDirect.clear_name")) {
    return NULL;
  }
  // 1-inline void MutexDirect::clear_name(void)
  (*local_this).clear_name();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_clear_name_54_comment =
  "C++ Interface:\n"
  "clear_name(const MutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_MutexDirect_clear_name_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MutexDirect::has_name(void) const
 */
static PyObject *Dtool_MutexDirect_has_name_55(PyObject *self, PyObject *) {
  MutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool MutexDirect::has_name(void) const
  bool return_value = (*(const MutexDirect*)local_this).has_name();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_has_name_55_comment =
  "C++ Interface:\n"
  "has_name(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_MutexDirect_has_name_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string MutexDirect::get_name(void) const
 */
static PyObject *Dtool_MutexDirect_get_name_56(PyObject *self, PyObject *) {
  MutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string MutexDirect::get_name(void) const
  std::string return_value = (*(const MutexDirect*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_get_name_56_comment =
  "C++ Interface:\n"
  "get_name(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_MutexDirect_get_name_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MutexDirect::output(ostream &out) const
 */
static PyObject *Dtool_MutexDirect_output_57(PyObject *self, PyObject *arg) {
  MutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-void MutexDirect::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "MutexDirect.output", false, true);
  if (arg_this != NULL) {
    (*(const MutexDirect*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(MutexDirect self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_output_57_comment =
  "C++ Interface:\n"
  "output(MutexDirect self, ostream out)\n"
  "\n"
  "/**\n"
  " * This method is declared virtual in MutexDebug, but non-virtual in\n"
  " * MutexDirect.\n"
  " */";
#else
static const char *Dtool_MutexDirect_output_57_comment = NULL;
#endif

static int Dtool_Init_MutexDirect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MutexDirect) {
    printf("MutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MutexDirect *local_this = (MutexDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MutexDirect) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MutexDirect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MutexDirect) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Mutex
 */
/**
 * Python function wrapper for:
 * inline Mutex::Mutex(void)
 * inline Mutex::Mutex(std::string const &name)
 */
static int Dtool_Init_Mutex(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Mutex::Mutex(void)
      Mutex *return_value = new Mutex();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Mutex, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "name");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
        return -1;
      }
      // 1-inline Mutex::Mutex(std::string const &name)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        Mutex *return_value = new Mutex(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Mutex, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Mutex() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Mutex()\n"
      "Mutex(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Mutex(PyObject *args, Mutex const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Mutex, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Mutex::Mutex(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Mutex *return_value = new Mutex(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_Mutex(PyObject *args, Mutex *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Mutex, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Mutex::Mutex(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Mutex *return_value = new Mutex(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_Mutex(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Mutex) {
    printf("Mutex ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Mutex *local_this = (Mutex *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Mutex) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MutexDirect) {
    return (MutexDirect *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Mutex(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Mutex) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MutexDirect) {
    MutexDirect* other_this = (MutexDirect*)from_this;
    return (Mutex*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConditionVarDirect
 */
/**
 * Python function wrapper for:
 * inline MutexDirect &ConditionVarDirect::get_mutex(void) const
 */
static PyObject *Dtool_ConditionVarDirect_get_mutex_63(PyObject *self, PyObject *) {
  ConditionVarDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConditionVarDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline MutexDirect &ConditionVarDirect::get_mutex(void) const
  MutexDirect *return_value = &((*(const ConditionVarDirect*)local_this).get_mutex());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MutexDirect, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarDirect_get_mutex_63_comment =
  "C++ Interface:\n"
  "get_mutex(ConditionVarDirect self)\n"
  "\n"
  "/**\n"
  " * Returns the mutex associated with this condition variable.\n"
  " */";
#else
static const char *Dtool_ConditionVarDirect_get_mutex_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConditionVarDirect::wait(void)
 * inline void ConditionVarDirect::wait(double timeout)
 */
static PyObject *Dtool_ConditionVarDirect_wait_64(PyObject *self, PyObject *args) {
  ConditionVarDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConditionVarDirect, (void **)&local_this, "ConditionVarDirect.wait")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void ConditionVarDirect::wait(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).wait();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline void ConditionVarDirect::wait(double timeout)
      if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        (*local_this).wait(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "wait() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wait(const ConditionVarDirect self)\n"
      "wait(const ConditionVarDirect self, double timeout)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarDirect_wait_64_comment =
  "C++ Interface:\n"
  "wait(const ConditionVarDirect self)\n"
  "wait(const ConditionVarDirect self, double timeout)\n"
  "\n"
  "/**\n"
  " * Waits on the condition.  The caller must already be holding the lock\n"
  " * associated with the condition variable before calling this function.\n"
  " *\n"
  " * wait() will release the lock, then go to sleep until some other thread\n"
  " * calls notify() on this condition variable.  At that time at least one\n"
  " * thread waiting on the same ConditionVarDirect will grab the lock again, and\n"
  " * then return from wait().\n"
  " *\n"
  " * It is possible that wait() will return even if no one has called notify().\n"
  " * It is the responsibility of the calling process to verify the condition on\n"
  " * return from wait, and possibly loop back to wait again if necessary.\n"
  " *\n"
  " * Note the semantics of a condition variable: the mutex must be held before\n"
  " * wait() is called, and it will still be held when wait() returns.  However,\n"
  " * it will be temporarily released during the wait() call itself.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Waits on the condition, with a timeout.  The function will return when the\n"
  " * condition variable is notified, or the timeout occurs.  There is no way to\n"
  " * directly tell which happened, and it is possible that neither in fact\n"
  " * happened (spurious wakeups are possible).\n"
  " *\n"
  " * See wait() with no parameters for more.\n"
  " */";
#else
static const char *Dtool_ConditionVarDirect_wait_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConditionVarDirect::notify(void)
 */
static PyObject *Dtool_ConditionVarDirect_notify_65(PyObject *self, PyObject *) {
  ConditionVarDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConditionVarDirect, (void **)&local_this, "ConditionVarDirect.notify")) {
    return NULL;
  }
  // 1-inline void ConditionVarDirect::notify(void)
  (*local_this).notify();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarDirect_notify_65_comment =
  "C++ Interface:\n"
  "notify(const ConditionVarDirect self)\n"
  "\n"
  "/**\n"
  " * Informs one of the other threads who are currently blocked on wait() that\n"
  " * the relevant condition has changed.  If multiple threads are currently\n"
  " * waiting, at least one of them will be woken up, although there is no way to\n"
  " * predict which one.  It is possible that more than one thread will be woken\n"
  " * up.\n"
  " *\n"
  " * The caller must be holding the mutex associated with the condition variable\n"
  " * before making this call, which will not release the mutex.\n"
  " *\n"
  " * If no threads are waiting, this is a no-op: the notify event is lost.\n"
  " */";
#else
static const char *Dtool_ConditionVarDirect_notify_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConditionVarDirect::output(ostream &out) const
 */
static PyObject *Dtool_ConditionVarDirect_output_66(PyObject *self, PyObject *arg) {
  ConditionVarDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConditionVarDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConditionVarDirect::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConditionVarDirect.output", false, true);
  if (arg_this != NULL) {
    (*(const ConditionVarDirect*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConditionVarDirect self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarDirect_output_66_comment =
  "C++ Interface:\n"
  "output(ConditionVarDirect self, ostream out)\n"
  "\n"
  "/**\n"
  " * This method is declared virtual in ConditionVarDebug, but non-virtual in\n"
  " * ConditionVarDirect.\n"
  " */";
#else
static const char *Dtool_ConditionVarDirect_output_66_comment = NULL;
#endif

static int Dtool_Init_ConditionVarDirect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConditionVarDirect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConditionVarDirect) {
    printf("ConditionVarDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConditionVarDirect *local_this = (ConditionVarDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConditionVarDirect) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConditionVarDirect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConditionVarDirect) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConditionVar
 */
/**
 * Python function wrapper for:
 * inline Mutex &ConditionVar::get_mutex(void) const
 */
static PyObject *Dtool_ConditionVar_get_mutex_70(PyObject *self, PyObject *) {
  ConditionVar *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConditionVar, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Mutex &ConditionVar::get_mutex(void) const
  Mutex *return_value = &((*(const ConditionVar*)local_this).get_mutex());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Mutex, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConditionVar_get_mutex_70_comment =
  "C++ Interface:\n"
  "get_mutex(ConditionVar self)\n"
  "\n"
  "/**\n"
  " * Returns the mutex associated with this condition variable.\n"
  " */";
#else
static const char *Dtool_ConditionVar_get_mutex_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConditionVar::ConditionVar(Mutex &mutex)
 */
static int Dtool_Init_ConditionVar(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConditionVar() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "mutex");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'mutex' (pos 1) not found");
    return -1;
  }
  // 1-inline ConditionVar::ConditionVar(Mutex &mutex)
  Mutex *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Mutex(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ConditionVar.ConditionVar", "Mutex");
    return -1;
  }
  ConditionVar *return_value = new ConditionVar(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConditionVar, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConditionVar(Mutex mutex)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConditionVar(PyObject *args, ConditionVar const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConditionVar, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConditionVar::ConditionVar(Mutex &mutex)
    Mutex *arg_this = (Mutex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Mutex, 0, "ConditionVar.ConditionVar", false, false);
    if (arg_this != NULL) {
      ConditionVar *return_value = new ConditionVar(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ConditionVar(PyObject *args, ConditionVar *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConditionVar, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConditionVar::ConditionVar(Mutex &mutex)
    Mutex *arg_this = (Mutex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Mutex, 0, "ConditionVar.ConditionVar", false, false);
    if (arg_this != NULL) {
      ConditionVar *return_value = new ConditionVar(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ConditionVar(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConditionVar) {
    printf("ConditionVar ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConditionVar *local_this = (ConditionVar *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConditionVar) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConditionVarDirect) {
    return (ConditionVarDirect *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConditionVar(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConditionVar) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConditionVarDirect) {
    ConditionVarDirect* other_this = (ConditionVarDirect*)from_this;
    return (ConditionVar*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConditionVarFullDirect
 */
/**
 * Python function wrapper for:
 * inline MutexDirect &ConditionVarFullDirect::get_mutex(void) const
 */
static PyObject *Dtool_ConditionVarFullDirect_get_mutex_73(PyObject *self, PyObject *) {
  ConditionVarFullDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConditionVarFullDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline MutexDirect &ConditionVarFullDirect::get_mutex(void) const
  MutexDirect *return_value = &((*(const ConditionVarFullDirect*)local_this).get_mutex());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MutexDirect, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarFullDirect_get_mutex_73_comment =
  "C++ Interface:\n"
  "get_mutex(ConditionVarFullDirect self)\n"
  "\n"
  "/**\n"
  " * Returns the mutex associated with this condition variable.\n"
  " */";
#else
static const char *Dtool_ConditionVarFullDirect_get_mutex_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConditionVarFullDirect::wait(void)
 * inline void ConditionVarFullDirect::wait(double timeout)
 */
static PyObject *Dtool_ConditionVarFullDirect_wait_74(PyObject *self, PyObject *args) {
  ConditionVarFullDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConditionVarFullDirect, (void **)&local_this, "ConditionVarFullDirect.wait")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void ConditionVarFullDirect::wait(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*local_this).wait();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline void ConditionVarFullDirect::wait(double timeout)
      if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        (*local_this).wait(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "wait() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wait(const ConditionVarFullDirect self)\n"
      "wait(const ConditionVarFullDirect self, double timeout)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarFullDirect_wait_74_comment =
  "C++ Interface:\n"
  "wait(const ConditionVarFullDirect self)\n"
  "wait(const ConditionVarFullDirect self, double timeout)\n"
  "\n"
  "/**\n"
  " * Waits on the condition.  The caller must already be holding the lock\n"
  " * associated with the condition variable before calling this function.\n"
  " *\n"
  " * wait() will release the lock, then go to sleep until some other thread\n"
  " * calls notify() on this condition variable.  At that time at least one\n"
  " * thread waiting on the same ConditionVarFullDirect will grab the lock again,\n"
  " * and then return from wait().\n"
  " *\n"
  " * It is possible that wait() will return even if no one has called notify().\n"
  " * It is the responsibility of the calling process to verify the condition on\n"
  " * return from wait, and possibly loop back to wait again if necessary.\n"
  " *\n"
  " * Note the semantics of a condition variable: the mutex must be held before\n"
  " * wait() is called, and it will still be held when wait() returns.  However,\n"
  " * it will be temporarily released during the wait() call itself.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Waits on the condition, with a timeout.  The function will return when the\n"
  " * condition variable is notified, or the timeout occurs.  There is no way to\n"
  " * directly tell which happened, and it is possible that neither in fact\n"
  " * happened (spurious wakeups are possible).\n"
  " *\n"
  " * See wait() with no parameters for more.\n"
  " */";
#else
static const char *Dtool_ConditionVarFullDirect_wait_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConditionVarFullDirect::notify(void)
 */
static PyObject *Dtool_ConditionVarFullDirect_notify_75(PyObject *self, PyObject *) {
  ConditionVarFullDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConditionVarFullDirect, (void **)&local_this, "ConditionVarFullDirect.notify")) {
    return NULL;
  }
  // 1-inline void ConditionVarFullDirect::notify(void)
  (*local_this).notify();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarFullDirect_notify_75_comment =
  "C++ Interface:\n"
  "notify(const ConditionVarFullDirect self)\n"
  "\n"
  "/**\n"
  " * Informs one of the other threads who are currently blocked on wait() that\n"
  " * the relevant condition has changed.  If multiple threads are currently\n"
  " * waiting, at least one of them will be woken up, although there is no way to\n"
  " * predict which one.  It is possible that more than one thread will be woken\n"
  " * up.\n"
  " *\n"
  " * The caller must be holding the mutex associated with the condition variable\n"
  " * before making this call, which will not release the mutex.\n"
  " *\n"
  " * If no threads are waiting, this is a no-op: the notify is lost.\n"
  " */";
#else
static const char *Dtool_ConditionVarFullDirect_notify_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConditionVarFullDirect::notify_all(void)
 */
static PyObject *Dtool_ConditionVarFullDirect_notify_all_76(PyObject *self, PyObject *) {
  ConditionVarFullDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConditionVarFullDirect, (void **)&local_this, "ConditionVarFullDirect.notify_all")) {
    return NULL;
  }
  // 1-inline void ConditionVarFullDirect::notify_all(void)
  (*local_this).notify_all();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarFullDirect_notify_all_76_comment =
  "C++ Interface:\n"
  "notify_all(const ConditionVarFullDirect self)\n"
  "\n"
  "/**\n"
  " * Informs all of the other threads who are currently blocked on wait() that\n"
  " * the relevant condition has changed.\n"
  " *\n"
  " * The caller must be holding the mutex associated with the condition variable\n"
  " * before making this call, which will not release the mutex.\n"
  " *\n"
  " * If no threads are waiting, this is a no-op: the notify event is lost.\n"
  " */";
#else
static const char *Dtool_ConditionVarFullDirect_notify_all_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConditionVarFullDirect::output(ostream &out) const
 */
static PyObject *Dtool_ConditionVarFullDirect_output_77(PyObject *self, PyObject *arg) {
  ConditionVarFullDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConditionVarFullDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConditionVarFullDirect::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConditionVarFullDirect.output", false, true);
  if (arg_this != NULL) {
    (*(const ConditionVarFullDirect*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConditionVarFullDirect self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarFullDirect_output_77_comment =
  "C++ Interface:\n"
  "output(ConditionVarFullDirect self, ostream out)\n"
  "\n"
  "/**\n"
  " * This method is declared virtual in ConditionVarFullDebug, but non-virtual\n"
  " * in ConditionVarFullDirect.\n"
  " */";
#else
static const char *Dtool_ConditionVarFullDirect_output_77_comment = NULL;
#endif

static int Dtool_Init_ConditionVarFullDirect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConditionVarFullDirect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConditionVarFullDirect) {
    printf("ConditionVarFullDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConditionVarFullDirect *local_this = (ConditionVarFullDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConditionVarFullDirect) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConditionVarFullDirect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConditionVarFullDirect) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConditionVarFull
 */
/**
 * Python function wrapper for:
 * inline Mutex &ConditionVarFull::get_mutex(void) const
 */
static PyObject *Dtool_ConditionVarFull_get_mutex_81(PyObject *self, PyObject *) {
  ConditionVarFull *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConditionVarFull, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Mutex &ConditionVarFull::get_mutex(void) const
  Mutex *return_value = &((*(const ConditionVarFull*)local_this).get_mutex());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Mutex, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarFull_get_mutex_81_comment =
  "C++ Interface:\n"
  "get_mutex(ConditionVarFull self)\n"
  "\n"
  "/**\n"
  " * Returns the mutex associated with this condition variable.\n"
  " */";
#else
static const char *Dtool_ConditionVarFull_get_mutex_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConditionVarFull::ConditionVarFull(Mutex &mutex)
 */
static int Dtool_Init_ConditionVarFull(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConditionVarFull() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "mutex");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'mutex' (pos 1) not found");
    return -1;
  }
  // 1-inline ConditionVarFull::ConditionVarFull(Mutex &mutex)
  Mutex *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Mutex(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 0, "ConditionVarFull.ConditionVarFull", "Mutex");
    return -1;
  }
  ConditionVarFull *return_value = new ConditionVarFull(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConditionVarFull, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConditionVarFull(Mutex mutex)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConditionVarFull(PyObject *args, ConditionVarFull const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConditionVarFull, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConditionVarFull::ConditionVarFull(Mutex &mutex)
    Mutex *arg_this = (Mutex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Mutex, 0, "ConditionVarFull.ConditionVarFull", false, false);
    if (arg_this != NULL) {
      ConditionVarFull *return_value = new ConditionVarFull(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ConditionVarFull(PyObject *args, ConditionVarFull *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConditionVarFull, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConditionVarFull::ConditionVarFull(Mutex &mutex)
    Mutex *arg_this = (Mutex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Mutex, 0, "ConditionVarFull.ConditionVarFull", false, false);
    if (arg_this != NULL) {
      ConditionVarFull *return_value = new ConditionVarFull(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ConditionVarFull(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConditionVarFull) {
    printf("ConditionVarFull ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConditionVarFull *local_this = (ConditionVarFull *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConditionVarFull) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConditionVarFullDirect) {
    return (ConditionVarFullDirect *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConditionVarFull(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConditionVarFull) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConditionVarFullDirect) {
    ConditionVarFullDirect* other_this = (ConditionVarFullDirect*)from_this;
    return (ConditionVarFull*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ReMutexDirect
 */
/**
 * Python function wrapper for:
 * inline void ReMutexDirect::acquire(void) const
 * inline void ReMutexDirect::acquire(Thread *current_thread) const
 */
static PyObject *Dtool_ReMutexDirect_acquire_83(PyObject *self, PyObject *args) {
  ReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void ReMutexDirect::acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*(const ReMutexDirect*)local_this).acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline void ReMutexDirect::acquire(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ReMutexDirect.acquire", false, true);
      if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        (*(const ReMutexDirect*)local_this).acquire(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "acquire() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "acquire(ReMutexDirect self)\n"
      "acquire(ReMutexDirect self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_acquire_83_comment =
  "C++ Interface:\n"
  "acquire(ReMutexDirect self)\n"
  "acquire(ReMutexDirect self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Grabs the reMutex if it is available.  If it is not available, blocks until\n"
  " * it becomes available, then grabs it.  In either case, the function does not\n"
  " * return until the reMutex is held; you should then call unlock().\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * reMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " *\n"
  " * Also see ReMutexHolder.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant on acquire() accepts the current thread as a parameter, if it\n"
  " * is already known, as an optimization.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_acquire_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ReMutexDirect::try_acquire(void) const
 * inline bool ReMutexDirect::try_acquire(Thread *current_thread) const
 */
static PyObject *Dtool_ReMutexDirect_try_acquire_84(PyObject *self, PyObject *args) {
  ReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool ReMutexDirect::try_acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = (*(const ReMutexDirect*)local_this).try_acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline bool ReMutexDirect::try_acquire(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ReMutexDirect.try_acquire", false, true);
      if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*(const ReMutexDirect*)local_this).try_acquire(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "try_acquire() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "try_acquire(ReMutexDirect self)\n"
      "try_acquire(ReMutexDirect self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_try_acquire_84_comment =
  "C++ Interface:\n"
  "try_acquire(ReMutexDirect self)\n"
  "try_acquire(ReMutexDirect self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns immediately, with a true value indicating the mutex has been\n"
  " * acquired, and false indicating it has not.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns immediately, with a true value indicating the mutex has been\n"
  " * acquired, and false indicating it has not.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_try_acquire_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ReMutexDirect::elevate_lock(void) const
 */
static PyObject *Dtool_ReMutexDirect_elevate_lock_85(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void ReMutexDirect::elevate_lock(void) const
  (*(const ReMutexDirect*)local_this).elevate_lock();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_elevate_lock_85_comment =
  "C++ Interface:\n"
  "elevate_lock(ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * This method increments the lock count, assuming the calling thread already\n"
  " * holds the lock.  After this call, release() will need to be called one\n"
  " * additional time to release the lock.\n"
  " *\n"
  " * This method really performs the same function as acquire(), but it offers a\n"
  " * potential (slight) performance benefit when the calling thread knows that\n"
  " * it already holds the lock.  It is an error to call this when the calling\n"
  " * thread does not hold the lock.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_elevate_lock_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ReMutexDirect::release(void) const
 */
static PyObject *Dtool_ReMutexDirect_release_86(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void ReMutexDirect::release(void) const
  (*(const ReMutexDirect*)local_this).release();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_release_86_comment =
  "C++ Interface:\n"
  "release(ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Releases the reMutex.  It is an error to call this if the reMutex was not\n"
  " * already locked.\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * reMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_release_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ReMutexDirect::debug_is_locked(void) const
 */
static PyObject *Dtool_ReMutexDirect_debug_is_locked_87(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ReMutexDirect::debug_is_locked(void) const
  bool return_value = (*(const ReMutexDirect*)local_this).debug_is_locked();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_debug_is_locked_87_comment =
  "C++ Interface:\n"
  "debug_is_locked(ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Returns true if the current thread has locked the ReMutex, false otherwise.\n"
  " * This method is only intended for use in debugging, hence the method name;\n"
  " * in the ReMutexDirect case, it always returns true, since there's not a\n"
  " * reliable way to determine this otherwise.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_debug_is_locked_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ReMutexDirect::set_name(std::string const &name)
 */
static PyObject *Dtool_ReMutexDirect_set_name_88(PyObject *self, PyObject *arg) {
  ReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ReMutexDirect, (void **)&local_this, "ReMutexDirect.set_name")) {
    return NULL;
  }
  // 1-inline void ReMutexDirect::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const ReMutexDirect self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_set_name_88_comment =
  "C++ Interface:\n"
  "set_name(const ReMutexDirect self, str name)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_set_name_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ReMutexDirect::clear_name(void)
 */
static PyObject *Dtool_ReMutexDirect_clear_name_89(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ReMutexDirect, (void **)&local_this, "ReMutexDirect.clear_name")) {
    return NULL;
  }
  // 1-inline void ReMutexDirect::clear_name(void)
  (*local_this).clear_name();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_clear_name_89_comment =
  "C++ Interface:\n"
  "clear_name(const ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_clear_name_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ReMutexDirect::has_name(void) const
 */
static PyObject *Dtool_ReMutexDirect_has_name_90(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ReMutexDirect::has_name(void) const
  bool return_value = (*(const ReMutexDirect*)local_this).has_name();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_has_name_90_comment =
  "C++ Interface:\n"
  "has_name(ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_has_name_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ReMutexDirect::get_name(void) const
 */
static PyObject *Dtool_ReMutexDirect_get_name_91(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ReMutexDirect::get_name(void) const
  std::string return_value = (*(const ReMutexDirect*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_get_name_91_comment =
  "C++ Interface:\n"
  "get_name(ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_get_name_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ReMutexDirect::output(ostream &out) const
 */
static PyObject *Dtool_ReMutexDirect_output_92(PyObject *self, PyObject *arg) {
  ReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ReMutexDirect::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ReMutexDirect.output", false, true);
  if (arg_this != NULL) {
    (*(const ReMutexDirect*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ReMutexDirect self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_output_92_comment =
  "C++ Interface:\n"
  "output(ReMutexDirect self, ostream out)\n"
  "\n"
  "/**\n"
  " * This method is declared virtual in MutexDebug, but non-virtual in\n"
  " * ReMutexDirect.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_output_92_comment = NULL;
#endif

static int Dtool_Init_ReMutexDirect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ReMutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ReMutexDirect) {
    printf("ReMutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ReMutexDirect *local_this = (ReMutexDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ReMutexDirect) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ReMutexDirect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ReMutexDirect) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ReMutex
 */
/**
 * Python function wrapper for:
 * inline ReMutex::ReMutex(void)
 * inline ReMutex::ReMutex(std::string const &name)
 */
static int Dtool_Init_ReMutex(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ReMutex::ReMutex(void)
      ReMutex *return_value = new ReMutex();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ReMutex, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "name");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
        return -1;
      }
      // 1-inline ReMutex::ReMutex(std::string const &name)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        ReMutex *return_value = new ReMutex(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ReMutex, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ReMutex() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ReMutex()\n"
      "ReMutex(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ReMutex(PyObject *args, ReMutex const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ReMutex, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ReMutex::ReMutex(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ReMutex *return_value = new ReMutex(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_ReMutex(PyObject *args, ReMutex *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ReMutex, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ReMutex::ReMutex(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ReMutex *return_value = new ReMutex(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_ReMutex(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ReMutex) {
    printf("ReMutex ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ReMutex *local_this = (ReMutex *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ReMutex) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReMutexDirect) {
    return (ReMutexDirect *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ReMutex(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ReMutex) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReMutexDirect) {
    ReMutexDirect* other_this = (ReMutexDirect*)from_this;
    return (ReMutex*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ExternalThread
 */
/**
 * Python function wrapper for:
 * static TypeHandle ExternalThread::get_class_type(void)
 */
static PyObject *Dtool_ExternalThread_get_class_type_97(PyObject *, PyObject *) {
  // 1-static TypeHandle ExternalThread::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ExternalThread::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ExternalThread_get_class_type_97_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ExternalThread_get_class_type_97_comment = NULL;
#endif

static int Dtool_Init_ExternalThread(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ExternalThread(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ExternalThread) {
    printf("ExternalThread ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ExternalThread *local_this = (ExternalThread *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ExternalThread) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_Thread) {
    return (Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(Thread *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ExternalThread(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ExternalThread) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ExternalThread*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ExternalThread*)other_this;
  }
  if (from_type == Dtool_Ptr_Thread) {
    Thread* other_this = (Thread*)from_this;
    return (ExternalThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ExternalThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ExternalThread*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LightMutexDirect
 */
/**
 * Python function wrapper for:
 * inline void LightMutexDirect::acquire(void) const
 */
static PyObject *Dtool_LightMutexDirect_acquire_100(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LightMutexDirect::acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*(const LightMutexDirect*)local_this).acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_acquire_100_comment =
  "C++ Interface:\n"
  "acquire(LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Grabs the lightMutex if it is available.  If it is not available, blocks\n"
  " * until it becomes available, then grabs it.  In either case, the function\n"
  " * does not return until the lightMutex is held; you should then call\n"
  " * unlock().\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * lightMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " *\n"
  " * Also see LightMutexHolder.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_acquire_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LightMutexDirect::release(void) const
 */
static PyObject *Dtool_LightMutexDirect_release_101(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LightMutexDirect::release(void) const
  (*(const LightMutexDirect*)local_this).release();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_release_101_comment =
  "C++ Interface:\n"
  "release(LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Releases the lightMutex.  It is an error to call this if the lightMutex was\n"
  " * not already locked.\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * lightMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_release_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LightMutexDirect::debug_is_locked(void) const
 */
static PyObject *Dtool_LightMutexDirect_debug_is_locked_102(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LightMutexDirect::debug_is_locked(void) const
  bool return_value = (*(const LightMutexDirect*)local_this).debug_is_locked();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_debug_is_locked_102_comment =
  "C++ Interface:\n"
  "debug_is_locked(LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Returns true if the current thread has locked the LightMutex, false\n"
  " * otherwise.  This method is only intended for use in debugging, hence the\n"
  " * method name; in the LightMutexDirect case, it always returns true, since\n"
  " * there's not a reliable way to determine this otherwise.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_debug_is_locked_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LightMutexDirect::set_name(std::string const &name)
 */
static PyObject *Dtool_LightMutexDirect_set_name_103(PyObject *self, PyObject *arg) {
  LightMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightMutexDirect, (void **)&local_this, "LightMutexDirect.set_name")) {
    return NULL;
  }
  // 1-inline void LightMutexDirect::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const LightMutexDirect self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_set_name_103_comment =
  "C++ Interface:\n"
  "set_name(const LightMutexDirect self, str name)\n"
  "\n"
  "/**\n"
  " * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_set_name_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LightMutexDirect::clear_name(void)
 */
static PyObject *Dtool_LightMutexDirect_clear_name_104(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightMutexDirect, (void **)&local_this, "LightMutexDirect.clear_name")) {
    return NULL;
  }
  // 1-inline void LightMutexDirect::clear_name(void)
  (*local_this).clear_name();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_clear_name_104_comment =
  "C++ Interface:\n"
  "clear_name(const LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_clear_name_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LightMutexDirect::has_name(void) const
 */
static PyObject *Dtool_LightMutexDirect_has_name_105(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LightMutexDirect::has_name(void) const
  bool return_value = (*(const LightMutexDirect*)local_this).has_name();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_has_name_105_comment =
  "C++ Interface:\n"
  "has_name(LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_has_name_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string LightMutexDirect::get_name(void) const
 */
static PyObject *Dtool_LightMutexDirect_get_name_106(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string LightMutexDirect::get_name(void) const
  std::string return_value = (*(const LightMutexDirect*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_get_name_106_comment =
  "C++ Interface:\n"
  "get_name(LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_get_name_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LightMutexDirect::output(ostream &out) const
 */
static PyObject *Dtool_LightMutexDirect_output_107(PyObject *self, PyObject *arg) {
  LightMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LightMutexDirect::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LightMutexDirect.output", false, true);
  if (arg_this != NULL) {
    (*(const LightMutexDirect*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LightMutexDirect self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_output_107_comment =
  "C++ Interface:\n"
  "output(LightMutexDirect self, ostream out)\n"
  "\n"
  "/**\n"
  " * This method is declared virtual in LightMutexDebug, but non-virtual in\n"
  " * LightMutexDirect.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_output_107_comment = NULL;
#endif

static int Dtool_Init_LightMutexDirect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LightMutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LightMutexDirect) {
    printf("LightMutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LightMutexDirect *local_this = (LightMutexDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LightMutexDirect) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LightMutexDirect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LightMutexDirect) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LightMutex
 */
/**
 * Python function wrapper for:
 * inline LightMutex::LightMutex(void)
 * inline LightMutex::LightMutex(std::string const &name)
 */
static int Dtool_Init_LightMutex(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LightMutex::LightMutex(void)
      LightMutex *return_value = new LightMutex();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LightMutex, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "name");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
        return -1;
      }
      // 1-inline LightMutex::LightMutex(std::string const &name)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        LightMutex *return_value = new LightMutex(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LightMutex, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LightMutex() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LightMutex()\n"
      "LightMutex(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LightMutex(PyObject *args, LightMutex const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LightMutex, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LightMutex::LightMutex(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      LightMutex *return_value = new LightMutex(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_LightMutex(PyObject *args, LightMutex *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LightMutex, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LightMutex::LightMutex(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      LightMutex *return_value = new LightMutex(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_LightMutex(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LightMutex) {
    printf("LightMutex ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LightMutex *local_this = (LightMutex *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LightMutex) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LightMutexDirect) {
    return (LightMutexDirect *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LightMutex(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LightMutex) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LightMutexDirect) {
    LightMutexDirect* other_this = (LightMutexDirect*)from_this;
    return (LightMutex*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LightReMutexDirect
 */
/**
 * Python function wrapper for:
 * inline void LightReMutexDirect::acquire(void) const
 * inline void LightReMutexDirect::acquire(Thread *current_thread) const
 */
static PyObject *Dtool_LightReMutexDirect_acquire_112(PyObject *self, PyObject *args) {
  LightReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void LightReMutexDirect::acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*(const LightReMutexDirect*)local_this).acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline void LightReMutexDirect::acquire(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "LightReMutexDirect.acquire", false, true);
      if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        (*(const LightReMutexDirect*)local_this).acquire(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "acquire() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "acquire(LightReMutexDirect self)\n"
      "acquire(LightReMutexDirect self, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_acquire_112_comment =
  "C++ Interface:\n"
  "acquire(LightReMutexDirect self)\n"
  "acquire(LightReMutexDirect self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Grabs the lightReMutex if it is available.  If it is not available, blocks\n"
  " * until it becomes available, then grabs it.  In either case, the function\n"
  " * does not return until the lightReMutex is held; you should then call\n"
  " * unlock().\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * lightReMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " *\n"
  " * Also see LightReMutexHolder.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant on acquire() accepts the current thread as a parameter, if it\n"
  " * is already known, as an optimization.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_acquire_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LightReMutexDirect::elevate_lock(void) const
 */
static PyObject *Dtool_LightReMutexDirect_elevate_lock_113(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LightReMutexDirect::elevate_lock(void) const
  (*(const LightReMutexDirect*)local_this).elevate_lock();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_elevate_lock_113_comment =
  "C++ Interface:\n"
  "elevate_lock(LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * This method increments the lock count, assuming the calling thread already\n"
  " * holds the lock.  After this call, release() will need to be called one\n"
  " * additional time to release the lock.\n"
  " *\n"
  " * This method really performs the same function as acquire(), but it offers a\n"
  " * potential (slight) performance benefit when the calling thread knows that\n"
  " * it already holds the lock.  It is an error to call this when the calling\n"
  " * thread does not hold the lock.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_elevate_lock_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LightReMutexDirect::release(void) const
 */
static PyObject *Dtool_LightReMutexDirect_release_114(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LightReMutexDirect::release(void) const
  (*(const LightReMutexDirect*)local_this).release();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_release_114_comment =
  "C++ Interface:\n"
  "release(LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Releases the lightReMutex.  It is an error to call this if the lightReMutex\n"
  " * was not already locked.\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * lightReMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_release_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LightReMutexDirect::debug_is_locked(void) const
 */
static PyObject *Dtool_LightReMutexDirect_debug_is_locked_115(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LightReMutexDirect::debug_is_locked(void) const
  bool return_value = (*(const LightReMutexDirect*)local_this).debug_is_locked();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_debug_is_locked_115_comment =
  "C++ Interface:\n"
  "debug_is_locked(LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Returns true if the current thread has locked the LightReMutex, false\n"
  " * otherwise.  This method is only intended for use in debugging, hence the\n"
  " * method name; in the LightReMutexDirect case, it always returns true, since\n"
  " * there's not a reliable way to determine this otherwise.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_debug_is_locked_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LightReMutexDirect::set_name(std::string const &name)
 */
static PyObject *Dtool_LightReMutexDirect_set_name_116(PyObject *self, PyObject *arg) {
  LightReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightReMutexDirect, (void **)&local_this, "LightReMutexDirect.set_name")) {
    return NULL;
  }
  // 1-inline void LightReMutexDirect::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const LightReMutexDirect self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_set_name_116_comment =
  "C++ Interface:\n"
  "set_name(const LightReMutexDirect self, str name)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_set_name_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LightReMutexDirect::clear_name(void)
 */
static PyObject *Dtool_LightReMutexDirect_clear_name_117(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightReMutexDirect, (void **)&local_this, "LightReMutexDirect.clear_name")) {
    return NULL;
  }
  // 1-inline void LightReMutexDirect::clear_name(void)
  (*local_this).clear_name();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_clear_name_117_comment =
  "C++ Interface:\n"
  "clear_name(const LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_clear_name_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LightReMutexDirect::has_name(void) const
 */
static PyObject *Dtool_LightReMutexDirect_has_name_118(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LightReMutexDirect::has_name(void) const
  bool return_value = (*(const LightReMutexDirect*)local_this).has_name();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_has_name_118_comment =
  "C++ Interface:\n"
  "has_name(LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_has_name_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string LightReMutexDirect::get_name(void) const
 */
static PyObject *Dtool_LightReMutexDirect_get_name_119(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string LightReMutexDirect::get_name(void) const
  std::string return_value = (*(const LightReMutexDirect*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_get_name_119_comment =
  "C++ Interface:\n"
  "get_name(LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_get_name_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LightReMutexDirect::output(ostream &out) const
 */
static PyObject *Dtool_LightReMutexDirect_output_120(PyObject *self, PyObject *arg) {
  LightReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightReMutexDirect, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LightReMutexDirect::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LightReMutexDirect.output", false, true);
  if (arg_this != NULL) {
    (*(const LightReMutexDirect*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LightReMutexDirect self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_output_120_comment =
  "C++ Interface:\n"
  "output(LightReMutexDirect self, ostream out)\n"
  "\n"
  "/**\n"
  " * This method is declared virtual in MutexDebug, but non-virtual in\n"
  " * LightReMutexDirect.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_output_120_comment = NULL;
#endif

static int Dtool_Init_LightReMutexDirect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LightReMutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LightReMutexDirect) {
    printf("LightReMutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LightReMutexDirect *local_this = (LightReMutexDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LightReMutexDirect) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LightReMutexDirect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LightReMutexDirect) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LightReMutex
 */
/**
 * Python function wrapper for:
 * inline LightReMutex::LightReMutex(void)
 * inline LightReMutex::LightReMutex(std::string const &name)
 */
static int Dtool_Init_LightReMutex(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LightReMutex::LightReMutex(void)
      LightReMutex *return_value = new LightReMutex();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LightReMutex, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "name");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
        return -1;
      }
      // 1-inline LightReMutex::LightReMutex(std::string const &name)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        LightReMutex *return_value = new LightReMutex(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LightReMutex, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LightReMutex() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LightReMutex()\n"
      "LightReMutex(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LightReMutex(PyObject *args, LightReMutex const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LightReMutex, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LightReMutex::LightReMutex(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      LightReMutex *return_value = new LightReMutex(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_LightReMutex(PyObject *args, LightReMutex *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LightReMutex, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LightReMutex::LightReMutex(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      LightReMutex *return_value = new LightReMutex(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_LightReMutex(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LightReMutex) {
    printf("LightReMutex ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LightReMutex *local_this = (LightReMutex *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LightReMutex) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LightReMutexDirect) {
    return (LightReMutexDirect *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LightReMutex(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LightReMutex) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LightReMutexDirect) {
    LightReMutexDirect* other_this = (LightReMutexDirect*)from_this;
    return (LightReMutex*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MainThread
 */
/**
 * Python function wrapper for:
 * static TypeHandle MainThread::get_class_type(void)
 */
static PyObject *Dtool_MainThread_get_class_type_125(PyObject *, PyObject *) {
  // 1-static TypeHandle MainThread::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MainThread::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MainThread_get_class_type_125_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MainThread_get_class_type_125_comment = NULL;
#endif

static int Dtool_Init_MainThread(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MainThread(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MainThread) {
    printf("MainThread ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MainThread *local_this = (MainThread *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MainThread) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_Thread) {
    return (Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(Thread *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MainThread(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MainThread) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MainThread*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MainThread*)other_this;
  }
  if (from_type == Dtool_Ptr_Thread) {
    Thread* other_this = (Thread*)from_this;
    return (MainThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MainThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (MainThread*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PythonThread
 */
/**
 * Python function wrapper for:
 * PyObject *PythonThread::join(void)
 */
static PyObject *Dtool_PythonThread_join_129(PyObject *self, PyObject *) {
  PythonThread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonThread, (void **)&local_this, "PythonThread.join")) {
    return NULL;
  }
  // 1-PyObject *PythonThread::join(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PyObject *return_value = (*local_this).join();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonThread_join_129_comment =
  "C++ Interface:\n"
  "join(const PythonThread self)\n"
  "\n"
  "/**\n"
  " * Blocks the calling process until the thread terminates.  If the thread has\n"
  " * already terminated, this returns immediately.\n"
  " *\n"
  " * The PythonThread flavor of this function returns the same value returned by\n"
  " * the thread function.\n"
  " */";
#else
static const char *Dtool_PythonThread_join_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PythonThread::get_class_type(void)
 */
static PyObject *Dtool_PythonThread_get_class_type_130(PyObject *, PyObject *) {
  // 1-static TypeHandle PythonThread::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PythonThread::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PythonThread_get_class_type_130_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PythonThread_get_class_type_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PythonThread::PythonThread(PyObject *function, PyObject *args, std::string const &name, std::string const &sync_name)
 */
static int Dtool_Init_PythonThread(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-PythonThread::PythonThread(PyObject *function, PyObject *args, std::string const &name, std::string const &sync_name)
  PyObject *param0;
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"function", "args", "name", "sync_name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#s#:PythonThread", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len)) {
    PythonThread *return_value = new PythonThread(param0, param1, std::string(param2_str, param2_len), std::string(param3_str, param3_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonThread, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PythonThread(object function, object args, str name, str sync_name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PythonThread(PyObject *args, CPT(PythonThread) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PythonThread, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 4) {
      // 1-PythonThread::PythonThread(PyObject *function, PyObject *args, std::string const &name, std::string const &sync_name)
      PyObject *param0;
      PyObject *param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      char *param3_str = NULL;
      Py_ssize_t param3_len;
      if (PyArg_ParseTuple(args, "OOs#s#:PythonThread", &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len)) {
        PythonThread *return_value = new PythonThread(param0, param1, std::string(param2_str, param2_len), std::string(param3_str, param3_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != (PyObject *)NULL) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PythonThread(PyObject *args, PT(PythonThread) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PythonThread, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 4) {
      // 1-PythonThread::PythonThread(PyObject *function, PyObject *args, std::string const &name, std::string const &sync_name)
      PyObject *param0;
      PyObject *param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      char *param3_str = NULL;
      Py_ssize_t param3_len;
      if (PyArg_ParseTuple(args, "OOs#s#:PythonThread", &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len)) {
        PythonThread *return_value = new PythonThread(param0, param1, std::string(param2_str, param2_len), std::string(param3_str, param3_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != (PyObject *)NULL) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PythonThread(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PythonThread) {
    printf("PythonThread ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PythonThread *local_this = (PythonThread *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PythonThread) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_Thread) {
    return (Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(Thread *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PythonThread(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PythonThread) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PythonThread*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PythonThread*)other_this;
  }
  if (from_type == Dtool_Ptr_Thread) {
    Thread* other_this = (Thread*)from_this;
    return (PythonThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PythonThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PythonThread*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Semaphore
 */
/**
 * Python function wrapper for:
 * inline void Semaphore::acquire(void)
 */
static PyObject *Dtool_Semaphore_acquire_134(PyObject *self, PyObject *) {
  Semaphore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Semaphore, (void **)&local_this, "Semaphore.acquire")) {
    return NULL;
  }
  // 1-inline void Semaphore::acquire(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Semaphore_acquire_134_comment =
  "C++ Interface:\n"
  "acquire(const Semaphore self)\n"
  "\n"
  "/**\n"
  " * Decrements the internal count.  If the count was already at zero, blocks\n"
  " * until the count is nonzero, then decrements it.\n"
  " */";
#else
static const char *Dtool_Semaphore_acquire_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Semaphore::try_acquire(void)
 */
static PyObject *Dtool_Semaphore_try_acquire_135(PyObject *self, PyObject *) {
  Semaphore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Semaphore, (void **)&local_this, "Semaphore.try_acquire")) {
    return NULL;
  }
  // 1-inline bool Semaphore::try_acquire(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).try_acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Semaphore_try_acquire_135_comment =
  "C++ Interface:\n"
  "try_acquire(const Semaphore self)\n"
  "\n"
  "/**\n"
  " * If the semaphore can be acquired without blocking, does so and returns\n"
  " * true.  Otherwise, returns false.\n"
  " */";
#else
static const char *Dtool_Semaphore_try_acquire_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Semaphore::release(void)
 */
static PyObject *Dtool_Semaphore_release_136(PyObject *self, PyObject *) {
  Semaphore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Semaphore, (void **)&local_this, "Semaphore.release")) {
    return NULL;
  }
  // 1-inline int Semaphore::release(void)
  int return_value = (*local_this).release();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Semaphore_release_136_comment =
  "C++ Interface:\n"
  "release(const Semaphore self)\n"
  "\n"
  "/**\n"
  " * Increments the semaphore's internal count.  This may wake up another thread\n"
  " * blocked on acquire().\n"
  " *\n"
  " * Returns the count of the semaphore upon release.\n"
  " */";
#else
static const char *Dtool_Semaphore_release_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Semaphore::get_count(void) const
 */
static PyObject *Dtool_Semaphore_get_count_137(PyObject *self, PyObject *) {
  Semaphore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Semaphore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int Semaphore::get_count(void) const
  int return_value = (*(const Semaphore*)local_this).get_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Semaphore_get_count_137_comment =
  "C++ Interface:\n"
  "get_count(Semaphore self)\n"
  "\n"
  "/**\n"
  " * Returns the current semaphore count.  Note that this call is not thread-\n"
  " * safe (the count may change at any time).\n"
  " */";
#else
static const char *Dtool_Semaphore_get_count_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Semaphore::output(ostream &out) const
 */
static PyObject *Dtool_Semaphore_output_138(PyObject *self, PyObject *arg) {
  Semaphore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Semaphore, (void **)&local_this)) {
    return NULL;
  }
  // 1-void Semaphore::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Semaphore.output", false, true);
  if (arg_this != NULL) {
    (*(const Semaphore*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Semaphore self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Semaphore_output_138_comment =
  "C++ Interface:\n"
  "output(Semaphore self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Semaphore_output_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Semaphore::Semaphore(int initial_count = 1)
 */
static int Dtool_Init_Semaphore(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline Semaphore::Semaphore(int initial_count = 1)
  int param0 = 1;
  static const char *keyword_list[] = {"initial_count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:Semaphore", (char **)keyword_list, &param0)) {
    Semaphore *return_value = new Semaphore((int)param0);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Semaphore, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Semaphore(int initial_count)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Semaphore(PyObject *args, Semaphore const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Semaphore, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Semaphore::Semaphore(int initial_count)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      Semaphore *return_value = new Semaphore((int)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_Semaphore(PyObject *args, Semaphore *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Semaphore, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Semaphore::Semaphore(int initial_count)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      Semaphore *return_value = new Semaphore((int)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_Semaphore(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Semaphore) {
    printf("Semaphore ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Semaphore *local_this = (Semaphore *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Semaphore) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Semaphore(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Semaphore) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for AsyncTaskBase (AsyncTaskBase)
 */
static PyMethodDef Dtool_Methods_AsyncTaskBase[] = {
  {"get_class_type", &Dtool_AsyncTaskBase_get_class_type_9, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskBase_get_class_type_9_comment},
  {"getClassType", &Dtool_AsyncTaskBase_get_class_type_9, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskBase_get_class_type_9_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3, METH_NOARGS, (const char *)Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3_comment},
  {"upcastToTypedReferenceCount", &Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3, METH_NOARGS, (const char *)Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3_comment},
  {"upcast_to_Namable", &Dtool_AsyncTaskBase_upcast_to_Namable_6, METH_NOARGS, (const char *)Dtool_AsyncTaskBase_upcast_to_Namable_6_comment},
  {"upcastToNamable", &Dtool_AsyncTaskBase_upcast_to_Namable_6, METH_NOARGS, (const char *)Dtool_AsyncTaskBase_upcast_to_Namable_6_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AsyncTaskBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTaskBase = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AsyncTaskBase = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AsyncTaskBase = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AsyncTaskBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AsyncTaskBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTaskBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AsyncTaskBase,
    &Dtool_SequenceMethods_AsyncTaskBase,
    &Dtool_MappingMethods_AsyncTaskBase,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AsyncTaskBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract base class for AsyncTask.  This is defined here only so we can\n"
    " * store a pointer to the current task on the Thread.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AsyncTaskBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AsyncTaskBase,
    PyType_GenericAlloc,
    Dtool_new_AsyncTaskBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTaskBase,
  Dtool_UpcastInterface_AsyncTaskBase,
  Dtool_DowncastInterface_AsyncTaskBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AsyncTaskBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_AsyncTaskBase._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_AsyncTaskBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTaskBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTaskBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTaskBase);
  }
}

/**
 * Python method tables for Thread (Thread)
 */
static PyMethodDef Dtool_Methods_Thread[] = {
  {"bind_thread", (PyCFunction) &Dtool_Thread_bind_thread_18, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Thread_bind_thread_18_comment},
  {"bindThread", (PyCFunction) &Dtool_Thread_bind_thread_18, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Thread_bind_thread_18_comment},
  {"get_sync_name", &Dtool_Thread_get_sync_name_19, METH_NOARGS, (const char *)Dtool_Thread_get_sync_name_19_comment},
  {"getSyncName", &Dtool_Thread_get_sync_name_19, METH_NOARGS, (const char *)Dtool_Thread_get_sync_name_19_comment},
  {"get_pstats_index", &Dtool_Thread_get_pstats_index_20, METH_NOARGS, (const char *)Dtool_Thread_get_pstats_index_20_comment},
  {"getPstatsIndex", &Dtool_Thread_get_pstats_index_20, METH_NOARGS, (const char *)Dtool_Thread_get_pstats_index_20_comment},
  {"get_unique_id", &Dtool_Thread_get_unique_id_21, METH_NOARGS, (const char *)Dtool_Thread_get_unique_id_21_comment},
  {"getUniqueId", &Dtool_Thread_get_unique_id_21, METH_NOARGS, (const char *)Dtool_Thread_get_unique_id_21_comment},
  {"get_pipeline_stage", &Dtool_Thread_get_pipeline_stage_22, METH_NOARGS, (const char *)Dtool_Thread_get_pipeline_stage_22_comment},
  {"getPipelineStage", &Dtool_Thread_get_pipeline_stage_22, METH_NOARGS, (const char *)Dtool_Thread_get_pipeline_stage_22_comment},
  {"set_pipeline_stage", &Dtool_Thread_set_pipeline_stage_23, METH_O, (const char *)Dtool_Thread_set_pipeline_stage_23_comment},
  {"setPipelineStage", &Dtool_Thread_set_pipeline_stage_23, METH_O, (const char *)Dtool_Thread_set_pipeline_stage_23_comment},
  {"set_min_pipeline_stage", &Dtool_Thread_set_min_pipeline_stage_24, METH_O, (const char *)Dtool_Thread_set_min_pipeline_stage_24_comment},
  {"setMinPipelineStage", &Dtool_Thread_set_min_pipeline_stage_24, METH_O, (const char *)Dtool_Thread_set_min_pipeline_stage_24_comment},
  {"get_main_thread", &Dtool_Thread_get_main_thread_25, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_main_thread_25_comment},
  {"getMainThread", &Dtool_Thread_get_main_thread_25, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_main_thread_25_comment},
  {"get_external_thread", &Dtool_Thread_get_external_thread_26, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_external_thread_26_comment},
  {"getExternalThread", &Dtool_Thread_get_external_thread_26, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_external_thread_26_comment},
  {"get_current_thread", &Dtool_Thread_get_current_thread_27, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_current_thread_27_comment},
  {"getCurrentThread", &Dtool_Thread_get_current_thread_27, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_current_thread_27_comment},
  {"get_current_pipeline_stage", &Dtool_Thread_get_current_pipeline_stage_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_current_pipeline_stage_28_comment},
  {"getCurrentPipelineStage", &Dtool_Thread_get_current_pipeline_stage_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_current_pipeline_stage_28_comment},
  {"is_threading_supported", &Dtool_Thread_is_threading_supported_29, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_threading_supported_29_comment},
  {"isThreadingSupported", &Dtool_Thread_is_threading_supported_29, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_threading_supported_29_comment},
  {"is_true_threads", &Dtool_Thread_is_true_threads_30, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_true_threads_30_comment},
  {"isTrueThreads", &Dtool_Thread_is_true_threads_30, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_true_threads_30_comment},
  {"is_simple_threads", &Dtool_Thread_is_simple_threads_31, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_simple_threads_31_comment},
  {"isSimpleThreads", &Dtool_Thread_is_simple_threads_31, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_simple_threads_31_comment},
  {"sleep", &Dtool_Thread_sleep_32, METH_O | METH_STATIC, (const char *)Dtool_Thread_sleep_32_comment},
  {"force_yield", &Dtool_Thread_force_yield_33, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_force_yield_33_comment},
  {"forceYield", &Dtool_Thread_force_yield_33, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_force_yield_33_comment},
  {"consider_yield", &Dtool_Thread_consider_yield_34, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_consider_yield_34_comment},
  {"considerYield", &Dtool_Thread_consider_yield_34, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_consider_yield_34_comment},
  {"output", &Dtool_Thread_output_35, METH_O, (const char *)Dtool_Thread_output_35_comment},
  {"output_blocker", &Dtool_Thread_output_blocker_36, METH_O, (const char *)Dtool_Thread_output_blocker_36_comment},
  {"outputBlocker", &Dtool_Thread_output_blocker_36, METH_O, (const char *)Dtool_Thread_output_blocker_36_comment},
  {"write_status", &Dtool_Thread_write_status_37, METH_O | METH_STATIC, (const char *)Dtool_Thread_write_status_37_comment},
  {"writeStatus", &Dtool_Thread_write_status_37, METH_O | METH_STATIC, (const char *)Dtool_Thread_write_status_37_comment},
  {"is_started", &Dtool_Thread_is_started_38, METH_NOARGS, (const char *)Dtool_Thread_is_started_38_comment},
  {"isStarted", &Dtool_Thread_is_started_38, METH_NOARGS, (const char *)Dtool_Thread_is_started_38_comment},
  {"is_joinable", &Dtool_Thread_is_joinable_39, METH_NOARGS, (const char *)Dtool_Thread_is_joinable_39_comment},
  {"isJoinable", &Dtool_Thread_is_joinable_39, METH_NOARGS, (const char *)Dtool_Thread_is_joinable_39_comment},
  {"start", (PyCFunction) &Dtool_Thread_start_40, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Thread_start_40_comment},
  {"join", &Dtool_Thread_join_41, METH_NOARGS, (const char *)Dtool_Thread_join_41_comment},
  {"preempt", &Dtool_Thread_preempt_42, METH_NOARGS, (const char *)Dtool_Thread_preempt_42_comment},
  {"set_python_data", &Dtool_Thread_set_python_data_43, METH_O, (const char *)Dtool_Thread_set_python_data_43_comment},
  {"setPythonData", &Dtool_Thread_set_python_data_43, METH_O, (const char *)Dtool_Thread_set_python_data_43_comment},
  {"get_python_data", &Dtool_Thread_get_python_data_44, METH_NOARGS, (const char *)Dtool_Thread_get_python_data_44_comment},
  {"getPythonData", &Dtool_Thread_get_python_data_44, METH_NOARGS, (const char *)Dtool_Thread_get_python_data_44_comment},
  {"get_current_task", &Dtool_Thread_get_current_task_45, METH_NOARGS, (const char *)Dtool_Thread_get_current_task_45_comment},
  {"getCurrentTask", &Dtool_Thread_get_current_task_45, METH_NOARGS, (const char *)Dtool_Thread_get_current_task_45_comment},
  {"prepare_for_exit", &Dtool_Thread_prepare_for_exit_46, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_prepare_for_exit_46_comment},
  {"prepareForExit", &Dtool_Thread_prepare_for_exit_46, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_prepare_for_exit_46_comment},
  {"get_class_type", &Dtool_Thread_get_class_type_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_class_type_47_comment},
  {"getClassType", &Dtool_Thread_get_class_type_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_class_type_47_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_Thread_upcast_to_TypedReferenceCount_13, METH_NOARGS, (const char *)Dtool_Thread_upcast_to_TypedReferenceCount_13_comment},
  {"upcastToTypedReferenceCount", &Dtool_Thread_upcast_to_TypedReferenceCount_13, METH_NOARGS, (const char *)Dtool_Thread_upcast_to_TypedReferenceCount_13_comment},
  {"upcast_to_Namable", &Dtool_Thread_upcast_to_Namable_15, METH_NOARGS, (const char *)Dtool_Thread_upcast_to_Namable_15_comment},
  {"upcastToNamable", &Dtool_Thread_upcast_to_Namable_15, METH_NOARGS, (const char *)Dtool_Thread_upcast_to_Namable_15_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     Thread
//////////////////
static PyObject *Dtool_Repr_Thread(PyObject *self) {
  Thread *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_Thread = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Thread = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Thread = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Thread = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Thread = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Thread",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Thread,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_Thread,
    &Dtool_NumberMethods_Thread,
    &Dtool_SequenceMethods_Thread,
    &Dtool_MappingMethods_Thread,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_Thread,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Thread,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A thread; that is, a lightweight process.  This is an abstract base class;\n"
    " * to use it, you must subclass from it and redefine thread_main().\n"
    " *\n"
    " * The thread itself will keep a reference count on the Thread object while it\n"
    " * is running; when the thread returns from its root function, the Thread\n"
    " * object will automatically be destructed if no other pointers are\n"
    " * referencing it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Thread,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Thread,
    PyType_GenericAlloc,
    Dtool_new_Thread,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Thread,
  Dtool_UpcastInterface_Thread,
  Dtool_DowncastInterface_Thread,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Thread(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_Thread._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_Thread._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Thread) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Thread)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Thread);
  }
}

/**
 * Python method tables for MutexDirect (MutexDirect)
 */
static PyMethodDef Dtool_Methods_MutexDirect[] = {
  {"acquire", &Dtool_MutexDirect_acquire_49, METH_NOARGS, (const char *)Dtool_MutexDirect_acquire_49_comment},
  {"try_acquire", &Dtool_MutexDirect_try_acquire_50, METH_NOARGS, (const char *)Dtool_MutexDirect_try_acquire_50_comment},
  {"tryAcquire", &Dtool_MutexDirect_try_acquire_50, METH_NOARGS, (const char *)Dtool_MutexDirect_try_acquire_50_comment},
  {"release", &Dtool_MutexDirect_release_51, METH_NOARGS, (const char *)Dtool_MutexDirect_release_51_comment},
  {"debug_is_locked", &Dtool_MutexDirect_debug_is_locked_52, METH_NOARGS, (const char *)Dtool_MutexDirect_debug_is_locked_52_comment},
  {"debugIsLocked", &Dtool_MutexDirect_debug_is_locked_52, METH_NOARGS, (const char *)Dtool_MutexDirect_debug_is_locked_52_comment},
  {"set_name", &Dtool_MutexDirect_set_name_53, METH_O, (const char *)Dtool_MutexDirect_set_name_53_comment},
  {"setName", &Dtool_MutexDirect_set_name_53, METH_O, (const char *)Dtool_MutexDirect_set_name_53_comment},
  {"clear_name", &Dtool_MutexDirect_clear_name_54, METH_NOARGS, (const char *)Dtool_MutexDirect_clear_name_54_comment},
  {"clearName", &Dtool_MutexDirect_clear_name_54, METH_NOARGS, (const char *)Dtool_MutexDirect_clear_name_54_comment},
  {"has_name", &Dtool_MutexDirect_has_name_55, METH_NOARGS, (const char *)Dtool_MutexDirect_has_name_55_comment},
  {"hasName", &Dtool_MutexDirect_has_name_55, METH_NOARGS, (const char *)Dtool_MutexDirect_has_name_55_comment},
  {"get_name", &Dtool_MutexDirect_get_name_56, METH_NOARGS, (const char *)Dtool_MutexDirect_get_name_56_comment},
  {"getName", &Dtool_MutexDirect_get_name_56, METH_NOARGS, (const char *)Dtool_MutexDirect_get_name_56_comment},
  {"output", &Dtool_MutexDirect_output_57, METH_O, (const char *)Dtool_MutexDirect_output_57_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     MutexDirect
//////////////////
static PyObject *Dtool_Repr_MutexDirect(PyObject *self) {
  MutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MutexDirect, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_MutexDirect = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_MutexDirect = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MutexDirect",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MutexDirect,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_MutexDirect,
    &Dtool_NumberMethods_MutexDirect,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_MutexDirect,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements a standard mutex by making direct calls to the\n"
    " * underlying implementation layer.  It doesn't perform any debugging\n"
    " * operations.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MutexDirect,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MutexDirect,
    PyType_GenericAlloc,
    Dtool_new_MutexDirect,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MutexDirect,
  Dtool_UpcastInterface_MutexDirect,
  Dtool_DowncastInterface_MutexDirect,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MutexDirect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MutexDirect._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_MutexDirect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MutexDirect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MutexDirect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MutexDirect);
  }
}

/**
 * Python method tables for Mutex (Mutex)
 */
static PyMethodDef Dtool_Methods_Mutex[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Mutex = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Mutex = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Mutex = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Mutex = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Mutex = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Mutex",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Mutex,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Mutex,
    &Dtool_SequenceMethods_Mutex,
    &Dtool_MappingMethods_Mutex,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Mutex,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Mutex,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Mutex,
    PyType_GenericAlloc,
    Dtool_new_Mutex,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Mutex,
  Dtool_UpcastInterface_Mutex,
  Dtool_DowncastInterface_Mutex,
  (CoerceFunction)Dtool_ConstCoerce_Mutex,
  (CoerceFunction)Dtool_Coerce_Mutex,
};

static void Dtool_PyModuleClassInit_Mutex(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MutexDirect(NULL);
    Dtool_Mutex._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MutexDirect);
    PyObject *dict = PyDict_New();
    Dtool_Mutex._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Mutex) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Mutex)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Mutex);
  }
}

/**
 * Python method tables for ConditionVarDirect (ConditionVarDirect)
 */
static PyMethodDef Dtool_Methods_ConditionVarDirect[] = {
  {"get_mutex", &Dtool_ConditionVarDirect_get_mutex_63, METH_NOARGS, (const char *)Dtool_ConditionVarDirect_get_mutex_63_comment},
  {"getMutex", &Dtool_ConditionVarDirect_get_mutex_63, METH_NOARGS, (const char *)Dtool_ConditionVarDirect_get_mutex_63_comment},
  {"wait", &Dtool_ConditionVarDirect_wait_64, METH_VARARGS, (const char *)Dtool_ConditionVarDirect_wait_64_comment},
  {"notify", &Dtool_ConditionVarDirect_notify_65, METH_NOARGS, (const char *)Dtool_ConditionVarDirect_notify_65_comment},
  {"output", &Dtool_ConditionVarDirect_output_66, METH_O, (const char *)Dtool_ConditionVarDirect_output_66_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ConditionVarDirect
//////////////////
static PyObject *Dtool_Repr_ConditionVarDirect(PyObject *self) {
  ConditionVarDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConditionVarDirect, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ConditionVarDirect = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ConditionVarDirect = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConditionVarDirect",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConditionVarDirect,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ConditionVarDirect,
    &Dtool_NumberMethods_ConditionVarDirect,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_ConditionVarDirect,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A condition variable, usually used to communicate information about\n"
    " * changing state to a thread that is waiting for something to happen.  A\n"
    " * condition variable can be used to \"wake up\" a thread when some arbitrary\n"
    " * condition has changed.\n"
    " *\n"
    " * A condition variable is associated with a single mutex, and several\n"
    " * condition variables may share the same mutex.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConditionVarDirect,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConditionVarDirect,
    PyType_GenericAlloc,
    Dtool_new_ConditionVarDirect,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConditionVarDirect,
  Dtool_UpcastInterface_ConditionVarDirect,
  Dtool_DowncastInterface_ConditionVarDirect,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ConditionVarDirect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConditionVarDirect._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ConditionVarDirect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConditionVarDirect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConditionVarDirect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConditionVarDirect);
  }
}

/**
 * Python method tables for ConditionVar (ConditionVar)
 */
static PyMethodDef Dtool_Methods_ConditionVar[] = {
  {"get_mutex", &Dtool_ConditionVar_get_mutex_70, METH_NOARGS, (const char *)Dtool_ConditionVar_get_mutex_70_comment},
  {"getMutex", &Dtool_ConditionVar_get_mutex_70, METH_NOARGS, (const char *)Dtool_ConditionVar_get_mutex_70_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ConditionVar = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConditionVar = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConditionVar = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConditionVar = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConditionVar = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConditionVar",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConditionVar,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConditionVar,
    &Dtool_SequenceMethods_ConditionVar,
    &Dtool_MappingMethods_ConditionVar,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConditionVar,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConditionVar,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConditionVar,
    PyType_GenericAlloc,
    Dtool_new_ConditionVar,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConditionVar,
  Dtool_UpcastInterface_ConditionVar,
  Dtool_DowncastInterface_ConditionVar,
  (CoerceFunction)Dtool_ConstCoerce_ConditionVar,
  (CoerceFunction)Dtool_Coerce_ConditionVar,
};

static void Dtool_PyModuleClassInit_ConditionVar(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConditionVarDirect(NULL);
    Dtool_ConditionVar._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConditionVarDirect);
    PyObject *dict = PyDict_New();
    Dtool_ConditionVar._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConditionVar) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConditionVar)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConditionVar);
  }
}

/**
 * Python method tables for ConditionVarFullDirect (ConditionVarFullDirect)
 */
static PyMethodDef Dtool_Methods_ConditionVarFullDirect[] = {
  {"get_mutex", &Dtool_ConditionVarFullDirect_get_mutex_73, METH_NOARGS, (const char *)Dtool_ConditionVarFullDirect_get_mutex_73_comment},
  {"getMutex", &Dtool_ConditionVarFullDirect_get_mutex_73, METH_NOARGS, (const char *)Dtool_ConditionVarFullDirect_get_mutex_73_comment},
  {"wait", &Dtool_ConditionVarFullDirect_wait_74, METH_VARARGS, (const char *)Dtool_ConditionVarFullDirect_wait_74_comment},
  {"notify", &Dtool_ConditionVarFullDirect_notify_75, METH_NOARGS, (const char *)Dtool_ConditionVarFullDirect_notify_75_comment},
  {"notify_all", &Dtool_ConditionVarFullDirect_notify_all_76, METH_NOARGS, (const char *)Dtool_ConditionVarFullDirect_notify_all_76_comment},
  {"notifyAll", &Dtool_ConditionVarFullDirect_notify_all_76, METH_NOARGS, (const char *)Dtool_ConditionVarFullDirect_notify_all_76_comment},
  {"output", &Dtool_ConditionVarFullDirect_output_77, METH_O, (const char *)Dtool_ConditionVarFullDirect_output_77_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ConditionVarFullDirect
//////////////////
static PyObject *Dtool_Repr_ConditionVarFullDirect(PyObject *self) {
  ConditionVarFullDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConditionVarFullDirect, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ConditionVarFullDirect = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ConditionVarFullDirect = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConditionVarFullDirect",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConditionVarFullDirect,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ConditionVarFullDirect,
    &Dtool_NumberMethods_ConditionVarFullDirect,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_ConditionVarFullDirect,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A condition variable, usually used to communicate information about\n"
    " * changing state to a thread that is waiting for something to happen.  A\n"
    " * condition variable can be used to \"wake up\" a thread when some arbitrary\n"
    " * condition has changed.\n"
    " *\n"
    " * A condition variable is associated with a single mutex, and several\n"
    " * condition variables may share the same mutex.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConditionVarFullDirect,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConditionVarFullDirect,
    PyType_GenericAlloc,
    Dtool_new_ConditionVarFullDirect,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConditionVarFullDirect,
  Dtool_UpcastInterface_ConditionVarFullDirect,
  Dtool_DowncastInterface_ConditionVarFullDirect,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ConditionVarFullDirect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConditionVarFullDirect._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ConditionVarFullDirect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConditionVarFullDirect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConditionVarFullDirect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConditionVarFullDirect);
  }
}

/**
 * Python method tables for ConditionVarFull (ConditionVarFull)
 */
static PyMethodDef Dtool_Methods_ConditionVarFull[] = {
  {"get_mutex", &Dtool_ConditionVarFull_get_mutex_81, METH_NOARGS, (const char *)Dtool_ConditionVarFull_get_mutex_81_comment},
  {"getMutex", &Dtool_ConditionVarFull_get_mutex_81, METH_NOARGS, (const char *)Dtool_ConditionVarFull_get_mutex_81_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ConditionVarFull = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConditionVarFull = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConditionVarFull = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConditionVarFull = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConditionVarFull = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConditionVarFull",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConditionVarFull,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConditionVarFull,
    &Dtool_SequenceMethods_ConditionVarFull,
    &Dtool_MappingMethods_ConditionVarFull,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConditionVarFull,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConditionVarFull,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConditionVarFull,
    PyType_GenericAlloc,
    Dtool_new_ConditionVarFull,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConditionVarFull,
  Dtool_UpcastInterface_ConditionVarFull,
  Dtool_DowncastInterface_ConditionVarFull,
  (CoerceFunction)Dtool_ConstCoerce_ConditionVarFull,
  (CoerceFunction)Dtool_Coerce_ConditionVarFull,
};

static void Dtool_PyModuleClassInit_ConditionVarFull(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConditionVarFullDirect(NULL);
    Dtool_ConditionVarFull._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConditionVarFullDirect);
    PyObject *dict = PyDict_New();
    Dtool_ConditionVarFull._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConditionVarFull) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConditionVarFull)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConditionVarFull);
  }
}

/**
 * Python method tables for ReMutexDirect (ReMutexDirect)
 */
static PyMethodDef Dtool_Methods_ReMutexDirect[] = {
  {"acquire", &Dtool_ReMutexDirect_acquire_83, METH_VARARGS, (const char *)Dtool_ReMutexDirect_acquire_83_comment},
  {"try_acquire", &Dtool_ReMutexDirect_try_acquire_84, METH_VARARGS, (const char *)Dtool_ReMutexDirect_try_acquire_84_comment},
  {"tryAcquire", &Dtool_ReMutexDirect_try_acquire_84, METH_VARARGS, (const char *)Dtool_ReMutexDirect_try_acquire_84_comment},
  {"elevate_lock", &Dtool_ReMutexDirect_elevate_lock_85, METH_NOARGS, (const char *)Dtool_ReMutexDirect_elevate_lock_85_comment},
  {"elevateLock", &Dtool_ReMutexDirect_elevate_lock_85, METH_NOARGS, (const char *)Dtool_ReMutexDirect_elevate_lock_85_comment},
  {"release", &Dtool_ReMutexDirect_release_86, METH_NOARGS, (const char *)Dtool_ReMutexDirect_release_86_comment},
  {"debug_is_locked", &Dtool_ReMutexDirect_debug_is_locked_87, METH_NOARGS, (const char *)Dtool_ReMutexDirect_debug_is_locked_87_comment},
  {"debugIsLocked", &Dtool_ReMutexDirect_debug_is_locked_87, METH_NOARGS, (const char *)Dtool_ReMutexDirect_debug_is_locked_87_comment},
  {"set_name", &Dtool_ReMutexDirect_set_name_88, METH_O, (const char *)Dtool_ReMutexDirect_set_name_88_comment},
  {"setName", &Dtool_ReMutexDirect_set_name_88, METH_O, (const char *)Dtool_ReMutexDirect_set_name_88_comment},
  {"clear_name", &Dtool_ReMutexDirect_clear_name_89, METH_NOARGS, (const char *)Dtool_ReMutexDirect_clear_name_89_comment},
  {"clearName", &Dtool_ReMutexDirect_clear_name_89, METH_NOARGS, (const char *)Dtool_ReMutexDirect_clear_name_89_comment},
  {"has_name", &Dtool_ReMutexDirect_has_name_90, METH_NOARGS, (const char *)Dtool_ReMutexDirect_has_name_90_comment},
  {"hasName", &Dtool_ReMutexDirect_has_name_90, METH_NOARGS, (const char *)Dtool_ReMutexDirect_has_name_90_comment},
  {"get_name", &Dtool_ReMutexDirect_get_name_91, METH_NOARGS, (const char *)Dtool_ReMutexDirect_get_name_91_comment},
  {"getName", &Dtool_ReMutexDirect_get_name_91, METH_NOARGS, (const char *)Dtool_ReMutexDirect_get_name_91_comment},
  {"output", &Dtool_ReMutexDirect_output_92, METH_O, (const char *)Dtool_ReMutexDirect_output_92_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ReMutexDirect
//////////////////
static PyObject *Dtool_Repr_ReMutexDirect(PyObject *self) {
  ReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReMutexDirect, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ReMutexDirect = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ReMutexDirect = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ReMutexDirect",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ReMutexDirect,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ReMutexDirect,
    &Dtool_NumberMethods_ReMutexDirect,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_ReMutexDirect,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements a standard reMutex by making direct calls to the\n"
    " * underlying implementation layer.  It doesn't perform any debugging\n"
    " * operations.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ReMutexDirect,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ReMutexDirect,
    PyType_GenericAlloc,
    Dtool_new_ReMutexDirect,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ReMutexDirect,
  Dtool_UpcastInterface_ReMutexDirect,
  Dtool_DowncastInterface_ReMutexDirect,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ReMutexDirect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReMutexDirect._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ReMutexDirect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ReMutexDirect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ReMutexDirect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ReMutexDirect);
  }
}

/**
 * Python method tables for ReMutex (ReMutex)
 */
static PyMethodDef Dtool_Methods_ReMutex[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ReMutex = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ReMutex = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ReMutex = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ReMutex = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ReMutex = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ReMutex",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ReMutex,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ReMutex,
    &Dtool_SequenceMethods_ReMutex,
    &Dtool_MappingMethods_ReMutex,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ReMutex,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ReMutex,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ReMutex,
    PyType_GenericAlloc,
    Dtool_new_ReMutex,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ReMutex,
  Dtool_UpcastInterface_ReMutex,
  Dtool_DowncastInterface_ReMutex,
  (CoerceFunction)Dtool_ConstCoerce_ReMutex,
  (CoerceFunction)Dtool_Coerce_ReMutex,
};

static void Dtool_PyModuleClassInit_ReMutex(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReMutexDirect(NULL);
    Dtool_ReMutex._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReMutexDirect);
    PyObject *dict = PyDict_New();
    Dtool_ReMutex._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ReMutex) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ReMutex)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ReMutex);
  }
}

/**
 * Python method tables for ExternalThread (ExternalThread)
 */
static PyMethodDef Dtool_Methods_ExternalThread[] = {
  {"get_class_type", &Dtool_ExternalThread_get_class_type_97, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExternalThread_get_class_type_97_comment},
  {"getClassType", &Dtool_ExternalThread_get_class_type_97, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExternalThread_get_class_type_97_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ExternalThread = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ExternalThread = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ExternalThread = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ExternalThread = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ExternalThread = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ExternalThread",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ExternalThread,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ExternalThread,
    &Dtool_SequenceMethods_ExternalThread,
    &Dtool_MappingMethods_ExternalThread,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ExternalThread,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The special \"external thread\" class.  There is one instance of these in the\n"
    " * world, and it is returned by Thread::get_external_thread().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ExternalThread,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ExternalThread,
    PyType_GenericAlloc,
    Dtool_new_ExternalThread,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ExternalThread,
  Dtool_UpcastInterface_ExternalThread,
  Dtool_DowncastInterface_ExternalThread,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ExternalThread(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Thread(NULL);
    Dtool_ExternalThread._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Thread);
    PyObject *dict = PyDict_New();
    Dtool_ExternalThread._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ExternalThread) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ExternalThread)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ExternalThread);
  }
}

/**
 * Python method tables for LightMutexDirect (LightMutexDirect)
 */
static PyMethodDef Dtool_Methods_LightMutexDirect[] = {
  {"acquire", &Dtool_LightMutexDirect_acquire_100, METH_NOARGS, (const char *)Dtool_LightMutexDirect_acquire_100_comment},
  {"release", &Dtool_LightMutexDirect_release_101, METH_NOARGS, (const char *)Dtool_LightMutexDirect_release_101_comment},
  {"debug_is_locked", &Dtool_LightMutexDirect_debug_is_locked_102, METH_NOARGS, (const char *)Dtool_LightMutexDirect_debug_is_locked_102_comment},
  {"debugIsLocked", &Dtool_LightMutexDirect_debug_is_locked_102, METH_NOARGS, (const char *)Dtool_LightMutexDirect_debug_is_locked_102_comment},
  {"set_name", &Dtool_LightMutexDirect_set_name_103, METH_O, (const char *)Dtool_LightMutexDirect_set_name_103_comment},
  {"setName", &Dtool_LightMutexDirect_set_name_103, METH_O, (const char *)Dtool_LightMutexDirect_set_name_103_comment},
  {"clear_name", &Dtool_LightMutexDirect_clear_name_104, METH_NOARGS, (const char *)Dtool_LightMutexDirect_clear_name_104_comment},
  {"clearName", &Dtool_LightMutexDirect_clear_name_104, METH_NOARGS, (const char *)Dtool_LightMutexDirect_clear_name_104_comment},
  {"has_name", &Dtool_LightMutexDirect_has_name_105, METH_NOARGS, (const char *)Dtool_LightMutexDirect_has_name_105_comment},
  {"hasName", &Dtool_LightMutexDirect_has_name_105, METH_NOARGS, (const char *)Dtool_LightMutexDirect_has_name_105_comment},
  {"get_name", &Dtool_LightMutexDirect_get_name_106, METH_NOARGS, (const char *)Dtool_LightMutexDirect_get_name_106_comment},
  {"getName", &Dtool_LightMutexDirect_get_name_106, METH_NOARGS, (const char *)Dtool_LightMutexDirect_get_name_106_comment},
  {"output", &Dtool_LightMutexDirect_output_107, METH_O, (const char *)Dtool_LightMutexDirect_output_107_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     LightMutexDirect
//////////////////
static PyObject *Dtool_Repr_LightMutexDirect(PyObject *self) {
  LightMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightMutexDirect, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LightMutexDirect = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_LightMutexDirect = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LightMutexDirect",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LightMutexDirect,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_LightMutexDirect,
    &Dtool_NumberMethods_LightMutexDirect,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_LightMutexDirect,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements a lightweight Mutex by making direct calls to the\n"
    " * underlying implementation layer.  It doesn't perform any debugging\n"
    " * operations.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LightMutexDirect,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LightMutexDirect,
    PyType_GenericAlloc,
    Dtool_new_LightMutexDirect,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightMutexDirect,
  Dtool_UpcastInterface_LightMutexDirect,
  Dtool_DowncastInterface_LightMutexDirect,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LightMutexDirect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LightMutexDirect._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LightMutexDirect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightMutexDirect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightMutexDirect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightMutexDirect);
  }
}

/**
 * Python method tables for LightMutex (LightMutex)
 */
static PyMethodDef Dtool_Methods_LightMutex[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LightMutex = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightMutex = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LightMutex = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LightMutex = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LightMutex = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LightMutex",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LightMutex,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LightMutex,
    &Dtool_SequenceMethods_LightMutex,
    &Dtool_MappingMethods_LightMutex,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LightMutex,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LightMutex,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LightMutex,
    PyType_GenericAlloc,
    Dtool_new_LightMutex,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightMutex,
  Dtool_UpcastInterface_LightMutex,
  Dtool_DowncastInterface_LightMutex,
  (CoerceFunction)Dtool_ConstCoerce_LightMutex,
  (CoerceFunction)Dtool_Coerce_LightMutex,
};

static void Dtool_PyModuleClassInit_LightMutex(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightMutexDirect(NULL);
    Dtool_LightMutex._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightMutexDirect);
    PyObject *dict = PyDict_New();
    Dtool_LightMutex._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightMutex) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightMutex)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightMutex);
  }
}

/**
 * Python method tables for LightReMutexDirect (LightReMutexDirect)
 */
static PyMethodDef Dtool_Methods_LightReMutexDirect[] = {
  {"acquire", &Dtool_LightReMutexDirect_acquire_112, METH_VARARGS, (const char *)Dtool_LightReMutexDirect_acquire_112_comment},
  {"elevate_lock", &Dtool_LightReMutexDirect_elevate_lock_113, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_elevate_lock_113_comment},
  {"elevateLock", &Dtool_LightReMutexDirect_elevate_lock_113, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_elevate_lock_113_comment},
  {"release", &Dtool_LightReMutexDirect_release_114, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_release_114_comment},
  {"debug_is_locked", &Dtool_LightReMutexDirect_debug_is_locked_115, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_debug_is_locked_115_comment},
  {"debugIsLocked", &Dtool_LightReMutexDirect_debug_is_locked_115, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_debug_is_locked_115_comment},
  {"set_name", &Dtool_LightReMutexDirect_set_name_116, METH_O, (const char *)Dtool_LightReMutexDirect_set_name_116_comment},
  {"setName", &Dtool_LightReMutexDirect_set_name_116, METH_O, (const char *)Dtool_LightReMutexDirect_set_name_116_comment},
  {"clear_name", &Dtool_LightReMutexDirect_clear_name_117, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_clear_name_117_comment},
  {"clearName", &Dtool_LightReMutexDirect_clear_name_117, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_clear_name_117_comment},
  {"has_name", &Dtool_LightReMutexDirect_has_name_118, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_has_name_118_comment},
  {"hasName", &Dtool_LightReMutexDirect_has_name_118, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_has_name_118_comment},
  {"get_name", &Dtool_LightReMutexDirect_get_name_119, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_get_name_119_comment},
  {"getName", &Dtool_LightReMutexDirect_get_name_119, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_get_name_119_comment},
  {"output", &Dtool_LightReMutexDirect_output_120, METH_O, (const char *)Dtool_LightReMutexDirect_output_120_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     LightReMutexDirect
//////////////////
static PyObject *Dtool_Repr_LightReMutexDirect(PyObject *self) {
  LightReMutexDirect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightReMutexDirect, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LightReMutexDirect = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_LightReMutexDirect = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LightReMutexDirect",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LightReMutexDirect,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_LightReMutexDirect,
    &Dtool_NumberMethods_LightReMutexDirect,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_LightReMutexDirect,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements a standard lightReMutex by making direct calls to the\n"
    " * underlying implementation layer.  It doesn't perform any debugging\n"
    " * operations.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LightReMutexDirect,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LightReMutexDirect,
    PyType_GenericAlloc,
    Dtool_new_LightReMutexDirect,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightReMutexDirect,
  Dtool_UpcastInterface_LightReMutexDirect,
  Dtool_DowncastInterface_LightReMutexDirect,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LightReMutexDirect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LightReMutexDirect._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LightReMutexDirect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightReMutexDirect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightReMutexDirect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightReMutexDirect);
  }
}

/**
 * Python method tables for LightReMutex (LightReMutex)
 */
static PyMethodDef Dtool_Methods_LightReMutex[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LightReMutex = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightReMutex = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LightReMutex = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LightReMutex = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LightReMutex = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LightReMutex",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LightReMutex,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LightReMutex,
    &Dtool_SequenceMethods_LightReMutex,
    &Dtool_MappingMethods_LightReMutex,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LightReMutex,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LightReMutex,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LightReMutex,
    PyType_GenericAlloc,
    Dtool_new_LightReMutex,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightReMutex,
  Dtool_UpcastInterface_LightReMutex,
  Dtool_DowncastInterface_LightReMutex,
  (CoerceFunction)Dtool_ConstCoerce_LightReMutex,
  (CoerceFunction)Dtool_Coerce_LightReMutex,
};

static void Dtool_PyModuleClassInit_LightReMutex(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightReMutexDirect(NULL);
    Dtool_LightReMutex._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightReMutexDirect);
    PyObject *dict = PyDict_New();
    Dtool_LightReMutex._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightReMutex) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightReMutex)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightReMutex);
  }
}

/**
 * Python method tables for MainThread (MainThread)
 */
static PyMethodDef Dtool_Methods_MainThread[] = {
  {"get_class_type", &Dtool_MainThread_get_class_type_125, METH_NOARGS | METH_STATIC, (const char *)Dtool_MainThread_get_class_type_125_comment},
  {"getClassType", &Dtool_MainThread_get_class_type_125, METH_NOARGS | METH_STATIC, (const char *)Dtool_MainThread_get_class_type_125_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MainThread = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MainThread = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MainThread = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MainThread = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MainThread = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MainThread",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MainThread,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MainThread,
    &Dtool_SequenceMethods_MainThread,
    &Dtool_MappingMethods_MainThread,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MainThread,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The special \"main thread\" class.  There is one instance of these in the\n"
    " * world, and it is returned by Thread::get_main_thread().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MainThread,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MainThread,
    PyType_GenericAlloc,
    Dtool_new_MainThread,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MainThread,
  Dtool_UpcastInterface_MainThread,
  Dtool_DowncastInterface_MainThread,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MainThread(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Thread(NULL);
    Dtool_MainThread._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Thread);
    PyObject *dict = PyDict_New();
    Dtool_MainThread._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MainThread) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MainThread)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MainThread);
  }
}

/**
 * Python method tables for PythonThread (PythonThread)
 */
static PyMethodDef Dtool_Methods_PythonThread[] = {
  {"join", &Dtool_PythonThread_join_129, METH_NOARGS, (const char *)Dtool_PythonThread_join_129_comment},
  {"get_class_type", &Dtool_PythonThread_get_class_type_130, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonThread_get_class_type_130_comment},
  {"getClassType", &Dtool_PythonThread_get_class_type_130, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonThread_get_class_type_130_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PythonThread = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PythonThread = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PythonThread = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PythonThread = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PythonThread = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PythonThread",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PythonThread,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PythonThread,
    &Dtool_SequenceMethods_PythonThread,
    &Dtool_MappingMethods_PythonThread,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PythonThread,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is exposed to Python to allow creation of a Panda thread from\n"
    " * the Python level.  It will spawn a thread that executes an arbitrary Python\n"
    " * functor.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PythonThread,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PythonThread,
    PyType_GenericAlloc,
    Dtool_new_PythonThread,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PythonThread,
  Dtool_UpcastInterface_PythonThread,
  Dtool_DowncastInterface_PythonThread,
  (CoerceFunction)Dtool_ConstCoerce_PythonThread,
  (CoerceFunction)Dtool_Coerce_PythonThread,
};

static void Dtool_PyModuleClassInit_PythonThread(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Thread(NULL);
    Dtool_PythonThread._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Thread);
    PyObject *dict = PyDict_New();
    Dtool_PythonThread._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PythonThread) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PythonThread)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PythonThread);
  }
}

/**
 * Python method tables for Semaphore (Semaphore)
 */
static PyMethodDef Dtool_Methods_Semaphore[] = {
  {"acquire", &Dtool_Semaphore_acquire_134, METH_NOARGS, (const char *)Dtool_Semaphore_acquire_134_comment},
  {"try_acquire", &Dtool_Semaphore_try_acquire_135, METH_NOARGS, (const char *)Dtool_Semaphore_try_acquire_135_comment},
  {"tryAcquire", &Dtool_Semaphore_try_acquire_135, METH_NOARGS, (const char *)Dtool_Semaphore_try_acquire_135_comment},
  {"release", &Dtool_Semaphore_release_136, METH_NOARGS, (const char *)Dtool_Semaphore_release_136_comment},
  {"get_count", &Dtool_Semaphore_get_count_137, METH_NOARGS, (const char *)Dtool_Semaphore_get_count_137_comment},
  {"getCount", &Dtool_Semaphore_get_count_137, METH_NOARGS, (const char *)Dtool_Semaphore_get_count_137_comment},
  {"output", &Dtool_Semaphore_output_138, METH_O, (const char *)Dtool_Semaphore_output_138_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     Semaphore
//////////////////
static PyObject *Dtool_Repr_Semaphore(PyObject *self) {
  Semaphore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Semaphore, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_Semaphore = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Semaphore = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Semaphore",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Semaphore,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_Semaphore,
    &Dtool_NumberMethods_Semaphore,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_Semaphore,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A classic semaphore synchronization primitive.\n"
    " *\n"
    " * A semaphore manages an internal counter which is decremented by each\n"
    " * acquire() call and incremented by each release() call.  The counter can\n"
    " * never go below zero; when acquire() finds that it is zero, it blocks,\n"
    " * waiting until some other thread calls release().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Semaphore,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Semaphore,
    PyType_GenericAlloc,
    Dtool_new_Semaphore,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Semaphore,
  Dtool_UpcastInterface_Semaphore,
  Dtool_DowncastInterface_Semaphore,
  (CoerceFunction)Dtool_ConstCoerce_Semaphore,
  (CoerceFunction)Dtool_Coerce_Semaphore,
};

static void Dtool_PyModuleClassInit_Semaphore(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Semaphore._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Semaphore._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Semaphore) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Semaphore)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Semaphore);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3pipeline_RegisterTypes() {
  Dtool_AsyncTaskBase._type = AsyncTaskBase::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AsyncTaskBase);
  Dtool_Thread._type = Thread::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Thread);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("MutexDirect", Dtool_MutexDirect);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Mutex", Dtool_Mutex);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConditionVarDirect", Dtool_ConditionVarDirect);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConditionVar", Dtool_ConditionVar);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConditionVarFullDirect", Dtool_ConditionVarFullDirect);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConditionVarFull", Dtool_ConditionVarFull);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ReMutexDirect", Dtool_ReMutexDirect);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ReMutex", Dtool_ReMutex);
#endif
  Dtool_ExternalThread._type = ExternalThread::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ExternalThread);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LightMutexDirect", Dtool_LightMutexDirect);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LightMutex", Dtool_LightMutex);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LightReMutexDirect", Dtool_LightReMutexDirect);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LightReMutex", Dtool_LightReMutex);
#endif
  Dtool_MainThread._type = MainThread::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MainThread);
  Dtool_PythonThread._type = PythonThread::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PythonThread);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Semaphore", Dtool_Semaphore);
#endif
}

void Dtool_libp3pipeline_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
#endif
}

void Dtool_libp3pipeline_BuildInstants(PyObject *module) {
  (void) module;
  // enum ThreadPriority
  PyModule_AddObject(module, "TP_low", Dtool_WrapValue(::TP_low));
  PyModule_AddObject(module, "TPLow", Dtool_WrapValue(::TP_low));
  PyModule_AddObject(module, "TP_normal", Dtool_WrapValue(::TP_normal));
  PyModule_AddObject(module, "TPNormal", Dtool_WrapValue(::TP_normal));
  PyModule_AddObject(module, "TP_high", Dtool_WrapValue(::TP_high));
  PyModule_AddObject(module, "TPHigh", Dtool_WrapValue(::TP_high));
  PyModule_AddObject(module, "TP_urgent", Dtool_WrapValue(::TP_urgent));
  PyModule_AddObject(module, "TPUrgent", Dtool_WrapValue(::TP_urgent));
  // AsyncTaskBase
  Dtool_PyModuleClassInit_AsyncTaskBase(module);
  PyModule_AddObject(module, "AsyncTaskBase", (PyObject *)&Dtool_AsyncTaskBase);
  // Thread
  Dtool_PyModuleClassInit_Thread(module);
  PyModule_AddObject(module, "Thread", (PyObject *)&Dtool_Thread);
  // MutexDirect
  Dtool_PyModuleClassInit_MutexDirect(module);
  PyModule_AddObject(module, "MutexDirect", (PyObject *)&Dtool_MutexDirect);
  // Mutex
  Dtool_PyModuleClassInit_Mutex(module);
  PyModule_AddObject(module, "Mutex", (PyObject *)&Dtool_Mutex);
  // ConditionVarDirect
  Dtool_PyModuleClassInit_ConditionVarDirect(module);
  PyModule_AddObject(module, "ConditionVarDirect", (PyObject *)&Dtool_ConditionVarDirect);
  // ConditionVar
  Dtool_PyModuleClassInit_ConditionVar(module);
  PyModule_AddObject(module, "ConditionVar", (PyObject *)&Dtool_ConditionVar);
  // ConditionVarFullDirect
  Dtool_PyModuleClassInit_ConditionVarFullDirect(module);
  PyModule_AddObject(module, "ConditionVarFullDirect", (PyObject *)&Dtool_ConditionVarFullDirect);
  // ConditionVarFull
  Dtool_PyModuleClassInit_ConditionVarFull(module);
  PyModule_AddObject(module, "ConditionVarFull", (PyObject *)&Dtool_ConditionVarFull);
  // ReMutexDirect
  Dtool_PyModuleClassInit_ReMutexDirect(module);
  PyModule_AddObject(module, "ReMutexDirect", (PyObject *)&Dtool_ReMutexDirect);
  // ReMutex
  Dtool_PyModuleClassInit_ReMutex(module);
  PyModule_AddObject(module, "ReMutex", (PyObject *)&Dtool_ReMutex);
  // ExternalThread
  Dtool_PyModuleClassInit_ExternalThread(module);
  PyModule_AddObject(module, "ExternalThread", (PyObject *)&Dtool_ExternalThread);
  // LightMutexDirect
  Dtool_PyModuleClassInit_LightMutexDirect(module);
  PyModule_AddObject(module, "LightMutexDirect", (PyObject *)&Dtool_LightMutexDirect);
  // LightMutex
  Dtool_PyModuleClassInit_LightMutex(module);
  PyModule_AddObject(module, "LightMutex", (PyObject *)&Dtool_LightMutex);
  // LightReMutexDirect
  Dtool_PyModuleClassInit_LightReMutexDirect(module);
  PyModule_AddObject(module, "LightReMutexDirect", (PyObject *)&Dtool_LightReMutexDirect);
  // LightReMutex
  Dtool_PyModuleClassInit_LightReMutex(module);
  PyModule_AddObject(module, "LightReMutex", (PyObject *)&Dtool_LightReMutex);
  // MainThread
  Dtool_PyModuleClassInit_MainThread(module);
  PyModule_AddObject(module, "MainThread", (PyObject *)&Dtool_MainThread);
  // PythonThread
  Dtool_PyModuleClassInit_PythonThread(module);
  PyModule_AddObject(module, "PythonThread", (PyObject *)&Dtool_PythonThread);
  // Semaphore
  Dtool_PyModuleClassInit_Semaphore(module);
  PyModule_AddObject(module, "Semaphore", (PyObject *)&Dtool_Semaphore);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3pipeline_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478209772,  /* file_identifier */
  "libp3pipeline",  /* library_name */
  "kd_i",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3pipeline.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  304  /* next_index */
};

Configure(_in_configure_libp3pipeline);
ConfigureFn(_in_configure_libp3pipeline) {
  interrogate_request_module(&_in_module_def);
}

