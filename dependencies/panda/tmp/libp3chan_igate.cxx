/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/chan -Ipanda/src/chan -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3chan_igate.cxx -od built/pandac/input/libp3chan.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/chan -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3chan animBundle.h animBundleNode.h animChannel.h animChannelBase.h animChannelMatrixDynamic.h animChannelMatrixFixed.h animChannelMatrixXfmTable.h animChannelScalarDynamic.h animChannelScalarTable.h animControl.h animControlCollection.h animGroup.h animPreloadTable.h auto_bind.h bindAnimRequest.h config_chan.h movingPartBase.h movingPartMatrix.h movingPartScalar.h p3chan_composite1.cxx p3chan_composite2.cxx partBundle.h partBundleHandle.h partBundleNode.h partGroup.h partSubset.h vector_PartGroupStar.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3chan
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "animBundle.h"
#include "animBundleNode.h"
#include "animChannel.h"
#include "animChannelBase.h"
#include "animChannelFixed.h"
#include "animChannelMatrixDynamic.h"
#include "animChannelMatrixFixed.h"
#include "animChannelMatrixXfmTable.h"
#include "animChannelScalarDynamic.h"
#include "animChannelScalarTable.h"
#include "animControl.h"
#include "animControlCollection.h"
#include "animGroup.h"
#include "animPreloadTable.h"
#include "auto_bind.h"
#include "bindAnimRequest.h"
#include "cmath.h"
#include "compose_matrix.h"
#include "configVariableBool.h"
#include "configVariableInt.h"
#include "config_chan.h"
#include "copyOnWriteObject.h"
#include "dcast.h"
#include "event.h"
#include "luse.h"
#include "modelLoadRequest.h"
#include "movingPart.h"
#include "movingPartBase.h"
#include "movingPartMatrix.h"
#include "movingPartScalar.h"
#include "notifyCategoryProxy.h"
#include "ordered_vector.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "partBundle.h"
#include "partBundleHandle.h"
#include "partBundleNode.h"
#include "partGroup.h"
#include "partSubset.h"
#include "pmap.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pt_Event.h"
#include "pta_stdfloat.h"
#include "transformState.h"
#include "typedWritableReferenceCount.h"
#include "vector_PartGroupStar.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class AnimGroup
 */
typedef AnimGroup AnimGroup_localtype;
Define_Module_ClassRef(panda3d.core, AnimGroup, AnimGroup_localtype, AnimGroup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimGroup = &Dtool_AnimGroup;
static void Dtool_PyModuleClassInit_AnimGroup(PyObject *module);
bool Dtool_ConstCoerce_AnimGroup(PyObject *args, CPT(AnimGroup) &coerced);
bool Dtool_Coerce_AnimGroup(PyObject *args, PT(AnimGroup) &coerced);

/**
 * Forward declarations for top-level class AnimBundle
 */
typedef AnimBundle AnimBundle_localtype;
Define_Module_ClassRef(panda3d.core, AnimBundle, AnimBundle_localtype, AnimBundle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimBundle = &Dtool_AnimBundle;
static void Dtool_PyModuleClassInit_AnimBundle(PyObject *module);
bool Dtool_ConstCoerce_AnimBundle(PyObject *args, CPT(AnimBundle) &coerced);
bool Dtool_Coerce_AnimBundle(PyObject *args, PT(AnimBundle) &coerced);

/**
 * Forward declarations for top-level class AnimBundleNode
 */
typedef AnimBundleNode AnimBundleNode_localtype;
Define_Module_ClassRef(panda3d.core, AnimBundleNode, AnimBundleNode_localtype, AnimBundleNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimBundleNode = &Dtool_AnimBundleNode;
static void Dtool_PyModuleClassInit_AnimBundleNode(PyObject *module);
bool Dtool_ConstCoerce_AnimBundleNode(PyObject *args, CPT(AnimBundleNode) &coerced);
bool Dtool_Coerce_AnimBundleNode(PyObject *args, PT(AnimBundleNode) &coerced);

/**
 * Forward declarations for top-level class PartGroup
 */
typedef PartGroup PartGroup_localtype;
Define_Module_ClassRef(panda3d.core, PartGroup, PartGroup_localtype, PartGroup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartGroup = &Dtool_PartGroup;
static void Dtool_PyModuleClassInit_PartGroup(PyObject *module);
bool Dtool_ConstCoerce_PartGroup(PyObject *args, CPT(PartGroup) &coerced);
bool Dtool_Coerce_PartGroup(PyObject *args, PT(PartGroup) &coerced);

/**
 * Forward declarations for top-level class AnimControl
 */
typedef AnimControl AnimControl_localtype;
Define_Module_ClassRef(panda3d.core, AnimControl, AnimControl_localtype, AnimControl);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimControl = &Dtool_AnimControl;
static void Dtool_PyModuleClassInit_AnimControl(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannelBase
 */
typedef AnimChannelBase AnimChannelBase_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannelBase, AnimChannelBase_localtype, AnimChannelBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannelBase = &Dtool_AnimChannelBase;
static void Dtool_PyModuleClassInit_AnimChannelBase(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannel_ACMatrixSwitchType
 */
typedef AnimChannel< ACMatrixSwitchType > AnimChannel_ACMatrixSwitchType_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannel_ACMatrixSwitchType, AnimChannel_ACMatrixSwitchType_localtype, AnimChannel_ACMatrixSwitchType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannel_ACMatrixSwitchType = &Dtool_AnimChannel_ACMatrixSwitchType;
static void Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannel_ACScalarSwitchType
 */
typedef AnimChannel< ACScalarSwitchType > AnimChannel_ACScalarSwitchType_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannel_ACScalarSwitchType, AnimChannel_ACScalarSwitchType_localtype, AnimChannel_ACScalarSwitchType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannel_ACScalarSwitchType = &Dtool_AnimChannel_ACScalarSwitchType;
static void Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannelMatrixDynamic
 */
typedef AnimChannelMatrixDynamic AnimChannelMatrixDynamic_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannelMatrixDynamic, AnimChannelMatrixDynamic_localtype, AnimChannelMatrixDynamic);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannelMatrixDynamic = &Dtool_AnimChannelMatrixDynamic;
static void Dtool_PyModuleClassInit_AnimChannelMatrixDynamic(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannelMatrixXfmTable
 */
typedef AnimChannelMatrixXfmTable AnimChannelMatrixXfmTable_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannelMatrixXfmTable, AnimChannelMatrixXfmTable_localtype, AnimChannelMatrixXfmTable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannelMatrixXfmTable = &Dtool_AnimChannelMatrixXfmTable;
static void Dtool_PyModuleClassInit_AnimChannelMatrixXfmTable(PyObject *module);
bool Dtool_ConstCoerce_AnimChannelMatrixXfmTable(PyObject *args, CPT(AnimChannelMatrixXfmTable) &coerced);
bool Dtool_Coerce_AnimChannelMatrixXfmTable(PyObject *args, PT(AnimChannelMatrixXfmTable) &coerced);

/**
 * Forward declarations for top-level class AnimChannelScalarDynamic
 */
typedef AnimChannelScalarDynamic AnimChannelScalarDynamic_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannelScalarDynamic, AnimChannelScalarDynamic_localtype, AnimChannelScalarDynamic);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannelScalarDynamic = &Dtool_AnimChannelScalarDynamic;
static void Dtool_PyModuleClassInit_AnimChannelScalarDynamic(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannelScalarTable
 */
typedef AnimChannelScalarTable AnimChannelScalarTable_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannelScalarTable, AnimChannelScalarTable_localtype, AnimChannelScalarTable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannelScalarTable = &Dtool_AnimChannelScalarTable;
static void Dtool_PyModuleClassInit_AnimChannelScalarTable(PyObject *module);

/**
 * Forward declarations for top-level class AnimControlCollection
 */
typedef AnimControlCollection AnimControlCollection_localtype;
Define_Module_Class(panda3d.core, AnimControlCollection, AnimControlCollection_localtype, AnimControlCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimControlCollection = &Dtool_AnimControlCollection;
static void Dtool_PyModuleClassInit_AnimControlCollection(PyObject *module);

/**
 * Forward declarations for top-level class AnimPreloadTable
 */
typedef AnimPreloadTable AnimPreloadTable_localtype;
Define_Module_ClassRef(panda3d.core, AnimPreloadTable, AnimPreloadTable_localtype, AnimPreloadTable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimPreloadTable = &Dtool_AnimPreloadTable;
static void Dtool_PyModuleClassInit_AnimPreloadTable(PyObject *module);

/**
 * Forward declarations for top-level class PartSubset
 */
typedef PartSubset PartSubset_localtype;
Define_Module_Class(panda3d.core, PartSubset, PartSubset_localtype, PartSubset);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartSubset = &Dtool_PartSubset;
static void Dtool_PyModuleClassInit_PartSubset(PyObject *module);

/**
 * Forward declarations for top-level class BindAnimRequest
 */
typedef BindAnimRequest BindAnimRequest_localtype;
Define_Module_ClassRef(panda3d.core, BindAnimRequest, BindAnimRequest_localtype, BindAnimRequest);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BindAnimRequest = &Dtool_BindAnimRequest;
static void Dtool_PyModuleClassInit_BindAnimRequest(PyObject *module);
bool Dtool_ConstCoerce_BindAnimRequest(PyObject *args, CPT(BindAnimRequest) &coerced);
bool Dtool_Coerce_BindAnimRequest(PyObject *args, PT(BindAnimRequest) &coerced);

/**
 * Forward declarations for top-level class PartBundle
 */
typedef PartBundle PartBundle_localtype;
Define_Module_ClassRef(panda3d.core, PartBundle, PartBundle_localtype, PartBundle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundle = &Dtool_PartBundle;
static void Dtool_PyModuleClassInit_PartBundle(PyObject *module);
bool Dtool_ConstCoerce_PartBundle(PyObject *args, CPT(PartBundle) &coerced);
bool Dtool_Coerce_PartBundle(PyObject *args, PT(PartBundle) &coerced);

/**
 * Forward declarations for top-level class PartBundleNode
 */
typedef PartBundleNode PartBundleNode_localtype;
Define_Module_ClassRef(panda3d.core, PartBundleNode, PartBundleNode_localtype, PartBundleNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundleNode = &Dtool_PartBundleNode;
static void Dtool_PyModuleClassInit_PartBundleNode(PyObject *module);
bool Dtool_ConstCoerce_PartBundleNode(PyObject *args, CPT(PartBundleNode) &coerced);
bool Dtool_Coerce_PartBundleNode(PyObject *args, PT(PartBundleNode) &coerced);

/**
 * Forward declarations for top-level class PartBundleHandle
 */
typedef PartBundleHandle PartBundleHandle_localtype;
Define_Module_ClassRef(panda3d.core, PartBundleHandle, PartBundleHandle_localtype, PartBundleHandle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundleHandle = &Dtool_PartBundleHandle;
static void Dtool_PyModuleClassInit_PartBundleHandle(PyObject *module);
bool Dtool_ConstCoerce_PartBundleHandle(PyObject *args, CPT(PartBundleHandle) &coerced);
bool Dtool_Coerce_PartBundleHandle(PyObject *args, PT(PartBundleHandle) &coerced);

/**
 * Forward declarations for top-level class MovingPartBase
 */
typedef MovingPartBase MovingPartBase_localtype;
Define_Module_ClassRef(panda3d.core, MovingPartBase, MovingPartBase_localtype, MovingPartBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartBase = &Dtool_MovingPartBase;
static void Dtool_PyModuleClassInit_MovingPartBase(PyObject *module);

/**
 * Forward declarations for top-level class MovingPartMatrix
 */
typedef MovingPartMatrix MovingPartMatrix_localtype;
Define_Module_ClassRef(panda3d.core, MovingPartMatrix, MovingPartMatrix_localtype, MovingPartMatrix);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartMatrix = &Dtool_MovingPartMatrix;
static void Dtool_PyModuleClassInit_MovingPartMatrix(PyObject *module);

/**
 * Forward declarations for top-level class MovingPart_ACMatrixSwitchType
 */
typedef MovingPart< ACMatrixSwitchType > MovingPart_ACMatrixSwitchType_localtype;
Define_Module_ClassRef(panda3d.core, MovingPart_ACMatrixSwitchType, MovingPart_ACMatrixSwitchType_localtype, MovingPart_ACMatrixSwitchType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPart_ACMatrixSwitchType = &Dtool_MovingPart_ACMatrixSwitchType;
static void Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType(PyObject *module);

/**
 * Forward declarations for top-level class MovingPartScalar
 */
typedef MovingPartScalar MovingPartScalar_localtype;
Define_Module_ClassRef(panda3d.core, MovingPartScalar, MovingPartScalar_localtype, MovingPartScalar);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartScalar = &Dtool_MovingPartScalar;
static void Dtool_PyModuleClassInit_MovingPartScalar(PyObject *module);

/**
 * Forward declarations for top-level class MovingPart_ACScalarSwitchType
 */
typedef MovingPart< ACScalarSwitchType > MovingPart_ACScalarSwitchType_localtype;
Define_Module_ClassRef(panda3d.core, MovingPart_ACScalarSwitchType, MovingPart_ACScalarSwitchType_localtype, MovingPart_ACScalarSwitchType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPart_ACScalarSwitchType = &Dtool_MovingPart_ACScalarSwitchType;
static void Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// GlobPattern
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GlobPattern;
inline static bool Dtool_ConstCoerce_GlobPattern(PyObject *args, GlobPattern const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_GlobPattern != NULL, false);
  nassertr(Dtool_Ptr_GlobPattern->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, GlobPattern const *&, bool&))Dtool_Ptr_GlobPattern->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_GlobPattern != NULL, false);
  nassertr(Dtool_Ptr_GlobPattern->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, GlobPattern *&, bool&))Dtool_Ptr_GlobPattern->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_GlobPattern;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GlobPattern = &Dtool_GlobPattern;
extern bool Dtool_ConstCoerce_GlobPattern(PyObject *args, GlobPattern const *&coerced, bool &manage);
extern bool Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern *&coerced, bool &manage);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LQuaternionf
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LQuaternionf;
inline static LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced) {
  nassertr(Dtool_Ptr_LQuaternionf != NULL, NULL);
  nassertr(Dtool_Ptr_LQuaternionf->_Dtool_Coerce != NULL, NULL);
  return ((LQuaternionf *(*)(PyObject *, LQuaternionf &))Dtool_Ptr_LQuaternionf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaternionf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaternionf = &Dtool_LQuaternionf;
extern LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced);
#endif
// BitArray
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_BitArray;
inline static bool Dtool_ConstCoerce_BitArray(PyObject *args, BitArray const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_BitArray != NULL, false);
  nassertr(Dtool_Ptr_BitArray->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, BitArray const *&, bool&))Dtool_Ptr_BitArray->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_BitArray(PyObject *args, BitArray *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_BitArray != NULL, false);
  nassertr(Dtool_Ptr_BitArray->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, BitArray *&, bool&))Dtool_Ptr_BitArray->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitArray;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitArray = &Dtool_BitArray;
extern bool Dtool_ConstCoerce_BitArray(PyObject *args, BitArray const *&coerced, bool &manage);
extern bool Dtool_Coerce_BitArray(PyObject *args, BitArray *&coerced, bool &manage);
#endif
// CachedTypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CachedTypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CachedTypedWritableReferenceCount = &Dtool_CachedTypedWritableReferenceCount;
#endif
// CopyOnWriteObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CopyOnWriteObject;
#else
extern struct Dtool_PyTypedObject Dtool_CopyOnWriteObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CopyOnWriteObject = &Dtool_CopyOnWriteObject;
#endif
// LoaderOptions
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LoaderOptions;
inline static LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced) {
  nassertr(Dtool_Ptr_LoaderOptions != NULL, NULL);
  nassertr(Dtool_Ptr_LoaderOptions->_Dtool_Coerce != NULL, NULL);
  return ((LoaderOptions *(*)(PyObject *, LoaderOptions &))Dtool_Ptr_LoaderOptions->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LoaderOptions;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LoaderOptions = &Dtool_LoaderOptions;
extern LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced);
#endif
// TransformState
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TransformState;
#else
extern struct Dtool_PyTypedObject Dtool_TransformState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformState = &Dtool_TransformState;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// AnimInterface
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_AnimInterface;
#else
extern struct Dtool_PyTypedObject Dtool_AnimInterface;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimInterface = &Dtool_AnimInterface;
#endif
// AsyncTask
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_AsyncTask;
#else
extern struct Dtool_PyTypedObject Dtool_AsyncTask;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTask = &Dtool_AsyncTask;
#endif
// AsyncTaskBase
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_AsyncTaskBase;
#else
extern struct Dtool_PyTypedObject Dtool_AsyncTaskBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskBase = &Dtool_AsyncTaskBase;
#endif
// Loader
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Loader;
inline static bool Dtool_ConstCoerce_Loader(PyObject *args, CPT(Loader) &coerced) {
  nassertr(Dtool_Ptr_Loader != NULL, false);
  nassertr(Dtool_Ptr_Loader->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(Loader) &))Dtool_Ptr_Loader->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_Loader(PyObject *args, PT(Loader) &coerced) {
  nassertr(Dtool_Ptr_Loader != NULL, false);
  nassertr(Dtool_Ptr_Loader->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(Loader) &))Dtool_Ptr_Loader->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Loader;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Loader = &Dtool_Loader;
extern bool Dtool_ConstCoerce_Loader(PyObject *args, CPT(Loader) &coerced);
extern bool Dtool_Coerce_Loader(PyObject *args, PT(Loader) &coerced);
#endif
// ModelLoadRequest
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ModelLoadRequest;
inline static bool Dtool_ConstCoerce_ModelLoadRequest(PyObject *args, CPT(ModelLoadRequest) &coerced) {
  nassertr(Dtool_Ptr_ModelLoadRequest != NULL, false);
  nassertr(Dtool_Ptr_ModelLoadRequest->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(ModelLoadRequest) &))Dtool_Ptr_ModelLoadRequest->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_ModelLoadRequest(PyObject *args, PT(ModelLoadRequest) &coerced) {
  nassertr(Dtool_Ptr_ModelLoadRequest != NULL, false);
  nassertr(Dtool_Ptr_ModelLoadRequest->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(ModelLoadRequest) &))Dtool_Ptr_ModelLoadRequest->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ModelLoadRequest;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelLoadRequest = &Dtool_ModelLoadRequest;
extern bool Dtool_ConstCoerce_ModelLoadRequest(PyObject *args, CPT(ModelLoadRequest) &coerced);
extern bool Dtool_Coerce_ModelLoadRequest(PyObject *args, PT(ModelLoadRequest) &coerced);
#endif
// ConstPointerToArray< float >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ConstPointerToArray_float;
inline static ConstPointerToArray< float > *Dtool_Coerce_ConstPointerToArray_float(PyObject *args, ConstPointerToArray< float > &coerced) {
  nassertr(Dtool_Ptr_ConstPointerToArray_float != NULL, NULL);
  nassertr(Dtool_Ptr_ConstPointerToArray_float->_Dtool_Coerce != NULL, NULL);
  return ((ConstPointerToArray< float > *(*)(PyObject *, ConstPointerToArray< float > &))Dtool_Ptr_ConstPointerToArray_float->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ConstPointerToArray_float;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_float = &Dtool_ConstPointerToArray_float;
extern ConstPointerToArray< float > *Dtool_Coerce_ConstPointerToArray_float(PyObject *args, ConstPointerToArray< float > &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * void auto_bind(PandaNode *root_node, AnimControlCollection &controls, int hierarchy_match_flags = 0)
 */
static PyObject *Dtool_auto_bind_183(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-void auto_bind(PandaNode *root_node, AnimControlCollection &controls, int hierarchy_match_flags = 0)
  PyObject *param0;
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"root_node", "controls", "hierarchy_match_flags", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:auto_bind", (char **)keyword_list, &param0, &param1, &param2)) {
    PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "auto_bind", false, true);
    AnimControlCollection *param1_this = (AnimControlCollection *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimControlCollection, 1, "auto_bind", false, true);
    if (param0_this != NULL && param1_this != NULL) {
      auto_bind(param0_this, *param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "auto_bind(PandaNode root_node, AnimControlCollection controls, int hierarchy_match_flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_auto_bind_183_comment =
  "C++ Interface:\n"
  "auto_bind(PandaNode root_node, AnimControlCollection controls, int hierarchy_match_flags)\n";
#else
static const char *Dtool_auto_bind_183_comment = NULL;
#endif

/**
 * Python wrappers for functions of class AnimGroup
 */
/**
 * Python function wrapper for:
 * int AnimGroup::get_num_children(void) const
 */
static PyObject *Dtool_AnimGroup_get_num_children_10(PyObject *self, PyObject *) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-int AnimGroup::get_num_children(void) const
  int return_value = (*(const AnimGroup*)local_this).get_num_children();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_get_num_children_10_comment =
  "C++ Interface:\n"
  "get_num_children(AnimGroup self)\n"
  "\n"
  "/**\n"
  " * Returns the number of child nodes of the group.\n"
  " */";
#else
static const char *Dtool_AnimGroup_get_num_children_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AnimGroup *AnimGroup::get_child(int n) const
 */
static PyObject *Dtool_AnimGroup_get_child_11(PyObject *self, PyObject *arg) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-AnimGroup *AnimGroup::get_child(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    AnimGroup *return_value = (*(const AnimGroup*)local_this).get_child((int)arg_val);
    if (return_value != (AnimGroup *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AnimGroup *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(AnimGroup self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_get_child_11_comment =
  "C++ Interface:\n"
  "get_child(AnimGroup self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth child of the group.\n"
  " */";
#else
static const char *Dtool_AnimGroup_get_child_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AnimGroup *AnimGroup::get_child_named(std::string const &name) const
 */
static PyObject *Dtool_AnimGroup_get_child_named_15(PyObject *self, PyObject *arg) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-AnimGroup *AnimGroup::get_child_named(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    AnimGroup *return_value = (*(const AnimGroup*)local_this).get_child_named(std::string(param1_str, param1_len));
    if (return_value != (AnimGroup *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AnimGroup *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child_named(AnimGroup self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_get_child_named_15_comment =
  "C++ Interface:\n"
  "get_child_named(AnimGroup self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first child found with the indicated name, or NULL if no such\n"
  " * child exists.  This method searches only the children of this particular\n"
  " * AnimGroup; it does not recursively search the entire graph.  See also\n"
  " * find_child().\n"
  " */";
#else
static const char *Dtool_AnimGroup_get_child_named_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AnimGroup *AnimGroup::find_child(std::string const &name) const
 */
static PyObject *Dtool_AnimGroup_find_child_16(PyObject *self, PyObject *arg) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-AnimGroup *AnimGroup::find_child(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    AnimGroup *return_value = (*(const AnimGroup*)local_this).find_child(std::string(param1_str, param1_len));
    if (return_value != (AnimGroup *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AnimGroup *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_child(AnimGroup self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_find_child_16_comment =
  "C++ Interface:\n"
  "find_child(AnimGroup self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first descendant found with the indicated name, or NULL if no\n"
  " * such descendant exists.  This method searches the entire graph beginning at\n"
  " * this AnimGroup; see also get_child_named().\n"
  " */";
#else
static const char *Dtool_AnimGroup_find_child_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimGroup::sort_descendants(void)
 */
static PyObject *Dtool_AnimGroup_sort_descendants_17(PyObject *self, PyObject *) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimGroup, (void **)&local_this, "AnimGroup.sort_descendants")) {
    return NULL;
  }
  // 1-void AnimGroup::sort_descendants(void)
  (*local_this).sort_descendants();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_sort_descendants_17_comment =
  "C++ Interface:\n"
  "sort_descendants(const AnimGroup self)\n"
  "\n"
  "/**\n"
  " * Sorts the children nodes at each level of the hierarchy into alphabetical\n"
  " * order.  This should be done after creating the hierarchy, to guarantee that\n"
  " * the correct names will match up together when the AnimBundle is later bound\n"
  " * to a PlayerRoot.\n"
  " */";
#else
static const char *Dtool_AnimGroup_sort_descendants_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimGroup::output(ostream &out) const
 */
static PyObject *Dtool_AnimGroup_output_18(PyObject *self, PyObject *arg) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AnimGroup::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AnimGroup.output", false, true);
  if (arg_this != NULL) {
    (*(const AnimGroup*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AnimGroup self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_output_18_comment =
  "C++ Interface:\n"
  "output(AnimGroup self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a one-line description of the group.\n"
  " */";
#else
static const char *Dtool_AnimGroup_output_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimGroup::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_AnimGroup_write_19(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AnimGroup::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "AnimGroup.write", false, true);
    if (param1_this != NULL) {
      (*(const AnimGroup*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AnimGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_write_19_comment =
  "C++ Interface:\n"
  "write(AnimGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a brief description of the group and all of its descendants.\n"
  " */";
#else
static const char *Dtool_AnimGroup_write_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimGroup::get_class_type(void)
 */
static PyObject *Dtool_AnimGroup_get_class_type_20(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimGroup::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimGroup::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_get_class_type_20_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimGroup_get_class_type_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *AnimGroup::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3(PyObject *self, PyObject *) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimGroup, (void **)&local_this, "AnimGroup.upcast_to_TypedWritableReferenceCount")) {
    return NULL;
  }
  // 1-TypedWritableReferenceCount *AnimGroup::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const AnimGroup self)\n"
  "\n"
  "upcast from AnimGroup to TypedWritableReferenceCount";
#else
static const char *Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Namable *AnimGroup::upcast_to_Namable(void)
 */
static PyObject *Dtool_AnimGroup_upcast_to_Namable_6(PyObject *self, PyObject *) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimGroup, (void **)&local_this, "AnimGroup.upcast_to_Namable")) {
    return NULL;
  }
  // 1-Namable *AnimGroup::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_upcast_to_Namable_6_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const AnimGroup self)\n"
  "\n"
  "upcast from AnimGroup to Namable";
#else
static const char *Dtool_AnimGroup_upcast_to_Namable_6_comment = NULL;
#endif

/**
 * sequence length function for property AnimGroup::children
 */
static Py_ssize_t Dtool_AnimGroup_children_Len(PyObject *self) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_children();
}

/**
 * sequence getter for property AnimGroup::children
 */
static PyObject *Dtool_AnimGroup_children_Getitem(PyObject *self, Py_ssize_t index) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_children()) {
    PyErr_SetString(PyExc_IndexError, "AnimGroup.children[] index out of range");
    return NULL;
  }
  // 1-AnimGroup *AnimGroup::get_child(int n) const
  AnimGroup *return_value = (*(const AnimGroup*)local_this).get_child(index);
  if (return_value != (AnimGroup *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (AnimGroup *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(AnimGroup self, index)\n");
  }
}

static PyObject *Dtool_AnimGroup_children_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_AnimGroup_children_Len;
  wrap->_getitem_func = &Dtool_AnimGroup_children_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * AnimGroup::AnimGroup(AnimGroup *parent, std::string const &name)
 * inline AnimGroup::AnimGroup(AnimGroup const &) = default
 */
static int Dtool_Init_AnimGroup(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline AnimGroup::AnimGroup(AnimGroup const &) = default
      CPT(AnimGroup) arg_this;
      if (!Dtool_ConstCoerce_AnimGroup(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "AnimGroup.AnimGroup", "AnimGroup");
        return -1;
      }
      AnimGroup *return_value = new AnimGroup(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimGroup, true, false);
    }
    break;
  case 2:
    {
      // 1-AnimGroup::AnimGroup(AnimGroup *parent, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"parent", "name", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:AnimGroup", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
        PT(AnimGroup) param0_this;
        if (!Dtool_Coerce_AnimGroup(param0, param0_this)) {
          Dtool_Raise_ArgTypeError(param0, 0, "AnimGroup.AnimGroup", "AnimGroup");
          return -1;
        }
        AnimGroup *return_value = new AnimGroup(MOVE(param0_this), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimGroup, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AnimGroup() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimGroup(const AnimGroup param0)\n"
      "AnimGroup(AnimGroup parent, str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AnimGroup(PyObject *args, CPT(AnimGroup) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AnimGroup, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-AnimGroup::AnimGroup(AnimGroup *parent, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:AnimGroup", &param0, &param1_str, &param1_len)) {
        AnimGroup *param0_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AnimGroup, 0, "AnimGroup.AnimGroup", false, false);
        if (param0_this != NULL) {
          AnimGroup *return_value = new AnimGroup(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_AnimGroup(PyObject *args, PT(AnimGroup) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AnimGroup, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-AnimGroup::AnimGroup(AnimGroup *parent, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:AnimGroup", &param0, &param1_str, &param1_len)) {
        AnimGroup *param0_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AnimGroup, 0, "AnimGroup.AnimGroup", false, false);
        if (param0_this != NULL) {
          AnimGroup *return_value = new AnimGroup(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_AnimGroup_get_children(PyObject *self, PyObject *) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_children();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_AnimGroup_get_child_11(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_AnimGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimGroup) {
    printf("AnimGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimGroup *local_this = (AnimGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimGroup*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimBundle
 */
/**
 * Python function wrapper for:
 * PointerTo< AnimBundle > AnimBundle::copy_bundle(void) const
 */
static PyObject *Dtool_AnimBundle_copy_bundle_23(PyObject *self, PyObject *) {
  AnimBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-PointerTo< AnimBundle > AnimBundle::copy_bundle(void) const
  PointerTo< AnimBundle > return_value = (*(const AnimBundle*)local_this).copy_bundle();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  AnimBundle *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimBundle, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimBundle_copy_bundle_23_comment =
  "C++ Interface:\n"
  "copy_bundle(AnimBundle self)\n"
  "\n"
  "/**\n"
  " * Returns a full copy of the bundle and its entire tree of nested AnimGroups.\n"
  " * However, the actual data stored in the leaves--that is, animation tables,\n"
  " * such as those stored in an AnimChannelMatrixXfmTable--will be shared.\n"
  " */";
#else
static const char *Dtool_AnimBundle_copy_bundle_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double AnimBundle::get_base_frame_rate(void) const
 */
static PyObject *Dtool_AnimBundle_get_base_frame_rate_24(PyObject *self, PyObject *) {
  AnimBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double AnimBundle::get_base_frame_rate(void) const
  double return_value = (*(const AnimBundle*)local_this).get_base_frame_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimBundle_get_base_frame_rate_24_comment =
  "C++ Interface:\n"
  "get_base_frame_rate(AnimBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the ideal number of frames per second of the animation, when it is\n"
  " * running at normal speed.  This may not be the same as the actual playing\n"
  " * frame rate, as it might have been adjusted through set_play_rate() on the\n"
  " * AnimControl object.  See AnimControl::get_effective_frame_rate().\n"
  " */";
#else
static const char *Dtool_AnimBundle_get_base_frame_rate_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AnimBundle::get_num_frames(void) const
 */
static PyObject *Dtool_AnimBundle_get_num_frames_25(PyObject *self, PyObject *) {
  AnimBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AnimBundle::get_num_frames(void) const
  int return_value = (*(const AnimBundle*)local_this).get_num_frames();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimBundle_get_num_frames_25_comment =
  "C++ Interface:\n"
  "get_num_frames(AnimBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the number of frames of animation, or 0 if the animation has no\n"
  " * fixed number of frames.\n"
  " */";
#else
static const char *Dtool_AnimBundle_get_num_frames_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimBundle::get_class_type(void)
 */
static PyObject *Dtool_AnimBundle_get_class_type_26(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimBundle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimBundle::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimBundle_get_class_type_26_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimBundle_get_class_type_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AnimBundle::AnimBundle(AnimBundle const &) = default
 * inline AnimBundle::AnimBundle(std::string const &name, PN_stdfloat fps, int num_frames)
 */
static int Dtool_Init_AnimBundle(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline AnimBundle::AnimBundle(AnimBundle const &) = default
      CPT(AnimBundle) arg_this;
      if (!Dtool_ConstCoerce_AnimBundle(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "AnimBundle.AnimBundle", "AnimBundle");
        return -1;
      }
      AnimBundle *return_value = new AnimBundle(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimBundle, true, false);
    }
    break;
  case 3:
    {
      // 1-inline AnimBundle::AnimBundle(std::string const &name, PN_stdfloat fps, int num_frames)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      float param1;
      int param2;
      static const char *keyword_list[] = {"name", "fps", "num_frames", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#fi:AnimBundle", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2)) {
        AnimBundle *return_value = new AnimBundle(std::string(param0_str, param0_len), (PN_stdfloat)param1, (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimBundle, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AnimBundle() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimBundle(const AnimBundle param0)\n"
      "AnimBundle(str name, float fps, int num_frames)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AnimBundle(PyObject *args, CPT(AnimBundle) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AnimBundle, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline AnimBundle::AnimBundle(std::string const &name, PN_stdfloat fps, int num_frames)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      float param1;
      int param2;
      if (PyArg_ParseTuple(args, "s#fi:AnimBundle", &param0_str, &param0_len, &param1, &param2)) {
        AnimBundle *return_value = new AnimBundle(std::string(param0_str, param0_len), (PN_stdfloat)param1, (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_AnimBundle(PyObject *args, PT(AnimBundle) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AnimBundle, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline AnimBundle::AnimBundle(std::string const &name, PN_stdfloat fps, int num_frames)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      float param1;
      int param2;
      if (PyArg_ParseTuple(args, "s#fi:AnimBundle", &param0_str, &param0_len, &param1, &param2)) {
        AnimBundle *return_value = new AnimBundle(std::string(param0_str, param0_len), (PN_stdfloat)param1, (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_AnimBundle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimBundle) {
    printf("AnimBundle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimBundle *local_this = (AnimBundle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimBundle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimBundle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimBundle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimBundle*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimBundleNode
 */
/**
 * Python function wrapper for:
 * inline AnimBundle *AnimBundleNode::get_bundle(void) const
 */
static PyObject *Dtool_AnimBundleNode_get_bundle_31(PyObject *self, PyObject *) {
  AnimBundleNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimBundleNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline AnimBundle *AnimBundleNode::get_bundle(void) const
  AnimBundle *return_value = (*(const AnimBundleNode*)local_this).get_bundle();
  if (return_value != (AnimBundle *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (AnimBundle *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimBundleNode_get_bundle_31_comment =
  "C++ Interface:\n"
  "get_bundle(AnimBundleNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimBundleNode_get_bundle_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static AnimBundle *AnimBundleNode::find_anim_bundle(PandaNode *root)
 */
static PyObject *Dtool_AnimBundleNode_find_anim_bundle_32(PyObject *, PyObject *arg) {
  // 1-static AnimBundle *AnimBundleNode::find_anim_bundle(PandaNode *root)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 0, "AnimBundleNode.find_anim_bundle", false, true);
  if (arg_this != NULL) {
    AnimBundle *return_value = AnimBundleNode::find_anim_bundle(arg_this);
    if (return_value != (AnimBundle *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AnimBundle *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimBundle, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_anim_bundle(PandaNode root)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimBundleNode_find_anim_bundle_32_comment =
  "C++ Interface:\n"
  "find_anim_bundle(PandaNode root)\n"
  "\n"
  "/**\n"
  " * Recursively walks the scene graph beginning at the indicated node (which\n"
  " * need not be an AnimBundleNode), and returns the first AnimBundle found.\n"
  " * Returns NULL if no AnimBundle can be found.\n"
  " */";
#else
static const char *Dtool_AnimBundleNode_find_anim_bundle_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimBundleNode::get_class_type(void)
 */
static PyObject *Dtool_AnimBundleNode_get_class_type_33(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimBundleNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimBundleNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimBundleNode_get_class_type_33_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimBundleNode_get_class_type_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AnimBundleNode::AnimBundleNode(std::string const &name, AnimBundle *bundle)
 */
static int Dtool_Init_AnimBundleNode(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline AnimBundleNode::AnimBundleNode(std::string const &name, AnimBundle *bundle)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  PyObject *param1;
  static const char *keyword_list[] = {"name", "bundle", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:AnimBundleNode", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    PT(AnimBundle) param1_this;
    if (!Dtool_Coerce_AnimBundle(param1, param1_this)) {
      Dtool_Raise_ArgTypeError(param1, 1, "AnimBundleNode.AnimBundleNode", "AnimBundle");
      return -1;
    }
    AnimBundleNode *return_value = new AnimBundleNode(std::string(param0_str, param0_len), MOVE(param1_this));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimBundleNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimBundleNode(str name, AnimBundle bundle)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AnimBundleNode(PyObject *args, CPT(AnimBundleNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AnimBundleNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline AnimBundleNode::AnimBundleNode(std::string const &name, AnimBundle *bundle)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:AnimBundleNode", &param0_str, &param0_len, &param1)) {
        AnimBundle *param1_this = (AnimBundle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimBundle, 1, "AnimBundleNode.AnimBundleNode", false, false);
        if (param1_this != NULL) {
          AnimBundleNode *return_value = new AnimBundleNode(std::string(param0_str, param0_len), param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_AnimBundleNode(PyObject *args, PT(AnimBundleNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AnimBundleNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline AnimBundleNode::AnimBundleNode(std::string const &name, AnimBundle *bundle)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:AnimBundleNode", &param0_str, &param0_len, &param1)) {
        AnimBundle *param1_this = (AnimBundle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimBundle, 1, "AnimBundleNode.AnimBundleNode", false, false);
        if (param1_this != NULL) {
          AnimBundleNode *return_value = new AnimBundleNode(std::string(param0_str, param0_len), param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_AnimBundleNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimBundleNode) {
    printf("AnimBundleNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimBundleNode *local_this = (AnimBundleNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimBundleNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimBundleNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimBundleNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (AnimBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimBundleNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PartGroup
 */
/**
 * Python function wrapper for:
 * virtual bool PartGroup::is_character_joint(void) const
 */
static PyObject *Dtool_PartGroup_is_character_joint_43(PyObject *self, PyObject *) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool PartGroup::is_character_joint(void) const
  bool return_value = (*(const PartGroup*)local_this).is_character_joint();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_is_character_joint_43_comment =
  "C++ Interface:\n"
  "is_character_joint(PartGroup self)\n"
  "\n"
  "/**\n"
  " * Returns true if this part is a CharacterJoint, false otherwise.  This is a\n"
  " * tiny optimization over is_of_type(CharacterType::get_class_type()).\n"
  " */";
#else
static const char *Dtool_PartGroup_is_character_joint_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PartGroup *PartGroup::make_copy(void) const
 */
static PyObject *Dtool_PartGroup_make_copy_44(PyObject *self, PyObject *) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PartGroup *PartGroup::make_copy(void) const
  PartGroup *return_value = (*(const PartGroup*)local_this).make_copy();
  if (return_value != (PartGroup *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PartGroup *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_make_copy_44_comment =
  "C++ Interface:\n"
  "make_copy(PartGroup self)\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new copy of the node.  Children are not copied, but\n"
  " * see copy_subgraph().\n"
  " */";
#else
static const char *Dtool_PartGroup_make_copy_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PartGroup *PartGroup::copy_subgraph(void) const
 */
static PyObject *Dtool_PartGroup_copy_subgraph_45(PyObject *self, PyObject *) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-PartGroup *PartGroup::copy_subgraph(void) const
  PartGroup *return_value = (*(const PartGroup*)local_this).copy_subgraph();
  if (return_value != (PartGroup *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PartGroup *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_copy_subgraph_45_comment =
  "C++ Interface:\n"
  "copy_subgraph(PartGroup self)\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new copy of this node and of all of its children.\n"
  " */";
#else
static const char *Dtool_PartGroup_copy_subgraph_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int PartGroup::get_num_children(void) const
 */
static PyObject *Dtool_PartGroup_get_num_children_46(PyObject *self, PyObject *) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-int PartGroup::get_num_children(void) const
  int return_value = (*(const PartGroup*)local_this).get_num_children();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_get_num_children_46_comment =
  "C++ Interface:\n"
  "get_num_children(PartGroup self)\n"
  "\n"
  "/**\n"
  " * Returns the number of child nodes of the group.\n"
  " */";
#else
static const char *Dtool_PartGroup_get_num_children_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PartGroup *PartGroup::get_child(int n) const
 */
static PyObject *Dtool_PartGroup_get_child_47(PyObject *self, PyObject *arg) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-PartGroup *PartGroup::get_child(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PartGroup *return_value = (*(const PartGroup*)local_this).get_child((int)arg_val);
    if (return_value != (PartGroup *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (PartGroup *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(PartGroup self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_get_child_47_comment =
  "C++ Interface:\n"
  "get_child(PartGroup self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth child of the group.\n"
  " */";
#else
static const char *Dtool_PartGroup_get_child_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PartGroup *PartGroup::get_child_named(std::string const &name) const
 */
static PyObject *Dtool_PartGroup_get_child_named_51(PyObject *self, PyObject *arg) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-PartGroup *PartGroup::get_child_named(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PartGroup *return_value = (*(const PartGroup*)local_this).get_child_named(std::string(param1_str, param1_len));
    if (return_value != (PartGroup *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (PartGroup *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child_named(PartGroup self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_get_child_named_51_comment =
  "C++ Interface:\n"
  "get_child_named(PartGroup self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first child found with the indicated name, or NULL if no such\n"
  " * child exists.  This method searches only the children of this particular\n"
  " * PartGroup; it does not recursively search the entire graph.  See also\n"
  " * find_child().\n"
  " */";
#else
static const char *Dtool_PartGroup_get_child_named_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PartGroup *PartGroup::find_child(std::string const &name) const
 */
static PyObject *Dtool_PartGroup_find_child_52(PyObject *self, PyObject *arg) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-PartGroup *PartGroup::find_child(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PartGroup *return_value = (*(const PartGroup*)local_this).find_child(std::string(param1_str, param1_len));
    if (return_value != (PartGroup *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (PartGroup *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_child(PartGroup self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_find_child_52_comment =
  "C++ Interface:\n"
  "find_child(PartGroup self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first descendant found with the indicated name, or NULL if no\n"
  " * such descendant exists.  This method searches the entire graph beginning at\n"
  " * this PartGroup; see also get_child_named().\n"
  " */";
#else
static const char *Dtool_PartGroup_find_child_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PartGroup::sort_descendants(void)
 */
static PyObject *Dtool_PartGroup_sort_descendants_53(PyObject *self, PyObject *) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.sort_descendants")) {
    return NULL;
  }
  // 1-void PartGroup::sort_descendants(void)
  (*local_this).sort_descendants();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_sort_descendants_53_comment =
  "C++ Interface:\n"
  "sort_descendants(const PartGroup self)\n"
  "\n"
  "/**\n"
  " * Sorts the children nodes at each level of the hierarchy into alphabetical\n"
  " * order.  This should be done after creating the hierarchy, to guarantee that\n"
  " * the correct names will match up together when the AnimBundle is later bound\n"
  " * to a PlayerRoot.\n"
  " */";
#else
static const char *Dtool_PartGroup_sort_descendants_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PartGroup::apply_freeze(TransformState const *transform)
 */
static PyObject *Dtool_PartGroup_apply_freeze_54(PyObject *self, PyObject *arg) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.apply_freeze")) {
    return NULL;
  }
  // 1-bool PartGroup::apply_freeze(TransformState const *transform)
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "PartGroup.apply_freeze", true, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).apply_freeze(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_freeze(const PartGroup self, const TransformState transform)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_apply_freeze_54_comment =
  "C++ Interface:\n"
  "apply_freeze(const PartGroup self, const TransformState transform)\n"
  "\n"
  "/**\n"
  " * Freezes this particular joint so that it will always hold the specified\n"
  " * transform.  Returns true if this is a joint that can be so frozen, false\n"
  " * otherwise.\n"
  " *\n"
  " * This is normally only called internally by PartBundle::freeze_joint(), but\n"
  " * you may also call it directly.\n"
  " */";
#else
static const char *Dtool_PartGroup_apply_freeze_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool PartGroup::apply_freeze_matrix(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
 */
static PyObject *Dtool_PartGroup_apply_freeze_matrix_55(PyObject *self, PyObject *args, PyObject *kwds) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.apply_freeze_matrix")) {
    return NULL;
  }
  // 1-virtual bool PartGroup::apply_freeze_matrix(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"pos", "hpr", "scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:apply_freeze_matrix", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param1_local;
    LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PartGroup.apply_freeze_matrix", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PartGroup.apply_freeze_matrix", "LVecBase3f");
    }
    LVecBase3f param3_local;
    LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "PartGroup.apply_freeze_matrix", "LVecBase3f");
    }
    bool return_value = (*local_this).apply_freeze_matrix(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_freeze_matrix(const PartGroup self, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_apply_freeze_matrix_55_comment =
  "C++ Interface:\n"
  "apply_freeze_matrix(const PartGroup self, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n"
  "\n"
  "/**\n"
  " * Freezes this particular joint so that it will always hold the specified\n"
  " * transform.  Returns true if this is a joint that can be so frozen, false\n"
  " * otherwise.\n"
  " *\n"
  " * This is normally only called internally by PartBundle::freeze_joint(), but\n"
  " * you may also call it directly.\n"
  " */";
#else
static const char *Dtool_PartGroup_apply_freeze_matrix_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool PartGroup::apply_freeze_scalar(PN_stdfloat value)
 */
static PyObject *Dtool_PartGroup_apply_freeze_scalar_56(PyObject *self, PyObject *arg) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.apply_freeze_scalar")) {
    return NULL;
  }
  // 1-virtual bool PartGroup::apply_freeze_scalar(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    bool return_value = (*local_this).apply_freeze_scalar((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_freeze_scalar(const PartGroup self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_apply_freeze_scalar_56_comment =
  "C++ Interface:\n"
  "apply_freeze_scalar(const PartGroup self, float value)\n"
  "\n"
  "/**\n"
  " * Freezes this particular joint so that it will always hold the specified\n"
  " * transform.  Returns true if this is a joint that can be so frozen, false\n"
  " * otherwise.\n"
  " *\n"
  " * This is normally only called internally by PartBundle::freeze_joint(), but\n"
  " * you may also call it directly.\n"
  " */";
#else
static const char *Dtool_PartGroup_apply_freeze_scalar_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool PartGroup::apply_control(PandaNode *node)
 */
static PyObject *Dtool_PartGroup_apply_control_57(PyObject *self, PyObject *arg) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.apply_control")) {
    return NULL;
  }
  // 1-virtual bool PartGroup::apply_control(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "PartGroup.apply_control", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).apply_control(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_control(const PartGroup self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_apply_control_57_comment =
  "C++ Interface:\n"
  "apply_control(const PartGroup self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Specifies a node to influence this particular joint so that it will always\n"
  " * hold the node's transform.  Returns true if this is a joint that can be so\n"
  " * controlled, false otherwise.\n"
  " *\n"
  " * This is normally only called internally by PartBundle::control_joint(), but\n"
  " * you may also call it directly.\n"
  " */";
#else
static const char *Dtool_PartGroup_apply_control_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool PartGroup::clear_forced_channel(void)
 */
static PyObject *Dtool_PartGroup_clear_forced_channel_58(PyObject *self, PyObject *) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.clear_forced_channel")) {
    return NULL;
  }
  // 1-virtual bool PartGroup::clear_forced_channel(void)
  bool return_value = (*local_this).clear_forced_channel();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_clear_forced_channel_58_comment =
  "C++ Interface:\n"
  "clear_forced_channel(const PartGroup self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous call to apply_freeze() or apply_control().\n"
  " * Returns true if the joint was modified, false otherwise.\n"
  " *\n"
  " * This is normally only called internally by PartBundle::release_joint(), but\n"
  " * you may also call it directly.\n"
  " */";
#else
static const char *Dtool_PartGroup_clear_forced_channel_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual AnimChannelBase *PartGroup::get_forced_channel(void) const
 */
static PyObject *Dtool_PartGroup_get_forced_channel_59(PyObject *self, PyObject *) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual AnimChannelBase *PartGroup::get_forced_channel(void) const
  AnimChannelBase *return_value = (*(const PartGroup*)local_this).get_forced_channel();
  if (return_value != (AnimChannelBase *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (AnimChannelBase *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimChannelBase, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_get_forced_channel_59_comment =
  "C++ Interface:\n"
  "get_forced_channel(PartGroup self)\n"
  "\n"
  "/**\n"
  " * Returns the AnimChannelBase that has been forced to this joint by a\n"
  " * previous call to apply_freeze() or apply_control(), or NULL if no such\n"
  " * channel has been applied.\n"
  " */";
#else
static const char *Dtool_PartGroup_get_forced_channel_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PartGroup::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_PartGroup_write_60(PyObject *self, PyObject *args, PyObject *kwds) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PartGroup::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PartGroup.write", false, true);
    if (param1_this != NULL) {
      (*(const PartGroup*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PartGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_write_60_comment =
  "C++ Interface:\n"
  "write(PartGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a brief description of the group and all of its descendants.\n"
  " */";
#else
static const char *Dtool_PartGroup_write_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PartGroup::write_with_value(ostream &out, int indent_level) const
 */
static PyObject *Dtool_PartGroup_write_with_value_61(PyObject *self, PyObject *args, PyObject *kwds) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PartGroup::write_with_value(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_with_value", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PartGroup.write_with_value", false, true);
    if (param1_this != NULL) {
      (*(const PartGroup*)local_this).write_with_value(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_with_value(PartGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_write_with_value_61_comment =
  "C++ Interface:\n"
  "write_with_value(PartGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a brief description of the group, showing its current value, and\n"
  " * that of all of its descendants.\n"
  " */";
#else
static const char *Dtool_PartGroup_write_with_value_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PartGroup::get_class_type(void)
 */
static PyObject *Dtool_PartGroup_get_class_type_62(PyObject *, PyObject *) {
  // 1-static TypeHandle PartGroup::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PartGroup::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_get_class_type_62_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PartGroup_get_class_type_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *PartGroup::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_36(PyObject *self, PyObject *) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.upcast_to_TypedWritableReferenceCount")) {
    return NULL;
  }
  // 1-TypedWritableReferenceCount *PartGroup::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_36_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const PartGroup self)\n"
  "\n"
  "upcast from PartGroup to TypedWritableReferenceCount";
#else
static const char *Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Namable *PartGroup::upcast_to_Namable(void)
 */
static PyObject *Dtool_PartGroup_upcast_to_Namable_38(PyObject *self, PyObject *) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.upcast_to_Namable")) {
    return NULL;
  }
  // 1-Namable *PartGroup::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_upcast_to_Namable_38_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const PartGroup self)\n"
  "\n"
  "upcast from PartGroup to Namable";
#else
static const char *Dtool_PartGroup_upcast_to_Namable_38_comment = NULL;
#endif

/**
 * sequence length function for property PartGroup::children
 */
static Py_ssize_t Dtool_PartGroup_children_Len(PyObject *self) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_children();
}

/**
 * sequence getter for property PartGroup::children
 */
static PyObject *Dtool_PartGroup_children_Getitem(PyObject *self, Py_ssize_t index) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_children()) {
    PyErr_SetString(PyExc_IndexError, "PartGroup.children[] index out of range");
    return NULL;
  }
  // 1-PartGroup *PartGroup::get_child(int n) const
  PartGroup *return_value = (*(const PartGroup*)local_this).get_child(index);
  if (return_value != (PartGroup *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (PartGroup *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(PartGroup self, index)\n");
  }
}

static PyObject *Dtool_PartGroup_children_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_PartGroup_children_Len;
  wrap->_getitem_func = &Dtool_PartGroup_children_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * PartGroup::PartGroup(PartGroup *parent, std::string const &name)
 */
static int Dtool_Init_PartGroup(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-PartGroup::PartGroup(PartGroup *parent, std::string const &name)
  PyObject *param0;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"parent", "name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:PartGroup", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    PT(PartGroup) param0_this;
    if (!Dtool_Coerce_PartGroup(param0, param0_this)) {
      Dtool_Raise_ArgTypeError(param0, 0, "PartGroup.PartGroup", "PartGroup");
      return -1;
    }
    PartGroup *return_value = new PartGroup(MOVE(param0_this), std::string(param1_str, param1_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartGroup, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PartGroup(PartGroup parent, str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PartGroup(PyObject *args, CPT(PartGroup) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PartGroup, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-PartGroup::PartGroup(PartGroup *parent, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:PartGroup", &param0, &param1_str, &param1_len)) {
        PartGroup *param0_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PartGroup, 0, "PartGroup.PartGroup", false, false);
        if (param0_this != NULL) {
          PartGroup *return_value = new PartGroup(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PartGroup(PyObject *args, PT(PartGroup) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PartGroup, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-PartGroup::PartGroup(PartGroup *parent, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:PartGroup", &param0, &param1_str, &param1_len)) {
        PartGroup *param0_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PartGroup, 0, "PartGroup.PartGroup", false, false);
        if (param0_this != NULL) {
          PartGroup *return_value = new PartGroup(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PartGroup_get_children(PyObject *self, PyObject *) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_children();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PartGroup_get_child_47(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PartGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PartGroup) {
    printf("PartGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PartGroup *local_this = (PartGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PartGroup) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PartGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PartGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PartGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PartGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PartGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PartGroup*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimControl
 */
/**
 * Python function wrapper for:
 * inline bool AnimControl::is_pending(void) const
 */
static PyObject *Dtool_AnimControl_is_pending_73(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControl, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AnimControl::is_pending(void) const
  bool return_value = (*(const AnimControl*)local_this).is_pending();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_is_pending_73_comment =
  "C++ Interface:\n"
  "is_pending(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns true if the AnimControl is being bound asynchronously, and has not\n"
  " * yet finished.  If this is true, the AnimControl's interface is still\n"
  " * available and will be perfectly useful (though get_anim() might return\n"
  " * NULL), but nothing visible will happen immediately.\n"
  " */";
#else
static const char *Dtool_AnimControl_is_pending_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimControl::wait_pending(void)
 */
static PyObject *Dtool_AnimControl_wait_pending_74(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.wait_pending")) {
    return NULL;
  }
  // 1-void AnimControl::wait_pending(void)
  (*local_this).wait_pending();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_wait_pending_74_comment =
  "C++ Interface:\n"
  "wait_pending(const AnimControl self)\n"
  "\n"
  "/**\n"
  " * Blocks the current thread until the AnimControl has finished loading and is\n"
  " * fully bound.\n"
  " */";
#else
static const char *Dtool_AnimControl_wait_pending_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControl::has_anim(void) const
 */
static PyObject *Dtool_AnimControl_has_anim_75(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControl, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AnimControl::has_anim(void) const
  bool return_value = (*(const AnimControl*)local_this).has_anim();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_has_anim_75_comment =
  "C++ Interface:\n"
  "has_anim(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns true if the AnimControl was successfully loaded, or false if there\n"
  " * was a problem.  This may return false while is_pending() is true.\n"
  " */";
#else
static const char *Dtool_AnimControl_has_anim_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimControl::set_pending_done_event(std::string const &done_event)
 */
static PyObject *Dtool_AnimControl_set_pending_done_event_76(PyObject *self, PyObject *arg) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.set_pending_done_event")) {
    return NULL;
  }
  // 1-void AnimControl::set_pending_done_event(std::string const &done_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_pending_done_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pending_done_event(const AnimControl self, str done_event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_set_pending_done_event_76_comment =
  "C++ Interface:\n"
  "set_pending_done_event(const AnimControl self, str done_event)\n"
  "\n"
  "/**\n"
  " * Specifies an event name that will be thrown when the AnimControl is\n"
  " * finished binding asynchronously.  If the AnimControl has already finished\n"
  " * binding, the event will be thrown immediately.\n"
  " */";
#else
static const char *Dtool_AnimControl_set_pending_done_event_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string AnimControl::get_pending_done_event(void) const
 */
static PyObject *Dtool_AnimControl_get_pending_done_event_77(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControl, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string AnimControl::get_pending_done_event(void) const
  std::string return_value = (*(const AnimControl*)local_this).get_pending_done_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_pending_done_event_77_comment =
  "C++ Interface:\n"
  "get_pending_done_event(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the AnimControl is finished\n"
  " * binding asynchronously.\n"
  " */";
#else
static const char *Dtool_AnimControl_get_pending_done_event_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PartBundle *AnimControl::get_part(void) const
 */
static PyObject *Dtool_AnimControl_get_part_78(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControl, (void **)&local_this)) {
    return NULL;
  }
  // 1-PartBundle *AnimControl::get_part(void) const
  PartBundle *return_value = (*(const AnimControl*)local_this).get_part();
  if (return_value != (PartBundle *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PartBundle *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_part_78_comment =
  "C++ Interface:\n"
  "get_part(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns the PartBundle bound in with this AnimControl.\n"
  " */";
#else
static const char *Dtool_AnimControl_get_part_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AnimBundle *AnimControl::get_anim(void) const
 */
static PyObject *Dtool_AnimControl_get_anim_79(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControl, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline AnimBundle *AnimControl::get_anim(void) const
  AnimBundle *return_value = (*(const AnimControl*)local_this).get_anim();
  if (return_value != (AnimBundle *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (AnimBundle *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_anim_79_comment =
  "C++ Interface:\n"
  "get_anim(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns the AnimBundle bound in with this AnimControl.\n"
  " */";
#else
static const char *Dtool_AnimControl_get_anim_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AnimControl::get_channel_index(void) const
 */
static PyObject *Dtool_AnimControl_get_channel_index_80(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControl, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AnimControl::get_channel_index(void) const
  int return_value = (*(const AnimControl*)local_this).get_channel_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_channel_index_80_comment =
  "C++ Interface:\n"
  "get_channel_index(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns the particular channel index associated with this AnimControl.\n"
  " * This channel index is the slot on which each AnimGroup is bound to its\n"
  " * associated PartGroup, for each joint in the animation.\n"
  " *\n"
  " * It will be true that\n"
  " * get_part()->find_child(\"n\")->get_bound(get_channel_index()) ==\n"
  " * get_anim()->find_child(\"n\"), for each joint \"n\".\n"
  " */";
#else
static const char *Dtool_AnimControl_get_channel_index_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BitArray const &AnimControl::get_bound_joints(void) const
 */
static PyObject *Dtool_AnimControl_get_bound_joints_81(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControl, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BitArray const &AnimControl::get_bound_joints(void) const
  BitArray const *return_value = &((*(const AnimControl*)local_this).get_bound_joints());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, false, true);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_bound_joints_81_comment =
  "C++ Interface:\n"
  "get_bound_joints(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns the subset of joints controlled by this AnimControl.  Most of the\n"
  " * time, this will be BitArray::all_on(), for a normal full-body animation.\n"
  " * For a subset animation, however, this will be just a subset of those bits,\n"
  " * corresponding to the set of joints and sliders actually bound (as\n"
  " * enumerated by bind_hierarchy() in depth-first LIFO order).\n"
  " */";
#else
static const char *Dtool_AnimControl_get_bound_joints_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AnimControl::set_anim_model(PandaNode *model)
 */
static PyObject *Dtool_AnimControl_set_anim_model_82(PyObject *self, PyObject *arg) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.set_anim_model")) {
    return NULL;
  }
  // 1-inline void AnimControl::set_anim_model(PandaNode *model)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "AnimControl.set_anim_model", false, true);
  if (arg_this != NULL) {
    (*local_this).set_anim_model(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anim_model(const AnimControl self, PandaNode model)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_set_anim_model_82_comment =
  "C++ Interface:\n"
  "set_anim_model(const AnimControl self, PandaNode model)\n"
  "\n"
  "/**\n"
  " * Associates the indicated PandaNode with the AnimControl.  By convention,\n"
  " * this node represents the root node of the model file that corresponds to\n"
  " * this AnimControl's animation file, though nothing in this code makes this\n"
  " * assumption or indeed does anything with this node.\n"
  " *\n"
  " * The purpose of this is simply to allow the AnimControl to keep a reference\n"
  " * count on the ModelRoot node that generated it, so that the model will not\n"
  " * disappear from the model pool until it is no longer referenced.\n"
  " */";
#else
static const char *Dtool_AnimControl_set_anim_model_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *AnimControl::get_anim_model(void) const
 */
static PyObject *Dtool_AnimControl_get_anim_model_83(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControl, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PandaNode *AnimControl::get_anim_model(void) const
  PandaNode *return_value = (*(const AnimControl*)local_this).get_anim_model();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_anim_model_83_comment =
  "C++ Interface:\n"
  "get_anim_model(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Retrieves the pointer set via set_anim_model().  See set_anim_model().\n"
  " */";
#else
static const char *Dtool_AnimControl_get_anim_model_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimControl::output(ostream &out) const
 */
static PyObject *Dtool_AnimControl_output_84(PyObject *self, PyObject *arg) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControl, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AnimControl::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AnimControl.output", false, true);
  if (arg_this != NULL) {
    (*(const AnimControl*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AnimControl self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_output_84_comment =
  "C++ Interface:\n"
  "output(AnimControl self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimControl_output_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimControl::get_class_type(void)
 */
static PyObject *Dtool_AnimControl_get_class_type_85(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimControl::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimControl::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_class_type_85_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimControl_get_class_type_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *AnimControl::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_AnimControl_upcast_to_TypedReferenceCount_65(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.upcast_to_TypedReferenceCount")) {
    return NULL;
  }
  // 1-TypedReferenceCount *AnimControl::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_upcast_to_TypedReferenceCount_65_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const AnimControl self)\n"
  "\n"
  "upcast from AnimControl to TypedReferenceCount";
#else
static const char *Dtool_AnimControl_upcast_to_TypedReferenceCount_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AnimInterface *AnimControl::upcast_to_AnimInterface(void)
 */
static PyObject *Dtool_AnimControl_upcast_to_AnimInterface_68(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.upcast_to_AnimInterface")) {
    return NULL;
  }
  // 1-AnimInterface *AnimControl::upcast_to_AnimInterface(void)
  AnimInterface *return_value = (AnimInterface *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AnimInterface, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_upcast_to_AnimInterface_68_comment =
  "C++ Interface:\n"
  "upcast_to_AnimInterface(const AnimControl self)\n"
  "\n"
  "upcast from AnimControl to AnimInterface";
#else
static const char *Dtool_AnimControl_upcast_to_AnimInterface_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Namable *AnimControl::upcast_to_Namable(void)
 */
static PyObject *Dtool_AnimControl_upcast_to_Namable_70(PyObject *self, PyObject *) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.upcast_to_Namable")) {
    return NULL;
  }
  // 1-Namable *AnimControl::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_upcast_to_Namable_70_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const AnimControl self)\n"
  "\n"
  "upcast from AnimControl to Namable";
#else
static const char *Dtool_AnimControl_upcast_to_Namable_70_comment = NULL;
#endif

static int Dtool_Init_AnimControl(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimControl(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimControl) {
    printf("AnimControl ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimControl *local_this = (AnimControl *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimControl) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimInterface) {
    return (AnimInterface *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimControl(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimControl) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimInterface) {
    AnimInterface* other_this = (AnimInterface*)from_this;
    return (AnimControl*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimControl*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimControl*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimControl*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AnimControl*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimChannelBase
 */
/**
 * Python function wrapper for:
 * virtual TypeHandle AnimChannelBase::get_type(void) const
 */
static PyObject *Dtool_AnimChannelBase_get_type_87(PyObject *self, PyObject *) {
  AnimChannelBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual TypeHandle AnimChannelBase::get_type(void) const
  TypeHandle *return_value = new TypeHandle((*(const AnimChannelBase*)local_this).get_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelBase_get_type_87_comment =
  "C++ Interface:\n"
  "get_type(AnimChannelBase self)\n";
#else
static const char *Dtool_AnimChannelBase_get_type_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannelBase::get_class_type(void)
 */
static PyObject *Dtool_AnimChannelBase_get_class_type_88(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannelBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimChannelBase::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelBase_get_class_type_88_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannelBase_get_class_type_88_comment = NULL;
#endif

static int Dtool_Init_AnimChannelBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannelBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimChannelBase) {
    printf("AnimChannelBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimChannelBase *local_this = (AnimChannelBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimChannelBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannelBase*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannelBase*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannelBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannelBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannelBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannelBase*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimChannel< ACMatrixSwitchType >
 */
/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_value(int frame, LMatrix4 &value) = 0
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_value_93(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_value")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_value(int frame, LMatrix4 &value) = 0
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_value", (char **)keyword_list, &param1, &param2)) {
    LMatrix4f param2_local;
    LMatrix4 *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_value", "LMatrix4f");
    }
    (*local_this).get_value((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(const AnimChannel self, int frame, LMatrix4f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_93_comment =
  "C++ Interface:\n"
  "get_value(const AnimChannel self, int frame, LMatrix4f value)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear(int frame, LMatrix4 &value)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_94(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_value_no_scale_shear")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear(int frame, LMatrix4 &value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_value_no_scale_shear", (char **)keyword_list, &param1, &param2)) {
    LMatrix4f param2_local;
    LMatrix4 *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_value_no_scale_shear", "LMatrix4f");
    }
    (*local_this).get_value_no_scale_shear((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value_no_scale_shear(const AnimChannel self, int frame, LMatrix4f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_94_comment =
  "C++ Interface:\n"
  "get_value_no_scale_shear(const AnimChannel self, int frame, LMatrix4f value)\n"
  "\n"
  "// These transform-component methods only have meaning for matrix types.";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_scale(int frame, LVecBase3 &scale)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_scale_95(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_scale")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_scale(int frame, LVecBase3 &scale)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_scale", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_scale", "LVecBase3f");
    }
    (*local_this).get_scale((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_scale(const AnimChannel self, int frame, LVecBase3f scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_scale_95_comment =
  "C++ Interface:\n"
  "get_scale(const AnimChannel self, int frame, LVecBase3f scale)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_scale_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_hpr(int frame, LVecBase3 &hpr)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_96(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_hpr")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_hpr(int frame, LVecBase3 &hpr)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "hpr", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_hpr", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_hpr", "LVecBase3f");
    }
    (*local_this).get_hpr((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hpr(const AnimChannel self, int frame, LVecBase3f hpr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_96_comment =
  "C++ Interface:\n"
  "get_hpr(const AnimChannel self, int frame, LVecBase3f hpr)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_quat(int frame, LQuaternion &quat)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_quat_97(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_quat")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_quat(int frame, LQuaternion &quat)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "quat", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_quat", (char **)keyword_list, &param1, &param2)) {
    LQuaternionf param2_local;
    LQuaternion *param2_this = Dtool_Coerce_LQuaternionf(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_quat", "LQuaternionf");
    }
    (*local_this).get_quat((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_quat(const AnimChannel self, int frame, LQuaternionf quat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_quat_97_comment =
  "C++ Interface:\n"
  "get_quat(const AnimChannel self, int frame, LQuaternionf quat)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_quat_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_pos(int frame, LVecBase3 &pos)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_pos_98(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_pos")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_pos(int frame, LVecBase3 &pos)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "pos", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_pos", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_pos", "LVecBase3f");
    }
    (*local_this).get_pos((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pos(const AnimChannel self, int frame, LVecBase3f pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_pos_98_comment =
  "C++ Interface:\n"
  "get_pos(const AnimChannel self, int frame, LVecBase3f pos)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_pos_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_shear(int frame, LVecBase3 &shear)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_shear_99(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_shear")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_shear(int frame, LVecBase3 &shear)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "shear", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_shear", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_shear", "LVecBase3f");
    }
    (*local_this).get_shear((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shear(const AnimChannel self, int frame, LVecBase3f shear)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_shear_99_comment =
  "C++ Interface:\n"
  "get_shear(const AnimChannel self, int frame, LVecBase3f shear)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_shear_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual TypeHandle AnimChannel< ACMatrixSwitchType >::get_value_type(void) const
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_100(PyObject *self, PyObject *) {
  AnimChannel< ACMatrixSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual TypeHandle AnimChannel< ACMatrixSwitchType >::get_value_type(void) const
  TypeHandle *return_value = new TypeHandle((*(const AnimChannel< ACMatrixSwitchType >*)local_this).get_value_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_100_comment =
  "C++ Interface:\n"
  "get_value_type(AnimChannel self)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannel< ACMatrixSwitchType >::get_class_type(void)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_101(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannel< ACMatrixSwitchType >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimChannel< ACMatrixSwitchType >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_101_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_101_comment = NULL;
#endif

static int Dtool_Init_AnimChannel_ACMatrixSwitchType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannel_ACMatrixSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    printf("AnimChannel_ACMatrixSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimChannel< ACMatrixSwitchType > *local_this = (AnimChannel< ACMatrixSwitchType > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimChannel_ACMatrixSwitchType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimChannel< ACScalarSwitchType >
 */
/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACScalarSwitchType >::get_scale(int frame, LVecBase3 &scale)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_scale_106(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACScalarSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACScalarSwitchType, (void **)&local_this, "AnimChannel_ACScalarSwitchType.get_scale")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACScalarSwitchType >::get_scale(int frame, LVecBase3 &scale)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_scale", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_scale", "LVecBase3f");
    }
    (*local_this).get_scale((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_scale(const AnimChannel self, int frame, LVecBase3f scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_scale_106_comment =
  "C++ Interface:\n"
  "get_scale(const AnimChannel self, int frame, LVecBase3f scale)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_scale_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACScalarSwitchType >::get_hpr(int frame, LVecBase3 &hpr)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_hpr_107(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACScalarSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACScalarSwitchType, (void **)&local_this, "AnimChannel_ACScalarSwitchType.get_hpr")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACScalarSwitchType >::get_hpr(int frame, LVecBase3 &hpr)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "hpr", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_hpr", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_hpr", "LVecBase3f");
    }
    (*local_this).get_hpr((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hpr(const AnimChannel self, int frame, LVecBase3f hpr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_hpr_107_comment =
  "C++ Interface:\n"
  "get_hpr(const AnimChannel self, int frame, LVecBase3f hpr)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_hpr_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACScalarSwitchType >::get_quat(int frame, LQuaternion &quat)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_quat_108(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACScalarSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACScalarSwitchType, (void **)&local_this, "AnimChannel_ACScalarSwitchType.get_quat")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACScalarSwitchType >::get_quat(int frame, LQuaternion &quat)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "quat", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_quat", (char **)keyword_list, &param1, &param2)) {
    LQuaternionf param2_local;
    LQuaternion *param2_this = Dtool_Coerce_LQuaternionf(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_quat", "LQuaternionf");
    }
    (*local_this).get_quat((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_quat(const AnimChannel self, int frame, LQuaternionf quat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_quat_108_comment =
  "C++ Interface:\n"
  "get_quat(const AnimChannel self, int frame, LQuaternionf quat)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_quat_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACScalarSwitchType >::get_pos(int frame, LVecBase3 &pos)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_pos_109(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACScalarSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACScalarSwitchType, (void **)&local_this, "AnimChannel_ACScalarSwitchType.get_pos")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACScalarSwitchType >::get_pos(int frame, LVecBase3 &pos)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "pos", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_pos", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_pos", "LVecBase3f");
    }
    (*local_this).get_pos((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pos(const AnimChannel self, int frame, LVecBase3f pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_pos_109_comment =
  "C++ Interface:\n"
  "get_pos(const AnimChannel self, int frame, LVecBase3f pos)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_pos_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACScalarSwitchType >::get_shear(int frame, LVecBase3 &shear)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_shear_110(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACScalarSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACScalarSwitchType, (void **)&local_this, "AnimChannel_ACScalarSwitchType.get_shear")) {
    return NULL;
  }
  // 1-virtual void AnimChannel< ACScalarSwitchType >::get_shear(int frame, LVecBase3 &shear)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "shear", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_shear", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_shear", "LVecBase3f");
    }
    (*local_this).get_shear((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shear(const AnimChannel self, int frame, LVecBase3f shear)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_shear_110_comment =
  "C++ Interface:\n"
  "get_shear(const AnimChannel self, int frame, LVecBase3f shear)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_shear_110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual TypeHandle AnimChannel< ACScalarSwitchType >::get_value_type(void) const
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_value_type_111(PyObject *self, PyObject *) {
  AnimChannel< ACScalarSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannel_ACScalarSwitchType, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual TypeHandle AnimChannel< ACScalarSwitchType >::get_value_type(void) const
  TypeHandle *return_value = new TypeHandle((*(const AnimChannel< ACScalarSwitchType >*)local_this).get_value_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_value_type_111_comment =
  "C++ Interface:\n"
  "get_value_type(AnimChannel self)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_value_type_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannel< ACScalarSwitchType >::get_class_type(void)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_class_type_112(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannel< ACScalarSwitchType >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimChannel< ACScalarSwitchType >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_class_type_112_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_class_type_112_comment = NULL;
#endif

static int Dtool_Init_AnimChannel_ACScalarSwitchType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannel_ACScalarSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    printf("AnimChannel_ACScalarSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimChannel< ACScalarSwitchType > *local_this = (AnimChannel< ACScalarSwitchType > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimChannel_ACScalarSwitchType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimChannelMatrixDynamic
 */
/**
 * Python function wrapper for:
 * void AnimChannelMatrixDynamic::set_value(LMatrix4 const &value)
 * void AnimChannelMatrixDynamic::set_value(TransformState const *value)
 */
static PyObject *Dtool_AnimChannelMatrixDynamic_set_value_115(PyObject *self, PyObject *arg) {
  AnimChannelMatrixDynamic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixDynamic, (void **)&local_this, "AnimChannelMatrixDynamic.set_value")) {
    return NULL;
  }
  {
    // -2 void AnimChannelMatrixDynamic::set_value(LMatrix4 const &value)
    LMatrix4 const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_value(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void AnimChannelMatrixDynamic::set_value(TransformState const *value)
    TransformState const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TransformState, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_value(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void AnimChannelMatrixDynamic::set_value(LMatrix4 const &value)
    LMatrix4f arg_local;
    LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_value(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void AnimChannelMatrixDynamic::set_value(TransformState const *value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const AnimChannelMatrixDynamic self, const LMatrix4f value)\n"
      "set_value(const AnimChannelMatrixDynamic self, const TransformState value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixDynamic_set_value_115_comment =
  "C++ Interface:\n"
  "set_value(const AnimChannelMatrixDynamic self, const LMatrix4f value)\n"
  "set_value(const AnimChannelMatrixDynamic self, const TransformState value)\n"
  "\n"
  "/**\n"
  " * Explicitly sets the matrix value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Explicitly sets the matrix value, using the indicated TransformState object\n"
  " * as a convenience.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixDynamic_set_value_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimChannelMatrixDynamic::set_value_node(PandaNode *node)
 */
static PyObject *Dtool_AnimChannelMatrixDynamic_set_value_node_116(PyObject *self, PyObject *arg) {
  AnimChannelMatrixDynamic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixDynamic, (void **)&local_this, "AnimChannelMatrixDynamic.set_value_node")) {
    return NULL;
  }
  // 1-void AnimChannelMatrixDynamic::set_value_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "AnimChannelMatrixDynamic.set_value_node", false, true);
  if (arg_this != NULL) {
    (*local_this).set_value_node(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value_node(const AnimChannelMatrixDynamic self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixDynamic_set_value_node_116_comment =
  "C++ Interface:\n"
  "set_value_node(const AnimChannelMatrixDynamic self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Specifies a node whose transform will be queried each frame to implicitly\n"
  " * specify the transform of this joint.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixDynamic_set_value_node_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *AnimChannelMatrixDynamic::get_value_transform(void) const
 */
static PyObject *Dtool_AnimChannelMatrixDynamic_get_value_transform_117(PyObject *self, PyObject *) {
  AnimChannelMatrixDynamic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelMatrixDynamic, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TransformState const *AnimChannelMatrixDynamic::get_value_transform(void) const
  TransformState const *return_value = (*(const AnimChannelMatrixDynamic*)local_this).get_value_transform();
  if (return_value != (TransformState const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (TransformState const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TransformState, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixDynamic_get_value_transform_117_comment =
  "C++ Interface:\n"
  "get_value_transform(AnimChannelMatrixDynamic self)\n"
  "\n"
  "/**\n"
  " * Returns the explicit TransformState value that was set via set_value(), if\n"
  " * any.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixDynamic_get_value_transform_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *AnimChannelMatrixDynamic::get_value_node(void) const
 */
static PyObject *Dtool_AnimChannelMatrixDynamic_get_value_node_118(PyObject *self, PyObject *) {
  AnimChannelMatrixDynamic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelMatrixDynamic, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PandaNode *AnimChannelMatrixDynamic::get_value_node(void) const
  PandaNode *return_value = (*(const AnimChannelMatrixDynamic*)local_this).get_value_node();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixDynamic_get_value_node_118_comment =
  "C++ Interface:\n"
  "get_value_node(AnimChannelMatrixDynamic self)\n"
  "\n"
  "/**\n"
  " * Returns the node that was set via set_value_node(), if any.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixDynamic_get_value_node_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannelMatrixDynamic::get_class_type(void)
 */
static PyObject *Dtool_AnimChannelMatrixDynamic_get_class_type_119(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannelMatrixDynamic::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimChannelMatrixDynamic::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixDynamic_get_class_type_119_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannelMatrixDynamic_get_class_type_119_comment = NULL;
#endif

static int Dtool_Init_AnimChannelMatrixDynamic(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannelMatrixDynamic(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimChannelMatrixDynamic) {
    printf("AnimChannelMatrixDynamic ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimChannelMatrixDynamic *local_this = (AnimChannelMatrixDynamic *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimChannelMatrixDynamic) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    return (AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimChannelMatrixDynamic(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimChannelMatrixDynamic) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    AnimChannel< ACMatrixSwitchType >* other_this = (AnimChannel< ACMatrixSwitchType >*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimChannelMatrixXfmTable
 */
/**
 * Python function wrapper for:
 * static inline bool AnimChannelMatrixXfmTable::is_valid_id(char table_id)
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_is_valid_id_123(PyObject *, PyObject *arg) {
  // 1-static inline bool AnimChannelMatrixXfmTable::is_valid_id(char table_id)
  char param0;
  if (PyArg_Parse(arg, "c:is_valid_id", &param0)) {
    bool return_value = AnimChannelMatrixXfmTable::is_valid_id((char) param0);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_valid_id(char table_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_is_valid_id_123_comment =
  "C++ Interface:\n"
  "is_valid_id(char table_id)\n"
  "\n"
  "/**\n"
  " * Returns true if the given letter is one of the nine valid table id's.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_is_valid_id_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimChannelMatrixXfmTable::set_table(char table_id, CPTA_stdfloat const &table)
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_set_table_124(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannelMatrixXfmTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixXfmTable, (void **)&local_this, "AnimChannelMatrixXfmTable.set_table")) {
    return NULL;
  }
  // 1-void AnimChannelMatrixXfmTable::set_table(char table_id, CPTA_stdfloat const &table)
  char param1;
  PyObject *param2;
  static const char *keyword_list[] = {"table_id", "table", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "cO:set_table", (char **)keyword_list, &param1, &param2)) {
    ConstPointerToArray< float > param2_local;
    CPTA_stdfloat const *param2_this = Dtool_Coerce_ConstPointerToArray_float(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannelMatrixXfmTable.set_table", "ConstPointerToArray");
    }
    (*local_this).set_table((char) param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_table(const AnimChannelMatrixXfmTable self, char table_id, const ConstPointerToArray table)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_set_table_124_comment =
  "C++ Interface:\n"
  "set_table(const AnimChannelMatrixXfmTable self, char table_id, const ConstPointerToArray table)\n"
  "\n"
  "/**\n"
  " * Assigns the indicated table.  table_id is one of 'i', 'j', 'k', for scale,\n"
  " * 'a', 'b', 'c' for shear, 'h', 'p', 'r', for rotation, and 'x', 'y', 'z',\n"
  " * for translation.  The new table must have either zero, one, or\n"
  " * get_num_frames() frames.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_set_table_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CPTA_stdfloat AnimChannelMatrixXfmTable::get_table(char table_id) const
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_get_table_125(PyObject *self, PyObject *arg) {
  AnimChannelMatrixXfmTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelMatrixXfmTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CPTA_stdfloat AnimChannelMatrixXfmTable::get_table(char table_id) const
  char param1;
  if (PyArg_Parse(arg, "c:get_table", &param1)) {
    CPTA_stdfloat *return_value = new CPTA_stdfloat((*(const AnimChannelMatrixXfmTable*)local_this).get_table((char) param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_float, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_table(AnimChannelMatrixXfmTable self, char table_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_get_table_125_comment =
  "C++ Interface:\n"
  "get_table(AnimChannelMatrixXfmTable self, char table_id)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the indicated subtable's data, if it exists, or NULL\n"
  " * if it does not.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_get_table_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimChannelMatrixXfmTable::clear_all_tables(void)
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_clear_all_tables_126(PyObject *self, PyObject *) {
  AnimChannelMatrixXfmTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixXfmTable, (void **)&local_this, "AnimChannelMatrixXfmTable.clear_all_tables")) {
    return NULL;
  }
  // 1-void AnimChannelMatrixXfmTable::clear_all_tables(void)
  (*local_this).clear_all_tables();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_clear_all_tables_126_comment =
  "C++ Interface:\n"
  "clear_all_tables(const AnimChannelMatrixXfmTable self)\n"
  "\n"
  "/**\n"
  " * Removes all the tables from the channel, and resets it to its initial\n"
  " * state.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_clear_all_tables_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimChannelMatrixXfmTable::has_table(char table_id) const
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_has_table_127(PyObject *self, PyObject *arg) {
  AnimChannelMatrixXfmTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelMatrixXfmTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AnimChannelMatrixXfmTable::has_table(char table_id) const
  char param1;
  if (PyArg_Parse(arg, "c:has_table", &param1)) {
    bool return_value = (*(const AnimChannelMatrixXfmTable*)local_this).has_table((char) param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_table(AnimChannelMatrixXfmTable self, char table_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_has_table_127_comment =
  "C++ Interface:\n"
  "has_table(AnimChannelMatrixXfmTable self, char table_id)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated subtable has been assigned.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_has_table_127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AnimChannelMatrixXfmTable::clear_table(char table_id)
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_clear_table_128(PyObject *self, PyObject *arg) {
  AnimChannelMatrixXfmTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixXfmTable, (void **)&local_this, "AnimChannelMatrixXfmTable.clear_table")) {
    return NULL;
  }
  // 1-inline void AnimChannelMatrixXfmTable::clear_table(char table_id)
  char param1;
  if (PyArg_Parse(arg, "c:clear_table", &param1)) {
    (*local_this).clear_table((char) param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_table(const AnimChannelMatrixXfmTable self, char table_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_clear_table_128_comment =
  "C++ Interface:\n"
  "clear_table(const AnimChannelMatrixXfmTable self, char table_id)\n"
  "\n"
  "/**\n"
  " * Removes the indicated table from the definition.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_clear_table_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannelMatrixXfmTable::get_class_type(void)
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_get_class_type_129(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannelMatrixXfmTable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimChannelMatrixXfmTable::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_get_class_type_129_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_get_class_type_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable(AnimGroup *parent, std::string const &name)
 */
static int Dtool_Init_AnimChannelMatrixXfmTable(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable(AnimGroup *parent, std::string const &name)
  PyObject *param0;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"parent", "name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:AnimChannelMatrixXfmTable", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    PT(AnimGroup) param0_this;
    if (!Dtool_Coerce_AnimGroup(param0, param0_this)) {
      Dtool_Raise_ArgTypeError(param0, 0, "AnimChannelMatrixXfmTable.AnimChannelMatrixXfmTable", "AnimGroup");
      return -1;
    }
    AnimChannelMatrixXfmTable *return_value = new AnimChannelMatrixXfmTable(MOVE(param0_this), std::string(param1_str, param1_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimChannelMatrixXfmTable, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimChannelMatrixXfmTable(AnimGroup parent, str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AnimChannelMatrixXfmTable(PyObject *args, CPT(AnimChannelMatrixXfmTable) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AnimChannelMatrixXfmTable, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable(AnimGroup *parent, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:AnimChannelMatrixXfmTable", &param0, &param1_str, &param1_len)) {
        AnimGroup *param0_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AnimGroup, 0, "AnimChannelMatrixXfmTable.AnimChannelMatrixXfmTable", false, false);
        if (param0_this != NULL) {
          AnimChannelMatrixXfmTable *return_value = new AnimChannelMatrixXfmTable(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_AnimChannelMatrixXfmTable(PyObject *args, PT(AnimChannelMatrixXfmTable) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AnimChannelMatrixXfmTable, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable(AnimGroup *parent, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:AnimChannelMatrixXfmTable", &param0, &param1_str, &param1_len)) {
        AnimGroup *param0_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AnimGroup, 0, "AnimChannelMatrixXfmTable.AnimChannelMatrixXfmTable", false, false);
        if (param0_this != NULL) {
          AnimChannelMatrixXfmTable *return_value = new AnimChannelMatrixXfmTable(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_AnimChannelMatrixXfmTable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimChannelMatrixXfmTable) {
    printf("AnimChannelMatrixXfmTable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimChannelMatrixXfmTable *local_this = (AnimChannelMatrixXfmTable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimChannelMatrixXfmTable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    return (AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimChannelMatrixXfmTable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimChannelMatrixXfmTable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    AnimChannel< ACMatrixSwitchType >* other_this = (AnimChannel< ACMatrixSwitchType >*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimChannelScalarDynamic
 */
/**
 * Python function wrapper for:
 * void AnimChannelScalarDynamic::set_value(PN_stdfloat value)
 */
static PyObject *Dtool_AnimChannelScalarDynamic_set_value_131(PyObject *self, PyObject *arg) {
  AnimChannelScalarDynamic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelScalarDynamic, (void **)&local_this, "AnimChannelScalarDynamic.set_value")) {
    return NULL;
  }
  // 1-void AnimChannelScalarDynamic::set_value(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_value((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const AnimChannelScalarDynamic self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarDynamic_set_value_131_comment =
  "C++ Interface:\n"
  "set_value(const AnimChannelScalarDynamic self, float value)\n"
  "\n"
  "/**\n"
  " * Explicitly sets the value.\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarDynamic_set_value_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimChannelScalarDynamic::set_value_node(PandaNode *node)
 */
static PyObject *Dtool_AnimChannelScalarDynamic_set_value_node_132(PyObject *self, PyObject *arg) {
  AnimChannelScalarDynamic *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelScalarDynamic, (void **)&local_this, "AnimChannelScalarDynamic.set_value_node")) {
    return NULL;
  }
  // 1-void AnimChannelScalarDynamic::set_value_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "AnimChannelScalarDynamic.set_value_node", false, true);
  if (arg_this != NULL) {
    (*local_this).set_value_node(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value_node(const AnimChannelScalarDynamic self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarDynamic_set_value_node_132_comment =
  "C++ Interface:\n"
  "set_value_node(const AnimChannelScalarDynamic self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Specifies a node whose transform will be queried each frame to implicitly\n"
  " * specify the transform of this joint.\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarDynamic_set_value_node_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannelScalarDynamic::get_class_type(void)
 */
static PyObject *Dtool_AnimChannelScalarDynamic_get_class_type_133(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannelScalarDynamic::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimChannelScalarDynamic::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarDynamic_get_class_type_133_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannelScalarDynamic_get_class_type_133_comment = NULL;
#endif

static int Dtool_Init_AnimChannelScalarDynamic(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannelScalarDynamic(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimChannelScalarDynamic) {
    printf("AnimChannelScalarDynamic ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimChannelScalarDynamic *local_this = (AnimChannelScalarDynamic *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimChannelScalarDynamic) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    return (AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimChannelScalarDynamic(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimChannelScalarDynamic) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    AnimChannel< ACScalarSwitchType >* other_this = (AnimChannel< ACScalarSwitchType >*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimChannelScalarTable
 */
/**
 * Python function wrapper for:
 * void AnimChannelScalarTable::set_table(CPTA_stdfloat const &table)
 */
static PyObject *Dtool_AnimChannelScalarTable_set_table_136(PyObject *self, PyObject *arg) {
  AnimChannelScalarTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelScalarTable, (void **)&local_this, "AnimChannelScalarTable.set_table")) {
    return NULL;
  }
  // 1-void AnimChannelScalarTable::set_table(CPTA_stdfloat const &table)
  ConstPointerToArray< float > arg_local;
  CPTA_stdfloat const *arg_this = Dtool_Coerce_ConstPointerToArray_float(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AnimChannelScalarTable.set_table", "ConstPointerToArray");
  }
  (*local_this).set_table(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_table(const AnimChannelScalarTable self, const ConstPointerToArray table)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarTable_set_table_136_comment =
  "C++ Interface:\n"
  "set_table(const AnimChannelScalarTable self, const ConstPointerToArray table)\n"
  "\n"
  "/**\n"
  " * Assigns the data table.\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarTable_set_table_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CPTA_stdfloat AnimChannelScalarTable::get_table(void) const
 */
static PyObject *Dtool_AnimChannelScalarTable_get_table_137(PyObject *self, PyObject *) {
  AnimChannelScalarTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelScalarTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CPTA_stdfloat AnimChannelScalarTable::get_table(void) const
  CPTA_stdfloat *return_value = new CPTA_stdfloat((*(const AnimChannelScalarTable*)local_this).get_table());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_float, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarTable_get_table_137_comment =
  "C++ Interface:\n"
  "get_table(AnimChannelScalarTable self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the table's data, if it exists, or NULL if it does\n"
  " * not.\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarTable_get_table_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimChannelScalarTable::has_table(void) const
 */
static PyObject *Dtool_AnimChannelScalarTable_has_table_138(PyObject *self, PyObject *) {
  AnimChannelScalarTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelScalarTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AnimChannelScalarTable::has_table(void) const
  bool return_value = (*(const AnimChannelScalarTable*)local_this).has_table();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarTable_has_table_138_comment =
  "C++ Interface:\n"
  "has_table(AnimChannelScalarTable self)\n"
  "\n"
  "/**\n"
  " * Returns true if the data table has been assigned.\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarTable_has_table_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AnimChannelScalarTable::clear_table(void)
 */
static PyObject *Dtool_AnimChannelScalarTable_clear_table_139(PyObject *self, PyObject *) {
  AnimChannelScalarTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelScalarTable, (void **)&local_this, "AnimChannelScalarTable.clear_table")) {
    return NULL;
  }
  // 1-inline void AnimChannelScalarTable::clear_table(void)
  (*local_this).clear_table();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarTable_clear_table_139_comment =
  "C++ Interface:\n"
  "clear_table(const AnimChannelScalarTable self)\n"
  "\n"
  "/**\n"
  " * Empties the data table.\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarTable_clear_table_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannelScalarTable::get_class_type(void)
 */
static PyObject *Dtool_AnimChannelScalarTable_get_class_type_140(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannelScalarTable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimChannelScalarTable::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarTable_get_class_type_140_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannelScalarTable_get_class_type_140_comment = NULL;
#endif

static int Dtool_Init_AnimChannelScalarTable(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannelScalarTable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimChannelScalarTable) {
    printf("AnimChannelScalarTable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimChannelScalarTable *local_this = (AnimChannelScalarTable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimChannelScalarTable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    return (AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimChannelScalarTable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimChannelScalarTable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    AnimChannel< ACScalarSwitchType >* other_this = (AnimChannel< ACScalarSwitchType >*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimControlCollection
 */
/**
 * Python function wrapper for:
 * void AnimControlCollection::store_anim(AnimControl *control, std::string const &name)
 */
static PyObject *Dtool_AnimControlCollection_store_anim_145(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.store_anim")) {
    return NULL;
  }
  // 1-void AnimControlCollection::store_anim(AnimControl *control, std::string const &name)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"control", "name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:store_anim", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    AnimControl *param1_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimControl, 1, "AnimControlCollection.store_anim", false, true);
    if (param1_this != NULL) {
      (*local_this).store_anim(param1_this, std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store_anim(const AnimControlCollection self, AnimControl control, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_store_anim_145_comment =
  "C++ Interface:\n"
  "store_anim(const AnimControlCollection self, AnimControl control, str name)\n"
  "\n"
  "/**\n"
  " * Associates the given AnimControl with this collection under the given name.\n"
  " * The AnimControl will remain associated until a new AnimControl is\n"
  " * associated with the same name later, or until unbind_anim() is called with\n"
  " * this name.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_store_anim_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AnimControl *AnimControlCollection::find_anim(std::string const &name) const
 */
static PyObject *Dtool_AnimControlCollection_find_anim_146(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-AnimControl *AnimControlCollection::find_anim(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    AnimControl *return_value = (*(const AnimControlCollection*)local_this).find_anim(std::string(param1_str, param1_len));
    if (return_value != (AnimControl *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AnimControl *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimControl, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_anim(AnimControlCollection self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_find_anim_146_comment =
  "C++ Interface:\n"
  "find_anim(AnimControlCollection self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the AnimControl associated with the given name, or NULL if no such\n"
  " * control has been associated.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_find_anim_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool AnimControlCollection::unbind_anim(std::string const &name)
 */
static PyObject *Dtool_AnimControlCollection_unbind_anim_147(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.unbind_anim")) {
    return NULL;
  }
  // 1-bool AnimControlCollection::unbind_anim(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).unbind_anim(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unbind_anim(const AnimControlCollection self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_unbind_anim_147_comment =
  "C++ Interface:\n"
  "unbind_anim(const AnimControlCollection self, str name)\n"
  "\n"
  "/**\n"
  " * Removes the AnimControl associated with the given name, if any.  Returns\n"
  " * true if an AnimControl was removed, false if there was no AnimControl with\n"
  " * the indicated name.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_unbind_anim_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int AnimControlCollection::get_num_anims(void) const
 */
static PyObject *Dtool_AnimControlCollection_get_num_anims_148(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-int AnimControlCollection::get_num_anims(void) const
  int return_value = (*(const AnimControlCollection*)local_this).get_num_anims();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_get_num_anims_148_comment =
  "C++ Interface:\n"
  "get_num_anims(AnimControlCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of AnimControls associated with this collection.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_get_num_anims_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AnimControl *AnimControlCollection::get_anim(int n) const
 */
static PyObject *Dtool_AnimControlCollection_get_anim_149(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-AnimControl *AnimControlCollection::get_anim(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    AnimControl *return_value = (*(const AnimControlCollection*)local_this).get_anim((int)arg_val);
    if (return_value != (AnimControl *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AnimControl *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimControl, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_anim(AnimControlCollection self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_get_anim_149_comment =
  "C++ Interface:\n"
  "get_anim(AnimControlCollection self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth AnimControl associated with this collection.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_get_anim_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string AnimControlCollection::get_anim_name(int n) const
 */
static PyObject *Dtool_AnimControlCollection_get_anim_name_150(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string AnimControlCollection::get_anim_name(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const AnimControlCollection*)local_this).get_anim_name((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_anim_name(AnimControlCollection self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_get_anim_name_150_comment =
  "C++ Interface:\n"
  "get_anim_name(AnimControlCollection self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth AnimControl associated with this collection.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_get_anim_name_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::clear_anims(void)
 */
static PyObject *Dtool_AnimControlCollection_clear_anims_153(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.clear_anims")) {
    return NULL;
  }
  // 1-void AnimControlCollection::clear_anims(void)
  (*local_this).clear_anims();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_clear_anims_153_comment =
  "C++ Interface:\n"
  "clear_anims(const AnimControlCollection self)\n"
  "\n"
  "/**\n"
  " * Disassociates all anims from this collection.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_clear_anims_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControlCollection::play(std::string const &anim_name)
 * inline bool AnimControlCollection::play(std::string const &anim_name, double from, double to)
 */
static PyObject *Dtool_AnimControlCollection_play_154(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.play")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "anim_name");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'anim_name' (pos 1) not found");
      }
      // 1-inline bool AnimControlCollection::play(std::string const &anim_name)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        bool return_value = (*local_this).play(std::string(param1_str, param1_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-inline bool AnimControlCollection::play(std::string const &anim_name, double from, double to)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      double param2;
      double param3;
      static const char *keyword_list[] = {"anim_name", "from", "to", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dd:play", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
        bool return_value = (*local_this).play(std::string(param1_str, param1_len), (double)param2, (double)param3);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "play() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "play(const AnimControlCollection self, str anim_name)\n"
      "play(const AnimControlCollection self, str anim_name, double from, double to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_play_154_comment =
  "C++ Interface:\n"
  "play(const AnimControlCollection self, str anim_name)\n"
  "play(const AnimControlCollection self, str anim_name, double from, double to)\n"
  "\n"
  "/**\n"
  " * Starts the named animation playing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts the named animation playing.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_play_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart)
 * inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart, double from, double to)
 */
static PyObject *Dtool_AnimControlCollection_loop_155(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.loop")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      static const char *keyword_list[] = {"anim_name", "restart", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:loop", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
        bool return_value = (*local_this).loop(std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart, double from, double to)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      double param3;
      double param4;
      static const char *keyword_list[] = {"anim_name", "restart", "from", "to", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Odd:loop", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4)) {
        bool return_value = (*local_this).loop(std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0), (double)param3, (double)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "loop() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "loop(const AnimControlCollection self, str anim_name, bool restart)\n"
      "loop(const AnimControlCollection self, str anim_name, bool restart, double from, double to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_loop_155_comment =
  "C++ Interface:\n"
  "loop(const AnimControlCollection self, str anim_name, bool restart)\n"
  "loop(const AnimControlCollection self, str anim_name, bool restart, double from, double to)\n"
  "\n"
  "/**\n"
  " * Starts the named animation looping.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts the named animation looping.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_loop_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControlCollection::stop(std::string const &anim_name)
 */
static PyObject *Dtool_AnimControlCollection_stop_156(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.stop")) {
    return NULL;
  }
  // 1-inline bool AnimControlCollection::stop(std::string const &anim_name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).stop(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "stop(const AnimControlCollection self, str anim_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_stop_156_comment =
  "C++ Interface:\n"
  "stop(const AnimControlCollection self, str anim_name)\n"
  "\n"
  "/**\n"
  " * Stops the named animation.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_stop_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControlCollection::pose(std::string const &anim_name, double frame)
 */
static PyObject *Dtool_AnimControlCollection_pose_157(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.pose")) {
    return NULL;
  }
  // 1-inline bool AnimControlCollection::pose(std::string const &anim_name, double frame)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  double param2;
  static const char *keyword_list[] = {"anim_name", "frame", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#d:pose", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    bool return_value = (*local_this).pose(std::string(param1_str, param1_len), (double)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pose(const AnimControlCollection self, str anim_name, double frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_pose_157_comment =
  "C++ Interface:\n"
  "pose(const AnimControlCollection self, str anim_name, double frame)\n"
  "\n"
  "/**\n"
  " * Sets to a particular frame in the named animation.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_pose_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::play_all(void)
 * void AnimControlCollection::play_all(double from, double to)
 */
static PyObject *Dtool_AnimControlCollection_play_all_158(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.play_all")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void AnimControlCollection::play_all(void)
      (*local_this).play_all();
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-void AnimControlCollection::play_all(double from, double to)
      double param1;
      double param2;
      static const char *keyword_list[] = {"from", "to", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:play_all", (char **)keyword_list, &param1, &param2)) {
        (*local_this).play_all((double)param1, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "play_all() takes 1 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "play_all(const AnimControlCollection self)\n"
      "play_all(const AnimControlCollection self, double from, double to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_play_all_158_comment =
  "C++ Interface:\n"
  "play_all(const AnimControlCollection self)\n"
  "play_all(const AnimControlCollection self, double from, double to)\n"
  "\n"
  "// These functions operate on all anims at once.\n"
  "\n"
  "/**\n"
  " * Starts all animations playing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts all animations playing.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_play_all_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::loop_all(bool restart)
 * void AnimControlCollection::loop_all(bool restart, double from, double to)
 */
static PyObject *Dtool_AnimControlCollection_loop_all_159(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.loop_all")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "restart");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'restart' (pos 1) not found");
      }
      // 1-void AnimControlCollection::loop_all(bool restart)
      (*local_this).loop_all((PyObject_IsTrue(arg) != 0));
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-void AnimControlCollection::loop_all(bool restart, double from, double to)
      PyObject *param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"restart", "from", "to", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Odd:loop_all", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).loop_all((PyObject_IsTrue(param1) != 0), (double)param2, (double)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "loop_all() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "loop_all(const AnimControlCollection self, bool restart)\n"
      "loop_all(const AnimControlCollection self, bool restart, double from, double to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_loop_all_159_comment =
  "C++ Interface:\n"
  "loop_all(const AnimControlCollection self, bool restart)\n"
  "loop_all(const AnimControlCollection self, bool restart, double from, double to)\n"
  "\n"
  "/**\n"
  " * Starts all animations looping.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts all animations looping.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_loop_all_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool AnimControlCollection::stop_all(void)
 */
static PyObject *Dtool_AnimControlCollection_stop_all_160(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.stop_all")) {
    return NULL;
  }
  // 1-bool AnimControlCollection::stop_all(void)
  bool return_value = (*local_this).stop_all();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_stop_all_160_comment =
  "C++ Interface:\n"
  "stop_all(const AnimControlCollection self)\n"
  "\n"
  "/**\n"
  " * Stops all currently playing animations.  Returns true if any animations\n"
  " * were stopped, false if none were playing.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_stop_all_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::pose_all(double frame)
 */
static PyObject *Dtool_AnimControlCollection_pose_all_161(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.pose_all")) {
    return NULL;
  }
  // 1-void AnimControlCollection::pose_all(double frame)
  if (PyNumber_Check(arg)) {
    (*local_this).pose_all(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pose_all(const AnimControlCollection self, double frame)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_pose_all_161_comment =
  "C++ Interface:\n"
  "pose_all(const AnimControlCollection self, double frame)\n"
  "\n"
  "/**\n"
  " * Sets all animations to the indicated frame.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_pose_all_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AnimControlCollection::get_frame(void) const
 * inline int AnimControlCollection::get_frame(std::string const &anim_name) const
 */
static PyObject *Dtool_AnimControlCollection_get_frame_162(PyObject *self, PyObject *args) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline int AnimControlCollection::get_frame(void) const
      int return_value = (*(const AnimControlCollection*)local_this).get_frame();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int AnimControlCollection::get_frame(std::string const &anim_name) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        int return_value = (*(const AnimControlCollection*)local_this).get_frame(std::string(param1_str, param1_len));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_frame() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_frame(AnimControlCollection self)\n"
      "get_frame(AnimControlCollection self, str anim_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_get_frame_162_comment =
  "C++ Interface:\n"
  "get_frame(AnimControlCollection self)\n"
  "get_frame(AnimControlCollection self, str anim_name)\n"
  "\n"
  "/**\n"
  " * Returns the current frame in the named animation, or 0 if the animation is\n"
  " * not found.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the current frame in the last-started animation.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_get_frame_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AnimControlCollection::get_num_frames(void) const
 * inline int AnimControlCollection::get_num_frames(std::string const &anim_name) const
 */
static PyObject *Dtool_AnimControlCollection_get_num_frames_163(PyObject *self, PyObject *args) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline int AnimControlCollection::get_num_frames(void) const
      int return_value = (*(const AnimControlCollection*)local_this).get_num_frames();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int AnimControlCollection::get_num_frames(std::string const &anim_name) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        int return_value = (*(const AnimControlCollection*)local_this).get_num_frames(std::string(param1_str, param1_len));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_num_frames() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_frames(AnimControlCollection self)\n"
      "get_num_frames(AnimControlCollection self, str anim_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_get_num_frames_163_comment =
  "C++ Interface:\n"
  "get_num_frames(AnimControlCollection self)\n"
  "get_num_frames(AnimControlCollection self, str anim_name)\n"
  "\n"
  "/**\n"
  " * Returns the total number of frames in the named animation, or 0 if the\n"
  " * animation is not found.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the total number of frames in the last-started animation.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_get_num_frames_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControlCollection::is_playing(void) const
 * inline bool AnimControlCollection::is_playing(std::string const &anim_name) const
 */
static PyObject *Dtool_AnimControlCollection_is_playing_164(PyObject *self, PyObject *args) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool AnimControlCollection::is_playing(void) const
      bool return_value = (*(const AnimControlCollection*)local_this).is_playing();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline bool AnimControlCollection::is_playing(std::string const &anim_name) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        bool return_value = (*(const AnimControlCollection*)local_this).is_playing(std::string(param1_str, param1_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "is_playing() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_playing(AnimControlCollection self)\n"
      "is_playing(AnimControlCollection self, str anim_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_is_playing_164_comment =
  "C++ Interface:\n"
  "is_playing(AnimControlCollection self)\n"
  "is_playing(AnimControlCollection self, str anim_name)\n"
  "\n"
  "/**\n"
  " * Returns true if the named animation is currently playing, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the last-started animation is currently playing, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_is_playing_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string AnimControlCollection::which_anim_playing(void) const
 */
static PyObject *Dtool_AnimControlCollection_which_anim_playing_165(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string AnimControlCollection::which_anim_playing(void) const
  std::string return_value = (*(const AnimControlCollection*)local_this).which_anim_playing();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_which_anim_playing_165_comment =
  "C++ Interface:\n"
  "which_anim_playing(AnimControlCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the bound AnimControl currently playing, if any.  If\n"
  " * more than one AnimControl is currently playing, returns all of the names\n"
  " * separated by spaces.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_which_anim_playing_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::output(ostream &out) const
 */
static PyObject *Dtool_AnimControlCollection_output_166(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-void AnimControlCollection::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AnimControlCollection.output", false, true);
  if (arg_this != NULL) {
    (*(const AnimControlCollection*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AnimControlCollection self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_output_166_comment =
  "C++ Interface:\n"
  "output(AnimControlCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_output_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::write(ostream &out) const
 */
static PyObject *Dtool_AnimControlCollection_write_167(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-void AnimControlCollection::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AnimControlCollection.write", false, true);
  if (arg_this != NULL) {
    (*(const AnimControlCollection*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AnimControlCollection self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_write_167_comment =
  "C++ Interface:\n"
  "write(AnimControlCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_write_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AnimControlCollection::AnimControlCollection(void)
 * inline AnimControlCollection::AnimControlCollection(AnimControlCollection const &) = default
 */
static int Dtool_Init_AnimControlCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-AnimControlCollection::AnimControlCollection(void)
      AnimControlCollection *return_value = new AnimControlCollection();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimControlCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline AnimControlCollection::AnimControlCollection(AnimControlCollection const &) = default
      AnimControlCollection const *arg_this = (AnimControlCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AnimControlCollection, 0, "AnimControlCollection.AnimControlCollection", true, true);
      if (arg_this != NULL) {
        AnimControlCollection *return_value = new AnimControlCollection(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimControlCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AnimControlCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimControlCollection()\n"
      "AnimControlCollection(const AnimControlCollection param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_AnimControlCollection_get_anims(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_anims();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_AnimControlCollection_get_anim_149(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_AnimControlCollection_get_anim_names(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_anims();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_AnimControlCollection_get_anim_name_150(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_AnimControlCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimControlCollection) {
    printf("AnimControlCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimControlCollection *local_this = (AnimControlCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimControlCollection) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimControlCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimControlCollection) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AnimPreloadTable
 */
/**
 * Python function wrapper for:
 * int AnimPreloadTable::get_num_anims(void) const
 */
static PyObject *Dtool_AnimPreloadTable_get_num_anims_171(PyObject *self, PyObject *) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimPreloadTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-int AnimPreloadTable::get_num_anims(void) const
  int return_value = (*(const AnimPreloadTable*)local_this).get_num_anims();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_get_num_anims_171_comment =
  "C++ Interface:\n"
  "get_num_anims(AnimPreloadTable self)\n"
  "\n"
  "/**\n"
  " * Returns the number of animation records in the table.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_get_num_anims_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int AnimPreloadTable::find_anim(std::string const &basename) const
 */
static PyObject *Dtool_AnimPreloadTable_find_anim_172(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimPreloadTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-int AnimPreloadTable::find_anim(std::string const &basename) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    int return_value = (*(const AnimPreloadTable*)local_this).find_anim(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_anim(AnimPreloadTable self, str basename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_find_anim_172_comment =
  "C++ Interface:\n"
  "find_anim(AnimPreloadTable self, str basename)\n"
  "\n"
  "/**\n"
  " * Returns the index number in the table of the animation record with the\n"
  " * indicated name, or -1 if the name is not present.  By convention, the\n"
  " * basename is the filename of the egg or bam file, without the directory part\n"
  " * and without the extension.  That is, it is\n"
  " * Filename::get_basename_wo_extension().\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_find_anim_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string AnimPreloadTable::get_basename(int n) const
 */
static PyObject *Dtool_AnimPreloadTable_get_basename_173(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimPreloadTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string AnimPreloadTable::get_basename(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const AnimPreloadTable*)local_this).get_basename((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_basename(AnimPreloadTable self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_get_basename_173_comment =
  "C++ Interface:\n"
  "get_basename(AnimPreloadTable self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the basename stored for the nth animation record.  See find_anim().\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_get_basename_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat AnimPreloadTable::get_base_frame_rate(int n) const
 */
static PyObject *Dtool_AnimPreloadTable_get_base_frame_rate_174(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimPreloadTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat AnimPreloadTable::get_base_frame_rate(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const AnimPreloadTable*)local_this).get_base_frame_rate((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_base_frame_rate(AnimPreloadTable self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_get_base_frame_rate_174_comment =
  "C++ Interface:\n"
  "get_base_frame_rate(AnimPreloadTable self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the frame rate stored for the nth animation record.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_get_base_frame_rate_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AnimPreloadTable::get_num_frames(int n) const
 */
static PyObject *Dtool_AnimPreloadTable_get_num_frames_175(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimPreloadTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AnimPreloadTable::get_num_frames(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const AnimPreloadTable*)local_this).get_num_frames((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_frames(AnimPreloadTable self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_get_num_frames_175_comment =
  "C++ Interface:\n"
  "get_num_frames(AnimPreloadTable self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of frames stored for the nth animation record.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_get_num_frames_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimPreloadTable::clear_anims(void)
 */
static PyObject *Dtool_AnimPreloadTable_clear_anims_176(PyObject *self, PyObject *) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimPreloadTable, (void **)&local_this, "AnimPreloadTable.clear_anims")) {
    return NULL;
  }
  // 1-void AnimPreloadTable::clear_anims(void)
  (*local_this).clear_anims();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_clear_anims_176_comment =
  "C++ Interface:\n"
  "clear_anims(const AnimPreloadTable self)\n"
  "\n"
  "/**\n"
  " * Removes all animation records from the table.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_clear_anims_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimPreloadTable::remove_anim(int n)
 */
static PyObject *Dtool_AnimPreloadTable_remove_anim_177(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimPreloadTable, (void **)&local_this, "AnimPreloadTable.remove_anim")) {
    return NULL;
  }
  // 1-void AnimPreloadTable::remove_anim(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).remove_anim((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_anim(const AnimPreloadTable self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_remove_anim_177_comment =
  "C++ Interface:\n"
  "remove_anim(const AnimPreloadTable self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the nth animation records from the table.  This renumbers indexes\n"
  " * for following animations.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_remove_anim_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimPreloadTable::add_anim(std::string const &basename, PN_stdfloat base_frame_rate, int num_frames)
 */
static PyObject *Dtool_AnimPreloadTable_add_anim_178(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimPreloadTable, (void **)&local_this, "AnimPreloadTable.add_anim")) {
    return NULL;
  }
  // 1-void AnimPreloadTable::add_anim(std::string const &basename, PN_stdfloat base_frame_rate, int num_frames)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  float param2;
  int param3;
  static const char *keyword_list[] = {"basename", "base_frame_rate", "num_frames", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#fi:add_anim", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    (*local_this).add_anim(std::string(param1_str, param1_len), (PN_stdfloat)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_anim(const AnimPreloadTable self, str basename, float base_frame_rate, int num_frames)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_add_anim_178_comment =
  "C++ Interface:\n"
  "add_anim(const AnimPreloadTable self, str basename, float base_frame_rate, int num_frames)\n"
  "\n"
  "/**\n"
  " * Adds a new animation record to the table.  If there is already a record of\n"
  " * this name, no operation is performed (the original record is unchanged).\n"
  " * See find_anim().  This will invalidate existing index numbers.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_add_anim_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AnimPreloadTable::add_anims_from(AnimPreloadTable const *other)
 */
static PyObject *Dtool_AnimPreloadTable_add_anims_from_179(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimPreloadTable, (void **)&local_this, "AnimPreloadTable.add_anims_from")) {
    return NULL;
  }
  // 1-void AnimPreloadTable::add_anims_from(AnimPreloadTable const *other)
  AnimPreloadTable const *arg_this = (AnimPreloadTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AnimPreloadTable, 1, "AnimPreloadTable.add_anims_from", true, true);
  if (arg_this != NULL) {
    (*local_this).add_anims_from(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_anims_from(const AnimPreloadTable self, const AnimPreloadTable other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_add_anims_from_179_comment =
  "C++ Interface:\n"
  "add_anims_from(const AnimPreloadTable self, const AnimPreloadTable other)\n"
  "\n"
  "/**\n"
  " * Copies the animation records from the other table into this one.  If a\n"
  " * given record name exists in both tables, the record in this one supercedes.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_add_anims_from_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimPreloadTable::output(ostream &out) const
 */
static PyObject *Dtool_AnimPreloadTable_output_180(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimPreloadTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AnimPreloadTable::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AnimPreloadTable.output", false, true);
  if (arg_this != NULL) {
    (*(const AnimPreloadTable*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AnimPreloadTable self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_output_180_comment =
  "C++ Interface:\n"
  "output(AnimPreloadTable self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_output_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimPreloadTable::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_AnimPreloadTable_write_181(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimPreloadTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AnimPreloadTable::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "AnimPreloadTable.write", false, true);
    if (param1_this != NULL) {
      (*(const AnimPreloadTable*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AnimPreloadTable self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_write_181_comment =
  "C++ Interface:\n"
  "write(AnimPreloadTable self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_write_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimPreloadTable::get_class_type(void)
 */
static PyObject *Dtool_AnimPreloadTable_get_class_type_182(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimPreloadTable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AnimPreloadTable::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_get_class_type_182_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimPreloadTable_get_class_type_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AnimPreloadTable::AnimPreloadTable(void)
 * inline AnimPreloadTable::AnimPreloadTable(AnimPreloadTable const &) = default
 */
static int Dtool_Init_AnimPreloadTable(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-AnimPreloadTable::AnimPreloadTable(void)
      AnimPreloadTable *return_value = new AnimPreloadTable();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimPreloadTable, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline AnimPreloadTable::AnimPreloadTable(AnimPreloadTable const &) = default
      AnimPreloadTable const *arg_this = (AnimPreloadTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AnimPreloadTable, 0, "AnimPreloadTable.AnimPreloadTable", true, true);
      if (arg_this != NULL) {
        AnimPreloadTable *return_value = new AnimPreloadTable(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimPreloadTable, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AnimPreloadTable() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimPreloadTable()\n"
      "AnimPreloadTable(const AnimPreloadTable param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AnimPreloadTable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AnimPreloadTable) {
    printf("AnimPreloadTable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AnimPreloadTable *local_this = (AnimPreloadTable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AnimPreloadTable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AnimPreloadTable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AnimPreloadTable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PartSubset
 */
/**
 * Python function wrapper for:
 * void PartSubset::operator =(PartSubset const &copy)
 */
static PyObject *Dtool_PartSubset_operator_186(PyObject *self, PyObject *arg) {
  PartSubset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartSubset, (void **)&local_this, "PartSubset.assign")) {
    return NULL;
  }
  // 1-void PartSubset::operator =(PartSubset const &copy)
  PartSubset const *arg_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartSubset, 1, "PartSubset.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    PartSubset *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PartSubset, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PartSubset self, const PartSubset copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_operator_186_comment =
  "C++ Interface:\n"
  "assign(const PartSubset self, const PartSubset copy)\n";
#else
static const char *Dtool_PartSubset_operator_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PartSubset::add_include_joint(GlobPattern const &name)
 */
static PyObject *Dtool_PartSubset_add_include_joint_187(PyObject *self, PyObject *arg) {
  PartSubset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartSubset, (void **)&local_this, "PartSubset.add_include_joint")) {
    return NULL;
  }
  // 1-void PartSubset::add_include_joint(GlobPattern const &name)
  GlobPattern const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_GlobPattern(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PartSubset.add_include_joint", "GlobPattern");
  }
  (*local_this).add_include_joint(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_include_joint(const PartSubset self, const GlobPattern name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_add_include_joint_187_comment =
  "C++ Interface:\n"
  "add_include_joint(const PartSubset self, const GlobPattern name)\n"
  "\n"
  "/**\n"
  " * Adds the named joint to the list of joints that will be explicitly included\n"
  " * in the subset.  Any joint at or below a named node will be included in the\n"
  " * subset (unless a lower node is also listed in the exclude list).\n"
  " *\n"
  " * Since the name is a GlobPattern, it may of course include filename globbing\n"
  " * characters like * and ?.\n"
  " */";
#else
static const char *Dtool_PartSubset_add_include_joint_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PartSubset::add_exclude_joint(GlobPattern const &name)
 */
static PyObject *Dtool_PartSubset_add_exclude_joint_188(PyObject *self, PyObject *arg) {
  PartSubset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartSubset, (void **)&local_this, "PartSubset.add_exclude_joint")) {
    return NULL;
  }
  // 1-void PartSubset::add_exclude_joint(GlobPattern const &name)
  GlobPattern const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_GlobPattern(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PartSubset.add_exclude_joint", "GlobPattern");
  }
  (*local_this).add_exclude_joint(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_exclude_joint(const PartSubset self, const GlobPattern name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_add_exclude_joint_188_comment =
  "C++ Interface:\n"
  "add_exclude_joint(const PartSubset self, const GlobPattern name)\n"
  "\n"
  "/**\n"
  " * Adds the named joint to the list of joints that will be explicitly\n"
  " * exlcluded from the subset.  Any joint at or below a named node will not be\n"
  " * included in the subset (unless a lower node is also listed in the include\n"
  " * list).\n"
  " *\n"
  " * Since the name is a GlobPattern, it may of course include filename globbing\n"
  " * characters like * and ?.\n"
  " */";
#else
static const char *Dtool_PartSubset_add_exclude_joint_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PartSubset::append(PartSubset const &other)
 */
static PyObject *Dtool_PartSubset_append_189(PyObject *self, PyObject *arg) {
  PartSubset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartSubset, (void **)&local_this, "PartSubset.append")) {
    return NULL;
  }
  // 1-void PartSubset::append(PartSubset const &other)
  PartSubset const *arg_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartSubset, 1, "PartSubset.append", true, true);
  if (arg_this != NULL) {
    (*local_this).append(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append(const PartSubset self, const PartSubset other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_append_189_comment =
  "C++ Interface:\n"
  "append(const PartSubset self, const PartSubset other)\n"
  "\n"
  "/**\n"
  " * Appends the include and exclude list from the other object onto this\n"
  " * object's lists.\n"
  " */";
#else
static const char *Dtool_PartSubset_append_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PartSubset::output(ostream &out) const
 */
static PyObject *Dtool_PartSubset_output_190(PyObject *self, PyObject *arg) {
  PartSubset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartSubset, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PartSubset::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PartSubset.output", false, true);
  if (arg_this != NULL) {
    (*(const PartSubset*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PartSubset self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_output_190_comment =
  "C++ Interface:\n"
  "output(PartSubset self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PartSubset_output_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PartSubset::is_include_empty(void) const
 */
static PyObject *Dtool_PartSubset_is_include_empty_191(PyObject *self, PyObject *) {
  PartSubset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartSubset, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PartSubset::is_include_empty(void) const
  bool return_value = (*(const PartSubset*)local_this).is_include_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_is_include_empty_191_comment =
  "C++ Interface:\n"
  "is_include_empty(PartSubset self)\n"
  "\n"
  "/**\n"
  " * Returns true if the include list is completely empty, false otherwise.  If\n"
  " * it is empty, it is the same thing as including all joints.\n"
  " */";
#else
static const char *Dtool_PartSubset_is_include_empty_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PartSubset::matches_include(std::string const &joint_name) const
 */
static PyObject *Dtool_PartSubset_matches_include_192(PyObject *self, PyObject *arg) {
  PartSubset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartSubset, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PartSubset::matches_include(std::string const &joint_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const PartSubset*)local_this).matches_include(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches_include(PartSubset self, str joint_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_matches_include_192_comment =
  "C++ Interface:\n"
  "matches_include(PartSubset self, str joint_name)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated name matches a name on the include list,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_PartSubset_matches_include_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PartSubset::matches_exclude(std::string const &joint_name) const
 */
static PyObject *Dtool_PartSubset_matches_exclude_193(PyObject *self, PyObject *arg) {
  PartSubset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartSubset, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PartSubset::matches_exclude(std::string const &joint_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const PartSubset*)local_this).matches_exclude(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches_exclude(PartSubset self, str joint_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_matches_exclude_193_comment =
  "C++ Interface:\n"
  "matches_exclude(PartSubset self, str joint_name)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated name matches a name on the exclude list,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_PartSubset_matches_exclude_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PartSubset::PartSubset(void)
 * PartSubset::PartSubset(PartSubset const &copy)
 */
static int Dtool_Init_PartSubset(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PartSubset::PartSubset(void)
      PartSubset *return_value = new PartSubset();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartSubset, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-PartSubset::PartSubset(PartSubset const &copy)
      PartSubset const *arg_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartSubset, 0, "PartSubset.PartSubset", true, true);
      if (arg_this != NULL) {
        PartSubset *return_value = new PartSubset(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartSubset, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PartSubset() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PartSubset()\n"
      "PartSubset(const PartSubset copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PartSubset(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PartSubset) {
    printf("PartSubset ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PartSubset *local_this = (PartSubset *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PartSubset) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PartSubset(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PartSubset) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BindAnimRequest
 */
/**
 * Python function wrapper for:
 * static TypeHandle BindAnimRequest::get_class_type(void)
 */
static PyObject *Dtool_BindAnimRequest_get_class_type_198(PyObject *, PyObject *) {
  // 1-static TypeHandle BindAnimRequest::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BindAnimRequest::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BindAnimRequest_get_class_type_198_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BindAnimRequest_get_class_type_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BindAnimRequest::BindAnimRequest(BindAnimRequest const &) = default
 * BindAnimRequest::BindAnimRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, Loader *loader, AnimControl *control, int hierarchy_match_flags, PartSubset const &subset)
 */
static int Dtool_Init_BindAnimRequest(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline BindAnimRequest::BindAnimRequest(BindAnimRequest const &) = default
      CPT(BindAnimRequest) arg_this;
      if (!Dtool_ConstCoerce_BindAnimRequest(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "BindAnimRequest.BindAnimRequest", "BindAnimRequest");
        return -1;
      }
      BindAnimRequest *return_value = new BindAnimRequest(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BindAnimRequest, true, false);
    }
    break;
  case 7:
    {
      // 1-BindAnimRequest::BindAnimRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, Loader *loader, AnimControl *control, int hierarchy_match_flags, PartSubset const &subset)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      int param5;
      PyObject *param6;
      static const char *keyword_list[] = {"name", "filename", "options", "loader", "control", "hierarchy_match_flags", "subset", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#OOOOiO:BindAnimRequest", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "BindAnimRequest.BindAnimRequest", "Filename");
          return -1;
        }
        LoaderOptions param2_local;
        LoaderOptions const *param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
        if (!(param2_this != NULL)) {
          Dtool_Raise_ArgTypeError(param2, 2, "BindAnimRequest.BindAnimRequest", "LoaderOptions");
          return -1;
        }
        PT(Loader) param3_this;
        if (!Dtool_Coerce_Loader(param3, param3_this)) {
          Dtool_Raise_ArgTypeError(param3, 3, "BindAnimRequest.BindAnimRequest", "Loader");
          return -1;
        }
        AnimControl *param4_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_AnimControl, 4, "BindAnimRequest.BindAnimRequest", false, true);
        PartSubset const *param6_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param6, Dtool_Ptr_PartSubset, 6, "BindAnimRequest.BindAnimRequest", true, true);
        if (param4_this != NULL && param6_this != NULL) {
          BindAnimRequest *return_value = new BindAnimRequest(std::string(param0_str, param0_len), *param1_this, *param2_this, MOVE(param3_this), param4_this, (int)param5, *param6_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BindAnimRequest, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BindAnimRequest() takes 1 or 7 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BindAnimRequest(const BindAnimRequest param0)\n"
      "BindAnimRequest(str name, const Filename filename, const LoaderOptions options, Loader loader, AnimControl control, int hierarchy_match_flags, const PartSubset subset)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BindAnimRequest(PyObject *args, CPT(BindAnimRequest) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BindAnimRequest, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 7) {
      // 1-BindAnimRequest::BindAnimRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, Loader *loader, AnimControl *control, int hierarchy_match_flags, PartSubset const &subset)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      int param5;
      PyObject *param6;
      if (PyArg_ParseTuple(args, "s#OOOOiO:BindAnimRequest", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
        Filename const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
        LoaderOptions const *param2_this;
        DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LoaderOptions, (void **)&param2_this);
        Loader *param3_this = (Loader *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Loader, 3, "BindAnimRequest.BindAnimRequest", false, false);
        AnimControl *param4_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_AnimControl, 4, "BindAnimRequest.BindAnimRequest", false, false);
        PartSubset const *param6_this;
        DTOOL_Call_ExtractThisPointerForType(param6, Dtool_Ptr_PartSubset, (void **)&param6_this);
        if (param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL && param6_this != NULL) {
          BindAnimRequest *return_value = new BindAnimRequest(std::string(param0_str, param0_len), *param1_this, *param2_this, param3_this, param4_this, (int)param5, *param6_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_BindAnimRequest(PyObject *args, PT(BindAnimRequest) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BindAnimRequest, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 7) {
      // 1-BindAnimRequest::BindAnimRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, Loader *loader, AnimControl *control, int hierarchy_match_flags, PartSubset const &subset)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      int param5;
      PyObject *param6;
      if (PyArg_ParseTuple(args, "s#OOOOiO:BindAnimRequest", &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
        Filename const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
        LoaderOptions const *param2_this;
        DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LoaderOptions, (void **)&param2_this);
        Loader *param3_this = (Loader *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Loader, 3, "BindAnimRequest.BindAnimRequest", false, false);
        AnimControl *param4_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_AnimControl, 4, "BindAnimRequest.BindAnimRequest", false, false);
        PartSubset const *param6_this;
        DTOOL_Call_ExtractThisPointerForType(param6, Dtool_Ptr_PartSubset, (void **)&param6_this);
        if (param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL && param6_this != NULL) {
          BindAnimRequest *return_value = new BindAnimRequest(std::string(param0_str, param0_len), *param1_this, *param2_this, param3_this, param4_this, (int)param5, *param6_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_BindAnimRequest(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BindAnimRequest) {
    printf("BindAnimRequest ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BindAnimRequest *local_this = (BindAnimRequest *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BindAnimRequest) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *)(ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTaskBase) {
    return (AsyncTaskBase *)(AsyncTask *)(ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_ModelLoadRequest) {
    return (ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTaskBase *)(AsyncTask *)(ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *)(ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *)(ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *)(ModelLoadRequest *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BindAnimRequest(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BindAnimRequest) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTaskBase) {
    AsyncTaskBase* other_this = (AsyncTaskBase*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_ModelLoadRequest) {
    ModelLoadRequest* other_this = (ModelLoadRequest*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BindAnimRequest*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PartBundle
 */
/**
 * Python function wrapper for:
 * inline ConstPointerTo< AnimPreloadTable > PartBundle::get_anim_preload(void) const
 */
static PyObject *Dtool_PartBundle_get_anim_preload_202(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConstPointerTo< AnimPreloadTable > PartBundle::get_anim_preload(void) const
  ConstPointerTo< AnimPreloadTable > return_value = (*(const PartBundle*)local_this).get_anim_preload();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  AnimPreloadTable const *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimPreloadTable, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_anim_preload_202_comment =
  "C++ Interface:\n"
  "get_anim_preload(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the AnimPreloadTable associated with the PartBundle.  This table,\n"
  " * if present, can be used for the benefit of load_bind_anim() to allow\n"
  " * asynchronous binding.\n"
  " */";
#else
static const char *Dtool_PartBundle_get_anim_preload_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< AnimPreloadTable > PartBundle::modify_anim_preload(void)
 */
static PyObject *Dtool_PartBundle_modify_anim_preload_203(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.modify_anim_preload")) {
    return NULL;
  }
  // 1-inline PointerTo< AnimPreloadTable > PartBundle::modify_anim_preload(void)
  PointerTo< AnimPreloadTable > return_value = (*local_this).modify_anim_preload();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  AnimPreloadTable *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimPreloadTable, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_modify_anim_preload_203_comment =
  "C++ Interface:\n"
  "modify_anim_preload(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the AnimPreloadTable associated with the\n"
  " * PartBundle, if any.\n"
  " */";
#else
static const char *Dtool_PartBundle_modify_anim_preload_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::set_anim_preload(AnimPreloadTable *table)
 */
static PyObject *Dtool_PartBundle_set_anim_preload_204(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_anim_preload")) {
    return NULL;
  }
  // 1-inline void PartBundle::set_anim_preload(AnimPreloadTable *table)
  AnimPreloadTable *arg_this = (AnimPreloadTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AnimPreloadTable, 1, "PartBundle.set_anim_preload", false, true);
  if (arg_this != NULL) {
    (*local_this).set_anim_preload(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anim_preload(const PartBundle self, AnimPreloadTable table)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_anim_preload_204_comment =
  "C++ Interface:\n"
  "set_anim_preload(const PartBundle self, AnimPreloadTable table)\n"
  "\n"
  "/**\n"
  " * Replaces the AnimPreloadTable associated with the PartBundle.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_anim_preload_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::clear_anim_preload(void)
 */
static PyObject *Dtool_PartBundle_clear_anim_preload_205(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.clear_anim_preload")) {
    return NULL;
  }
  // 1-inline void PartBundle::clear_anim_preload(void)
  (*local_this).clear_anim_preload();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_clear_anim_preload_205_comment =
  "C++ Interface:\n"
  "clear_anim_preload(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Removes any AnimPreloadTable associated with the PartBundle.\n"
  " */";
#else
static const char *Dtool_PartBundle_clear_anim_preload_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PartBundle::merge_anim_preloads(PartBundle const *other)
 */
static PyObject *Dtool_PartBundle_merge_anim_preloads_206(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.merge_anim_preloads")) {
    return NULL;
  }
  // 1-void PartBundle::merge_anim_preloads(PartBundle const *other)
  CPT(PartBundle) arg_this;
  if (!Dtool_ConstCoerce_PartBundle(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PartBundle.merge_anim_preloads", "PartBundle");
  }
  (*local_this).merge_anim_preloads(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "merge_anim_preloads(const PartBundle self, const PartBundle other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_merge_anim_preloads_206_comment =
  "C++ Interface:\n"
  "merge_anim_preloads(const PartBundle self, const PartBundle other)\n"
  "\n"
  "/**\n"
  " * Copies the contents of the other PartBundle's preload table into this one.\n"
  " */";
#else
static const char *Dtool_PartBundle_merge_anim_preloads_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::set_blend_type(PartBundle::BlendType bt)
 */
static PyObject *Dtool_PartBundle_set_blend_type_208(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_blend_type")) {
    return NULL;
  }
  // 1-inline void PartBundle::set_blend_type(PartBundle::BlendType bt)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_blend_type((PartBundle::BlendType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_type(const PartBundle self, int bt)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_blend_type_208_comment =
  "C++ Interface:\n"
  "set_blend_type(const PartBundle self, int bt)\n"
  "\n"
  "/**\n"
  " * Defines the algorithm that is used when blending multiple frames or\n"
  " * multiple animations together, when either anim_blend_flag or\n"
  " * frame_blend_flag is set to true.\n"
  " *\n"
  " * See partBundle.h for a description of the meaning of each of the BlendType\n"
  " * values.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_blend_type_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PartBundle::BlendType PartBundle::get_blend_type(void) const
 */
static PyObject *Dtool_PartBundle_get_blend_type_209(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PartBundle::BlendType PartBundle::get_blend_type(void) const
  PartBundle::BlendType return_value = (*(const PartBundle*)local_this).get_blend_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_blend_type_209_comment =
  "C++ Interface:\n"
  "get_blend_type(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the algorithm that is used when blending multiple frames or\n"
  " * multiple animations together, when either anim_blend_flag or\n"
  " * frame_blend_flag is set to true.\n"
  " */";
#else
static const char *Dtool_PartBundle_get_blend_type_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PartBundle::set_anim_blend_flag(bool anim_blend_flag)
 */
static PyObject *Dtool_PartBundle_set_anim_blend_flag_210(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_anim_blend_flag")) {
    return NULL;
  }
  // 1-void PartBundle::set_anim_blend_flag(bool anim_blend_flag)
  (*local_this).set_anim_blend_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anim_blend_flag(const PartBundle self, bool anim_blend_flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_anim_blend_flag_210_comment =
  "C++ Interface:\n"
  "set_anim_blend_flag(const PartBundle self, bool anim_blend_flag)\n"
  "\n"
  "/**\n"
  " * Defines the way the character responds to multiple calls to\n"
  " * set_control_effect()).  By default, this flag is set false, which disallows\n"
  " * multiple animations.  When this flag is false, it is not necessary to\n"
  " * explicitly set the control_effect when starting an animation; starting the\n"
  " * animation will implicitly remove the control_effect from the previous\n"
  " * animation and set it on the current one.\n"
  " *\n"
  " * However, if this flag is set true, the control_effect must be explicitly\n"
  " * set via set_control_effect() whenever an animation is to affect the\n"
  " * character.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_anim_blend_flag_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PartBundle::get_anim_blend_flag(void) const
 */
static PyObject *Dtool_PartBundle_get_anim_blend_flag_211(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PartBundle::get_anim_blend_flag(void) const
  bool return_value = (*(const PartBundle*)local_this).get_anim_blend_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_anim_blend_flag_211_comment =
  "C++ Interface:\n"
  "get_anim_blend_flag(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns whether the character allows multiple different animations to be\n"
  " * bound simultaneously.  See set_anim_blend_flag().\n"
  " */";
#else
static const char *Dtool_PartBundle_get_anim_blend_flag_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::set_frame_blend_flag(bool frame_blend_flag)
 */
static PyObject *Dtool_PartBundle_set_frame_blend_flag_212(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_frame_blend_flag")) {
    return NULL;
  }
  // 1-inline void PartBundle::set_frame_blend_flag(bool frame_blend_flag)
  (*local_this).set_frame_blend_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_blend_flag(const PartBundle self, bool frame_blend_flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_frame_blend_flag_212_comment =
  "C++ Interface:\n"
  "set_frame_blend_flag(const PartBundle self, bool frame_blend_flag)\n"
  "\n"
  "/**\n"
  " * Specifies whether the character interpolates (blends) between two\n"
  " * sequential frames of an active animation, showing a smooth intra-frame\n"
  " * motion, or whether it holds each frame until the next frame is ready,\n"
  " * showing precisely the specified animation.\n"
  " *\n"
  " * When this value is false, the character holds each frame until the next is\n"
  " * ready.  When this is true, the character will interpolate between two\n"
  " * consecutive frames of animation for each frame the animation is onscreen,\n"
  " * according to the amount of time elapsed between the frames.\n"
  " *\n"
  " * The default value of this flag is determined by the interpolate-frames\n"
  " * Config.prc variable.\n"
  " *\n"
  " * Use set_blend_type() to change the algorithm that the character uses to\n"
  " * interpolate matrix positions.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_frame_blend_flag_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PartBundle::get_frame_blend_flag(void) const
 */
static PyObject *Dtool_PartBundle_get_frame_blend_flag_213(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PartBundle::get_frame_blend_flag(void) const
  bool return_value = (*(const PartBundle*)local_this).get_frame_blend_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_frame_blend_flag_213_comment =
  "C++ Interface:\n"
  "get_frame_blend_flag(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns whether the character interpolates (blends) between two sequential\n"
  " * animation frames, or whether it holds the current frame until the next one\n"
  " * is ready.  See set_frame_blend_flag().\n"
  " */";
#else
static const char *Dtool_PartBundle_get_frame_blend_flag_213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::set_root_xform(LMatrix4 const &root_xform)
 */
static PyObject *Dtool_PartBundle_set_root_xform_214(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_root_xform")) {
    return NULL;
  }
  // 1-inline void PartBundle::set_root_xform(LMatrix4 const &root_xform)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PartBundle.set_root_xform", "LMatrix4f");
  }
  (*local_this).set_root_xform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_root_xform(const PartBundle self, const LMatrix4f root_xform)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_root_xform_214_comment =
  "C++ Interface:\n"
  "set_root_xform(const PartBundle self, const LMatrix4f root_xform)\n"
  "\n"
  "/**\n"
  " * Specifies the transform matrix which is implicitly applied at the root of\n"
  " * the animated hierarchy.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_root_xform_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::xform(LMatrix4 const &mat)
 */
static PyObject *Dtool_PartBundle_xform_215(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.xform")) {
    return NULL;
  }
  // 1-inline void PartBundle::xform(LMatrix4 const &mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PartBundle.xform", "LMatrix4f");
  }
  (*local_this).xform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const PartBundle self, const LMatrix4f mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_xform_215_comment =
  "C++ Interface:\n"
  "xform(const PartBundle self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transform to the root of the animated hierarchy.\n"
  " */";
#else
static const char *Dtool_PartBundle_xform_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &PartBundle::get_root_xform(void) const
 */
static PyObject *Dtool_PartBundle_get_root_xform_216(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4 const &PartBundle::get_root_xform(void) const
  LMatrix4 const *return_value = &((*(const PartBundle*)local_this).get_root_xform());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_root_xform_216_comment =
  "C++ Interface:\n"
  "get_root_xform(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the transform matrix which is implicitly applied at the root of the\n"
  " * animated hierarchy.\n"
  " */";
#else
static const char *Dtool_PartBundle_get_root_xform_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PartBundle > PartBundle::apply_transform(TransformState const *transform)
 */
static PyObject *Dtool_PartBundle_apply_transform_217(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.apply_transform")) {
    return NULL;
  }
  // 1-PointerTo< PartBundle > PartBundle::apply_transform(TransformState const *transform)
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "PartBundle.apply_transform", true, true);
  if (arg_this != NULL) {
    PointerTo< PartBundle > return_value = (*local_this).apply_transform(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    PartBundle *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PartBundle, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_transform(const PartBundle self, const TransformState transform)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_apply_transform_217_comment =
  "C++ Interface:\n"
  "apply_transform(const PartBundle self, const TransformState transform)\n"
  "\n"
  "/**\n"
  " * Returns a PartBundle that is a duplicate of this one, but with the\n"
  " * indicated transform applied.  If this is called multiple times with the\n"
  " * same TransformState pointer, it returns the same PartBundle each time.\n"
  " */";
#else
static const char *Dtool_PartBundle_apply_transform_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PartBundle::get_num_nodes(void) const
 */
static PyObject *Dtool_PartBundle_get_num_nodes_218(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PartBundle::get_num_nodes(void) const
  int return_value = (*(const PartBundle*)local_this).get_num_nodes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_num_nodes_218_comment =
  "C++ Interface:\n"
  "get_num_nodes(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the number of PartBundleNodes that contain a pointer to this\n"
  " * PartBundle.\n"
  " */";
#else
static const char *Dtool_PartBundle_get_num_nodes_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PartBundleNode *PartBundle::get_node(int n) const
 */
static PyObject *Dtool_PartBundle_get_node_219(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PartBundleNode *PartBundle::get_node(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PartBundleNode *return_value = (*(const PartBundle*)local_this).get_node((int)arg_val);
    if (return_value != (PartBundleNode *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (PartBundleNode *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundleNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(PartBundle self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_node_219_comment =
  "C++ Interface:\n"
  "get_node(PartBundle self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth PartBundleNode associated with this PartBundle.\n"
  " */";
#else
static const char *Dtool_PartBundle_get_node_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PartBundle::clear_control_effects(void)
 */
static PyObject *Dtool_PartBundle_clear_control_effects_247(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.clear_control_effects")) {
    return NULL;
  }
  // 1-void PartBundle::clear_control_effects(void)
  (*local_this).clear_control_effects();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_clear_control_effects_247_comment =
  "C++ Interface:\n"
  "clear_control_effects(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Sets the control effect of all AnimControls to zero (but does not \"stop\"\n"
  " * the AnimControls).  The character will no longer be affected by any\n"
  " * animation, and will return to its default pose (unless restore-initial-pose\n"
  " * is false).\n"
  " *\n"
  " * The AnimControls which are no longer associated will not be using any CPU\n"
  " * cycles, but they may still be in the \"playing\" state; if they are later\n"
  " * reassociated with the PartBundle they will resume at their current frame as\n"
  " * if they'd been running all along.\n"
  " */";
#else
static const char *Dtool_PartBundle_clear_control_effects_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::set_control_effect(AnimControl *control, PN_stdfloat effect)
 */
static PyObject *Dtool_PartBundle_set_control_effect_248(PyObject *self, PyObject *args, PyObject *kwds) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_control_effect")) {
    return NULL;
  }
  // 1-inline void PartBundle::set_control_effect(AnimControl *control, PN_stdfloat effect)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"control", "effect", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_control_effect", (char **)keyword_list, &param1, &param2)) {
    AnimControl *param1_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimControl, 1, "PartBundle.set_control_effect", false, true);
    if (param1_this != NULL) {
      (*local_this).set_control_effect(param1_this, (PN_stdfloat)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_control_effect(const PartBundle self, AnimControl control, float effect)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_control_effect_248_comment =
  "C++ Interface:\n"
  "set_control_effect(const PartBundle self, AnimControl control, float effect)\n"
  "\n"
  "/**\n"
  " * Sets the amount by which the character is affected by the indicated\n"
  " * AnimControl (and its associated animation).  Normally, this will only be\n"
  " * zero or one.  Zero indicates the animation does not affect the character,\n"
  " * and one means it does.\n"
  " *\n"
  " * If the _anim_blend_flag is not false (see set_anim_blend_flag()), it is\n"
  " * possible to have multiple AnimControls in effect simultaneously.  In this\n"
  " * case, the effect is a weight that indicates the relative importance of each\n"
  " * AnimControl to the final animation.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_control_effect_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PartBundle::get_control_effect(AnimControl *control) const
 */
static PyObject *Dtool_PartBundle_get_control_effect_249(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PartBundle::get_control_effect(AnimControl *control) const
  AnimControl *arg_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AnimControl, 1, "PartBundle.get_control_effect", false, true);
  if (arg_this != NULL) {
    PN_stdfloat return_value = (*(const PartBundle*)local_this).get_control_effect(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_control_effect(PartBundle self, AnimControl control)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_control_effect_249_comment =
  "C++ Interface:\n"
  "get_control_effect(PartBundle self, AnimControl control)\n"
  "\n"
  "/**\n"
  " * Returns the amount by which the character is affected by the indicated\n"
  " * AnimControl and its associated animation.  See set_control_effect().\n"
  " */";
#else
static const char *Dtool_PartBundle_get_control_effect_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PartBundle::output(ostream &out) const
 */
static PyObject *Dtool_PartBundle_output_250(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PartBundle::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PartBundle.output", false, true);
  if (arg_this != NULL) {
    (*(const PartBundle*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PartBundle self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_output_250_comment =
  "C++ Interface:\n"
  "output(PartBundle self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a one-line description of the bundle.\n"
  " */";
#else
static const char *Dtool_PartBundle_output_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags = 0, PartSubset const &subset = PartSubset())
 */
static PyObject *Dtool_PartBundle_bind_anim_251(PyObject *self, PyObject *args, PyObject *kwds) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.bind_anim")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "anim");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'anim' (pos 1) not found");
      }
      // 1-PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags, PartSubset const &subset)
      PT(AnimBundle) arg_this;
      if (!Dtool_Coerce_AnimBundle(arg, arg_this)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PartBundle.bind_anim", "AnimBundle");
      }
      PointerTo< AnimControl > return_value = (*local_this).bind_anim(MOVE(arg_this));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      AnimControl *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      if (return_ptr == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimControl, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 2:
    {
      // 1-PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags, PartSubset const &subset)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"anim", "hierarchy_match_flags", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:bind_anim", (char **)keyword_list, &param1, &param2)) {
        PT(AnimBundle) param1_this;
        if (!Dtool_Coerce_AnimBundle(param1, param1_this)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PartBundle.bind_anim", "AnimBundle");
        }
        PointerTo< AnimControl > return_value = (*local_this).bind_anim(MOVE(param1_this), (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        AnimControl *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        if (return_ptr == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimControl, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 3:
    {
      // 1-PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags, PartSubset const &subset)
      PyObject *param1;
      int param2;
      PyObject *param3;
      static const char *keyword_list[] = {"anim", "hierarchy_match_flags", "subset", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO:bind_anim", (char **)keyword_list, &param1, &param2, &param3)) {
        PT(AnimBundle) param1_this;
        if (!Dtool_Coerce_AnimBundle(param1, param1_this)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PartBundle.bind_anim", "AnimBundle");
        }
        PartSubset const *param3_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PartSubset, 3, "PartBundle.bind_anim", true, true);
        if (param3_this != NULL) {
          PointerTo< AnimControl > return_value = (*local_this).bind_anim(MOVE(param1_this), (int)param2, *param3_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          // Transfer ownership of return_value.
          AnimControl *return_ptr = return_value.p();
          return_value.cheat() = NULL;
          if (return_ptr == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimControl, true, false, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "bind_anim() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bind_anim(const PartBundle self, AnimBundle anim)\n"
      "bind_anim(const PartBundle self, AnimBundle anim, int hierarchy_match_flags)\n"
      "bind_anim(const PartBundle self, AnimBundle anim, int hierarchy_match_flags, const PartSubset subset)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_bind_anim_251_comment =
  "C++ Interface:\n"
  "bind_anim(const PartBundle self, AnimBundle anim)\n"
  "bind_anim(const PartBundle self, AnimBundle anim, int hierarchy_match_flags)\n"
  "bind_anim(const PartBundle self, AnimBundle anim, int hierarchy_match_flags, const PartSubset subset)\n"
  "\n"
  "/**\n"
  " * Binds the animation to the bundle, if possible, and returns a new\n"
  " * AnimControl that can be used to start and stop the animation.  If the anim\n"
  " * hierarchy does not match the part hierarchy, returns NULL.\n"
  " *\n"
  " * If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,\n"
  " * it may contain a union of PartGroup::HierarchyMatchFlags values indicating\n"
  " * conditions that will be tolerated (but warnings will still be issued).\n"
  " *\n"
  " * If subset is specified, it restricts the binding only to the named subtree\n"
  " * of joints.\n"
  " *\n"
  " * The AnimControl is not stored within the PartBundle; it is the user's\n"
  " * responsibility to maintain the pointer.  The animation will automatically\n"
  " * unbind itself when the AnimControl destructs (i.e.  its reference count\n"
  " * goes to zero).\n"
  " */";
#else
static const char *Dtool_PartBundle_bind_anim_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< AnimControl > PartBundle::load_bind_anim(Loader *loader, Filename const &filename, int hierarchy_match_flags, PartSubset const &subset, bool allow_async)
 */
static PyObject *Dtool_PartBundle_load_bind_anim_252(PyObject *self, PyObject *args, PyObject *kwds) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.load_bind_anim")) {
    return NULL;
  }
  // 1-PointerTo< AnimControl > PartBundle::load_bind_anim(Loader *loader, Filename const &filename, int hierarchy_match_flags, PartSubset const &subset, bool allow_async)
  PyObject *param1;
  PyObject *param2;
  int param3;
  PyObject *param4;
  PyObject *param5;
  static const char *keyword_list[] = {"loader", "filename", "hierarchy_match_flags", "subset", "allow_async", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOiOO:load_bind_anim", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    PT(Loader) param1_this;
    if (!Dtool_Coerce_Loader(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PartBundle.load_bind_anim", "Loader");
    }
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PartBundle.load_bind_anim", "Filename");
    }
    PartSubset const *param4_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_PartSubset, 4, "PartBundle.load_bind_anim", true, true);
    if (param4_this != NULL) {
      PointerTo< AnimControl > return_value = (*local_this).load_bind_anim(MOVE(param1_this), *param2_this, (int)param3, *param4_this, (PyObject_IsTrue(param5) != 0));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      AnimControl *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      if (return_ptr == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimControl, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_bind_anim(const PartBundle self, Loader loader, const Filename filename, int hierarchy_match_flags, const PartSubset subset, bool allow_async)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_load_bind_anim_252_comment =
  "C++ Interface:\n"
  "load_bind_anim(const PartBundle self, Loader loader, const Filename filename, int hierarchy_match_flags, const PartSubset subset, bool allow_async)\n"
  "\n"
  "/**\n"
  " * Binds an animation to the bundle.  The animation is loaded from the disk\n"
  " * via the indicated Loader object.  In other respects, this behaves similarly\n"
  " * to bind_anim(), with the addition of asynchronous support.\n"
  " *\n"
  " * If allow_aysnc is true, the load will be asynchronous if possible.  This\n"
  " * requires that the animation basename can be found in the PartBundle's\n"
  " * preload table (see get_anim_preload()).\n"
  " *\n"
  " * In an asynchronous load, the animation file will be loaded and bound in a\n"
  " * sub-thread.  This means that the animation will not necessarily be\n"
  " * available at the time this method returns.  You may still use the returned\n"
  " * AnimControl immediately, though, but no visible effect will occur until the\n"
  " * animation eventually becomes available.\n"
  " *\n"
  " * You can test AnimControl::is_pending() to see if the animation has been\n"
  " * loaded yet, or wait for it to finish with AnimControl::wait_pending() or\n"
  " * even PartBundle::wait_pending().  You can also set an event to be triggered\n"
  " * when the animation finishes loading with\n"
  " * AnimControl::set_pending_done_event().\n"
  " */";
#else
static const char *Dtool_PartBundle_load_bind_anim_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PartBundle::wait_pending(void)
 */
static PyObject *Dtool_PartBundle_wait_pending_253(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.wait_pending")) {
    return NULL;
  }
  // 1-void PartBundle::wait_pending(void)
  (*local_this).wait_pending();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_wait_pending_253_comment =
  "C++ Interface:\n"
  "wait_pending(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Blocks the current thread until all currently-pending AnimControls, with a\n"
  " * nonzero control effect, have been loaded and are properly bound.\n"
  " */";
#else
static const char *Dtool_PartBundle_wait_pending_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PartBundle::freeze_joint(std::string const &joint_name, LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
 * bool PartBundle::freeze_joint(std::string const &joint_name, PN_stdfloat value)
 * bool PartBundle::freeze_joint(std::string const &joint_name, TransformState const *transform)
 */
static PyObject *Dtool_PartBundle_freeze_joint_254(PyObject *self, PyObject *args, PyObject *kwds) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.freeze_joint")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 bool PartBundle::freeze_joint(std::string const &joint_name, TransformState const *transform)
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        PyObject *param2;
        static const char *keyword_list[] = {"joint_name", "transform", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:freeze_joint", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          TransformState const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_TransformState, (void **)&param2_this);
          if (param2_this != NULL) {
            bool return_value = (*local_this).freeze_joint(std::string(param1_str, param1_len), param2_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool PartBundle::freeze_joint(std::string const &joint_name, PN_stdfloat value)
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        float param2;
        static const char *keyword_list[] = {"joint_name", "value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#f:freeze_joint", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          bool return_value = (*local_this).freeze_joint(std::string(param1_str, param1_len), (PN_stdfloat)param2);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      // No coercion possible: bool PartBundle::freeze_joint(std::string const &joint_name, TransformState const *transform)
      // No coercion possible: bool PartBundle::freeze_joint(std::string const &joint_name, PN_stdfloat value)
    }
    break;
  case 4:
    {
      // 1-bool PartBundle::freeze_joint(std::string const &joint_name, LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"joint_name", "pos", "hpr", "scale", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#OOO:freeze_joint", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "PartBundle.freeze_joint", "LVecBase3f");
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "PartBundle.freeze_joint", "LVecBase3f");
        }
        LVecBase3f param4_local;
        LVecBase3 const *param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
        if (!(param4_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "PartBundle.freeze_joint", "LVecBase3f");
        }
        bool return_value = (*local_this).freeze_joint(std::string(param1_str, param1_len), *param2_this, *param3_this, *param4_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "freeze_joint() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "freeze_joint(const PartBundle self, str joint_name, const TransformState transform)\n"
      "freeze_joint(const PartBundle self, str joint_name, float value)\n"
      "freeze_joint(const PartBundle self, str joint_name, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_freeze_joint_254_comment =
  "C++ Interface:\n"
  "freeze_joint(const PartBundle self, str joint_name, const TransformState transform)\n"
  "freeze_joint(const PartBundle self, str joint_name, float value)\n"
  "freeze_joint(const PartBundle self, str joint_name, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n"
  "\n"
  "/**\n"
  " * Specifies that the joint with the indicated name should be frozen with the\n"
  " * specified transform.  It will henceforth always hold this fixed transform,\n"
  " * regardless of any animations that may subsequently be bound to the joint.\n"
  " *\n"
  " * Returns true if the joint is successfully frozen, or false if the named\n"
  " * child is not a joint (or slider) or does not exist.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies that the joint with the indicated name should be frozen with the\n"
  " * specified transform.  It will henceforth always hold this fixed transform,\n"
  " * regardless of any animations that may subsequently be bound to the joint.\n"
  " *\n"
  " * Returns true if the joint is successfully frozen, or false if the named\n"
  " * child is not a joint (or slider) or does not exist.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies that the joint with the indicated name should be frozen with the\n"
  " * specified transform.  It will henceforth always hold this fixed transform,\n"
  " * regardless of any animations that may subsequently be bound to the joint.\n"
  " *\n"
  " * Returns true if the joint is successfully frozen, or false if the named\n"
  " * child is not a joint (or slider) or does not exist.\n"
  " */";
#else
static const char *Dtool_PartBundle_freeze_joint_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PartBundle::control_joint(std::string const &joint_name, PandaNode *node)
 */
static PyObject *Dtool_PartBundle_control_joint_255(PyObject *self, PyObject *args, PyObject *kwds) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.control_joint")) {
    return NULL;
  }
  // 1-bool PartBundle::control_joint(std::string const &joint_name, PandaNode *node)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"joint_name", "node", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:control_joint", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    PandaNode *param2_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PandaNode, 2, "PartBundle.control_joint", false, true);
    if (param2_this != NULL) {
      bool return_value = (*local_this).control_joint(std::string(param1_str, param1_len), param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "control_joint(const PartBundle self, str joint_name, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_control_joint_255_comment =
  "C++ Interface:\n"
  "control_joint(const PartBundle self, str joint_name, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Specifies that the joint with the indicated name should be animated with\n"
  " * the transform on the indicated node.  It will henceforth always follow the\n"
  " * node's transform, regardless of any animations that may subsequently be\n"
  " * bound to the joint.\n"
  " *\n"
  " * Returns true if the joint is successfully controlled, or false if the named\n"
  " * child is not a joint (or slider) or does not exist.\n"
  " */";
#else
static const char *Dtool_PartBundle_control_joint_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PartBundle::release_joint(std::string const &joint_name)
 */
static PyObject *Dtool_PartBundle_release_joint_256(PyObject *self, PyObject *arg) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.release_joint")) {
    return NULL;
  }
  // 1-bool PartBundle::release_joint(std::string const &joint_name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).release_joint(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_joint(const PartBundle self, str joint_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_release_joint_256_comment =
  "C++ Interface:\n"
  "release_joint(const PartBundle self, str joint_name)\n"
  "\n"
  "/**\n"
  " * Releases the named joint from the effects of a previous call to\n"
  " * freeze_joint() or control_joint(). It will henceforth once again follow\n"
  " * whatever transforms are dictated by the animation.\n"
  " *\n"
  " * Returns true if the joint is released, or false if the named child was not\n"
  " * previously controlled or frozen, or it does not exist.\n"
  " */";
#else
static const char *Dtool_PartBundle_release_joint_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PartBundle::update(void)
 */
static PyObject *Dtool_PartBundle_update_257(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.update")) {
    return NULL;
  }
  // 1-bool PartBundle::update(void)
  bool return_value = (*local_this).update();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_update_257_comment =
  "C++ Interface:\n"
  "update(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Updates all the parts in the bundle to reflect the data for the current\n"
  " * frame (as set in each of the AnimControls).\n"
  " *\n"
  " * Returns true if any part has changed as a result of this, or false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PartBundle_update_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PartBundle::force_update(void)
 */
static PyObject *Dtool_PartBundle_force_update_258(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.force_update")) {
    return NULL;
  }
  // 1-bool PartBundle::force_update(void)
  bool return_value = (*local_this).force_update();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_force_update_258_comment =
  "C++ Interface:\n"
  "force_update(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Updates all the parts in the bundle to reflect the data for the current\n"
  " * frame, whether we believe it needs it or not.\n"
  " */";
#else
static const char *Dtool_PartBundle_force_update_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PartBundle::get_class_type(void)
 */
static PyObject *Dtool_PartBundle_get_class_type_259(PyObject *, PyObject *) {
  // 1-static TypeHandle PartBundle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PartBundle::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_class_type_259_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PartBundle_get_class_type_259_comment = NULL;
#endif

static PyObject *Dtool_PartBundle_blend_type_Getter(PyObject *self, void *) {
  const PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PartBundle::BlendType PartBundle::get_blend_type(void) const
  PartBundle::BlendType return_value = (*(const PartBundle*)local_this).get_blend_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PartBundle_blend_type_Setter(PyObject *self, PyObject *arg, void *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.blend_type")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete blend_type attribute");
    return -1;
  }
  // 1-inline void PartBundle::set_blend_type(PartBundle::BlendType bt)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_blend_type((PartBundle::BlendType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blend_type(const PartBundle self, int bt)\n");
  }
  return -1;
}

static PyObject *Dtool_PartBundle_anim_blend_flag_Getter(PyObject *self, void *) {
  const PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool PartBundle::get_anim_blend_flag(void) const
  bool return_value = (*(const PartBundle*)local_this).get_anim_blend_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PartBundle_anim_blend_flag_Setter(PyObject *self, PyObject *arg, void *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.anim_blend_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete anim_blend_flag attribute");
    return -1;
  }
  // 1-void PartBundle::set_anim_blend_flag(bool anim_blend_flag)
  (*local_this).set_anim_blend_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_anim_blend_flag(const PartBundle self, bool anim_blend_flag)\n");
  }
  return -1;
}

static PyObject *Dtool_PartBundle_frame_blend_flag_Getter(PyObject *self, void *) {
  const PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool PartBundle::get_frame_blend_flag(void) const
  bool return_value = (*(const PartBundle*)local_this).get_frame_blend_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PartBundle_frame_blend_flag_Setter(PyObject *self, PyObject *arg, void *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.frame_blend_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete frame_blend_flag attribute");
    return -1;
  }
  // 1-inline void PartBundle::set_frame_blend_flag(bool frame_blend_flag)
  (*local_this).set_frame_blend_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_blend_flag(const PartBundle self, bool frame_blend_flag)\n");
  }
  return -1;
}

static PyObject *Dtool_PartBundle_root_xform_Getter(PyObject *self, void *) {
  const PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LMatrix4 const &PartBundle::get_root_xform(void) const
  LMatrix4 const *return_value = &((*(const PartBundle*)local_this).get_root_xform());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

static int Dtool_PartBundle_root_xform_Setter(PyObject *self, PyObject *arg, void *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.root_xform")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete root_xform attribute");
    return -1;
  }
  // 1-inline void PartBundle::set_root_xform(LMatrix4 const &root_xform)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PartBundle.set_root_xform", "LMatrix4f");
    return -1;
  }
  (*local_this).set_root_xform(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_root_xform(const PartBundle self, const LMatrix4f root_xform)\n");
  }
  return -1;
}

/**
 * sequence length function for property PartBundle::nodes
 */
static Py_ssize_t Dtool_PartBundle_nodes_Len(PyObject *self) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_nodes();
}

/**
 * sequence getter for property PartBundle::nodes
 */
static PyObject *Dtool_PartBundle_nodes_Getitem(PyObject *self, Py_ssize_t index) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_nodes()) {
    PyErr_SetString(PyExc_IndexError, "PartBundle.nodes[] index out of range");
    return NULL;
  }
  // 1-inline PartBundleNode *PartBundle::get_node(int n) const
  PartBundleNode *return_value = (*(const PartBundle*)local_this).get_node(index);
  if (return_value != (PartBundleNode *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (PartBundleNode *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundleNode, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(PartBundle self, index)\n");
  }
}

static PyObject *Dtool_PartBundle_nodes_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_PartBundle_nodes_Len;
  wrap->_getitem_func = &Dtool_PartBundle_nodes_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * PartBundle::PartBundle(std::string const &name = "")
 */
static int Dtool_Init_PartBundle(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-PartBundle::PartBundle(std::string const &name = "")
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:PartBundle", (char **)keyword_list, &param0_str, &param0_len)) {
    PartBundle *return_value = new PartBundle(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartBundle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PartBundle(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PartBundle(PyObject *args, CPT(PartBundle) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PartBundle, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PartBundle::PartBundle(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PartBundle *return_value = new PartBundle(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PartBundle(PyObject *args, PT(PartBundle) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PartBundle, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PartBundle::PartBundle(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PartBundle *return_value = new PartBundle(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PartBundle_get_nodes(PyObject *self, PyObject *) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_nodes();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PartBundle_get_node_219(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PartBundle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PartBundle) {
    printf("PartBundle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PartBundle *local_this = (PartBundle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PartBundle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PartBundle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PartBundle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PartBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (PartBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PartBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PartBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PartBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PartBundle*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PartBundleNode
 */
/**
 * Python function wrapper for:
 * inline int PartBundleNode::get_num_bundles(void) const
 */
static PyObject *Dtool_PartBundleNode_get_num_bundles_231(PyObject *self, PyObject *) {
  PartBundleNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PartBundleNode::get_num_bundles(void) const
  int return_value = (*(const PartBundleNode*)local_this).get_num_bundles();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundleNode_get_num_bundles_231_comment =
  "C++ Interface:\n"
  "get_num_bundles(PartBundleNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PartBundleNode_get_num_bundles_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PartBundle *PartBundleNode::get_bundle(int n) const
 */
static PyObject *Dtool_PartBundleNode_get_bundle_232(PyObject *self, PyObject *arg) {
  PartBundleNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PartBundle *PartBundleNode::get_bundle(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PartBundle *return_value = (*(const PartBundleNode*)local_this).get_bundle((int)arg_val);
    if (return_value != (PartBundle *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (PartBundle *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundle, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bundle(PartBundleNode self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundleNode_get_bundle_232_comment =
  "C++ Interface:\n"
  "get_bundle(PartBundleNode self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PartBundleNode_get_bundle_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PartBundleHandle *PartBundleNode::get_bundle_handle(int n) const
 */
static PyObject *Dtool_PartBundleNode_get_bundle_handle_234(PyObject *self, PyObject *arg) {
  PartBundleNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PartBundleHandle *PartBundleNode::get_bundle_handle(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PartBundleHandle *return_value = (*(const PartBundleNode*)local_this).get_bundle_handle((int)arg_val);
    if (return_value != (PartBundleHandle *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (PartBundleHandle *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PartBundleHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bundle_handle(PartBundleNode self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundleNode_get_bundle_handle_234_comment =
  "C++ Interface:\n"
  "get_bundle_handle(PartBundleNode self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the PartBundleHandle that wraps around the actual nth PartBundle.\n"
  " * While the PartBundle pointer might later change due to a future flatten\n"
  " * operation, the PartBundleHandle will not.\n"
  " */";
#else
static const char *Dtool_PartBundleNode_get_bundle_handle_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PartBundleNode::get_class_type(void)
 */
static PyObject *Dtool_PartBundleNode_get_class_type_246(PyObject *, PyObject *) {
  // 1-static TypeHandle PartBundleNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PartBundleNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PartBundleNode_get_class_type_246_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PartBundleNode_get_class_type_246_comment = NULL;
#endif

/**
 * sequence length function for property PartBundleNode::bundles
 */
static Py_ssize_t Dtool_PartBundleNode_bundles_Len(PyObject *self) {
  PartBundleNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_bundles();
}

/**
 * sequence getter for property PartBundleNode::bundles
 */
static PyObject *Dtool_PartBundleNode_bundles_Getitem(PyObject *self, Py_ssize_t index) {
  PartBundleNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_bundles()) {
    PyErr_SetString(PyExc_IndexError, "PartBundleNode.bundles[] index out of range");
    return NULL;
  }
  // 1-inline PartBundle *PartBundleNode::get_bundle(int n) const
  PartBundle *return_value = (*(const PartBundleNode*)local_this).get_bundle(index);
  if (return_value != (PartBundle *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (PartBundle *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bundle(PartBundleNode self, index)\n");
  }
}

static PyObject *Dtool_PartBundleNode_bundles_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_PartBundleNode_bundles_Len;
  wrap->_getitem_func = &Dtool_PartBundleNode_bundles_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property PartBundleNode::bundle_handles
 */
static Py_ssize_t Dtool_PartBundleNode_bundle_handles_Len(PyObject *self) {
  PartBundleNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_bundles();
}

/**
 * sequence getter for property PartBundleNode::bundle_handles
 */
static PyObject *Dtool_PartBundleNode_bundle_handles_Getitem(PyObject *self, Py_ssize_t index) {
  PartBundleNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_bundles()) {
    PyErr_SetString(PyExc_IndexError, "PartBundleNode.bundle_handles[] index out of range");
    return NULL;
  }
  // 1-inline PartBundleHandle *PartBundleNode::get_bundle_handle(int n) const
  PartBundleHandle *return_value = (*(const PartBundleNode*)local_this).get_bundle_handle(index);
  if (return_value != (PartBundleHandle *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (PartBundleHandle *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PartBundleHandle, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bundle_handle(PartBundleNode self, index)\n");
  }
}

static PyObject *Dtool_PartBundleNode_bundle_handles_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_PartBundleNode_bundle_handles_Len;
  wrap->_getitem_func = &Dtool_PartBundleNode_bundle_handles_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline PartBundleNode::PartBundleNode(std::string const &name, PartBundle *bundle)
 */
static int Dtool_Init_PartBundleNode(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline PartBundleNode::PartBundleNode(std::string const &name, PartBundle *bundle)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  PyObject *param1;
  static const char *keyword_list[] = {"name", "bundle", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:PartBundleNode", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    PT(PartBundle) param1_this;
    if (!Dtool_Coerce_PartBundle(param1, param1_this)) {
      Dtool_Raise_ArgTypeError(param1, 1, "PartBundleNode.PartBundleNode", "PartBundle");
      return -1;
    }
    PartBundleNode *return_value = new PartBundleNode(std::string(param0_str, param0_len), MOVE(param1_this));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartBundleNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PartBundleNode(str name, PartBundle bundle)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PartBundleNode(PyObject *args, CPT(PartBundleNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PartBundleNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline PartBundleNode::PartBundleNode(std::string const &name, PartBundle *bundle)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:PartBundleNode", &param0_str, &param0_len, &param1)) {
        PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PartBundle, 1, "PartBundleNode.PartBundleNode", false, false);
        if (param1_this != NULL) {
          PartBundleNode *return_value = new PartBundleNode(std::string(param0_str, param0_len), param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PartBundleNode(PyObject *args, PT(PartBundleNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PartBundleNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline PartBundleNode::PartBundleNode(std::string const &name, PartBundle *bundle)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:PartBundleNode", &param0_str, &param0_len, &param1)) {
        PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PartBundle, 1, "PartBundleNode.PartBundleNode", false, false);
        if (param1_this != NULL) {
          PartBundleNode *return_value = new PartBundleNode(std::string(param0_str, param0_len), param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PartBundleNode_get_bundles(PyObject *self, PyObject *) {
  PartBundleNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_bundles();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PartBundleNode_get_bundle_232(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PartBundleNode_get_bundle_handles(PyObject *self, PyObject *) {
  PartBundleNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_bundles();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PartBundleNode_get_bundle_handle_234(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PartBundleNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PartBundleNode) {
    printf("PartBundleNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PartBundleNode *local_this = (PartBundleNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PartBundleNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PartBundleNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PartBundleNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PartBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PartBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PartBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PartBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PartBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PartBundleNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PartBundleHandle
 */
/**
 * Python function wrapper for:
 * inline PartBundle *PartBundleHandle::get_bundle(void)
 */
static PyObject *Dtool_PartBundleHandle_get_bundle_243(PyObject *self, PyObject *) {
  PartBundleHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundleHandle, (void **)&local_this, "PartBundleHandle.get_bundle")) {
    return NULL;
  }
  // 1-inline PartBundle *PartBundleHandle::get_bundle(void)
  PartBundle *return_value = (*local_this).get_bundle();
  if (return_value != (PartBundle *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PartBundle *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartBundleHandle_get_bundle_243_comment =
  "C++ Interface:\n"
  "get_bundle(const PartBundleHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the actual PartBundle embedded within the handle.\n"
  " */";
#else
static const char *Dtool_PartBundleHandle_get_bundle_243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundleHandle::set_bundle(PartBundle *bundle)
 */
static PyObject *Dtool_PartBundleHandle_set_bundle_244(PyObject *self, PyObject *arg) {
  PartBundleHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundleHandle, (void **)&local_this, "PartBundleHandle.set_bundle")) {
    return NULL;
  }
  // 1-inline void PartBundleHandle::set_bundle(PartBundle *bundle)
  PT(PartBundle) arg_this;
  if (!Dtool_Coerce_PartBundle(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PartBundleHandle.set_bundle", "PartBundle");
  }
  (*local_this).set_bundle(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bundle(const PartBundleHandle self, PartBundle bundle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PartBundleHandle_set_bundle_244_comment =
  "C++ Interface:\n"
  "set_bundle(const PartBundleHandle self, PartBundle bundle)\n"
  "\n"
  "/**\n"
  " * Changes the actual PartBundle embedded within the handle.\n"
  " */";
#else
static const char *Dtool_PartBundleHandle_set_bundle_244_comment = NULL;
#endif

static PyObject *Dtool_PartBundleHandle_bundle_Getter(PyObject *self, void *) {
  PartBundleHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundleHandle, (void **)&local_this, "PartBundleHandle.bundle")) {
    return NULL;
  }

  // 1-inline PartBundle *PartBundleHandle::get_bundle(void)
  PartBundle *return_value = (*local_this).get_bundle();
  if (return_value != (PartBundle *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (PartBundle *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_PartBundleHandle_bundle_Setter(PyObject *self, PyObject *arg, void *) {
  PartBundleHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundleHandle, (void **)&local_this, "PartBundleHandle.bundle")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete bundle attribute");
    return -1;
  }
  // 1-inline void PartBundleHandle::set_bundle(PartBundle *bundle)
  PT(PartBundle) arg_this;
  if (!Dtool_Coerce_PartBundle(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PartBundleHandle.set_bundle", "PartBundle");
    return -1;
  }
  (*local_this).set_bundle(MOVE(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bundle(const PartBundleHandle self, PartBundle bundle)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
 * inline PartBundleHandle::PartBundleHandle(PartBundleHandle const &) = default
 */
static int Dtool_Init_PartBundleHandle(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PartBundleHandle() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
    PyObject *param0;
    static const char *keyword_list[] = {"bundle", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PartBundleHandle", (char **)keyword_list, &param0)) {
      PartBundle *param0_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PartBundle, 0, "PartBundleHandle.PartBundleHandle", false, false);
      if (param0_this != NULL) {
        PartBundleHandle *return_value = new PartBundleHandle(param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartBundleHandle, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline PartBundleHandle::PartBundleHandle(PartBundleHandle const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PartBundleHandle", (char **)keyword_list, &param0)) {
      PartBundleHandle const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PartBundleHandle, (void **)&param0_this);
      if (param0_this != NULL) {
        PartBundleHandle *return_value = new PartBundleHandle(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartBundleHandle, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
    PyObject *param0;
    static const char *keyword_list[] = {"bundle", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PartBundleHandle", (char **)keyword_list, &param0)) {
      PT(PartBundle) param0_this;
      if (Dtool_Coerce_PartBundle(param0, param0_this)) {
        PartBundleHandle *return_value = new PartBundleHandle(MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartBundleHandle, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline PartBundleHandle::PartBundleHandle(PartBundleHandle const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PartBundleHandle", (char **)keyword_list, &param0)) {
      CPT(PartBundleHandle) param0_this;
      if (Dtool_ConstCoerce_PartBundleHandle(param0, param0_this)) {
        PartBundleHandle *return_value = new PartBundleHandle(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartBundleHandle, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PartBundleHandle(PartBundle bundle)\n"
      "PartBundleHandle(const PartBundleHandle param0)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PartBundleHandle(PyObject *args, CPT(PartBundleHandle) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PartBundleHandle, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
    PartBundle *arg_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartBundle, 0, "PartBundleHandle.PartBundleHandle", false, false);
    if (arg_this != NULL) {
      PartBundleHandle *return_value = new PartBundleHandle(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_PartBundleHandle(PyObject *args, PT(PartBundleHandle) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PartBundleHandle, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
    PartBundle *arg_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartBundle, 0, "PartBundleHandle.PartBundleHandle", false, false);
    if (arg_this != NULL) {
      PartBundleHandle *return_value = new PartBundleHandle(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_PartBundleHandle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PartBundleHandle) {
    printf("PartBundleHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PartBundleHandle *local_this = (PartBundleHandle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PartBundleHandle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PartBundleHandle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PartBundleHandle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PartBundleHandle*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MovingPartBase
 */
/**
 * Python function wrapper for:
 * inline int MovingPartBase::get_max_bound(void) const
 */
static PyObject *Dtool_MovingPartBase_get_max_bound_262(PyObject *self, PyObject *) {
  MovingPartBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovingPartBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int MovingPartBase::get_max_bound(void) const
  int return_value = (*(const MovingPartBase*)local_this).get_max_bound();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovingPartBase_get_max_bound_262_comment =
  "C++ Interface:\n"
  "get_max_bound(MovingPartBase self)\n"
  "\n"
  "/**\n"
  " * Returns the number of channels that might be bound to this PartGroup.  This\n"
  " * might not be the actual number of channels, since there might be holes in\n"
  " * the list; it is one more than the index number of the highest bound\n"
  " * channel.  Thus, it is called get_max_bound() instead of get_num_bound().\n"
  " */";
#else
static const char *Dtool_MovingPartBase_get_max_bound_262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AnimChannelBase *MovingPartBase::get_bound(int n) const
 */
static PyObject *Dtool_MovingPartBase_get_bound_263(PyObject *self, PyObject *arg) {
  MovingPartBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovingPartBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline AnimChannelBase *MovingPartBase::get_bound(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    AnimChannelBase *return_value = (*(const MovingPartBase*)local_this).get_bound((int)arg_val);
    if (return_value != (AnimChannelBase *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AnimChannelBase *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimChannelBase, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bound(MovingPartBase self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MovingPartBase_get_bound_263_comment =
  "C++ Interface:\n"
  "get_bound(MovingPartBase self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth bound channel on this PartGroup.  n can be determined by\n"
  " * iterating from 0 to one less than get_max_bound(); or n might be\n"
  " * AnimControl::get_channel_index().\n"
  " *\n"
  " * This will return NULL if there is no channel bound on the indicated index.\n"
  " * It is an error to call this if n is less than zero or greater than or equal\n"
  " * to get_max_bound().\n"
  " */";
#else
static const char *Dtool_MovingPartBase_get_bound_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void MovingPartBase::output_value(ostream &out) const = 0
 */
static PyObject *Dtool_MovingPartBase_output_value_264(PyObject *self, PyObject *arg) {
  MovingPartBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovingPartBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void MovingPartBase::output_value(ostream &out) const = 0
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "MovingPartBase.output_value", false, true);
  if (arg_this != NULL) {
    (*(const MovingPartBase*)local_this).output_value(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_value(MovingPartBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MovingPartBase_output_value_264_comment =
  "C++ Interface:\n"
  "output_value(MovingPartBase self, ostream out)\n";
#else
static const char *Dtool_MovingPartBase_output_value_264_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MovingPartBase::get_class_type(void)
 */
static PyObject *Dtool_MovingPartBase_get_class_type_265(PyObject *, PyObject *) {
  // 1-static TypeHandle MovingPartBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MovingPartBase::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPartBase_get_class_type_265_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovingPartBase_get_class_type_265_comment = NULL;
#endif

static int Dtool_Init_MovingPartBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MovingPartBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MovingPartBase) {
    printf("MovingPartBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MovingPartBase *local_this = (MovingPartBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MovingPartBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovingPartBase*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (MovingPartBase*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovingPartBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovingPartBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovingPartBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovingPartBase*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MovingPartMatrix
 */
/**
 * Python function wrapper for:
 * static TypeHandle MovingPartMatrix::get_class_type(void)
 */
static PyObject *Dtool_MovingPartMatrix_get_class_type_273(PyObject *, PyObject *) {
  // 1-static TypeHandle MovingPartMatrix::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MovingPartMatrix::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPartMatrix_get_class_type_273_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovingPartMatrix_get_class_type_273_comment = NULL;
#endif

static int Dtool_Init_MovingPartMatrix(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MovingPartMatrix(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MovingPartMatrix) {
    printf("MovingPartMatrix ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MovingPartMatrix *local_this = (MovingPartMatrix *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MovingPartMatrix) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    return (MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MovingPartMatrix(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MovingPartMatrix) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    MovingPart< ACMatrixSwitchType >* other_this = (MovingPart< ACMatrixSwitchType >*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MovingPart< ACMatrixSwitchType >
 */
/**
 * Python function wrapper for:
 * static TypeHandle MovingPart< ACMatrixSwitchType >::get_class_type(void)
 */
static PyObject *Dtool_MovingPart_ACMatrixSwitchType_get_class_type_269(PyObject *, PyObject *) {
  // 1-static TypeHandle MovingPart< ACMatrixSwitchType >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MovingPart< ACMatrixSwitchType >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_class_type_269_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_class_type_269_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_value(void) const
 */
static PyObject *Dtool_MovingPart_ACMatrixSwitchType_get_value_270(PyObject *self, PyObject *) {
  MovingPart< ACMatrixSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovingPart_ACMatrixSwitchType, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_value(void) const
  LMatrix4 *return_value = new LMatrix4((*(const MovingPart< ACMatrixSwitchType >*)local_this).get_value());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_value_270_comment =
  "C++ Interface:\n"
  "get_value(MovingPart self)\n";
#else
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_value_270_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_default_value(void) const
 */
static PyObject *Dtool_MovingPart_ACMatrixSwitchType_get_default_value_271(PyObject *self, PyObject *) {
  MovingPart< ACMatrixSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovingPart_ACMatrixSwitchType, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_default_value(void) const
  LMatrix4 *return_value = new LMatrix4((*(const MovingPart< ACMatrixSwitchType >*)local_this).get_default_value());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_default_value_271_comment =
  "C++ Interface:\n"
  "get_default_value(MovingPart self)\n";
#else
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_default_value_271_comment = NULL;
#endif

static int Dtool_Init_MovingPart_ACMatrixSwitchType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MovingPart_ACMatrixSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    printf("MovingPart_ACMatrixSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MovingPart< ACMatrixSwitchType > *local_this = (MovingPart< ACMatrixSwitchType > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MovingPart_ACMatrixSwitchType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MovingPartScalar
 */
/**
 * Python function wrapper for:
 * static TypeHandle MovingPartScalar::get_class_type(void)
 */
static PyObject *Dtool_MovingPartScalar_get_class_type_280(PyObject *, PyObject *) {
  // 1-static TypeHandle MovingPartScalar::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MovingPartScalar::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPartScalar_get_class_type_280_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovingPartScalar_get_class_type_280_comment = NULL;
#endif

static int Dtool_Init_MovingPartScalar(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MovingPartScalar(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MovingPartScalar) {
    printf("MovingPartScalar ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MovingPartScalar *local_this = (MovingPartScalar *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MovingPartScalar) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    return (MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MovingPartScalar(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MovingPartScalar) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    MovingPart< ACScalarSwitchType >* other_this = (MovingPart< ACScalarSwitchType >*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovingPartScalar*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MovingPart< ACScalarSwitchType >
 */
/**
 * Python function wrapper for:
 * static TypeHandle MovingPart< ACScalarSwitchType >::get_class_type(void)
 */
static PyObject *Dtool_MovingPart_ACScalarSwitchType_get_class_type_276(PyObject *, PyObject *) {
  // 1-static TypeHandle MovingPart< ACScalarSwitchType >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MovingPart< ACScalarSwitchType >::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACScalarSwitchType_get_class_type_276_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovingPart_ACScalarSwitchType_get_class_type_276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_value(void) const
 */
static PyObject *Dtool_MovingPart_ACScalarSwitchType_get_value_277(PyObject *self, PyObject *) {
  MovingPart< ACScalarSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovingPart_ACScalarSwitchType, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_value(void) const
  PN_stdfloat return_value = (*(const MovingPart< ACScalarSwitchType >*)local_this).get_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACScalarSwitchType_get_value_277_comment =
  "C++ Interface:\n"
  "get_value(MovingPart self)\n";
#else
static const char *Dtool_MovingPart_ACScalarSwitchType_get_value_277_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_default_value(void) const
 */
static PyObject *Dtool_MovingPart_ACScalarSwitchType_get_default_value_278(PyObject *self, PyObject *) {
  MovingPart< ACScalarSwitchType > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MovingPart_ACScalarSwitchType, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_default_value(void) const
  PN_stdfloat return_value = (*(const MovingPart< ACScalarSwitchType >*)local_this).get_default_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACScalarSwitchType_get_default_value_278_comment =
  "C++ Interface:\n"
  "get_default_value(MovingPart self)\n";
#else
static const char *Dtool_MovingPart_ACScalarSwitchType_get_default_value_278_comment = NULL;
#endif

static int Dtool_Init_MovingPart_ACScalarSwitchType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MovingPart_ACScalarSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    printf("MovingPart_ACScalarSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MovingPart< ACScalarSwitchType > *local_this = (MovingPart< ACScalarSwitchType > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MovingPart_ACScalarSwitchType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for AnimGroup (AnimGroup)
 */
static PyMethodDef Dtool_Methods_AnimGroup[] = {
  {"get_num_children", &Dtool_AnimGroup_get_num_children_10, METH_NOARGS, (const char *)Dtool_AnimGroup_get_num_children_10_comment},
  {"getNumChildren", &Dtool_AnimGroup_get_num_children_10, METH_NOARGS, (const char *)Dtool_AnimGroup_get_num_children_10_comment},
  {"get_child", &Dtool_AnimGroup_get_child_11, METH_O, (const char *)Dtool_AnimGroup_get_child_11_comment},
  {"getChild", &Dtool_AnimGroup_get_child_11, METH_O, (const char *)Dtool_AnimGroup_get_child_11_comment},
  {"get_child_named", &Dtool_AnimGroup_get_child_named_15, METH_O, (const char *)Dtool_AnimGroup_get_child_named_15_comment},
  {"getChildNamed", &Dtool_AnimGroup_get_child_named_15, METH_O, (const char *)Dtool_AnimGroup_get_child_named_15_comment},
  {"find_child", &Dtool_AnimGroup_find_child_16, METH_O, (const char *)Dtool_AnimGroup_find_child_16_comment},
  {"findChild", &Dtool_AnimGroup_find_child_16, METH_O, (const char *)Dtool_AnimGroup_find_child_16_comment},
  {"sort_descendants", &Dtool_AnimGroup_sort_descendants_17, METH_NOARGS, (const char *)Dtool_AnimGroup_sort_descendants_17_comment},
  {"sortDescendants", &Dtool_AnimGroup_sort_descendants_17, METH_NOARGS, (const char *)Dtool_AnimGroup_sort_descendants_17_comment},
  {"output", &Dtool_AnimGroup_output_18, METH_O, (const char *)Dtool_AnimGroup_output_18_comment},
  {"write", (PyCFunction) &Dtool_AnimGroup_write_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimGroup_write_19_comment},
  {"get_class_type", &Dtool_AnimGroup_get_class_type_20, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimGroup_get_class_type_20_comment},
  {"getClassType", &Dtool_AnimGroup_get_class_type_20, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimGroup_get_class_type_20_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3, METH_NOARGS, (const char *)Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3, METH_NOARGS, (const char *)Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3_comment},
  {"upcast_to_Namable", &Dtool_AnimGroup_upcast_to_Namable_6, METH_NOARGS, (const char *)Dtool_AnimGroup_upcast_to_Namable_6_comment},
  {"upcastToNamable", &Dtool_AnimGroup_upcast_to_Namable_6, METH_NOARGS, (const char *)Dtool_AnimGroup_upcast_to_Namable_6_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_children", (PyCFunction) &MakeSeq_AnimGroup_get_children, METH_NOARGS, NULL},
  { "getChildren", (PyCFunction) &MakeSeq_AnimGroup_get_children, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     AnimGroup
//////////////////
static PyObject *Dtool_Repr_AnimGroup(PyObject *self) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AnimGroup
//////////////////
static PyObject *Dtool_Str_AnimGroup(PyObject *self) {
  AnimGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_AnimGroup[] = {
  {(char *)"children", &Dtool_AnimGroup_children_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_AnimGroup = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimGroup = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimGroup = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimGroup = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimGroup = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimGroup",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimGroup,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_AnimGroup,
    &Dtool_NumberMethods_AnimGroup,
    &Dtool_SequenceMethods_AnimGroup,
    &Dtool_MappingMethods_AnimGroup,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_AnimGroup,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimGroup,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for AnimChannel and AnimBundle.  It implements a\n"
    " * hierarchy of AnimChannels.  The root of the hierarchy must be an\n"
    " * AnimBundle.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimGroup,
    0, // tp_members
    Dtool_Properties_AnimGroup,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimGroup,
    PyType_GenericAlloc,
    Dtool_new_AnimGroup,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimGroup,
  Dtool_UpcastInterface_AnimGroup,
  Dtool_DowncastInterface_AnimGroup,
  (CoerceFunction)Dtool_ConstCoerce_AnimGroup,
  (CoerceFunction)Dtool_Coerce_AnimGroup,
};

static void Dtool_PyModuleClassInit_AnimGroup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != NULL);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_AnimGroup._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_AnimGroup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimGroup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimGroup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimGroup);
  }
}

/**
 * Python method tables for AnimBundle (AnimBundle)
 */
static PyMethodDef Dtool_Methods_AnimBundle[] = {
  {"copy_bundle", &Dtool_AnimBundle_copy_bundle_23, METH_NOARGS, (const char *)Dtool_AnimBundle_copy_bundle_23_comment},
  {"copyBundle", &Dtool_AnimBundle_copy_bundle_23, METH_NOARGS, (const char *)Dtool_AnimBundle_copy_bundle_23_comment},
  {"get_base_frame_rate", &Dtool_AnimBundle_get_base_frame_rate_24, METH_NOARGS, (const char *)Dtool_AnimBundle_get_base_frame_rate_24_comment},
  {"getBaseFrameRate", &Dtool_AnimBundle_get_base_frame_rate_24, METH_NOARGS, (const char *)Dtool_AnimBundle_get_base_frame_rate_24_comment},
  {"get_num_frames", &Dtool_AnimBundle_get_num_frames_25, METH_NOARGS, (const char *)Dtool_AnimBundle_get_num_frames_25_comment},
  {"getNumFrames", &Dtool_AnimBundle_get_num_frames_25, METH_NOARGS, (const char *)Dtool_AnimBundle_get_num_frames_25_comment},
  {"get_class_type", &Dtool_AnimBundle_get_class_type_26, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimBundle_get_class_type_26_comment},
  {"getClassType", &Dtool_AnimBundle_get_class_type_26, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimBundle_get_class_type_26_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AnimBundle = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimBundle = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimBundle = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimBundle = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimBundle = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimBundle",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimBundle,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AnimBundle,
    &Dtool_SequenceMethods_AnimBundle,
    &Dtool_MappingMethods_AnimBundle,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimBundle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the root of an AnimChannel hierarchy.  It knows the frame rate and\n"
    " * number of frames of all the channels in the hierarchy (which must all\n"
    " * match).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimBundle,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimBundle,
    PyType_GenericAlloc,
    Dtool_new_AnimBundle,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimBundle,
  Dtool_UpcastInterface_AnimBundle,
  Dtool_DowncastInterface_AnimBundle,
  (CoerceFunction)Dtool_ConstCoerce_AnimBundle,
  (CoerceFunction)Dtool_Coerce_AnimBundle,
};

static void Dtool_PyModuleClassInit_AnimBundle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimGroup(NULL);
    Dtool_AnimBundle._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimGroup);
    PyObject *dict = PyDict_New();
    Dtool_AnimBundle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimBundle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimBundle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimBundle);
  }
}

/**
 * Python method tables for AnimBundleNode (AnimBundleNode)
 */
static PyMethodDef Dtool_Methods_AnimBundleNode[] = {
  {"get_bundle", &Dtool_AnimBundleNode_get_bundle_31, METH_NOARGS, (const char *)Dtool_AnimBundleNode_get_bundle_31_comment},
  {"getBundle", &Dtool_AnimBundleNode_get_bundle_31, METH_NOARGS, (const char *)Dtool_AnimBundleNode_get_bundle_31_comment},
  {"find_anim_bundle", &Dtool_AnimBundleNode_find_anim_bundle_32, METH_O | METH_STATIC, (const char *)Dtool_AnimBundleNode_find_anim_bundle_32_comment},
  {"findAnimBundle", &Dtool_AnimBundleNode_find_anim_bundle_32, METH_O | METH_STATIC, (const char *)Dtool_AnimBundleNode_find_anim_bundle_32_comment},
  {"get_class_type", &Dtool_AnimBundleNode_get_class_type_33, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimBundleNode_get_class_type_33_comment},
  {"getClassType", &Dtool_AnimBundleNode_get_class_type_33, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimBundleNode_get_class_type_33_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AnimBundleNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimBundleNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimBundleNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimBundleNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimBundleNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimBundleNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimBundleNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AnimBundleNode,
    &Dtool_SequenceMethods_AnimBundleNode,
    &Dtool_MappingMethods_AnimBundleNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimBundleNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a node that contains a pointer to an AnimBundle.  Like\n"
    " * PartBundleNode, it exists solely to make it easy to store AnimBundles in\n"
    " * the scene graph.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimBundleNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimBundleNode,
    PyType_GenericAlloc,
    Dtool_new_AnimBundleNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimBundleNode,
  Dtool_UpcastInterface_AnimBundleNode,
  Dtool_DowncastInterface_AnimBundleNode,
  (CoerceFunction)Dtool_ConstCoerce_AnimBundleNode,
  (CoerceFunction)Dtool_Coerce_AnimBundleNode,
};

static void Dtool_PyModuleClassInit_AnimBundleNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_AnimBundleNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_AnimBundleNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimBundleNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimBundleNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimBundleNode);
  }
}

/**
 * Python method tables for PartGroup (PartGroup)
 */
static PyMethodDef Dtool_Methods_PartGroup[] = {
  {"is_character_joint", &Dtool_PartGroup_is_character_joint_43, METH_NOARGS, (const char *)Dtool_PartGroup_is_character_joint_43_comment},
  {"isCharacterJoint", &Dtool_PartGroup_is_character_joint_43, METH_NOARGS, (const char *)Dtool_PartGroup_is_character_joint_43_comment},
  {"make_copy", &Dtool_PartGroup_make_copy_44, METH_NOARGS, (const char *)Dtool_PartGroup_make_copy_44_comment},
  {"makeCopy", &Dtool_PartGroup_make_copy_44, METH_NOARGS, (const char *)Dtool_PartGroup_make_copy_44_comment},
  {"copy_subgraph", &Dtool_PartGroup_copy_subgraph_45, METH_NOARGS, (const char *)Dtool_PartGroup_copy_subgraph_45_comment},
  {"copySubgraph", &Dtool_PartGroup_copy_subgraph_45, METH_NOARGS, (const char *)Dtool_PartGroup_copy_subgraph_45_comment},
  {"get_num_children", &Dtool_PartGroup_get_num_children_46, METH_NOARGS, (const char *)Dtool_PartGroup_get_num_children_46_comment},
  {"getNumChildren", &Dtool_PartGroup_get_num_children_46, METH_NOARGS, (const char *)Dtool_PartGroup_get_num_children_46_comment},
  {"get_child", &Dtool_PartGroup_get_child_47, METH_O, (const char *)Dtool_PartGroup_get_child_47_comment},
  {"getChild", &Dtool_PartGroup_get_child_47, METH_O, (const char *)Dtool_PartGroup_get_child_47_comment},
  {"get_child_named", &Dtool_PartGroup_get_child_named_51, METH_O, (const char *)Dtool_PartGroup_get_child_named_51_comment},
  {"getChildNamed", &Dtool_PartGroup_get_child_named_51, METH_O, (const char *)Dtool_PartGroup_get_child_named_51_comment},
  {"find_child", &Dtool_PartGroup_find_child_52, METH_O, (const char *)Dtool_PartGroup_find_child_52_comment},
  {"findChild", &Dtool_PartGroup_find_child_52, METH_O, (const char *)Dtool_PartGroup_find_child_52_comment},
  {"sort_descendants", &Dtool_PartGroup_sort_descendants_53, METH_NOARGS, (const char *)Dtool_PartGroup_sort_descendants_53_comment},
  {"sortDescendants", &Dtool_PartGroup_sort_descendants_53, METH_NOARGS, (const char *)Dtool_PartGroup_sort_descendants_53_comment},
  {"apply_freeze", &Dtool_PartGroup_apply_freeze_54, METH_O, (const char *)Dtool_PartGroup_apply_freeze_54_comment},
  {"applyFreeze", &Dtool_PartGroup_apply_freeze_54, METH_O, (const char *)Dtool_PartGroup_apply_freeze_54_comment},
  {"apply_freeze_matrix", (PyCFunction) &Dtool_PartGroup_apply_freeze_matrix_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartGroup_apply_freeze_matrix_55_comment},
  {"applyFreezeMatrix", (PyCFunction) &Dtool_PartGroup_apply_freeze_matrix_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartGroup_apply_freeze_matrix_55_comment},
  {"apply_freeze_scalar", &Dtool_PartGroup_apply_freeze_scalar_56, METH_O, (const char *)Dtool_PartGroup_apply_freeze_scalar_56_comment},
  {"applyFreezeScalar", &Dtool_PartGroup_apply_freeze_scalar_56, METH_O, (const char *)Dtool_PartGroup_apply_freeze_scalar_56_comment},
  {"apply_control", &Dtool_PartGroup_apply_control_57, METH_O, (const char *)Dtool_PartGroup_apply_control_57_comment},
  {"applyControl", &Dtool_PartGroup_apply_control_57, METH_O, (const char *)Dtool_PartGroup_apply_control_57_comment},
  {"clear_forced_channel", &Dtool_PartGroup_clear_forced_channel_58, METH_NOARGS, (const char *)Dtool_PartGroup_clear_forced_channel_58_comment},
  {"clearForcedChannel", &Dtool_PartGroup_clear_forced_channel_58, METH_NOARGS, (const char *)Dtool_PartGroup_clear_forced_channel_58_comment},
  {"get_forced_channel", &Dtool_PartGroup_get_forced_channel_59, METH_NOARGS, (const char *)Dtool_PartGroup_get_forced_channel_59_comment},
  {"getForcedChannel", &Dtool_PartGroup_get_forced_channel_59, METH_NOARGS, (const char *)Dtool_PartGroup_get_forced_channel_59_comment},
  {"write", (PyCFunction) &Dtool_PartGroup_write_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartGroup_write_60_comment},
  {"write_with_value", (PyCFunction) &Dtool_PartGroup_write_with_value_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartGroup_write_with_value_61_comment},
  {"writeWithValue", (PyCFunction) &Dtool_PartGroup_write_with_value_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartGroup_write_with_value_61_comment},
  {"get_class_type", &Dtool_PartGroup_get_class_type_62, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartGroup_get_class_type_62_comment},
  {"getClassType", &Dtool_PartGroup_get_class_type_62, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartGroup_get_class_type_62_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_36, METH_NOARGS, (const char *)Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_36_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_36, METH_NOARGS, (const char *)Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_36_comment},
  {"upcast_to_Namable", &Dtool_PartGroup_upcast_to_Namable_38, METH_NOARGS, (const char *)Dtool_PartGroup_upcast_to_Namable_38_comment},
  {"upcastToNamable", &Dtool_PartGroup_upcast_to_Namable_38, METH_NOARGS, (const char *)Dtool_PartGroup_upcast_to_Namable_38_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_children", (PyCFunction) &MakeSeq_PartGroup_get_children, METH_NOARGS, NULL},
  { "getChildren", (PyCFunction) &MakeSeq_PartGroup_get_children, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     PartGroup
//////////////////
static PyObject *Dtool_Str_PartGroup(PyObject *self) {
  PartGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PartGroup[] = {
  {(char *)"children", &Dtool_PartGroup_children_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PartGroup = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PartGroup = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PartGroup = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PartGroup = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PartGroup = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PartGroup",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PartGroup,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PartGroup,
    &Dtool_SequenceMethods_PartGroup,
    &Dtool_MappingMethods_PartGroup,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_PartGroup,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PartGroup,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for PartRoot and MovingPart.  It defines a hierarchy\n"
    " * of MovingParts.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PartGroup,
    0, // tp_members
    Dtool_Properties_PartGroup,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PartGroup,
    PyType_GenericAlloc,
    Dtool_new_PartGroup,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PartGroup,
  Dtool_UpcastInterface_PartGroup,
  Dtool_DowncastInterface_PartGroup,
  (CoerceFunction)Dtool_ConstCoerce_PartGroup,
  (CoerceFunction)Dtool_Coerce_PartGroup,
};

static void Dtool_PyModuleClassInit_PartGroup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != NULL);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_PartGroup._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_PartGroup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PartGroup::HierarchyMatchFlags;
    PyDict_SetItemString(dict, "HMF_ok_part_extra", Dtool_WrapValue(PartGroup::HMF_ok_part_extra));
    PyDict_SetItemString(dict, "HMFOkPartExtra", Dtool_WrapValue(PartGroup::HMF_ok_part_extra));
    PyDict_SetItemString(dict, "HMF_ok_anim_extra", Dtool_WrapValue(PartGroup::HMF_ok_anim_extra));
    PyDict_SetItemString(dict, "HMFOkAnimExtra", Dtool_WrapValue(PartGroup::HMF_ok_anim_extra));
    PyDict_SetItemString(dict, "HMF_ok_wrong_root_name", Dtool_WrapValue(PartGroup::HMF_ok_wrong_root_name));
    PyDict_SetItemString(dict, "HMFOkWrongRootName", Dtool_WrapValue(PartGroup::HMF_ok_wrong_root_name));
    if (PyType_Ready((PyTypeObject *)&Dtool_PartGroup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PartGroup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PartGroup);
  }
}

/**
 * Python method tables for AnimControl (AnimControl)
 */
static PyMethodDef Dtool_Methods_AnimControl[] = {
  {"is_pending", &Dtool_AnimControl_is_pending_73, METH_NOARGS, (const char *)Dtool_AnimControl_is_pending_73_comment},
  {"isPending", &Dtool_AnimControl_is_pending_73, METH_NOARGS, (const char *)Dtool_AnimControl_is_pending_73_comment},
  {"wait_pending", &Dtool_AnimControl_wait_pending_74, METH_NOARGS, (const char *)Dtool_AnimControl_wait_pending_74_comment},
  {"waitPending", &Dtool_AnimControl_wait_pending_74, METH_NOARGS, (const char *)Dtool_AnimControl_wait_pending_74_comment},
  {"has_anim", &Dtool_AnimControl_has_anim_75, METH_NOARGS, (const char *)Dtool_AnimControl_has_anim_75_comment},
  {"hasAnim", &Dtool_AnimControl_has_anim_75, METH_NOARGS, (const char *)Dtool_AnimControl_has_anim_75_comment},
  {"set_pending_done_event", &Dtool_AnimControl_set_pending_done_event_76, METH_O, (const char *)Dtool_AnimControl_set_pending_done_event_76_comment},
  {"setPendingDoneEvent", &Dtool_AnimControl_set_pending_done_event_76, METH_O, (const char *)Dtool_AnimControl_set_pending_done_event_76_comment},
  {"get_pending_done_event", &Dtool_AnimControl_get_pending_done_event_77, METH_NOARGS, (const char *)Dtool_AnimControl_get_pending_done_event_77_comment},
  {"getPendingDoneEvent", &Dtool_AnimControl_get_pending_done_event_77, METH_NOARGS, (const char *)Dtool_AnimControl_get_pending_done_event_77_comment},
  {"get_part", &Dtool_AnimControl_get_part_78, METH_NOARGS, (const char *)Dtool_AnimControl_get_part_78_comment},
  {"getPart", &Dtool_AnimControl_get_part_78, METH_NOARGS, (const char *)Dtool_AnimControl_get_part_78_comment},
  {"get_anim", &Dtool_AnimControl_get_anim_79, METH_NOARGS, (const char *)Dtool_AnimControl_get_anim_79_comment},
  {"getAnim", &Dtool_AnimControl_get_anim_79, METH_NOARGS, (const char *)Dtool_AnimControl_get_anim_79_comment},
  {"get_channel_index", &Dtool_AnimControl_get_channel_index_80, METH_NOARGS, (const char *)Dtool_AnimControl_get_channel_index_80_comment},
  {"getChannelIndex", &Dtool_AnimControl_get_channel_index_80, METH_NOARGS, (const char *)Dtool_AnimControl_get_channel_index_80_comment},
  {"get_bound_joints", &Dtool_AnimControl_get_bound_joints_81, METH_NOARGS, (const char *)Dtool_AnimControl_get_bound_joints_81_comment},
  {"getBoundJoints", &Dtool_AnimControl_get_bound_joints_81, METH_NOARGS, (const char *)Dtool_AnimControl_get_bound_joints_81_comment},
  {"set_anim_model", &Dtool_AnimControl_set_anim_model_82, METH_O, (const char *)Dtool_AnimControl_set_anim_model_82_comment},
  {"setAnimModel", &Dtool_AnimControl_set_anim_model_82, METH_O, (const char *)Dtool_AnimControl_set_anim_model_82_comment},
  {"get_anim_model", &Dtool_AnimControl_get_anim_model_83, METH_NOARGS, (const char *)Dtool_AnimControl_get_anim_model_83_comment},
  {"getAnimModel", &Dtool_AnimControl_get_anim_model_83, METH_NOARGS, (const char *)Dtool_AnimControl_get_anim_model_83_comment},
  {"output", &Dtool_AnimControl_output_84, METH_O, (const char *)Dtool_AnimControl_output_84_comment},
  {"get_class_type", &Dtool_AnimControl_get_class_type_85, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimControl_get_class_type_85_comment},
  {"getClassType", &Dtool_AnimControl_get_class_type_85, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimControl_get_class_type_85_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_AnimControl_upcast_to_TypedReferenceCount_65, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_TypedReferenceCount_65_comment},
  {"upcastToTypedReferenceCount", &Dtool_AnimControl_upcast_to_TypedReferenceCount_65, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_TypedReferenceCount_65_comment},
  {"upcast_to_AnimInterface", &Dtool_AnimControl_upcast_to_AnimInterface_68, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_AnimInterface_68_comment},
  {"upcastToAnimInterface", &Dtool_AnimControl_upcast_to_AnimInterface_68, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_AnimInterface_68_comment},
  {"upcast_to_Namable", &Dtool_AnimControl_upcast_to_Namable_70, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_Namable_70_comment},
  {"upcastToNamable", &Dtool_AnimControl_upcast_to_Namable_70, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_Namable_70_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     AnimControl
//////////////////
static PyObject *Dtool_Repr_AnimControl(PyObject *self) {
  AnimControl *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControl, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AnimControl = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimControl = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimControl = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimControl = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimControl = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimControl",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimControl,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_AnimControl,
    &Dtool_NumberMethods_AnimControl,
    &Dtool_SequenceMethods_AnimControl,
    &Dtool_MappingMethods_AnimControl,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_AnimControl,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimControl,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Controls the timing of a character animation.  An AnimControl object is\n"
    " * created for each character/bundle binding and manages the state of the\n"
    " * animation: whether started, stopped, or looping, and the current frame\n"
    " * number and play rate.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimControl,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimControl,
    PyType_GenericAlloc,
    Dtool_new_AnimControl,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimControl,
  Dtool_UpcastInterface_AnimControl,
  Dtool_DowncastInterface_AnimControl,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AnimControl(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_AnimInterface != NULL);
    assert(Dtool_Ptr_AnimInterface->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_AnimInterface->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_AnimControl._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_AnimInterface, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_AnimControl._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimControl) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimControl)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimControl);
  }
}

/**
 * Python method tables for AnimChannelBase (AnimChannelBase)
 */
static PyMethodDef Dtool_Methods_AnimChannelBase[] = {
  {"get_type", &Dtool_AnimChannelBase_get_type_87, METH_NOARGS, (const char *)Dtool_AnimChannelBase_get_type_87_comment},
  {"getType", &Dtool_AnimChannelBase_get_type_87, METH_NOARGS, (const char *)Dtool_AnimChannelBase_get_type_87_comment},
  {"get_class_type", &Dtool_AnimChannelBase_get_class_type_88, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelBase_get_class_type_88_comment},
  {"getClassType", &Dtool_AnimChannelBase_get_class_type_88, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelBase_get_class_type_88_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AnimChannelBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannelBase = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimChannelBase = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimChannelBase = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimChannelBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimChannelBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannelBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AnimChannelBase,
    &Dtool_SequenceMethods_AnimChannelBase,
    &Dtool_MappingMethods_AnimChannelBase,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimChannelBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Parent class for all animation channels.  An AnimChannel is an arbitrary\n"
    " * function that changes over time (actually, over frames), usually defined by\n"
    " * a table read from an egg file (but possibly computed or generated in any\n"
    " * other way).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimChannelBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimChannelBase,
    PyType_GenericAlloc,
    Dtool_new_AnimChannelBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannelBase,
  Dtool_UpcastInterface_AnimChannelBase,
  Dtool_DowncastInterface_AnimChannelBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AnimChannelBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimGroup(NULL);
    Dtool_AnimChannelBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimGroup);
    PyObject *dict = PyDict_New();
    Dtool_AnimChannelBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannelBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannelBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannelBase);
  }
}

/**
 * Python method tables for AnimChannel_ACMatrixSwitchType (AnimChannel_ACMatrixSwitchType)
 */
static PyMethodDef Dtool_Methods_AnimChannel_ACMatrixSwitchType[] = {
  {"get_value", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_value_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_93_comment},
  {"getValue", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_value_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_93_comment},
  {"get_value_no_scale_shear", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_94, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_94_comment},
  {"getValueNoScaleShear", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_94, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_94_comment},
  {"get_scale", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_scale_95, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_scale_95_comment},
  {"getScale", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_scale_95, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_scale_95_comment},
  {"get_hpr", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_96, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_96_comment},
  {"getHpr", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_96, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_96_comment},
  {"get_quat", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_quat_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_quat_97_comment},
  {"getQuat", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_quat_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_quat_97_comment},
  {"get_pos", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_pos_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_pos_98_comment},
  {"getPos", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_pos_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_pos_98_comment},
  {"get_shear", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_shear_99, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_shear_99_comment},
  {"getShear", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_shear_99, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_shear_99_comment},
  {"get_value_type", &Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_100, METH_NOARGS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_100_comment},
  {"getValueType", &Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_100, METH_NOARGS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_100_comment},
  {"get_class_type", &Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_101, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_101_comment},
  {"getClassType", &Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_101, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_101_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AnimChannel_ACMatrixSwitchType = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannel_ACMatrixSwitchType = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimChannel_ACMatrixSwitchType = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimChannel_ACMatrixSwitchType = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimChannel_ACMatrixSwitchType = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimChannel_ACMatrixSwitchType",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannel_ACMatrixSwitchType,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AnimChannel_ACMatrixSwitchType,
    &Dtool_SequenceMethods_AnimChannel_ACMatrixSwitchType,
    &Dtool_MappingMethods_AnimChannel_ACMatrixSwitchType,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimChannel_ACMatrixSwitchType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimChannel_ACMatrixSwitchType,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimChannel_ACMatrixSwitchType,
    PyType_GenericAlloc,
    Dtool_new_AnimChannel_ACMatrixSwitchType,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType,
  Dtool_UpcastInterface_AnimChannel_ACMatrixSwitchType,
  Dtool_DowncastInterface_AnimChannel_ACMatrixSwitchType,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannelBase(NULL);
    Dtool_AnimChannel_ACMatrixSwitchType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannelBase);
    PyObject *dict = PyDict_New();
    Dtool_AnimChannel_ACMatrixSwitchType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannel_ACMatrixSwitchType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannel_ACMatrixSwitchType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
  }
}

/**
 * Python method tables for AnimChannel_ACScalarSwitchType (AnimChannel_ACScalarSwitchType)
 */
static PyMethodDef Dtool_Methods_AnimChannel_ACScalarSwitchType[] = {
  {"get_scale", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_scale_106, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_scale_106_comment},
  {"getScale", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_scale_106, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_scale_106_comment},
  {"get_hpr", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_hpr_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_hpr_107_comment},
  {"getHpr", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_hpr_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_hpr_107_comment},
  {"get_quat", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_quat_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_quat_108_comment},
  {"getQuat", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_quat_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_quat_108_comment},
  {"get_pos", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_pos_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_pos_109_comment},
  {"getPos", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_pos_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_pos_109_comment},
  {"get_shear", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_shear_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_shear_110_comment},
  {"getShear", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_shear_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_shear_110_comment},
  {"get_value_type", &Dtool_AnimChannel_ACScalarSwitchType_get_value_type_111, METH_NOARGS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_value_type_111_comment},
  {"getValueType", &Dtool_AnimChannel_ACScalarSwitchType_get_value_type_111, METH_NOARGS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_value_type_111_comment},
  {"get_class_type", &Dtool_AnimChannel_ACScalarSwitchType_get_class_type_112, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_class_type_112_comment},
  {"getClassType", &Dtool_AnimChannel_ACScalarSwitchType_get_class_type_112, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_class_type_112_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AnimChannel_ACScalarSwitchType = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannel_ACScalarSwitchType = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimChannel_ACScalarSwitchType = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimChannel_ACScalarSwitchType = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimChannel_ACScalarSwitchType = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimChannel_ACScalarSwitchType",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannel_ACScalarSwitchType,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AnimChannel_ACScalarSwitchType,
    &Dtool_SequenceMethods_AnimChannel_ACScalarSwitchType,
    &Dtool_MappingMethods_AnimChannel_ACScalarSwitchType,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimChannel_ACScalarSwitchType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimChannel_ACScalarSwitchType,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimChannel_ACScalarSwitchType,
    PyType_GenericAlloc,
    Dtool_new_AnimChannel_ACScalarSwitchType,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType,
  Dtool_UpcastInterface_AnimChannel_ACScalarSwitchType,
  Dtool_DowncastInterface_AnimChannel_ACScalarSwitchType,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannelBase(NULL);
    Dtool_AnimChannel_ACScalarSwitchType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannelBase);
    PyObject *dict = PyDict_New();
    Dtool_AnimChannel_ACScalarSwitchType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannel_ACScalarSwitchType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannel_ACScalarSwitchType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannel_ACScalarSwitchType);
  }
}

/**
 * Python method tables for AnimChannelMatrixDynamic (AnimChannelMatrixDynamic)
 */
static PyMethodDef Dtool_Methods_AnimChannelMatrixDynamic[] = {
  {"set_value", &Dtool_AnimChannelMatrixDynamic_set_value_115, METH_O, (const char *)Dtool_AnimChannelMatrixDynamic_set_value_115_comment},
  {"setValue", &Dtool_AnimChannelMatrixDynamic_set_value_115, METH_O, (const char *)Dtool_AnimChannelMatrixDynamic_set_value_115_comment},
  {"set_value_node", &Dtool_AnimChannelMatrixDynamic_set_value_node_116, METH_O, (const char *)Dtool_AnimChannelMatrixDynamic_set_value_node_116_comment},
  {"setValueNode", &Dtool_AnimChannelMatrixDynamic_set_value_node_116, METH_O, (const char *)Dtool_AnimChannelMatrixDynamic_set_value_node_116_comment},
  {"get_value_transform", &Dtool_AnimChannelMatrixDynamic_get_value_transform_117, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixDynamic_get_value_transform_117_comment},
  {"getValueTransform", &Dtool_AnimChannelMatrixDynamic_get_value_transform_117, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixDynamic_get_value_transform_117_comment},
  {"get_value_node", &Dtool_AnimChannelMatrixDynamic_get_value_node_118, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixDynamic_get_value_node_118_comment},
  {"getValueNode", &Dtool_AnimChannelMatrixDynamic_get_value_node_118, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixDynamic_get_value_node_118_comment},
  {"get_class_type", &Dtool_AnimChannelMatrixDynamic_get_class_type_119, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelMatrixDynamic_get_class_type_119_comment},
  {"getClassType", &Dtool_AnimChannelMatrixDynamic_get_class_type_119, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelMatrixDynamic_get_class_type_119_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AnimChannelMatrixDynamic = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannelMatrixDynamic = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimChannelMatrixDynamic = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimChannelMatrixDynamic = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimChannelMatrixDynamic = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimChannelMatrixDynamic",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannelMatrixDynamic,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AnimChannelMatrixDynamic,
    &Dtool_SequenceMethods_AnimChannelMatrixDynamic,
    &Dtool_MappingMethods_AnimChannelMatrixDynamic,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimChannelMatrixDynamic,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An animation channel that accepts a matrix each frame from some dynamic\n"
    " * input provided by code.\n"
    " *\n"
    " * This object operates in two modes: in explicit mode, the programmer should\n"
    " * call set_value() each frame to indicate the new value; in implicit mode,\n"
    " * the programmer should call set_value_node() to indicate the node whose\n"
    " * transform will be copied to the joint each frame.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimChannelMatrixDynamic,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimChannelMatrixDynamic,
    PyType_GenericAlloc,
    Dtool_new_AnimChannelMatrixDynamic,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannelMatrixDynamic,
  Dtool_UpcastInterface_AnimChannelMatrixDynamic,
  Dtool_DowncastInterface_AnimChannelMatrixDynamic,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AnimChannelMatrixDynamic(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(NULL);
    Dtool_AnimChannelMatrixDynamic._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
    PyObject *dict = PyDict_New();
    Dtool_AnimChannelMatrixDynamic._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannelMatrixDynamic) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannelMatrixDynamic)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannelMatrixDynamic);
  }
}

/**
 * Python method tables for AnimChannelMatrixXfmTable (AnimChannelMatrixXfmTable)
 */
static PyMethodDef Dtool_Methods_AnimChannelMatrixXfmTable[] = {
  {"is_valid_id", &Dtool_AnimChannelMatrixXfmTable_is_valid_id_123, METH_O | METH_STATIC, (const char *)Dtool_AnimChannelMatrixXfmTable_is_valid_id_123_comment},
  {"isValidId", &Dtool_AnimChannelMatrixXfmTable_is_valid_id_123, METH_O | METH_STATIC, (const char *)Dtool_AnimChannelMatrixXfmTable_is_valid_id_123_comment},
  {"set_table", (PyCFunction) &Dtool_AnimChannelMatrixXfmTable_set_table_124, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannelMatrixXfmTable_set_table_124_comment},
  {"setTable", (PyCFunction) &Dtool_AnimChannelMatrixXfmTable_set_table_124, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannelMatrixXfmTable_set_table_124_comment},
  {"get_table", &Dtool_AnimChannelMatrixXfmTable_get_table_125, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_get_table_125_comment},
  {"getTable", &Dtool_AnimChannelMatrixXfmTable_get_table_125, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_get_table_125_comment},
  {"clear_all_tables", &Dtool_AnimChannelMatrixXfmTable_clear_all_tables_126, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixXfmTable_clear_all_tables_126_comment},
  {"clearAllTables", &Dtool_AnimChannelMatrixXfmTable_clear_all_tables_126, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixXfmTable_clear_all_tables_126_comment},
  {"has_table", &Dtool_AnimChannelMatrixXfmTable_has_table_127, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_has_table_127_comment},
  {"hasTable", &Dtool_AnimChannelMatrixXfmTable_has_table_127, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_has_table_127_comment},
  {"clear_table", &Dtool_AnimChannelMatrixXfmTable_clear_table_128, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_clear_table_128_comment},
  {"clearTable", &Dtool_AnimChannelMatrixXfmTable_clear_table_128, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_clear_table_128_comment},
  {"get_class_type", &Dtool_AnimChannelMatrixXfmTable_get_class_type_129, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelMatrixXfmTable_get_class_type_129_comment},
  {"getClassType", &Dtool_AnimChannelMatrixXfmTable_get_class_type_129, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelMatrixXfmTable_get_class_type_129_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AnimChannelMatrixXfmTable = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannelMatrixXfmTable = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimChannelMatrixXfmTable = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimChannelMatrixXfmTable = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimChannelMatrixXfmTable = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimChannelMatrixXfmTable",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannelMatrixXfmTable,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AnimChannelMatrixXfmTable,
    &Dtool_SequenceMethods_AnimChannelMatrixXfmTable,
    &Dtool_MappingMethods_AnimChannelMatrixXfmTable,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimChannelMatrixXfmTable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An animation channel that issues a matrix each frame, read from a table\n"
    " * such as might have been read from an egg file.  The table actually consists\n"
    " * of nine sub-tables, each representing one component of the transform:\n"
    " * scale, rotate, translate.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimChannelMatrixXfmTable,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimChannelMatrixXfmTable,
    PyType_GenericAlloc,
    Dtool_new_AnimChannelMatrixXfmTable,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannelMatrixXfmTable,
  Dtool_UpcastInterface_AnimChannelMatrixXfmTable,
  Dtool_DowncastInterface_AnimChannelMatrixXfmTable,
  (CoerceFunction)Dtool_ConstCoerce_AnimChannelMatrixXfmTable,
  (CoerceFunction)Dtool_Coerce_AnimChannelMatrixXfmTable,
};

static void Dtool_PyModuleClassInit_AnimChannelMatrixXfmTable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(NULL);
    Dtool_AnimChannelMatrixXfmTable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
    PyObject *dict = PyDict_New();
    Dtool_AnimChannelMatrixXfmTable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannelMatrixXfmTable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannelMatrixXfmTable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannelMatrixXfmTable);
  }
}

/**
 * Python method tables for AnimChannelScalarDynamic (AnimChannelScalarDynamic)
 */
static PyMethodDef Dtool_Methods_AnimChannelScalarDynamic[] = {
  {"set_value", &Dtool_AnimChannelScalarDynamic_set_value_131, METH_O, (const char *)Dtool_AnimChannelScalarDynamic_set_value_131_comment},
  {"setValue", &Dtool_AnimChannelScalarDynamic_set_value_131, METH_O, (const char *)Dtool_AnimChannelScalarDynamic_set_value_131_comment},
  {"set_value_node", &Dtool_AnimChannelScalarDynamic_set_value_node_132, METH_O, (const char *)Dtool_AnimChannelScalarDynamic_set_value_node_132_comment},
  {"setValueNode", &Dtool_AnimChannelScalarDynamic_set_value_node_132, METH_O, (const char *)Dtool_AnimChannelScalarDynamic_set_value_node_132_comment},
  {"get_class_type", &Dtool_AnimChannelScalarDynamic_get_class_type_133, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelScalarDynamic_get_class_type_133_comment},
  {"getClassType", &Dtool_AnimChannelScalarDynamic_get_class_type_133, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelScalarDynamic_get_class_type_133_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AnimChannelScalarDynamic = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannelScalarDynamic = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimChannelScalarDynamic = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimChannelScalarDynamic = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimChannelScalarDynamic = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimChannelScalarDynamic",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannelScalarDynamic,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AnimChannelScalarDynamic,
    &Dtool_SequenceMethods_AnimChannelScalarDynamic,
    &Dtool_MappingMethods_AnimChannelScalarDynamic,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimChannelScalarDynamic,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An animation channel that accepts a scalar each frame from some dynamic\n"
    " * input provided by code.\n"
    " *\n"
    " * This object operates in two modes: in explicit mode, the programmer should\n"
    " * call set_value() each frame to indicate the new value; in implicit mode,\n"
    " * the programmer should call set_value_node() to indicate the node whose X\n"
    " * component will be copied to the scalar each frame.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimChannelScalarDynamic,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimChannelScalarDynamic,
    PyType_GenericAlloc,
    Dtool_new_AnimChannelScalarDynamic,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannelScalarDynamic,
  Dtool_UpcastInterface_AnimChannelScalarDynamic,
  Dtool_DowncastInterface_AnimChannelScalarDynamic,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AnimChannelScalarDynamic(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(NULL);
    Dtool_AnimChannelScalarDynamic._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannel_ACScalarSwitchType);
    PyObject *dict = PyDict_New();
    Dtool_AnimChannelScalarDynamic._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannelScalarDynamic) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannelScalarDynamic)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannelScalarDynamic);
  }
}

/**
 * Python method tables for AnimChannelScalarTable (AnimChannelScalarTable)
 */
static PyMethodDef Dtool_Methods_AnimChannelScalarTable[] = {
  {"set_table", &Dtool_AnimChannelScalarTable_set_table_136, METH_O, (const char *)Dtool_AnimChannelScalarTable_set_table_136_comment},
  {"setTable", &Dtool_AnimChannelScalarTable_set_table_136, METH_O, (const char *)Dtool_AnimChannelScalarTable_set_table_136_comment},
  {"get_table", &Dtool_AnimChannelScalarTable_get_table_137, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_get_table_137_comment},
  {"getTable", &Dtool_AnimChannelScalarTable_get_table_137, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_get_table_137_comment},
  {"has_table", &Dtool_AnimChannelScalarTable_has_table_138, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_has_table_138_comment},
  {"hasTable", &Dtool_AnimChannelScalarTable_has_table_138, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_has_table_138_comment},
  {"clear_table", &Dtool_AnimChannelScalarTable_clear_table_139, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_clear_table_139_comment},
  {"clearTable", &Dtool_AnimChannelScalarTable_clear_table_139, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_clear_table_139_comment},
  {"get_class_type", &Dtool_AnimChannelScalarTable_get_class_type_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelScalarTable_get_class_type_140_comment},
  {"getClassType", &Dtool_AnimChannelScalarTable_get_class_type_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelScalarTable_get_class_type_140_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AnimChannelScalarTable = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannelScalarTable = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimChannelScalarTable = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimChannelScalarTable = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimChannelScalarTable = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimChannelScalarTable",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannelScalarTable,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AnimChannelScalarTable,
    &Dtool_SequenceMethods_AnimChannelScalarTable,
    &Dtool_MappingMethods_AnimChannelScalarTable,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimChannelScalarTable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An animation channel that issues a scalar each frame, read from a table\n"
    " * such as might have been read from an egg file.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimChannelScalarTable,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimChannelScalarTable,
    PyType_GenericAlloc,
    Dtool_new_AnimChannelScalarTable,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannelScalarTable,
  Dtool_UpcastInterface_AnimChannelScalarTable,
  Dtool_DowncastInterface_AnimChannelScalarTable,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AnimChannelScalarTable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(NULL);
    Dtool_AnimChannelScalarTable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannel_ACScalarSwitchType);
    PyObject *dict = PyDict_New();
    Dtool_AnimChannelScalarTable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannelScalarTable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannelScalarTable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannelScalarTable);
  }
}

/**
 * Python method tables for AnimControlCollection (AnimControlCollection)
 */
static PyMethodDef Dtool_Methods_AnimControlCollection[] = {
  {"store_anim", (PyCFunction) &Dtool_AnimControlCollection_store_anim_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_store_anim_145_comment},
  {"storeAnim", (PyCFunction) &Dtool_AnimControlCollection_store_anim_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_store_anim_145_comment},
  {"find_anim", &Dtool_AnimControlCollection_find_anim_146, METH_O, (const char *)Dtool_AnimControlCollection_find_anim_146_comment},
  {"findAnim", &Dtool_AnimControlCollection_find_anim_146, METH_O, (const char *)Dtool_AnimControlCollection_find_anim_146_comment},
  {"unbind_anim", &Dtool_AnimControlCollection_unbind_anim_147, METH_O, (const char *)Dtool_AnimControlCollection_unbind_anim_147_comment},
  {"unbindAnim", &Dtool_AnimControlCollection_unbind_anim_147, METH_O, (const char *)Dtool_AnimControlCollection_unbind_anim_147_comment},
  {"get_num_anims", &Dtool_AnimControlCollection_get_num_anims_148, METH_NOARGS, (const char *)Dtool_AnimControlCollection_get_num_anims_148_comment},
  {"getNumAnims", &Dtool_AnimControlCollection_get_num_anims_148, METH_NOARGS, (const char *)Dtool_AnimControlCollection_get_num_anims_148_comment},
  {"get_anim", &Dtool_AnimControlCollection_get_anim_149, METH_O, (const char *)Dtool_AnimControlCollection_get_anim_149_comment},
  {"getAnim", &Dtool_AnimControlCollection_get_anim_149, METH_O, (const char *)Dtool_AnimControlCollection_get_anim_149_comment},
  {"get_anim_name", &Dtool_AnimControlCollection_get_anim_name_150, METH_O, (const char *)Dtool_AnimControlCollection_get_anim_name_150_comment},
  {"getAnimName", &Dtool_AnimControlCollection_get_anim_name_150, METH_O, (const char *)Dtool_AnimControlCollection_get_anim_name_150_comment},
  {"clear_anims", &Dtool_AnimControlCollection_clear_anims_153, METH_NOARGS, (const char *)Dtool_AnimControlCollection_clear_anims_153_comment},
  {"clearAnims", &Dtool_AnimControlCollection_clear_anims_153, METH_NOARGS, (const char *)Dtool_AnimControlCollection_clear_anims_153_comment},
  {"play", (PyCFunction) &Dtool_AnimControlCollection_play_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_play_154_comment},
  {"loop", (PyCFunction) &Dtool_AnimControlCollection_loop_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_loop_155_comment},
  {"stop", &Dtool_AnimControlCollection_stop_156, METH_O, (const char *)Dtool_AnimControlCollection_stop_156_comment},
  {"pose", (PyCFunction) &Dtool_AnimControlCollection_pose_157, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_pose_157_comment},
  {"play_all", (PyCFunction) &Dtool_AnimControlCollection_play_all_158, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_play_all_158_comment},
  {"playAll", (PyCFunction) &Dtool_AnimControlCollection_play_all_158, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_play_all_158_comment},
  {"loop_all", (PyCFunction) &Dtool_AnimControlCollection_loop_all_159, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_loop_all_159_comment},
  {"loopAll", (PyCFunction) &Dtool_AnimControlCollection_loop_all_159, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_loop_all_159_comment},
  {"stop_all", &Dtool_AnimControlCollection_stop_all_160, METH_NOARGS, (const char *)Dtool_AnimControlCollection_stop_all_160_comment},
  {"stopAll", &Dtool_AnimControlCollection_stop_all_160, METH_NOARGS, (const char *)Dtool_AnimControlCollection_stop_all_160_comment},
  {"pose_all", &Dtool_AnimControlCollection_pose_all_161, METH_O, (const char *)Dtool_AnimControlCollection_pose_all_161_comment},
  {"poseAll", &Dtool_AnimControlCollection_pose_all_161, METH_O, (const char *)Dtool_AnimControlCollection_pose_all_161_comment},
  {"get_frame", &Dtool_AnimControlCollection_get_frame_162, METH_VARARGS, (const char *)Dtool_AnimControlCollection_get_frame_162_comment},
  {"getFrame", &Dtool_AnimControlCollection_get_frame_162, METH_VARARGS, (const char *)Dtool_AnimControlCollection_get_frame_162_comment},
  {"get_num_frames", &Dtool_AnimControlCollection_get_num_frames_163, METH_VARARGS, (const char *)Dtool_AnimControlCollection_get_num_frames_163_comment},
  {"getNumFrames", &Dtool_AnimControlCollection_get_num_frames_163, METH_VARARGS, (const char *)Dtool_AnimControlCollection_get_num_frames_163_comment},
  {"is_playing", &Dtool_AnimControlCollection_is_playing_164, METH_VARARGS, (const char *)Dtool_AnimControlCollection_is_playing_164_comment},
  {"isPlaying", &Dtool_AnimControlCollection_is_playing_164, METH_VARARGS, (const char *)Dtool_AnimControlCollection_is_playing_164_comment},
  {"which_anim_playing", &Dtool_AnimControlCollection_which_anim_playing_165, METH_NOARGS, (const char *)Dtool_AnimControlCollection_which_anim_playing_165_comment},
  {"whichAnimPlaying", &Dtool_AnimControlCollection_which_anim_playing_165, METH_NOARGS, (const char *)Dtool_AnimControlCollection_which_anim_playing_165_comment},
  {"output", &Dtool_AnimControlCollection_output_166, METH_O, (const char *)Dtool_AnimControlCollection_output_166_comment},
  {"write", &Dtool_AnimControlCollection_write_167, METH_O, (const char *)Dtool_AnimControlCollection_write_167_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_anims", (PyCFunction) &MakeSeq_AnimControlCollection_get_anims, METH_NOARGS, NULL},
  { "getAnims", (PyCFunction) &MakeSeq_AnimControlCollection_get_anims, METH_NOARGS, NULL},
  {"get_anim_names", (PyCFunction) &MakeSeq_AnimControlCollection_get_anim_names, METH_NOARGS, NULL},
  { "getAnimNames", (PyCFunction) &MakeSeq_AnimControlCollection_get_anim_names, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     AnimControlCollection
//////////////////
static PyObject *Dtool_Repr_AnimControlCollection(PyObject *self) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AnimControlCollection
//////////////////
static PyObject *Dtool_Str_AnimControlCollection(PyObject *self) {
  AnimControlCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AnimControlCollection = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_AnimControlCollection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimControlCollection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimControlCollection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_AnimControlCollection,
    &Dtool_NumberMethods_AnimControlCollection,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_AnimControlCollection,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a named collection of AnimControl pointers.  An AnimControl may be\n"
    " * added to the collection by name.  While an AnimControl is associated, its\n"
    " * reference count is maintained; associating a new AnimControl with the same\n"
    " * name will decrement the previous control's reference count (and possibly\n"
    " * delete it, unbinding its animation).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimControlCollection,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimControlCollection,
    PyType_GenericAlloc,
    Dtool_new_AnimControlCollection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimControlCollection,
  Dtool_UpcastInterface_AnimControlCollection,
  Dtool_DowncastInterface_AnimControlCollection,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AnimControlCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AnimControlCollection._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_AnimControlCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimControlCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimControlCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimControlCollection);
  }
}

/**
 * Python method tables for AnimPreloadTable (AnimPreloadTable)
 */
static PyMethodDef Dtool_Methods_AnimPreloadTable[] = {
  {"get_num_anims", &Dtool_AnimPreloadTable_get_num_anims_171, METH_NOARGS, (const char *)Dtool_AnimPreloadTable_get_num_anims_171_comment},
  {"getNumAnims", &Dtool_AnimPreloadTable_get_num_anims_171, METH_NOARGS, (const char *)Dtool_AnimPreloadTable_get_num_anims_171_comment},
  {"find_anim", &Dtool_AnimPreloadTable_find_anim_172, METH_O, (const char *)Dtool_AnimPreloadTable_find_anim_172_comment},
  {"findAnim", &Dtool_AnimPreloadTable_find_anim_172, METH_O, (const char *)Dtool_AnimPreloadTable_find_anim_172_comment},
  {"get_basename", &Dtool_AnimPreloadTable_get_basename_173, METH_O, (const char *)Dtool_AnimPreloadTable_get_basename_173_comment},
  {"getBasename", &Dtool_AnimPreloadTable_get_basename_173, METH_O, (const char *)Dtool_AnimPreloadTable_get_basename_173_comment},
  {"get_base_frame_rate", &Dtool_AnimPreloadTable_get_base_frame_rate_174, METH_O, (const char *)Dtool_AnimPreloadTable_get_base_frame_rate_174_comment},
  {"getBaseFrameRate", &Dtool_AnimPreloadTable_get_base_frame_rate_174, METH_O, (const char *)Dtool_AnimPreloadTable_get_base_frame_rate_174_comment},
  {"get_num_frames", &Dtool_AnimPreloadTable_get_num_frames_175, METH_O, (const char *)Dtool_AnimPreloadTable_get_num_frames_175_comment},
  {"getNumFrames", &Dtool_AnimPreloadTable_get_num_frames_175, METH_O, (const char *)Dtool_AnimPreloadTable_get_num_frames_175_comment},
  {"clear_anims", &Dtool_AnimPreloadTable_clear_anims_176, METH_NOARGS, (const char *)Dtool_AnimPreloadTable_clear_anims_176_comment},
  {"clearAnims", &Dtool_AnimPreloadTable_clear_anims_176, METH_NOARGS, (const char *)Dtool_AnimPreloadTable_clear_anims_176_comment},
  {"remove_anim", &Dtool_AnimPreloadTable_remove_anim_177, METH_O, (const char *)Dtool_AnimPreloadTable_remove_anim_177_comment},
  {"removeAnim", &Dtool_AnimPreloadTable_remove_anim_177, METH_O, (const char *)Dtool_AnimPreloadTable_remove_anim_177_comment},
  {"add_anim", (PyCFunction) &Dtool_AnimPreloadTable_add_anim_178, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimPreloadTable_add_anim_178_comment},
  {"addAnim", (PyCFunction) &Dtool_AnimPreloadTable_add_anim_178, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimPreloadTable_add_anim_178_comment},
  {"add_anims_from", &Dtool_AnimPreloadTable_add_anims_from_179, METH_O, (const char *)Dtool_AnimPreloadTable_add_anims_from_179_comment},
  {"addAnimsFrom", &Dtool_AnimPreloadTable_add_anims_from_179, METH_O, (const char *)Dtool_AnimPreloadTable_add_anims_from_179_comment},
  {"output", &Dtool_AnimPreloadTable_output_180, METH_O, (const char *)Dtool_AnimPreloadTable_output_180_comment},
  {"write", (PyCFunction) &Dtool_AnimPreloadTable_write_181, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimPreloadTable_write_181_comment},
  {"get_class_type", &Dtool_AnimPreloadTable_get_class_type_182, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimPreloadTable_get_class_type_182_comment},
  {"getClassType", &Dtool_AnimPreloadTable_get_class_type_182, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimPreloadTable_get_class_type_182_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     AnimPreloadTable
//////////////////
static PyObject *Dtool_Repr_AnimPreloadTable(PyObject *self) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimPreloadTable, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AnimPreloadTable
//////////////////
static PyObject *Dtool_Str_AnimPreloadTable(PyObject *self) {
  AnimPreloadTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimPreloadTable, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AnimPreloadTable = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimPreloadTable = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AnimPreloadTable = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AnimPreloadTable = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AnimPreloadTable = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AnimPreloadTable",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimPreloadTable,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_AnimPreloadTable,
    &Dtool_NumberMethods_AnimPreloadTable,
    &Dtool_SequenceMethods_AnimPreloadTable,
    &Dtool_MappingMethods_AnimPreloadTable,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_AnimPreloadTable,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AnimPreloadTable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This table records data about a list of animations for a particular model,\n"
    " * such as number of frames and frame rate.  It's used for implementating\n"
    " * asynchronous binding.\n"
    " *\n"
    " * This table is normally built by an offline tool, such as egg-optchar.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AnimPreloadTable,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AnimPreloadTable,
    PyType_GenericAlloc,
    Dtool_new_AnimPreloadTable,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimPreloadTable,
  Dtool_UpcastInterface_AnimPreloadTable,
  Dtool_DowncastInterface_AnimPreloadTable,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AnimPreloadTable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CopyOnWriteObject != NULL);
    assert(Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit(NULL);
    Dtool_AnimPreloadTable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CopyOnWriteObject);
    PyObject *dict = PyDict_New();
    Dtool_AnimPreloadTable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimPreloadTable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimPreloadTable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimPreloadTable);
  }
}

/**
 * Python method tables for PartSubset (PartSubset)
 */
static PyMethodDef Dtool_Methods_PartSubset[] = {
  {"assign", &Dtool_PartSubset_operator_186, METH_O, (const char *)Dtool_PartSubset_operator_186_comment},
  {"add_include_joint", &Dtool_PartSubset_add_include_joint_187, METH_O, (const char *)Dtool_PartSubset_add_include_joint_187_comment},
  {"addIncludeJoint", &Dtool_PartSubset_add_include_joint_187, METH_O, (const char *)Dtool_PartSubset_add_include_joint_187_comment},
  {"add_exclude_joint", &Dtool_PartSubset_add_exclude_joint_188, METH_O, (const char *)Dtool_PartSubset_add_exclude_joint_188_comment},
  {"addExcludeJoint", &Dtool_PartSubset_add_exclude_joint_188, METH_O, (const char *)Dtool_PartSubset_add_exclude_joint_188_comment},
  {"append", &Dtool_PartSubset_append_189, METH_O, (const char *)Dtool_PartSubset_append_189_comment},
  {"output", &Dtool_PartSubset_output_190, METH_O, (const char *)Dtool_PartSubset_output_190_comment},
  {"is_include_empty", &Dtool_PartSubset_is_include_empty_191, METH_NOARGS, (const char *)Dtool_PartSubset_is_include_empty_191_comment},
  {"isIncludeEmpty", &Dtool_PartSubset_is_include_empty_191, METH_NOARGS, (const char *)Dtool_PartSubset_is_include_empty_191_comment},
  {"matches_include", &Dtool_PartSubset_matches_include_192, METH_O, (const char *)Dtool_PartSubset_matches_include_192_comment},
  {"matchesInclude", &Dtool_PartSubset_matches_include_192, METH_O, (const char *)Dtool_PartSubset_matches_include_192_comment},
  {"matches_exclude", &Dtool_PartSubset_matches_exclude_193, METH_O, (const char *)Dtool_PartSubset_matches_exclude_193_comment},
  {"matchesExclude", &Dtool_PartSubset_matches_exclude_193, METH_O, (const char *)Dtool_PartSubset_matches_exclude_193_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PartSubset
//////////////////
static PyObject *Dtool_Repr_PartSubset(PyObject *self) {
  PartSubset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartSubset, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PartSubset = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_PartSubset = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PartSubset",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PartSubset,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PartSubset,
    &Dtool_NumberMethods_PartSubset,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PartSubset,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to define a subset of part names to apply to the\n"
    " * PartBundle::bind_anim() operation.  Only those part names within the subset\n"
    " * will be included in the bind.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PartSubset,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PartSubset,
    PyType_GenericAlloc,
    Dtool_new_PartSubset,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PartSubset,
  Dtool_UpcastInterface_PartSubset,
  Dtool_DowncastInterface_PartSubset,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PartSubset(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PartSubset._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PartSubset._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PartSubset) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PartSubset)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PartSubset);
  }
}

/**
 * Python method tables for BindAnimRequest (BindAnimRequest)
 */
static PyMethodDef Dtool_Methods_BindAnimRequest[] = {
  {"get_class_type", &Dtool_BindAnimRequest_get_class_type_198, METH_NOARGS | METH_STATIC, (const char *)Dtool_BindAnimRequest_get_class_type_198_comment},
  {"getClassType", &Dtool_BindAnimRequest_get_class_type_198, METH_NOARGS | METH_STATIC, (const char *)Dtool_BindAnimRequest_get_class_type_198_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_BindAnimRequest = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BindAnimRequest = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BindAnimRequest = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BindAnimRequest = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BindAnimRequest = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BindAnimRequest",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BindAnimRequest,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BindAnimRequest,
    &Dtool_SequenceMethods_BindAnimRequest,
    &Dtool_MappingMethods_BindAnimRequest,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BindAnimRequest,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class object manages an asynchronous load-and-bind animation request,\n"
    " * as issued through PartBundle::load_bind_anim().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BindAnimRequest,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BindAnimRequest,
    PyType_GenericAlloc,
    Dtool_new_BindAnimRequest,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BindAnimRequest,
  Dtool_UpcastInterface_BindAnimRequest,
  Dtool_DowncastInterface_BindAnimRequest,
  (CoerceFunction)Dtool_ConstCoerce_BindAnimRequest,
  (CoerceFunction)Dtool_Coerce_BindAnimRequest,
};

static void Dtool_PyModuleClassInit_BindAnimRequest(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ModelLoadRequest != NULL);
    assert(Dtool_Ptr_ModelLoadRequest->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ModelLoadRequest->_Dtool_ModuleClassInit(NULL);
    Dtool_BindAnimRequest._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ModelLoadRequest);
    PyObject *dict = PyDict_New();
    Dtool_BindAnimRequest._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BindAnimRequest) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BindAnimRequest)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BindAnimRequest);
  }
}

/**
 * Python method tables for PartBundle (PartBundle)
 */
static PyMethodDef Dtool_Methods_PartBundle[] = {
  {"get_anim_preload", &Dtool_PartBundle_get_anim_preload_202, METH_NOARGS, (const char *)Dtool_PartBundle_get_anim_preload_202_comment},
  {"getAnimPreload", &Dtool_PartBundle_get_anim_preload_202, METH_NOARGS, (const char *)Dtool_PartBundle_get_anim_preload_202_comment},
  {"modify_anim_preload", &Dtool_PartBundle_modify_anim_preload_203, METH_NOARGS, (const char *)Dtool_PartBundle_modify_anim_preload_203_comment},
  {"modifyAnimPreload", &Dtool_PartBundle_modify_anim_preload_203, METH_NOARGS, (const char *)Dtool_PartBundle_modify_anim_preload_203_comment},
  {"set_anim_preload", &Dtool_PartBundle_set_anim_preload_204, METH_O, (const char *)Dtool_PartBundle_set_anim_preload_204_comment},
  {"setAnimPreload", &Dtool_PartBundle_set_anim_preload_204, METH_O, (const char *)Dtool_PartBundle_set_anim_preload_204_comment},
  {"clear_anim_preload", &Dtool_PartBundle_clear_anim_preload_205, METH_NOARGS, (const char *)Dtool_PartBundle_clear_anim_preload_205_comment},
  {"clearAnimPreload", &Dtool_PartBundle_clear_anim_preload_205, METH_NOARGS, (const char *)Dtool_PartBundle_clear_anim_preload_205_comment},
  {"merge_anim_preloads", &Dtool_PartBundle_merge_anim_preloads_206, METH_O, (const char *)Dtool_PartBundle_merge_anim_preloads_206_comment},
  {"mergeAnimPreloads", &Dtool_PartBundle_merge_anim_preloads_206, METH_O, (const char *)Dtool_PartBundle_merge_anim_preloads_206_comment},
  {"set_blend_type", &Dtool_PartBundle_set_blend_type_208, METH_O, (const char *)Dtool_PartBundle_set_blend_type_208_comment},
  {"setBlendType", &Dtool_PartBundle_set_blend_type_208, METH_O, (const char *)Dtool_PartBundle_set_blend_type_208_comment},
  {"get_blend_type", &Dtool_PartBundle_get_blend_type_209, METH_NOARGS, (const char *)Dtool_PartBundle_get_blend_type_209_comment},
  {"getBlendType", &Dtool_PartBundle_get_blend_type_209, METH_NOARGS, (const char *)Dtool_PartBundle_get_blend_type_209_comment},
  {"set_anim_blend_flag", &Dtool_PartBundle_set_anim_blend_flag_210, METH_O, (const char *)Dtool_PartBundle_set_anim_blend_flag_210_comment},
  {"setAnimBlendFlag", &Dtool_PartBundle_set_anim_blend_flag_210, METH_O, (const char *)Dtool_PartBundle_set_anim_blend_flag_210_comment},
  {"get_anim_blend_flag", &Dtool_PartBundle_get_anim_blend_flag_211, METH_NOARGS, (const char *)Dtool_PartBundle_get_anim_blend_flag_211_comment},
  {"getAnimBlendFlag", &Dtool_PartBundle_get_anim_blend_flag_211, METH_NOARGS, (const char *)Dtool_PartBundle_get_anim_blend_flag_211_comment},
  {"set_frame_blend_flag", &Dtool_PartBundle_set_frame_blend_flag_212, METH_O, (const char *)Dtool_PartBundle_set_frame_blend_flag_212_comment},
  {"setFrameBlendFlag", &Dtool_PartBundle_set_frame_blend_flag_212, METH_O, (const char *)Dtool_PartBundle_set_frame_blend_flag_212_comment},
  {"get_frame_blend_flag", &Dtool_PartBundle_get_frame_blend_flag_213, METH_NOARGS, (const char *)Dtool_PartBundle_get_frame_blend_flag_213_comment},
  {"getFrameBlendFlag", &Dtool_PartBundle_get_frame_blend_flag_213, METH_NOARGS, (const char *)Dtool_PartBundle_get_frame_blend_flag_213_comment},
  {"set_root_xform", &Dtool_PartBundle_set_root_xform_214, METH_O, (const char *)Dtool_PartBundle_set_root_xform_214_comment},
  {"setRootXform", &Dtool_PartBundle_set_root_xform_214, METH_O, (const char *)Dtool_PartBundle_set_root_xform_214_comment},
  {"xform", &Dtool_PartBundle_xform_215, METH_O, (const char *)Dtool_PartBundle_xform_215_comment},
  {"get_root_xform", &Dtool_PartBundle_get_root_xform_216, METH_NOARGS, (const char *)Dtool_PartBundle_get_root_xform_216_comment},
  {"getRootXform", &Dtool_PartBundle_get_root_xform_216, METH_NOARGS, (const char *)Dtool_PartBundle_get_root_xform_216_comment},
  {"apply_transform", &Dtool_PartBundle_apply_transform_217, METH_O, (const char *)Dtool_PartBundle_apply_transform_217_comment},
  {"applyTransform", &Dtool_PartBundle_apply_transform_217, METH_O, (const char *)Dtool_PartBundle_apply_transform_217_comment},
  {"get_num_nodes", &Dtool_PartBundle_get_num_nodes_218, METH_NOARGS, (const char *)Dtool_PartBundle_get_num_nodes_218_comment},
  {"getNumNodes", &Dtool_PartBundle_get_num_nodes_218, METH_NOARGS, (const char *)Dtool_PartBundle_get_num_nodes_218_comment},
  {"get_node", &Dtool_PartBundle_get_node_219, METH_O, (const char *)Dtool_PartBundle_get_node_219_comment},
  {"getNode", &Dtool_PartBundle_get_node_219, METH_O, (const char *)Dtool_PartBundle_get_node_219_comment},
  {"clear_control_effects", &Dtool_PartBundle_clear_control_effects_247, METH_NOARGS, (const char *)Dtool_PartBundle_clear_control_effects_247_comment},
  {"clearControlEffects", &Dtool_PartBundle_clear_control_effects_247, METH_NOARGS, (const char *)Dtool_PartBundle_clear_control_effects_247_comment},
  {"set_control_effect", (PyCFunction) &Dtool_PartBundle_set_control_effect_248, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_set_control_effect_248_comment},
  {"setControlEffect", (PyCFunction) &Dtool_PartBundle_set_control_effect_248, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_set_control_effect_248_comment},
  {"get_control_effect", &Dtool_PartBundle_get_control_effect_249, METH_O, (const char *)Dtool_PartBundle_get_control_effect_249_comment},
  {"getControlEffect", &Dtool_PartBundle_get_control_effect_249, METH_O, (const char *)Dtool_PartBundle_get_control_effect_249_comment},
  {"output", &Dtool_PartBundle_output_250, METH_O, (const char *)Dtool_PartBundle_output_250_comment},
  {"bind_anim", (PyCFunction) &Dtool_PartBundle_bind_anim_251, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_bind_anim_251_comment},
  {"bindAnim", (PyCFunction) &Dtool_PartBundle_bind_anim_251, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_bind_anim_251_comment},
  {"load_bind_anim", (PyCFunction) &Dtool_PartBundle_load_bind_anim_252, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_load_bind_anim_252_comment},
  {"loadBindAnim", (PyCFunction) &Dtool_PartBundle_load_bind_anim_252, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_load_bind_anim_252_comment},
  {"wait_pending", &Dtool_PartBundle_wait_pending_253, METH_NOARGS, (const char *)Dtool_PartBundle_wait_pending_253_comment},
  {"waitPending", &Dtool_PartBundle_wait_pending_253, METH_NOARGS, (const char *)Dtool_PartBundle_wait_pending_253_comment},
  {"freeze_joint", (PyCFunction) &Dtool_PartBundle_freeze_joint_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_freeze_joint_254_comment},
  {"freezeJoint", (PyCFunction) &Dtool_PartBundle_freeze_joint_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_freeze_joint_254_comment},
  {"control_joint", (PyCFunction) &Dtool_PartBundle_control_joint_255, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_control_joint_255_comment},
  {"controlJoint", (PyCFunction) &Dtool_PartBundle_control_joint_255, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_control_joint_255_comment},
  {"release_joint", &Dtool_PartBundle_release_joint_256, METH_O, (const char *)Dtool_PartBundle_release_joint_256_comment},
  {"releaseJoint", &Dtool_PartBundle_release_joint_256, METH_O, (const char *)Dtool_PartBundle_release_joint_256_comment},
  {"update", &Dtool_PartBundle_update_257, METH_NOARGS, (const char *)Dtool_PartBundle_update_257_comment},
  {"force_update", &Dtool_PartBundle_force_update_258, METH_NOARGS, (const char *)Dtool_PartBundle_force_update_258_comment},
  {"forceUpdate", &Dtool_PartBundle_force_update_258, METH_NOARGS, (const char *)Dtool_PartBundle_force_update_258_comment},
  {"get_class_type", &Dtool_PartBundle_get_class_type_259, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartBundle_get_class_type_259_comment},
  {"getClassType", &Dtool_PartBundle_get_class_type_259, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartBundle_get_class_type_259_comment},
  {"get_nodes", (PyCFunction) &MakeSeq_PartBundle_get_nodes, METH_NOARGS, NULL},
  { "getNodes", (PyCFunction) &MakeSeq_PartBundle_get_nodes, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PartBundle
//////////////////
static PyObject *Dtool_Repr_PartBundle(PyObject *self) {
  PartBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PartBundle[] = {
  {(char *)"blend_type", &Dtool_PartBundle_blend_type_Getter, &Dtool_PartBundle_blend_type_Setter, NULL, NULL},
  {(char *)"anim_blend_flag", &Dtool_PartBundle_anim_blend_flag_Getter, &Dtool_PartBundle_anim_blend_flag_Setter, NULL, NULL},
  {(char *)"frame_blend_flag", &Dtool_PartBundle_frame_blend_flag_Getter, &Dtool_PartBundle_frame_blend_flag_Setter, NULL, NULL},
  {(char *)"root_xform", &Dtool_PartBundle_root_xform_Getter, &Dtool_PartBundle_root_xform_Setter, NULL, NULL},
  {(char *)"nodes", &Dtool_PartBundle_nodes_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PartBundle = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PartBundle = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PartBundle = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PartBundle = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PartBundle = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PartBundle",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PartBundle,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PartBundle,
    &Dtool_NumberMethods_PartBundle,
    &Dtool_SequenceMethods_PartBundle,
    &Dtool_MappingMethods_PartBundle,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PartBundle,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PartBundle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the root of a MovingPart hierarchy.  It defines the hierarchy of\n"
    " * moving parts that make up an animatable object.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PartBundle,
    0, // tp_members
    Dtool_Properties_PartBundle,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PartBundle,
    PyType_GenericAlloc,
    Dtool_new_PartBundle,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PartBundle,
  Dtool_UpcastInterface_PartBundle,
  Dtool_DowncastInterface_PartBundle,
  (CoerceFunction)Dtool_ConstCoerce_PartBundle,
  (CoerceFunction)Dtool_Coerce_PartBundle,
};

static void Dtool_PyModuleClassInit_PartBundle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PartGroup(NULL);
    Dtool_PartBundle._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PartGroup);
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_PartBundle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PartBundle::BlendType;
    PyDict_SetItemString(dict, "BT_linear", Dtool_WrapValue(PartBundle::BT_linear));
    PyDict_SetItemString(dict, "BTLinear", Dtool_WrapValue(PartBundle::BT_linear));
    PyDict_SetItemString(dict, "BT_normalized_linear", Dtool_WrapValue(PartBundle::BT_normalized_linear));
    PyDict_SetItemString(dict, "BTNormalizedLinear", Dtool_WrapValue(PartBundle::BT_normalized_linear));
    PyDict_SetItemString(dict, "BT_componentwise", Dtool_WrapValue(PartBundle::BT_componentwise));
    PyDict_SetItemString(dict, "BTComponentwise", Dtool_WrapValue(PartBundle::BT_componentwise));
    PyDict_SetItemString(dict, "BT_componentwise_quat", Dtool_WrapValue(PartBundle::BT_componentwise_quat));
    PyDict_SetItemString(dict, "BTComponentwiseQuat", Dtool_WrapValue(PartBundle::BT_componentwise_quat));
    if (PyType_Ready((PyTypeObject *)&Dtool_PartBundle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PartBundle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PartBundle);
  }
}

/**
 * Python method tables for PartBundleNode (PartBundleNode)
 */
static PyMethodDef Dtool_Methods_PartBundleNode[] = {
  {"get_num_bundles", &Dtool_PartBundleNode_get_num_bundles_231, METH_NOARGS, (const char *)Dtool_PartBundleNode_get_num_bundles_231_comment},
  {"getNumBundles", &Dtool_PartBundleNode_get_num_bundles_231, METH_NOARGS, (const char *)Dtool_PartBundleNode_get_num_bundles_231_comment},
  {"get_bundle", &Dtool_PartBundleNode_get_bundle_232, METH_O, (const char *)Dtool_PartBundleNode_get_bundle_232_comment},
  {"getBundle", &Dtool_PartBundleNode_get_bundle_232, METH_O, (const char *)Dtool_PartBundleNode_get_bundle_232_comment},
  {"get_bundle_handle", &Dtool_PartBundleNode_get_bundle_handle_234, METH_O, (const char *)Dtool_PartBundleNode_get_bundle_handle_234_comment},
  {"getBundleHandle", &Dtool_PartBundleNode_get_bundle_handle_234, METH_O, (const char *)Dtool_PartBundleNode_get_bundle_handle_234_comment},
  {"get_class_type", &Dtool_PartBundleNode_get_class_type_246, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartBundleNode_get_class_type_246_comment},
  {"getClassType", &Dtool_PartBundleNode_get_class_type_246, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartBundleNode_get_class_type_246_comment},
  {"get_bundles", (PyCFunction) &MakeSeq_PartBundleNode_get_bundles, METH_NOARGS, NULL},
  { "getBundles", (PyCFunction) &MakeSeq_PartBundleNode_get_bundles, METH_NOARGS, NULL},
  {"get_bundle_handles", (PyCFunction) &MakeSeq_PartBundleNode_get_bundle_handles, METH_NOARGS, NULL},
  { "getBundleHandles", (PyCFunction) &MakeSeq_PartBundleNode_get_bundle_handles, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_PartBundleNode[] = {
  {(char *)"bundles", &Dtool_PartBundleNode_bundles_Getter, NULL, NULL, NULL},
  {(char *)"bundle_handles", &Dtool_PartBundleNode_bundle_handles_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PartBundleNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PartBundleNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PartBundleNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PartBundleNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PartBundleNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PartBundleNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PartBundleNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PartBundleNode,
    &Dtool_SequenceMethods_PartBundleNode,
    &Dtool_MappingMethods_PartBundleNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PartBundleNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a node that contains a pointer to an PartBundle.  Like\n"
    " * AnimBundleNode, it exists to make it easy to store PartBundles in the scene\n"
    " * graph.\n"
    " *\n"
    " * (Unlike AnimBundleNode, however, PartBundleNode has an additional function:\n"
    " * it is also the base class of the Character node type, which adds additional\n"
    " * functionality.)\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PartBundleNode,
    0, // tp_members
    Dtool_Properties_PartBundleNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PartBundleNode,
    PyType_GenericAlloc,
    Dtool_new_PartBundleNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PartBundleNode,
  Dtool_UpcastInterface_PartBundleNode,
  Dtool_DowncastInterface_PartBundleNode,
  (CoerceFunction)Dtool_ConstCoerce_PartBundleNode,
  (CoerceFunction)Dtool_Coerce_PartBundleNode,
};

static void Dtool_PyModuleClassInit_PartBundleNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_PartBundleNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_PartBundleNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PartBundleNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PartBundleNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PartBundleNode);
  }
}

/**
 * Python method tables for PartBundleHandle (PartBundleHandle)
 */
static PyMethodDef Dtool_Methods_PartBundleHandle[] = {
  {"get_bundle", &Dtool_PartBundleHandle_get_bundle_243, METH_NOARGS, (const char *)Dtool_PartBundleHandle_get_bundle_243_comment},
  {"getBundle", &Dtool_PartBundleHandle_get_bundle_243, METH_NOARGS, (const char *)Dtool_PartBundleHandle_get_bundle_243_comment},
  {"set_bundle", &Dtool_PartBundleHandle_set_bundle_244, METH_O, (const char *)Dtool_PartBundleHandle_set_bundle_244_comment},
  {"setBundle", &Dtool_PartBundleHandle_set_bundle_244, METH_O, (const char *)Dtool_PartBundleHandle_set_bundle_244_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_PartBundleHandle[] = {
  {(char *)"bundle", &Dtool_PartBundleHandle_bundle_Getter, &Dtool_PartBundleHandle_bundle_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PartBundleHandle = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PartBundleHandle = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PartBundleHandle = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PartBundleHandle = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PartBundleHandle = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PartBundleHandle",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PartBundleHandle,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PartBundleHandle,
    &Dtool_SequenceMethods_PartBundleHandle,
    &Dtool_MappingMethods_PartBundleHandle,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PartBundleHandle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a trivial class returned by PartBundleNode::get_bundle().  Its\n"
    " * purpose is to hold the actual PartBundle pointer contained within the\n"
    " * PartBundleNode, so that scene graph flatten operations can safely combine\n"
    " * or duplicate PartBundles as necessary without affecting high-level bundle\n"
    " * operations.\n"
    " *\n"
    " * The high-level Actor class defined in direct/src/actor, for instance, will\n"
    " * store a list of PartBundleHandles instead of on actual PartBundles, so that\n"
    " * it will be immune to changes from these flatten operations.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PartBundleHandle,
    0, // tp_members
    Dtool_Properties_PartBundleHandle,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PartBundleHandle,
    PyType_GenericAlloc,
    Dtool_new_PartBundleHandle,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PartBundleHandle,
  Dtool_UpcastInterface_PartBundleHandle,
  Dtool_DowncastInterface_PartBundleHandle,
  (CoerceFunction)Dtool_ConstCoerce_PartBundleHandle,
  (CoerceFunction)Dtool_Coerce_PartBundleHandle,
};

static void Dtool_PyModuleClassInit_PartBundleHandle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_PartBundleHandle._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_PartBundleHandle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PartBundleHandle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PartBundleHandle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PartBundleHandle);
  }
}

/**
 * Python method tables for MovingPartBase (MovingPartBase)
 */
static PyMethodDef Dtool_Methods_MovingPartBase[] = {
  {"get_max_bound", &Dtool_MovingPartBase_get_max_bound_262, METH_NOARGS, (const char *)Dtool_MovingPartBase_get_max_bound_262_comment},
  {"getMaxBound", &Dtool_MovingPartBase_get_max_bound_262, METH_NOARGS, (const char *)Dtool_MovingPartBase_get_max_bound_262_comment},
  {"get_bound", &Dtool_MovingPartBase_get_bound_263, METH_O, (const char *)Dtool_MovingPartBase_get_bound_263_comment},
  {"getBound", &Dtool_MovingPartBase_get_bound_263, METH_O, (const char *)Dtool_MovingPartBase_get_bound_263_comment},
  {"output_value", &Dtool_MovingPartBase_output_value_264, METH_O, (const char *)Dtool_MovingPartBase_output_value_264_comment},
  {"outputValue", &Dtool_MovingPartBase_output_value_264, METH_O, (const char *)Dtool_MovingPartBase_output_value_264_comment},
  {"get_class_type", &Dtool_MovingPartBase_get_class_type_265, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartBase_get_class_type_265_comment},
  {"getClassType", &Dtool_MovingPartBase_get_class_type_265, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartBase_get_class_type_265_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MovingPartBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovingPartBase = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MovingPartBase = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MovingPartBase = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MovingPartBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MovingPartBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MovingPartBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MovingPartBase,
    &Dtool_SequenceMethods_MovingPartBase,
    &Dtool_MappingMethods_MovingPartBase,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MovingPartBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for a single animatable piece that may be bound to\n"
    " * one channel (or more, if blending is in effect).  It corresponds to, for\n"
    " * instance, a single joint or slider of a character.\n"
    " *\n"
    " * MovingPartBase does not have a particular value type.  See the derived\n"
    " * template class, MovingPart, for this.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MovingPartBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MovingPartBase,
    PyType_GenericAlloc,
    Dtool_new_MovingPartBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovingPartBase,
  Dtool_UpcastInterface_MovingPartBase,
  Dtool_DowncastInterface_MovingPartBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MovingPartBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PartGroup(NULL);
    Dtool_MovingPartBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PartGroup);
    PyObject *dict = PyDict_New();
    Dtool_MovingPartBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovingPartBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovingPartBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovingPartBase);
  }
}

/**
 * Python method tables for MovingPartMatrix (MovingPartMatrix)
 */
static PyMethodDef Dtool_Methods_MovingPartMatrix[] = {
  {"get_class_type", &Dtool_MovingPartMatrix_get_class_type_273, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartMatrix_get_class_type_273_comment},
  {"getClassType", &Dtool_MovingPartMatrix_get_class_type_273, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartMatrix_get_class_type_273_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MovingPartMatrix = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovingPartMatrix = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MovingPartMatrix = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MovingPartMatrix = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MovingPartMatrix = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MovingPartMatrix",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MovingPartMatrix,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MovingPartMatrix,
    &Dtool_SequenceMethods_MovingPartMatrix,
    &Dtool_MappingMethods_MovingPartMatrix,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MovingPartMatrix,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a particular kind of MovingPart that accepts a matrix each frame.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MovingPartMatrix,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MovingPartMatrix,
    PyType_GenericAlloc,
    Dtool_new_MovingPartMatrix,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovingPartMatrix,
  Dtool_UpcastInterface_MovingPartMatrix,
  Dtool_DowncastInterface_MovingPartMatrix,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MovingPartMatrix(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType(NULL);
    Dtool_MovingPartMatrix._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovingPart_ACMatrixSwitchType);
    PyObject *dict = PyDict_New();
    Dtool_MovingPartMatrix._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovingPartMatrix) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovingPartMatrix)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovingPartMatrix);
  }
}

/**
 * Python method tables for MovingPart_ACMatrixSwitchType (MovingPart_ACMatrixSwitchType)
 */
static PyMethodDef Dtool_Methods_MovingPart_ACMatrixSwitchType[] = {
  {"get_class_type", &Dtool_MovingPart_ACMatrixSwitchType_get_class_type_269, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_class_type_269_comment},
  {"getClassType", &Dtool_MovingPart_ACMatrixSwitchType_get_class_type_269, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_class_type_269_comment},
  {"get_value", &Dtool_MovingPart_ACMatrixSwitchType_get_value_270, METH_NOARGS, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_value_270_comment},
  {"getValue", &Dtool_MovingPart_ACMatrixSwitchType_get_value_270, METH_NOARGS, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_value_270_comment},
  {"get_default_value", &Dtool_MovingPart_ACMatrixSwitchType_get_default_value_271, METH_NOARGS, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_default_value_271_comment},
  {"getDefaultValue", &Dtool_MovingPart_ACMatrixSwitchType_get_default_value_271, METH_NOARGS, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_default_value_271_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MovingPart_ACMatrixSwitchType = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovingPart_ACMatrixSwitchType = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MovingPart_ACMatrixSwitchType = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MovingPart_ACMatrixSwitchType = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MovingPart_ACMatrixSwitchType = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MovingPart_ACMatrixSwitchType",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MovingPart_ACMatrixSwitchType,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MovingPart_ACMatrixSwitchType,
    &Dtool_SequenceMethods_MovingPart_ACMatrixSwitchType,
    &Dtool_MappingMethods_MovingPart_ACMatrixSwitchType,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MovingPart_ACMatrixSwitchType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MovingPart_ACMatrixSwitchType,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MovingPart_ACMatrixSwitchType,
    PyType_GenericAlloc,
    Dtool_new_MovingPart_ACMatrixSwitchType,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType,
  Dtool_UpcastInterface_MovingPart_ACMatrixSwitchType,
  Dtool_DowncastInterface_MovingPart_ACMatrixSwitchType,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovingPartBase(NULL);
    Dtool_MovingPart_ACMatrixSwitchType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovingPartBase);
    PyObject *dict = PyDict_New();
    Dtool_MovingPart_ACMatrixSwitchType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovingPart_ACMatrixSwitchType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovingPart_ACMatrixSwitchType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovingPart_ACMatrixSwitchType);
  }
}

/**
 * Python method tables for MovingPartScalar (MovingPartScalar)
 */
static PyMethodDef Dtool_Methods_MovingPartScalar[] = {
  {"get_class_type", &Dtool_MovingPartScalar_get_class_type_280, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartScalar_get_class_type_280_comment},
  {"getClassType", &Dtool_MovingPartScalar_get_class_type_280, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartScalar_get_class_type_280_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MovingPartScalar = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovingPartScalar = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MovingPartScalar = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MovingPartScalar = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MovingPartScalar = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MovingPartScalar",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MovingPartScalar,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MovingPartScalar,
    &Dtool_SequenceMethods_MovingPartScalar,
    &Dtool_MappingMethods_MovingPartScalar,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MovingPartScalar,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a particular kind of MovingPart that accepts a scalar each frame.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MovingPartScalar,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MovingPartScalar,
    PyType_GenericAlloc,
    Dtool_new_MovingPartScalar,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovingPartScalar,
  Dtool_UpcastInterface_MovingPartScalar,
  Dtool_DowncastInterface_MovingPartScalar,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MovingPartScalar(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType(NULL);
    Dtool_MovingPartScalar._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovingPart_ACScalarSwitchType);
    PyObject *dict = PyDict_New();
    Dtool_MovingPartScalar._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovingPartScalar) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovingPartScalar)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovingPartScalar);
  }
}

/**
 * Python method tables for MovingPart_ACScalarSwitchType (MovingPart_ACScalarSwitchType)
 */
static PyMethodDef Dtool_Methods_MovingPart_ACScalarSwitchType[] = {
  {"get_class_type", &Dtool_MovingPart_ACScalarSwitchType_get_class_type_276, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_class_type_276_comment},
  {"getClassType", &Dtool_MovingPart_ACScalarSwitchType_get_class_type_276, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_class_type_276_comment},
  {"get_value", &Dtool_MovingPart_ACScalarSwitchType_get_value_277, METH_NOARGS, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_value_277_comment},
  {"getValue", &Dtool_MovingPart_ACScalarSwitchType_get_value_277, METH_NOARGS, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_value_277_comment},
  {"get_default_value", &Dtool_MovingPart_ACScalarSwitchType_get_default_value_278, METH_NOARGS, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_default_value_278_comment},
  {"getDefaultValue", &Dtool_MovingPart_ACScalarSwitchType_get_default_value_278, METH_NOARGS, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_default_value_278_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MovingPart_ACScalarSwitchType = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovingPart_ACScalarSwitchType = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MovingPart_ACScalarSwitchType = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MovingPart_ACScalarSwitchType = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MovingPart_ACScalarSwitchType = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MovingPart_ACScalarSwitchType",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MovingPart_ACScalarSwitchType,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MovingPart_ACScalarSwitchType,
    &Dtool_SequenceMethods_MovingPart_ACScalarSwitchType,
    &Dtool_MappingMethods_MovingPart_ACScalarSwitchType,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MovingPart_ACScalarSwitchType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MovingPart_ACScalarSwitchType,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MovingPart_ACScalarSwitchType,
    PyType_GenericAlloc,
    Dtool_new_MovingPart_ACScalarSwitchType,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType,
  Dtool_UpcastInterface_MovingPart_ACScalarSwitchType,
  Dtool_DowncastInterface_MovingPart_ACScalarSwitchType,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovingPartBase(NULL);
    Dtool_MovingPart_ACScalarSwitchType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovingPartBase);
    PyObject *dict = PyDict_New();
    Dtool_MovingPart_ACScalarSwitchType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovingPart_ACScalarSwitchType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovingPart_ACScalarSwitchType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovingPart_ACScalarSwitchType);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3chan_RegisterTypes() {
  Dtool_AnimGroup._type = AnimGroup::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimGroup);
  Dtool_AnimBundle._type = AnimBundle::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimBundle);
  Dtool_AnimBundleNode._type = AnimBundleNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimBundleNode);
  Dtool_PartGroup._type = PartGroup::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PartGroup);
  Dtool_AnimControl._type = AnimControl::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimControl);
  Dtool_AnimChannelBase._type = AnimChannelBase::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimChannelBase);
  Dtool_AnimChannel_ACMatrixSwitchType._type = AnimChannel< ACMatrixSwitchType >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimChannel_ACMatrixSwitchType);
  Dtool_AnimChannel_ACScalarSwitchType._type = AnimChannel< ACScalarSwitchType >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimChannel_ACScalarSwitchType);
  Dtool_AnimChannelMatrixDynamic._type = AnimChannelMatrixDynamic::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimChannelMatrixDynamic);
  Dtool_AnimChannelMatrixXfmTable._type = AnimChannelMatrixXfmTable::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimChannelMatrixXfmTable);
  Dtool_AnimChannelScalarDynamic._type = AnimChannelScalarDynamic::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimChannelScalarDynamic);
  Dtool_AnimChannelScalarTable._type = AnimChannelScalarTable::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimChannelScalarTable);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("AnimControlCollection", Dtool_AnimControlCollection);
#endif
  Dtool_AnimPreloadTable._type = AnimPreloadTable::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AnimPreloadTable);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PartSubset", Dtool_PartSubset);
#endif
  Dtool_BindAnimRequest._type = BindAnimRequest::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BindAnimRequest);
  Dtool_PartBundle._type = PartBundle::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PartBundle);
  Dtool_PartBundleNode._type = PartBundleNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PartBundleNode);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PartBundleHandle", Dtool_PartBundleHandle);
#endif
  Dtool_MovingPartBase._type = MovingPartBase::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MovingPartBase);
  Dtool_MovingPartMatrix._type = MovingPartMatrix::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MovingPartMatrix);
  Dtool_MovingPart_ACMatrixSwitchType._type = MovingPart< ACMatrixSwitchType >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MovingPart_ACMatrixSwitchType);
  Dtool_MovingPartScalar._type = MovingPartScalar::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MovingPartScalar);
  Dtool_MovingPart_ACScalarSwitchType._type = MovingPart< ACScalarSwitchType >::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MovingPart_ACScalarSwitchType);
}

void Dtool_libp3chan_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_GlobPattern = LookupNamedClass("GlobPattern");
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_LQuaternionf = LookupRuntimeTypedClass(LQuaternionf::get_class_type());
  Dtool_Ptr_BitArray = LookupRuntimeTypedClass(BitArray::get_class_type());
  Dtool_Ptr_CachedTypedWritableReferenceCount = LookupRuntimeTypedClass(CachedTypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_CopyOnWriteObject = LookupRuntimeTypedClass(CopyOnWriteObject::get_class_type());
  Dtool_Ptr_LoaderOptions = LookupNamedClass("LoaderOptions");
  Dtool_Ptr_TransformState = LookupRuntimeTypedClass(TransformState::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_AnimInterface = LookupRuntimeTypedClass(AnimInterface::get_class_type());
  Dtool_Ptr_AsyncTask = LookupRuntimeTypedClass(AsyncTask::get_class_type());
  Dtool_Ptr_AsyncTaskBase = LookupRuntimeTypedClass(AsyncTaskBase::get_class_type());
  Dtool_Ptr_Loader = LookupRuntimeTypedClass(Loader::get_class_type());
  Dtool_Ptr_ModelLoadRequest = LookupRuntimeTypedClass(ModelLoadRequest::get_class_type());
  Dtool_Ptr_ConstPointerToArray_float = LookupNamedClass("ConstPointerToArray< float >");
#endif
}

void Dtool_libp3chan_BuildInstants(PyObject *module) {
  (void) module;
  // AnimGroup
  Dtool_PyModuleClassInit_AnimGroup(module);
  PyModule_AddObject(module, "AnimGroup", (PyObject *)&Dtool_AnimGroup);
  // AnimBundle
  Dtool_PyModuleClassInit_AnimBundle(module);
  PyModule_AddObject(module, "AnimBundle", (PyObject *)&Dtool_AnimBundle);
  // AnimBundleNode
  Dtool_PyModuleClassInit_AnimBundleNode(module);
  PyModule_AddObject(module, "AnimBundleNode", (PyObject *)&Dtool_AnimBundleNode);
  // PartGroup
  Dtool_PyModuleClassInit_PartGroup(module);
  PyModule_AddObject(module, "PartGroup", (PyObject *)&Dtool_PartGroup);
  // AnimControl
  Dtool_PyModuleClassInit_AnimControl(module);
  PyModule_AddObject(module, "AnimControl", (PyObject *)&Dtool_AnimControl);
  // AnimChannelBase
  Dtool_PyModuleClassInit_AnimChannelBase(module);
  PyModule_AddObject(module, "AnimChannelBase", (PyObject *)&Dtool_AnimChannelBase);
  // AnimChannel< ACMatrixSwitchType >
  Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(module);
  PyModule_AddObject(module, "AnimChannel_ACMatrixSwitchType", (PyObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
  Py_INCREF(Dtool_Ptr_AnimChannel_ACMatrixSwitchType);
  PyModule_AddObject(module, "AnimChannelACMatrixSwitchType", (PyObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
  // typedef AnimChannel< ACMatrixSwitchType > AnimChannelMatrix
  Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(module);
  Py_INCREF((PyObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
  PyModule_AddObject(module, "AnimChannelMatrix", (PyObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
  // AnimChannel< ACScalarSwitchType >
  Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(module);
  PyModule_AddObject(module, "AnimChannel_ACScalarSwitchType", (PyObject *)&Dtool_AnimChannel_ACScalarSwitchType);
  Py_INCREF(Dtool_Ptr_AnimChannel_ACScalarSwitchType);
  PyModule_AddObject(module, "AnimChannelACScalarSwitchType", (PyObject *)&Dtool_AnimChannel_ACScalarSwitchType);
  // typedef AnimChannel< ACScalarSwitchType > AnimChannelScalar
  Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(module);
  Py_INCREF((PyObject *)&Dtool_AnimChannel_ACScalarSwitchType);
  PyModule_AddObject(module, "AnimChannelScalar", (PyObject *)&Dtool_AnimChannel_ACScalarSwitchType);
  // AnimChannelMatrixDynamic
  Dtool_PyModuleClassInit_AnimChannelMatrixDynamic(module);
  PyModule_AddObject(module, "AnimChannelMatrixDynamic", (PyObject *)&Dtool_AnimChannelMatrixDynamic);
  // AnimChannelMatrixXfmTable
  Dtool_PyModuleClassInit_AnimChannelMatrixXfmTable(module);
  PyModule_AddObject(module, "AnimChannelMatrixXfmTable", (PyObject *)&Dtool_AnimChannelMatrixXfmTable);
  // AnimChannelScalarDynamic
  Dtool_PyModuleClassInit_AnimChannelScalarDynamic(module);
  PyModule_AddObject(module, "AnimChannelScalarDynamic", (PyObject *)&Dtool_AnimChannelScalarDynamic);
  // AnimChannelScalarTable
  Dtool_PyModuleClassInit_AnimChannelScalarTable(module);
  PyModule_AddObject(module, "AnimChannelScalarTable", (PyObject *)&Dtool_AnimChannelScalarTable);
  // AnimControlCollection
  Dtool_PyModuleClassInit_AnimControlCollection(module);
  PyModule_AddObject(module, "AnimControlCollection", (PyObject *)&Dtool_AnimControlCollection);
  // AnimPreloadTable
  Dtool_PyModuleClassInit_AnimPreloadTable(module);
  PyModule_AddObject(module, "AnimPreloadTable", (PyObject *)&Dtool_AnimPreloadTable);
  // PartSubset
  Dtool_PyModuleClassInit_PartSubset(module);
  PyModule_AddObject(module, "PartSubset", (PyObject *)&Dtool_PartSubset);
  // BindAnimRequest
  Dtool_PyModuleClassInit_BindAnimRequest(module);
  PyModule_AddObject(module, "BindAnimRequest", (PyObject *)&Dtool_BindAnimRequest);
  // PartBundle
  Dtool_PyModuleClassInit_PartBundle(module);
  PyModule_AddObject(module, "PartBundle", (PyObject *)&Dtool_PartBundle);
  // PartBundleNode
  Dtool_PyModuleClassInit_PartBundleNode(module);
  PyModule_AddObject(module, "PartBundleNode", (PyObject *)&Dtool_PartBundleNode);
  // PartBundleHandle
  Dtool_PyModuleClassInit_PartBundleHandle(module);
  PyModule_AddObject(module, "PartBundleHandle", (PyObject *)&Dtool_PartBundleHandle);
  // MovingPartBase
  Dtool_PyModuleClassInit_MovingPartBase(module);
  PyModule_AddObject(module, "MovingPartBase", (PyObject *)&Dtool_MovingPartBase);
  // MovingPartMatrix
  Dtool_PyModuleClassInit_MovingPartMatrix(module);
  PyModule_AddObject(module, "MovingPartMatrix", (PyObject *)&Dtool_MovingPartMatrix);
  // MovingPart< ACMatrixSwitchType >
  Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType(module);
  PyModule_AddObject(module, "MovingPart_ACMatrixSwitchType", (PyObject *)&Dtool_MovingPart_ACMatrixSwitchType);
  Py_INCREF(Dtool_Ptr_MovingPart_ACMatrixSwitchType);
  PyModule_AddObject(module, "MovingPartACMatrixSwitchType", (PyObject *)&Dtool_MovingPart_ACMatrixSwitchType);
  // MovingPartScalar
  Dtool_PyModuleClassInit_MovingPartScalar(module);
  PyModule_AddObject(module, "MovingPartScalar", (PyObject *)&Dtool_MovingPartScalar);
  // MovingPart< ACScalarSwitchType >
  Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType(module);
  PyModule_AddObject(module, "MovingPart_ACScalarSwitchType", (PyObject *)&Dtool_MovingPart_ACScalarSwitchType);
  Py_INCREF(Dtool_Ptr_MovingPart_ACScalarSwitchType);
  PyModule_AddObject(module, "MovingPartACScalarSwitchType", (PyObject *)&Dtool_MovingPart_ACScalarSwitchType);
}

static PyMethodDef python_simple_funcs[] = {
  {"auto_bind", (PyCFunction) &Dtool_auto_bind_183, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_auto_bind_183_comment},
  {"autoBind", (PyCFunction) &Dtool_auto_bind_183, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_auto_bind_183_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3chan_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478212640,  /* file_identifier */
  "libp3chan",  /* library_name */
  "8NZB",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3chan.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  603  /* next_index */
};

Configure(_in_configure_libp3chan);
ConfigureFn(_in_configure_libp3chan) {
  interrogate_request_module(&_in_module_def);
}

