/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/collide -Ipanda/src/collide -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3collide_igate.cxx -od built/pandac/input/libp3collide.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/collide -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3collide collisionBox.h collisionEntry.h collisionFloorMesh.h collisionGeom.h collisionHandler.h collisionHandlerEvent.h collisionHandlerFloor.h collisionHandlerFluidPusher.h collisionHandlerGravity.h collisionHandlerHighestEvent.h collisionHandlerPhysical.h collisionHandlerPusher.h collisionHandlerQueue.h collisionInvSphere.h collisionLevelState.h collisionLevelStateBase.h collisionLine.h collisionNode.h collisionParabola.h collisionPlane.h collisionPolygon.h collisionRay.h collisionRecorder.h collisionSegment.h collisionSolid.h collisionSphere.h collisionTraverser.h collisionTube.h collisionVisualizer.h config_collide.h p3collide_composite1.cxx p3collide_composite2.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3collide
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "clipPlaneAttrib.h"
#include "collisionBox.h"
#include "collisionEntry.h"
#include "collisionFloorMesh.h"
#include "collisionGeom.h"
#include "collisionHandler.h"
#include "collisionHandlerEvent.h"
#include "collisionHandlerFloor.h"
#include "collisionHandlerFluidPusher.h"
#include "collisionHandlerGravity.h"
#include "collisionHandlerHighestEvent.h"
#include "collisionHandlerPhysical.h"
#include "collisionHandlerPusher.h"
#include "collisionHandlerQueue.h"
#include "collisionInvSphere.h"
#include "collisionLevelState.h"
#include "collisionLevelStateBase.h"
#include "collisionLine.h"
#include "collisionNode.h"
#include "collisionParabola.h"
#include "collisionPlane.h"
#include "collisionPolygon.h"
#include "collisionRay.h"
#include "collisionRecorder.h"
#include "collisionSegment.h"
#include "collisionSolid.h"
#include "collisionSphere.h"
#include "collisionTraverser.h"
#include "collisionTube.h"
#include "collisionVisualizer.h"
#include "config_collide.h"
#include "look_at.h"
#include "luse.h"
#include "nodePath.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "parabola.h"
#include "plane.h"
#include "pmap.h"
#include "pointerTo.h"
#include "pvector.h"
#include "transformState.h"
#include "typedWritableReferenceCount.h"
#include "vector_string.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class CollisionSolid
 */
typedef CollisionSolid CollisionSolid_localtype;
Define_Module_ClassRef(panda3d.core, CollisionSolid, CollisionSolid_localtype, CollisionSolid);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionSolid = &Dtool_CollisionSolid;
static void Dtool_PyModuleClassInit_CollisionSolid(PyObject *module);

/**
 * Forward declarations for top-level class CollisionBox
 */
typedef CollisionBox CollisionBox_localtype;
Define_Module_ClassRef(panda3d.core, CollisionBox, CollisionBox_localtype, CollisionBox);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionBox = &Dtool_CollisionBox;
static void Dtool_PyModuleClassInit_CollisionBox(PyObject *module);
bool Dtool_ConstCoerce_CollisionBox(PyObject *args, CPT(CollisionBox) &coerced);
bool Dtool_Coerce_CollisionBox(PyObject *args, PT(CollisionBox) &coerced);

/**
 * Forward declarations for top-level class CollisionHandler
 */
typedef CollisionHandler CollisionHandler_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandler, CollisionHandler_localtype, CollisionHandler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandler = &Dtool_CollisionHandler;
static void Dtool_PyModuleClassInit_CollisionHandler(PyObject *module);

/**
 * Forward declarations for top-level class CollisionNode
 */
typedef CollisionNode CollisionNode_localtype;
Define_Module_ClassRef(panda3d.core, CollisionNode, CollisionNode_localtype, CollisionNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionNode = &Dtool_CollisionNode;
static void Dtool_PyModuleClassInit_CollisionNode(PyObject *module);
bool Dtool_ConstCoerce_CollisionNode(PyObject *args, CPT(CollisionNode) &coerced);
bool Dtool_Coerce_CollisionNode(PyObject *args, PT(CollisionNode) &coerced);

/**
 * Forward declarations for top-level class CollisionTraverser
 */
typedef CollisionTraverser CollisionTraverser_localtype;
Define_Module_Class(panda3d.core, CollisionTraverser, CollisionTraverser_localtype, CollisionTraverser);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionTraverser = &Dtool_CollisionTraverser;
static void Dtool_PyModuleClassInit_CollisionTraverser(PyObject *module);
bool Dtool_ConstCoerce_CollisionTraverser(PyObject *args, CollisionTraverser const *&coerced, bool &manage);
bool Dtool_Coerce_CollisionTraverser(PyObject *args, CollisionTraverser *&coerced, bool &manage);

/**
 * Forward declarations for top-level class CollisionRecorder
 */
typedef CollisionRecorder CollisionRecorder_localtype;
Define_Module_Class(panda3d.core, CollisionRecorder, CollisionRecorder_localtype, CollisionRecorder);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionRecorder = &Dtool_CollisionRecorder;
static void Dtool_PyModuleClassInit_CollisionRecorder(PyObject *module);

/**
 * Forward declarations for top-level class CollisionEntry
 */
typedef CollisionEntry CollisionEntry_localtype;
Define_Module_ClassRef(panda3d.core, CollisionEntry, CollisionEntry_localtype, CollisionEntry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionEntry = &Dtool_CollisionEntry;
static void Dtool_PyModuleClassInit_CollisionEntry(PyObject *module);

/**
 * Forward declarations for top-level class CollisionPlane
 */
typedef CollisionPlane CollisionPlane_localtype;
Define_Module_ClassRef(panda3d.core, CollisionPlane, CollisionPlane_localtype, CollisionPlane);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionPlane = &Dtool_CollisionPlane;
static void Dtool_PyModuleClassInit_CollisionPlane(PyObject *module);
bool Dtool_ConstCoerce_CollisionPlane(PyObject *args, CPT(CollisionPlane) &coerced);
bool Dtool_Coerce_CollisionPlane(PyObject *args, PT(CollisionPlane) &coerced);

/**
 * Forward declarations for top-level class CollisionFloorMesh
 */
typedef CollisionFloorMesh CollisionFloorMesh_localtype;
Define_Module_ClassRef(panda3d.core, CollisionFloorMesh, CollisionFloorMesh_localtype, CollisionFloorMesh);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionFloorMesh = &Dtool_CollisionFloorMesh;
static void Dtool_PyModuleClassInit_CollisionFloorMesh(PyObject *module);

/**
 * Forward declarations for top-level class CollisionPolygon
 */
typedef CollisionPolygon CollisionPolygon_localtype;
Define_Module_ClassRef(panda3d.core, CollisionPolygon, CollisionPolygon_localtype, CollisionPolygon);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionPolygon = &Dtool_CollisionPolygon;
static void Dtool_PyModuleClassInit_CollisionPolygon(PyObject *module);
bool Dtool_ConstCoerce_CollisionPolygon(PyObject *args, CPT(CollisionPolygon) &coerced);
bool Dtool_Coerce_CollisionPolygon(PyObject *args, PT(CollisionPolygon) &coerced);

/**
 * Forward declarations for top-level class CollisionHandlerEvent
 */
typedef CollisionHandlerEvent CollisionHandlerEvent_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerEvent, CollisionHandlerEvent_localtype, CollisionHandlerEvent);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerEvent = &Dtool_CollisionHandlerEvent;
static void Dtool_PyModuleClassInit_CollisionHandlerEvent(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerPhysical
 */
typedef CollisionHandlerPhysical CollisionHandlerPhysical_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerPhysical, CollisionHandlerPhysical_localtype, CollisionHandlerPhysical);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerPhysical = &Dtool_CollisionHandlerPhysical;
static void Dtool_PyModuleClassInit_CollisionHandlerPhysical(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerFloor
 */
typedef CollisionHandlerFloor CollisionHandlerFloor_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerFloor, CollisionHandlerFloor_localtype, CollisionHandlerFloor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerFloor = &Dtool_CollisionHandlerFloor;
static void Dtool_PyModuleClassInit_CollisionHandlerFloor(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerPusher
 */
typedef CollisionHandlerPusher CollisionHandlerPusher_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerPusher, CollisionHandlerPusher_localtype, CollisionHandlerPusher);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerPusher = &Dtool_CollisionHandlerPusher;
static void Dtool_PyModuleClassInit_CollisionHandlerPusher(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerFluidPusher
 */
typedef CollisionHandlerFluidPusher CollisionHandlerFluidPusher_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerFluidPusher, CollisionHandlerFluidPusher_localtype, CollisionHandlerFluidPusher);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerFluidPusher = &Dtool_CollisionHandlerFluidPusher;
static void Dtool_PyModuleClassInit_CollisionHandlerFluidPusher(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerGravity
 */
typedef CollisionHandlerGravity CollisionHandlerGravity_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerGravity, CollisionHandlerGravity_localtype, CollisionHandlerGravity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerGravity = &Dtool_CollisionHandlerGravity;
static void Dtool_PyModuleClassInit_CollisionHandlerGravity(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerHighestEvent
 */
typedef CollisionHandlerHighestEvent CollisionHandlerHighestEvent_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerHighestEvent, CollisionHandlerHighestEvent_localtype, CollisionHandlerHighestEvent);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerHighestEvent = &Dtool_CollisionHandlerHighestEvent;
static void Dtool_PyModuleClassInit_CollisionHandlerHighestEvent(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerQueue
 */
typedef CollisionHandlerQueue CollisionHandlerQueue_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerQueue, CollisionHandlerQueue_localtype, CollisionHandlerQueue);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerQueue = &Dtool_CollisionHandlerQueue;
static void Dtool_PyModuleClassInit_CollisionHandlerQueue(PyObject *module);

/**
 * Forward declarations for top-level class CollisionSphere
 */
typedef CollisionSphere CollisionSphere_localtype;
Define_Module_ClassRef(panda3d.core, CollisionSphere, CollisionSphere_localtype, CollisionSphere);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionSphere = &Dtool_CollisionSphere;
static void Dtool_PyModuleClassInit_CollisionSphere(PyObject *module);
bool Dtool_ConstCoerce_CollisionSphere(PyObject *args, CPT(CollisionSphere) &coerced);
bool Dtool_Coerce_CollisionSphere(PyObject *args, PT(CollisionSphere) &coerced);

/**
 * Forward declarations for top-level class CollisionInvSphere
 */
typedef CollisionInvSphere CollisionInvSphere_localtype;
Define_Module_ClassRef(panda3d.core, CollisionInvSphere, CollisionInvSphere_localtype, CollisionInvSphere);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionInvSphere = &Dtool_CollisionInvSphere;
static void Dtool_PyModuleClassInit_CollisionInvSphere(PyObject *module);
bool Dtool_ConstCoerce_CollisionInvSphere(PyObject *args, CPT(CollisionInvSphere) &coerced);
bool Dtool_Coerce_CollisionInvSphere(PyObject *args, PT(CollisionInvSphere) &coerced);

/**
 * Forward declarations for top-level class CollisionRay
 */
typedef CollisionRay CollisionRay_localtype;
Define_Module_ClassRef(panda3d.core, CollisionRay, CollisionRay_localtype, CollisionRay);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionRay = &Dtool_CollisionRay;
static void Dtool_PyModuleClassInit_CollisionRay(PyObject *module);
bool Dtool_ConstCoerce_CollisionRay(PyObject *args, CPT(CollisionRay) &coerced);
bool Dtool_Coerce_CollisionRay(PyObject *args, PT(CollisionRay) &coerced);

/**
 * Forward declarations for top-level class CollisionLine
 */
typedef CollisionLine CollisionLine_localtype;
Define_Module_ClassRef(panda3d.core, CollisionLine, CollisionLine_localtype, CollisionLine);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionLine = &Dtool_CollisionLine;
static void Dtool_PyModuleClassInit_CollisionLine(PyObject *module);
bool Dtool_ConstCoerce_CollisionLine(PyObject *args, CPT(CollisionLine) &coerced);
bool Dtool_Coerce_CollisionLine(PyObject *args, PT(CollisionLine) &coerced);

/**
 * Forward declarations for top-level class CollisionParabola
 */
typedef CollisionParabola CollisionParabola_localtype;
Define_Module_ClassRef(panda3d.core, CollisionParabola, CollisionParabola_localtype, CollisionParabola);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionParabola = &Dtool_CollisionParabola;
static void Dtool_PyModuleClassInit_CollisionParabola(PyObject *module);
bool Dtool_ConstCoerce_CollisionParabola(PyObject *args, CPT(CollisionParabola) &coerced);
bool Dtool_Coerce_CollisionParabola(PyObject *args, PT(CollisionParabola) &coerced);

/**
 * Forward declarations for top-level class CollisionSegment
 */
typedef CollisionSegment CollisionSegment_localtype;
Define_Module_ClassRef(panda3d.core, CollisionSegment, CollisionSegment_localtype, CollisionSegment);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionSegment = &Dtool_CollisionSegment;
static void Dtool_PyModuleClassInit_CollisionSegment(PyObject *module);
bool Dtool_ConstCoerce_CollisionSegment(PyObject *args, CPT(CollisionSegment) &coerced);
bool Dtool_Coerce_CollisionSegment(PyObject *args, PT(CollisionSegment) &coerced);

/**
 * Forward declarations for top-level class CollisionTube
 */
typedef CollisionTube CollisionTube_localtype;
Define_Module_ClassRef(panda3d.core, CollisionTube, CollisionTube_localtype, CollisionTube);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionTube = &Dtool_CollisionTube;
static void Dtool_PyModuleClassInit_CollisionTube(PyObject *module);
bool Dtool_ConstCoerce_CollisionTube(PyObject *args, CPT(CollisionTube) &coerced);
bool Dtool_Coerce_CollisionTube(PyObject *args, PT(CollisionTube) &coerced);

/**
 * Forward declarations for top-level class CollisionVisualizer
 */
typedef CollisionVisualizer CollisionVisualizer_localtype;
Define_Module_ClassRef(panda3d.core, CollisionVisualizer, CollisionVisualizer_localtype, CollisionVisualizer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionVisualizer = &Dtool_CollisionVisualizer;
static void Dtool_PyModuleClassInit_CollisionVisualizer(PyObject *module);
bool Dtool_ConstCoerce_CollisionVisualizer(PyObject *args, CPT(CollisionVisualizer) &coerced);
bool Dtool_Coerce_CollisionVisualizer(PyObject *args, PT(CollisionVisualizer) &coerced);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// CachedTypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CachedTypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CachedTypedWritableReferenceCount = &Dtool_CachedTypedWritableReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// CopyOnWriteObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CopyOnWriteObject;
#else
extern struct Dtool_PyTypedObject Dtool_CopyOnWriteObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CopyOnWriteObject = &Dtool_CopyOnWriteObject;
#endif
// LPoint2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint2f;
inline static LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced) {
  nassertr(Dtool_Ptr_LPoint2f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint2f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint2f *(*)(PyObject *, LPoint2f &))Dtool_Ptr_LPoint2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2f = &Dtool_LPoint2f;
extern LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3f;
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != NULL, NULL);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LPoint3i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3i;
inline static LPoint3i *Dtool_Coerce_LPoint3i(PyObject *args, LPoint3i &coerced) {
  nassertr(Dtool_Ptr_LPoint3i != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3i->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3i *(*)(PyObject *, LPoint3i &))Dtool_Ptr_LPoint3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3i = &Dtool_LPoint3i;
extern LPoint3i *Dtool_Coerce_LPoint3i(PyObject *args, LPoint3i &coerced);
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_BitMask_uint32_t_32;
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != NULL, NULL);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != NULL, NULL);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif
// BoundingVolume
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_BoundingVolume;
#else
extern struct Dtool_PyTypedObject Dtool_BoundingVolume;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingVolume = &Dtool_BoundingVolume;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// LParabolaf
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LParabolaf;
inline static LParabolaf *Dtool_Coerce_LParabolaf(PyObject *args, LParabolaf &coerced) {
  nassertr(Dtool_Ptr_LParabolaf != NULL, NULL);
  nassertr(Dtool_Ptr_LParabolaf->_Dtool_Coerce != NULL, NULL);
  return ((LParabolaf *(*)(PyObject *, LParabolaf &))Dtool_Ptr_LParabolaf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LParabolaf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LParabolaf = &Dtool_LParabolaf;
extern LParabolaf *Dtool_Coerce_LParabolaf(PyObject *args, LParabolaf &coerced);
#endif
// LPlanef
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPlanef;
inline static LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced) {
  nassertr(Dtool_Ptr_LPlanef != NULL, NULL);
  nassertr(Dtool_Ptr_LPlanef->_Dtool_Coerce != NULL, NULL);
  return ((LPlanef *(*)(PyObject *, LPlanef &))Dtool_Ptr_LPlanef->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPlanef;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPlanef = &Dtool_LPlanef;
extern LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// DriveInterface
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DriveInterface;
inline static bool Dtool_ConstCoerce_DriveInterface(PyObject *args, CPT(DriveInterface) &coerced) {
  nassertr(Dtool_Ptr_DriveInterface != NULL, false);
  nassertr(Dtool_Ptr_DriveInterface->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(DriveInterface) &))Dtool_Ptr_DriveInterface->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_DriveInterface(PyObject *args, PT(DriveInterface) &coerced) {
  nassertr(Dtool_Ptr_DriveInterface != NULL, false);
  nassertr(Dtool_Ptr_DriveInterface->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(DriveInterface) &))Dtool_Ptr_DriveInterface->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DriveInterface;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DriveInterface = &Dtool_DriveInterface;
extern bool Dtool_ConstCoerce_DriveInterface(PyObject *args, CPT(DriveInterface) &coerced);
extern bool Dtool_Coerce_DriveInterface(PyObject *args, PT(DriveInterface) &coerced);
#endif
// LensNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LensNode;
inline static bool Dtool_ConstCoerce_LensNode(PyObject *args, CPT(LensNode) &coerced) {
  nassertr(Dtool_Ptr_LensNode != NULL, false);
  nassertr(Dtool_Ptr_LensNode->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(LensNode) &))Dtool_Ptr_LensNode->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_LensNode(PyObject *args, PT(LensNode) &coerced) {
  nassertr(Dtool_Ptr_LensNode != NULL, false);
  nassertr(Dtool_Ptr_LensNode->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(LensNode) &))Dtool_Ptr_LensNode->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LensNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LensNode = &Dtool_LensNode;
extern bool Dtool_ConstCoerce_LensNode(PyObject *args, CPT(LensNode) &coerced);
extern bool Dtool_Coerce_LensNode(PyObject *args, PT(LensNode) &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class CollisionSolid
 */
/**
 * Python function wrapper for:
 * virtual LPoint3 CollisionSolid::get_collision_origin(void) const = 0
 */
static PyObject *Dtool_CollisionSolid_get_collision_origin_3(PyObject *self, PyObject *) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual LPoint3 CollisionSolid::get_collision_origin(void) const = 0
  LPoint3 *return_value = new LPoint3((*(const CollisionSolid*)local_this).get_collision_origin());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_get_collision_origin_3_comment =
  "C++ Interface:\n"
  "get_collision_origin(CollisionSolid self)\n";
#else
static const char *Dtool_CollisionSolid_get_collision_origin_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSolid::set_tangible(bool tangible)
 */
static PyObject *Dtool_CollisionSolid_set_tangible_7(PyObject *self, PyObject *arg) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.set_tangible")) {
    return NULL;
  }
  // 1-inline void CollisionSolid::set_tangible(bool tangible)
  (*local_this).set_tangible((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tangible(const CollisionSolid self, bool tangible)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_set_tangible_7_comment =
  "C++ Interface:\n"
  "set_tangible(const CollisionSolid self, bool tangible)\n"
  "\n"
  "/**\n"
  " * Sets the current state of the 'tangible' flag.  Set this true to make the\n"
  " * solid tangible, so that a CollisionHandlerPusher will not allow another\n"
  " * object to intersect it, or false to make it intangible, so that a\n"
  " * CollisionHandlerPusher will ignore it except to throw an event.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_set_tangible_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionSolid::is_tangible(void) const
 */
static PyObject *Dtool_CollisionSolid_is_tangible_8(PyObject *self, PyObject *) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionSolid::is_tangible(void) const
  bool return_value = (*(const CollisionSolid*)local_this).is_tangible();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_is_tangible_8_comment =
  "C++ Interface:\n"
  "is_tangible(CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * Returns whether the solid is considered 'tangible' or not.  An intangible\n"
  " * solid has no effect in a CollisionHandlerPusher (except to throw an event);\n"
  " * it's useful for defining 'trigger' planes and spheres, that cause an effect\n"
  " * when passed through.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_is_tangible_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSolid::set_effective_normal(LVector3 const &effective_normal)
 */
static PyObject *Dtool_CollisionSolid_set_effective_normal_11(PyObject *self, PyObject *arg) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.set_effective_normal")) {
    return NULL;
  }
  // 1-inline void CollisionSolid::set_effective_normal(LVector3 const &effective_normal)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionSolid.set_effective_normal", "LVector3f");
  }
  (*local_this).set_effective_normal(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_effective_normal(const CollisionSolid self, const LVector3f effective_normal)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_set_effective_normal_11_comment =
  "C++ Interface:\n"
  "set_effective_normal(const CollisionSolid self, const LVector3f effective_normal)\n"
  "\n"
  "/**\n"
  " * Records a false normal for this CollisionSolid that will be reported by the\n"
  " * collision system with all collisions into it, instead of its actual normal.\n"
  " * This is useful as a workaround for the problem of an avatar wanting to\n"
  " * stand on a sloping ground; by storing a false normal, the ground appears to\n"
  " * be perfectly level, and the avatar does not tend to slide down it.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_set_effective_normal_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSolid::clear_effective_normal(void)
 */
static PyObject *Dtool_CollisionSolid_clear_effective_normal_12(PyObject *self, PyObject *) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.clear_effective_normal")) {
    return NULL;
  }
  // 1-inline void CollisionSolid::clear_effective_normal(void)
  (*local_this).clear_effective_normal();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_clear_effective_normal_12_comment =
  "C++ Interface:\n"
  "clear_effective_normal(const CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * Removes the normal previously set by set_effective_normal().\n"
  " */";
#else
static const char *Dtool_CollisionSolid_clear_effective_normal_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionSolid::has_effective_normal(void) const
 */
static PyObject *Dtool_CollisionSolid_has_effective_normal_13(PyObject *self, PyObject *) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionSolid::has_effective_normal(void) const
  bool return_value = (*(const CollisionSolid*)local_this).has_effective_normal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_has_effective_normal_13_comment =
  "C++ Interface:\n"
  "has_effective_normal(CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * Returns true if a special normal was set by set_effective_normal(), false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_has_effective_normal_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &CollisionSolid::get_effective_normal(void) const
 */
static PyObject *Dtool_CollisionSolid_get_effective_normal_14(PyObject *self, PyObject *) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 const &CollisionSolid::get_effective_normal(void) const
  LVector3 const *return_value = &((*(const CollisionSolid*)local_this).get_effective_normal());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_get_effective_normal_14_comment =
  "C++ Interface:\n"
  "get_effective_normal(CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * Returns the normal that was set by set_effective_normal().  It is an error\n"
  " * to call this unless has_effective_normal() returns true.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_get_effective_normal_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal)
 */
static PyObject *Dtool_CollisionSolid_set_respect_effective_normal_15(PyObject *self, PyObject *arg) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.set_respect_effective_normal")) {
    return NULL;
  }
  // 1-inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal)
  (*local_this).set_respect_effective_normal((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_respect_effective_normal(const CollisionSolid self, bool respect_effective_normal)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_set_respect_effective_normal_15_comment =
  "C++ Interface:\n"
  "set_respect_effective_normal(const CollisionSolid self, bool respect_effective_normal)\n"
  "\n"
  "/**\n"
  " * This is only meaningful for CollisionSolids that will be added to a\n"
  " * traverser as colliders.  It is normally true, but if set false, it means\n"
  " * that this particular solid does not care about the \"effective\" normal of\n"
  " * other solids it meets, but rather always uses the true normal.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_set_respect_effective_normal_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionSolid::get_respect_effective_normal(void) const
 */
static PyObject *Dtool_CollisionSolid_get_respect_effective_normal_16(PyObject *self, PyObject *) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionSolid::get_respect_effective_normal(void) const
  bool return_value = (*(const CollisionSolid*)local_this).get_respect_effective_normal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_get_respect_effective_normal_16_comment =
  "C++ Interface:\n"
  "get_respect_effective_normal(CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * See set_respect_effective_normal().\n"
  " */";
#else
static const char *Dtool_CollisionSolid_get_respect_effective_normal_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const
 */
static PyObject *Dtool_CollisionSolid_get_bounds_18(PyObject *self, PyObject *) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }
  // 1-ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const
  ConstPointerTo< BoundingVolume > return_value = (*(const CollisionSolid*)local_this).get_bounds();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  BoundingVolume const *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_get_bounds_18_comment =
  "C++ Interface:\n"
  "get_bounds(CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * Returns the solid's bounding volume.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_get_bounds_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume)
 */
static PyObject *Dtool_CollisionSolid_set_bounds_19(PyObject *self, PyObject *arg) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.set_bounds")) {
    return NULL;
  }
  // 1-void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume)
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "CollisionSolid.set_bounds", true, true);
  if (arg_this != NULL) {
    (*local_this).set_bounds(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bounds(const CollisionSolid self, const BoundingVolume bounding_volume)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_set_bounds_19_comment =
  "C++ Interface:\n"
  "set_bounds(const CollisionSolid self, const BoundingVolume bounding_volume)\n"
  "\n"
  "/**\n"
  " * Returns the solid's bounding volume.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_set_bounds_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CollisionSolid::output(ostream &out) const
 */
static PyObject *Dtool_CollisionSolid_output_22(PyObject *self, PyObject *arg) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void CollisionSolid::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CollisionSolid.output", false, true);
  if (arg_this != NULL) {
    (*(const CollisionSolid*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CollisionSolid self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_output_22_comment =
  "C++ Interface:\n"
  "output(CollisionSolid self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSolid_output_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void CollisionSolid::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_CollisionSolid_write_23(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void CollisionSolid::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "CollisionSolid.write", false, true);
    if (param1_this != NULL) {
      (*(const CollisionSolid*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CollisionSolid self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_write_23_comment =
  "C++ Interface:\n"
  "write(CollisionSolid self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSolid_write_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionSolid::get_class_type(void)
 */
static PyObject *Dtool_CollisionSolid_get_class_type_24(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionSolid::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionSolid::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_get_class_type_24_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionSolid_get_class_type_24_comment = NULL;
#endif

static PyObject *Dtool_CollisionSolid_collision_origin_Getter(PyObject *self, void *) {
  const CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }

  // 1-virtual LPoint3 CollisionSolid::get_collision_origin(void) const = 0
  LPoint3 *return_value = new LPoint3((*(const CollisionSolid*)local_this).get_collision_origin());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

static PyObject *Dtool_CollisionSolid_tangible_Getter(PyObject *self, void *) {
  const CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool CollisionSolid::is_tangible(void) const
  bool return_value = (*(const CollisionSolid*)local_this).is_tangible();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionSolid_tangible_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.tangible")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete tangible attribute");
    return -1;
  }
  // 1-inline void CollisionSolid::set_tangible(bool tangible)
  (*local_this).set_tangible((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tangible(const CollisionSolid self, bool tangible)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionSolid_respect_effective_normal_Getter(PyObject *self, void *) {
  const CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool CollisionSolid::get_respect_effective_normal(void) const
  bool return_value = (*(const CollisionSolid*)local_this).get_respect_effective_normal();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionSolid_respect_effective_normal_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.respect_effective_normal")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete respect_effective_normal attribute");
    return -1;
  }
  // 1-inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal)
  (*local_this).set_respect_effective_normal((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_respect_effective_normal(const CollisionSolid self, bool respect_effective_normal)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionSolid_bounds_Getter(PyObject *self, void *) {
  const CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }

  // 1-ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const
  ConstPointerTo< BoundingVolume > return_value = (*(const CollisionSolid*)local_this).get_bounds();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  BoundingVolume const *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

static int Dtool_CollisionSolid_bounds_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.bounds")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete bounds attribute");
    return -1;
  }
  // 1-void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume)
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "CollisionSolid.set_bounds", true, true);
  if (arg_this != NULL) {
    (*local_this).set_bounds(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bounds(const CollisionSolid self, const BoundingVolume bounding_volume)\n");
  }
  return -1;
}

static int Dtool_Init_CollisionSolid(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CollisionSolid(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionSolid) {
    printf("CollisionSolid ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionSolid *local_this = (CollisionSolid *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionSolid(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionSolid*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionSolid*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionSolid*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionSolid*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionSolid*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionSolid*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionBox
 */
/**
 * Python function wrapper for:
 * inline int CollisionBox::get_num_points(void) const
 */
static PyObject *Dtool_CollisionBox_get_num_points_27(PyObject *self, PyObject *) {
  CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CollisionBox::get_num_points(void) const
  int return_value = (*(const CollisionBox*)local_this).get_num_points();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_num_points_27_comment =
  "C++ Interface:\n"
  "get_num_points(CollisionBox self)\n"
  "\n"
  "/**\n"
  " * Returns 8: the number of vertices of a rectangular solid.\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_num_points_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 CollisionBox::get_point_aabb(int n) const
 */
static PyObject *Dtool_CollisionBox_get_point_aabb_28(PyObject *self, PyObject *arg) {
  CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 CollisionBox::get_point_aabb(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3((*(const CollisionBox*)local_this).get_point_aabb((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_aabb(CollisionBox self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_point_aabb_28_comment =
  "C++ Interface:\n"
  "get_point_aabb(CollisionBox self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the Axis Aligned Bounding Box.\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_point_aabb_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 CollisionBox::get_point(int n) const
 */
static PyObject *Dtool_CollisionBox_get_point_29(PyObject *self, PyObject *arg) {
  CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 CollisionBox::get_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3((*(const CollisionBox*)local_this).get_point((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(CollisionBox self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_point_29_comment =
  "C++ Interface:\n"
  "get_point(CollisionBox self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the OBB.\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_point_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionBox::get_num_planes(void) const
 */
static PyObject *Dtool_CollisionBox_get_num_planes_30(PyObject *self, PyObject *) {
  CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CollisionBox::get_num_planes(void) const
  int return_value = (*(const CollisionBox*)local_this).get_num_planes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_num_planes_30_comment =
  "C++ Interface:\n"
  "get_num_planes(CollisionBox self)\n"
  "\n"
  "/**\n"
  " * Returns 6: the number of faces of a rectangular solid.\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_num_planes_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPlane CollisionBox::set_plane(int n) const
 */
static PyObject *Dtool_CollisionBox_set_plane_31(PyObject *self, PyObject *arg) {
  CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPlane CollisionBox::set_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPlane *return_value = new LPlane((*(const CollisionBox*)local_this).set_plane((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_plane(CollisionBox self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_set_plane_31_comment =
  "C++ Interface:\n"
  "set_plane(CollisionBox self, int n)\n"
  "\n"
  "/**\n"
  " * Creates the nth face of the rectangular solid.\n"
  " */";
#else
static const char *Dtool_CollisionBox_set_plane_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPlane CollisionBox::get_plane(int n) const
 */
static PyObject *Dtool_CollisionBox_get_plane_32(PyObject *self, PyObject *arg) {
  CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPlane CollisionBox::get_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPlane *return_value = new LPlane((*(const CollisionBox*)local_this).get_plane((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(CollisionBox self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_plane_32_comment =
  "C++ Interface:\n"
  "get_plane(CollisionBox self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth face of the rectangular solid.\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_plane_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionBox::set_center(LPoint3 const &center)
 * inline void CollisionBox::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionBox_set_center_33(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionBox, (void **)&local_this, "CollisionBox.set_center")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "center");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'center' (pos 1) not found");
      }
      // 1-inline void CollisionBox::set_center(LPoint3 const &center)
      LPoint3f arg_local;
      LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CollisionBox.set_center", "LPoint3f");
      }
      (*local_this).set_center(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void CollisionBox::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_center", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_center((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_center() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center(const CollisionBox self, const LPoint3f center)\n"
      "set_center(const CollisionBox self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_set_center_33_comment =
  "C++ Interface:\n"
  "set_center(const CollisionBox self, const LPoint3f center)\n"
  "set_center(const CollisionBox self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionBox_set_center_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionBox::get_center(void) const
 */
static PyObject *Dtool_CollisionBox_get_center_34(PyObject *self, PyObject *) {
  CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &CollisionBox::get_center(void) const
  LPoint3 const *return_value = &((*(const CollisionBox*)local_this).get_center());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_center_34_comment =
  "C++ Interface:\n"
  "get_center(CollisionBox self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_center_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionBox::get_min(void) const
 */
static PyObject *Dtool_CollisionBox_get_min_35(PyObject *self, PyObject *) {
  CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &CollisionBox::get_min(void) const
  LPoint3 const *return_value = &((*(const CollisionBox*)local_this).get_min());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_min_35_comment =
  "C++ Interface:\n"
  "get_min(CollisionBox self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_min_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionBox::get_max(void) const
 */
static PyObject *Dtool_CollisionBox_get_max_36(PyObject *self, PyObject *) {
  CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &CollisionBox::get_max(void) const
  LPoint3 const *return_value = &((*(const CollisionBox*)local_this).get_max());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_max_36_comment =
  "C++ Interface:\n"
  "get_max(CollisionBox self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_max_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 CollisionBox::get_dimensions(void) const
 */
static PyObject *Dtool_CollisionBox_get_dimensions_37(PyObject *self, PyObject *) {
  CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 CollisionBox::get_dimensions(void) const
  LVector3 *return_value = new LVector3((*(const CollisionBox*)local_this).get_dimensions());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_dimensions_37_comment =
  "C++ Interface:\n"
  "get_dimensions(CollisionBox self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_dimensions_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionBox::get_class_type(void)
 */
static PyObject *Dtool_CollisionBox_get_class_type_45(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionBox::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionBox::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_class_type_45_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionBox_get_class_type_45_comment = NULL;
#endif

static PyObject *Dtool_CollisionBox_center_Getter(PyObject *self, void *) {
  const CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &CollisionBox::get_center(void) const
  LPoint3 const *return_value = &((*(const CollisionBox*)local_this).get_center());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static PyObject *Dtool_CollisionBox_min_Getter(PyObject *self, void *) {
  const CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &CollisionBox::get_min(void) const
  LPoint3 const *return_value = &((*(const CollisionBox*)local_this).get_min());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static PyObject *Dtool_CollisionBox_max_Getter(PyObject *self, void *) {
  const CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &CollisionBox::get_max(void) const
  LPoint3 const *return_value = &((*(const CollisionBox*)local_this).get_max());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static PyObject *Dtool_CollisionBox_dimensions_Getter(PyObject *self, void *) {
  const CollisionBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector3 CollisionBox::get_dimensions(void) const
  LVector3 *return_value = new LVector3((*(const CollisionBox*)local_this).get_dimensions());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

/**
 * Python function wrapper for:
 * inline CollisionBox::CollisionBox(LPoint3 const &min, LPoint3 const &max)
 * inline CollisionBox::CollisionBox(LPoint3 const &center, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static int Dtool_Init_CollisionBox(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline CollisionBox::CollisionBox(LPoint3 const &min, LPoint3 const &max)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"min", "max", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:CollisionBox", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionBox.CollisionBox", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionBox.CollisionBox", "LPoint3f");
          return -1;
        }
        CollisionBox *return_value = new CollisionBox(*param0_this, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionBox, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline CollisionBox::CollisionBox(LPoint3 const &center, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      PyObject *param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"center", "x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:CollisionBox", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionBox.CollisionBox", "LPoint3f");
          return -1;
        }
        CollisionBox *return_value = new CollisionBox(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionBox, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionBox() takes 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionBox(const LPoint3f min, const LPoint3f max)\n"
      "CollisionBox(const LPoint3f center, float x, float y, float z)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionBox(PyObject *args, CPT(CollisionBox) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionBox, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionBox::CollisionBox(LPoint3 const &min, LPoint3 const &max)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionBox", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LPoint3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionBox *return_value = new CollisionBox(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline CollisionBox::CollisionBox(LPoint3 const &center, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
        PyObject *param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "Offf:CollisionBox", &param0, &param1, &param2, &param3)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          if (param0_this != NULL) {
            CollisionBox *return_value = new CollisionBox(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CollisionBox(PyObject *args, PT(CollisionBox) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionBox, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionBox::CollisionBox(LPoint3 const &min, LPoint3 const &max)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionBox", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LPoint3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionBox *return_value = new CollisionBox(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline CollisionBox::CollisionBox(LPoint3 const &center, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
        PyObject *param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "Offf:CollisionBox", &param0, &param1, &param2, &param3)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          if (param0_this != NULL) {
            CollisionBox *return_value = new CollisionBox(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CollisionBox(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionBox) {
    printf("CollisionBox ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionBox *local_this = (CollisionBox *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionBox) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionBox(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionBox) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionBox*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionHandler
 */
/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandler::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandler_get_class_type_49(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandler::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionHandler::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandler_get_class_type_49_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandler_get_class_type_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollisionHandler::CollisionHandler(CollisionHandler const &) = default
 */
static int Dtool_Init_CollisionHandler(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandler() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline CollisionHandler::CollisionHandler(CollisionHandler const &) = default
  CollisionHandler const *arg_this = (CollisionHandler *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionHandler, 0, "CollisionHandler.CollisionHandler", true, true);
  if (arg_this != NULL) {
    CollisionHandler *return_value = new CollisionHandler(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandler, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandler(const CollisionHandler param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionHandler) {
    printf("CollisionHandler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionHandler *local_this = (CollisionHandler *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionHandler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandler*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionNode
 */
/**
 * Python function wrapper for:
 * inline void CollisionNode::set_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_CollisionNode_set_collide_mask_55(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.set_collide_mask")) {
    return NULL;
  }
  // 1-inline void CollisionNode::set_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionNode.set_collide_mask", "BitMask");
  }
  (*local_this).set_collide_mask(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_mask(const CollisionNode self, BitMask mask)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_set_collide_mask_55_comment =
  "C++ Interface:\n"
  "set_collide_mask(const CollisionNode self, BitMask mask)\n"
  "\n"
  "/**\n"
  " * Simultaneously sets both the \"from\" and \"into\" CollideMask values to the\n"
  " * same thing.\n"
  " */";
#else
static const char *Dtool_CollisionNode_set_collide_mask_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionNode::set_from_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_CollisionNode_set_from_collide_mask_56(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.set_from_collide_mask")) {
    return NULL;
  }
  // 1-void CollisionNode::set_from_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionNode.set_from_collide_mask", "BitMask");
  }
  (*local_this).set_from_collide_mask(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_collide_mask(const CollisionNode self, BitMask mask)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_set_from_collide_mask_56_comment =
  "C++ Interface:\n"
  "set_from_collide_mask(const CollisionNode self, BitMask mask)\n"
  "\n"
  "/**\n"
  " * Sets the \"from\" CollideMask.  In order for a collision to be detected from\n"
  " * this object into another object, the intersection of this object's \"from\"\n"
  " * mask and the other object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_CollisionNode_set_from_collide_mask_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionNode::set_into_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_CollisionNode_set_into_collide_mask_57(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.set_into_collide_mask")) {
    return NULL;
  }
  // 1-inline void CollisionNode::set_into_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionNode.set_into_collide_mask", "BitMask");
  }
  (*local_this).set_into_collide_mask(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_into_collide_mask(const CollisionNode self, BitMask mask)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_set_into_collide_mask_57_comment =
  "C++ Interface:\n"
  "set_into_collide_mask(const CollisionNode self, BitMask mask)\n"
  "\n"
  "/**\n"
  " * Sets the \"into\" CollideMask.  In order for a collision to be detected from\n"
  " * another object into this object, the intersection of the other object's\n"
  " * \"from\" mask and this object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_CollisionNode_set_into_collide_mask_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask CollisionNode::get_from_collide_mask(void) const
 */
static PyObject *Dtool_CollisionNode_get_from_collide_mask_58(PyObject *self, PyObject *) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CollideMask CollisionNode::get_from_collide_mask(void) const
  CollideMask *return_value = new CollideMask((*(const CollisionNode*)local_this).get_from_collide_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_from_collide_mask_58_comment =
  "C++ Interface:\n"
  "get_from_collide_mask(CollisionNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current \"from\" CollideMask.  In order for a collision to be\n"
  " * detected from this object into another object, the intersection of this\n"
  " * object's \"from\" mask and the other object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_from_collide_mask_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask CollisionNode::get_into_collide_mask(void) const
 */
static PyObject *Dtool_CollisionNode_get_into_collide_mask_59(PyObject *self, PyObject *) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CollideMask CollisionNode::get_into_collide_mask(void) const
  CollideMask *return_value = new CollideMask((*(const CollisionNode*)local_this).get_into_collide_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_into_collide_mask_59_comment =
  "C++ Interface:\n"
  "get_into_collide_mask(CollisionNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current \"into\" CollideMask.  In order for a collision to be\n"
  " * detected from another object into this object, the intersection of the\n"
  " * other object's \"from\" mask and this object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_into_collide_mask_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionNode::clear_solids(void)
 */
static PyObject *Dtool_CollisionNode_clear_solids_65(PyObject *self, PyObject *) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.clear_solids")) {
    return NULL;
  }
  // 1-inline void CollisionNode::clear_solids(void)
  (*local_this).clear_solids();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_clear_solids_65_comment =
  "C++ Interface:\n"
  "clear_solids(const CollisionNode self)\n"
  "\n"
  "/**\n"
  " * Removes all solids from the node.\n"
  " */";
#else
static const char *Dtool_CollisionNode_clear_solids_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionNode::get_num_solids(void) const
 */
static PyObject *Dtool_CollisionNode_get_num_solids_66(PyObject *self, PyObject *) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CollisionNode::get_num_solids(void) const
  int return_value = (*(const CollisionNode*)local_this).get_num_solids();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_num_solids_66_comment =
  "C++ Interface:\n"
  "get_num_solids(CollisionNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_num_solids_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(int n) const
 */
static PyObject *Dtool_CollisionNode_get_solid_67(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ConstPointerTo< CollisionSolid > return_value = (*(const CollisionNode*)local_this).get_solid((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    CollisionSolid const *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_CollisionSolid, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_solid(CollisionNode self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_solid_67_comment =
  "C++ Interface:\n"
  "get_solid(CollisionNode self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_solid_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< CollisionSolid > CollisionNode::modify_solid(int n)
 */
static PyObject *Dtool_CollisionNode_modify_solid_69(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.modify_solid")) {
    return NULL;
  }
  // 1-inline PointerTo< CollisionSolid > CollisionNode::modify_solid(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< CollisionSolid > return_value = (*local_this).modify_solid((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    CollisionSolid *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_CollisionSolid, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_solid(const CollisionNode self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_modify_solid_69_comment =
  "C++ Interface:\n"
  "modify_solid(const CollisionNode self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionNode_modify_solid_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionNode::set_solid(int n, CollisionSolid *solid)
 */
static PyObject *Dtool_CollisionNode_set_solid_70(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.set_solid")) {
    return NULL;
  }
  // 1-inline void CollisionNode::set_solid(int n, CollisionSolid *solid)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "solid", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_solid", (char **)keyword_list, &param1, &param2)) {
    CollisionSolid *param2_this = (CollisionSolid *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_CollisionSolid, 2, "CollisionNode.set_solid", false, true);
    if (param2_this != NULL) {
      (*local_this).set_solid((int)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_solid(const CollisionNode self, int n, CollisionSolid solid)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_set_solid_70_comment =
  "C++ Interface:\n"
  "set_solid(const CollisionNode self, int n, CollisionSolid solid)\n"
  "\n"
  "/**\n"
  " * Replaces the solid with the indicated index.\n"
  " */";
#else
static const char *Dtool_CollisionNode_set_solid_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionNode::remove_solid(int n)
 */
static PyObject *Dtool_CollisionNode_remove_solid_71(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.remove_solid")) {
    return NULL;
  }
  // 1-inline void CollisionNode::remove_solid(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).remove_solid((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_solid(const CollisionNode self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_remove_solid_71_comment =
  "C++ Interface:\n"
  "remove_solid(const CollisionNode self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the solid with the indicated index.  This will shift all subsequent\n"
  " * indices down by one.\n"
  " */";
#else
static const char *Dtool_CollisionNode_remove_solid_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionNode::add_solid(CollisionSolid const *solid)
 */
static PyObject *Dtool_CollisionNode_add_solid_72(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.add_solid")) {
    return NULL;
  }
  // 1-inline int CollisionNode::add_solid(CollisionSolid const *solid)
  CollisionSolid const *arg_this = (CollisionSolid *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionSolid, 1, "CollisionNode.add_solid", true, true);
  if (arg_this != NULL) {
    int return_value = (*local_this).add_solid(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_solid(const CollisionNode self, const CollisionSolid solid)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_add_solid_72_comment =
  "C++ Interface:\n"
  "add_solid(const CollisionNode self, const CollisionSolid solid)\n"
  "\n"
  "/**\n"
  " * Adds the indicated solid to the node.  Returns the index of the new solid\n"
  " * within the node's list of solids.\n"
  " */";
#else
static const char *Dtool_CollisionNode_add_solid_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionNode::get_collider_sort(void) const
 */
static PyObject *Dtool_CollisionNode_get_collider_sort_75(PyObject *self, PyObject *) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CollisionNode::get_collider_sort(void) const
  int return_value = (*(const CollisionNode*)local_this).get_collider_sort();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_collider_sort_75_comment =
  "C++ Interface:\n"
  "get_collider_sort(CollisionNode self)\n"
  "\n"
  "/**\n"
  " * Returns the collider_sort value that has been set for this particular node.\n"
  " * See set_collider_sort().\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_collider_sort_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionNode::set_collider_sort(int sort)
 */
static PyObject *Dtool_CollisionNode_set_collider_sort_76(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.set_collider_sort")) {
    return NULL;
  }
  // 1-inline void CollisionNode::set_collider_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_collider_sort((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collider_sort(const CollisionNode self, int sort)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_set_collider_sort_76_comment =
  "C++ Interface:\n"
  "set_collider_sort(const CollisionNode self, int sort)\n"
  "\n"
  "/**\n"
  " * Sets a particular collider_sort value on this node.  This controls the\n"
  " * order in which colliders (that is, \"from nodes\") are grouped together for\n"
  " * the collision traversal.\n"
  " *\n"
  " * If there are 32 or fewer colliders added to any particular\n"
  " * CollisionTraverser, then this value has no meaning.  It is only useful if\n"
  " * there are many colliders, which may force the CollisionTraverser to make\n"
  " * multiple passes through the data; in that case, it may be a useful\n"
  " * optimization to group colliders that have similar bounding volumes together\n"
  " * (by giving them similar sort values).\n"
  " */";
#else
static const char *Dtool_CollisionNode_set_collider_sort_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline CollideMask CollisionNode::get_default_collide_mask(void)
 */
static PyObject *Dtool_CollisionNode_get_default_collide_mask_79(PyObject *, PyObject *) {
  // 1-static inline CollideMask CollisionNode::get_default_collide_mask(void)
  CollideMask *return_value = new CollideMask(CollisionNode::get_default_collide_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_default_collide_mask_79_comment =
  "C++ Interface:\n"
  "get_default_collide_mask()\n"
  "\n"
  "/**\n"
  " * Returns the default into_collide_mask assigned to new CollisionNodes.\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_default_collide_mask_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionNode::get_class_type(void)
 */
static PyObject *Dtool_CollisionNode_get_class_type_80(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_class_type_80_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionNode_get_class_type_80_comment = NULL;
#endif

static PyObject *Dtool_CollisionNode_from_collide_mask_Getter(PyObject *self, void *) {
  const CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline CollideMask CollisionNode::get_from_collide_mask(void) const
  CollideMask *return_value = new CollideMask((*(const CollisionNode*)local_this).get_from_collide_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_CollisionNode_from_collide_mask_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.from_collide_mask")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete from_collide_mask attribute");
    return -1;
  }
  // 1-void CollisionNode::set_from_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionNode.set_from_collide_mask", "BitMask");
    return -1;
  }
  (*local_this).set_from_collide_mask(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_from_collide_mask(const CollisionNode self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionNode_into_collide_mask_Getter(PyObject *self, void *) {
  const CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline CollideMask CollisionNode::get_into_collide_mask(void) const
  CollideMask *return_value = new CollideMask((*(const CollisionNode*)local_this).get_into_collide_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_CollisionNode_into_collide_mask_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.into_collide_mask")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete into_collide_mask attribute");
    return -1;
  }
  // 1-inline void CollisionNode::set_into_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionNode.set_into_collide_mask", "BitMask");
    return -1;
  }
  (*local_this).set_into_collide_mask(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_into_collide_mask(const CollisionNode self, BitMask mask)\n");
  }
  return -1;
}

/**
 * sequence length function for property CollisionNode::solids
 */
static Py_ssize_t Dtool_CollisionNode_solids_Len(PyObject *self) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_solids();
}

/**
 * sequence getter for property CollisionNode::solids
 */
static PyObject *Dtool_CollisionNode_solids_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_solids()) {
    PyErr_SetString(PyExc_IndexError, "CollisionNode.solids[] index out of range");
    return NULL;
  }
  // 1-inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(int n) const
  ConstPointerTo< CollisionSolid > return_value = (*(const CollisionNode*)local_this).get_solid(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  CollisionSolid const *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_CollisionSolid, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_solid(CollisionNode self, index)\n");
  }
}

static int Dtool_CollisionNode_solids_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.solids")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    local_this->remove_solid(index);
    return 0;
  }
  // 1-inline void CollisionNode::set_solid(int n, CollisionSolid *solid)
  CollisionSolid *arg_this = (CollisionSolid *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionSolid, 2, "CollisionNode.set_solid", false, true);
  if (arg_this != NULL) {
    (*local_this).set_solid(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_solid(const CollisionNode self, index, CollisionSolid solid)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionNode_solids_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_CollisionNode_solids_Len;
  wrap->_getitem_func = &Dtool_CollisionNode_solids_Getitem;
  wrap->_setitem_func = &Dtool_CollisionNode_solids_Setitem;
  return (PyObject *)wrap;
}

static PyObject *Dtool_CollisionNode_collider_sort_Getter(PyObject *self, void *) {
  const CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int CollisionNode::get_collider_sort(void) const
  int return_value = (*(const CollisionNode*)local_this).get_collider_sort();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionNode_collider_sort_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.collider_sort")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete collider_sort attribute");
    return -1;
  }
  // 1-inline void CollisionNode::set_collider_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_collider_sort((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_collider_sort(const CollisionNode self, int sort)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * CollisionNode::CollisionNode(std::string const &name)
 */
static int Dtool_Init_CollisionNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-CollisionNode::CollisionNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    CollisionNode *return_value = new CollisionNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionNode(PyObject *args, CPT(CollisionNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CollisionNode::CollisionNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CollisionNode *return_value = new CollisionNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_CollisionNode(PyObject *args, PT(CollisionNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CollisionNode::CollisionNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CollisionNode *return_value = new CollisionNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionNode_get_solids(PyObject *self, PyObject *) {
  CollisionNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_solids();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionNode_get_solid_67(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionNode) {
    printf("CollisionNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionNode *local_this = (CollisionNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CollisionNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (CollisionNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionTraverser
 */
/**
 * Python function wrapper for:
 * inline void CollisionTraverser::set_respect_prev_transform(bool flag)
 */
static PyObject *Dtool_CollisionTraverser_set_respect_prev_transform_85(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.set_respect_prev_transform")) {
    return NULL;
  }
  // 1-inline void CollisionTraverser::set_respect_prev_transform(bool flag)
  (*local_this).set_respect_prev_transform((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_respect_prev_transform(const CollisionTraverser self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_set_respect_prev_transform_85_comment =
  "C++ Interface:\n"
  "set_respect_prev_transform(const CollisionTraverser self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates whether the prev_transform stored on a node\n"
  " * (as updated via set_fluid_pos(), etc.) is respected to calculate\n"
  " * collisions.  If this is true, certain types of collision tests will be\n"
  " * enhanced by the information about objects in motion.  If this is false,\n"
  " * objects are always considered to be static.  The default is false.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_set_respect_prev_transform_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionTraverser::get_respect_prev_transform(void) const
 */
static PyObject *Dtool_CollisionTraverser_get_respect_prev_transform_86(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionTraverser::get_respect_prev_transform(void) const
  bool return_value = (*(const CollisionTraverser*)local_this).get_respect_prev_transform();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_respect_prev_transform_86_comment =
  "C++ Interface:\n"
  "get_respect_prev_transform(CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the flag that indicates whether the prev_transform stored on a node\n"
  " * is respected to calculate collisions.  See set_respect_prev_transform().\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_get_respect_prev_transform_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::add_collider(NodePath const &collider, CollisionHandler *handler)
 */
static PyObject *Dtool_CollisionTraverser_add_collider_88(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.add_collider")) {
    return NULL;
  }
  // 1-void CollisionTraverser::add_collider(NodePath const &collider, CollisionHandler *handler)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"collider", "handler", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_collider", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CollisionTraverser.add_collider", true, true);
    CollisionHandler *param2_this = (CollisionHandler *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_CollisionHandler, 2, "CollisionTraverser.add_collider", false, true);
    if (param1_this != NULL && param2_this != NULL) {
      (*local_this).add_collider(*param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_collider(const CollisionTraverser self, const NodePath collider, CollisionHandler handler)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_add_collider_88_comment =
  "C++ Interface:\n"
  "add_collider(const CollisionTraverser self, const NodePath collider, CollisionHandler handler)\n"
  "\n"
  "/**\n"
  " * Adds a new CollisionNode, representing an object that will be tested for\n"
  " * collisions into other objects, along with the handler that will serve each\n"
  " * detected collision.  Each CollisionNode may be served by only one handler\n"
  " * at a time, but a given handler may serve many CollisionNodes.\n"
  " *\n"
  " * The handler that serves a particular node may be changed from time to time\n"
  " * by calling add_collider() again on the same node.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_add_collider_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CollisionTraverser::remove_collider(NodePath const &collider)
 */
static PyObject *Dtool_CollisionTraverser_remove_collider_89(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.remove_collider")) {
    return NULL;
  }
  // 1-bool CollisionTraverser::remove_collider(NodePath const &collider)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionTraverser.remove_collider", true, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).remove_collider(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_collider(const CollisionTraverser self, const NodePath collider)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_remove_collider_89_comment =
  "C++ Interface:\n"
  "remove_collider(const CollisionTraverser self, const NodePath collider)\n"
  "\n"
  "/**\n"
  " * Removes the collider (and its associated handler) from the set of\n"
  " * CollisionNodes that will be tested each frame for collisions into other\n"
  " * objects.  Returns true if the definition was found and removed, false if it\n"
  " * wasn't present to begin with.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_remove_collider_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CollisionTraverser::has_collider(NodePath const &collider) const
 */
static PyObject *Dtool_CollisionTraverser_has_collider_90(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool CollisionTraverser::has_collider(NodePath const &collider) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionTraverser.has_collider", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const CollisionTraverser*)local_this).has_collider(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_collider(CollisionTraverser self, const NodePath collider)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_has_collider_90_comment =
  "C++ Interface:\n"
  "has_collider(CollisionTraverser self, const NodePath collider)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated node is current in the set of nodes that will\n"
  " * be tested each frame for collisions into other objects.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_has_collider_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CollisionTraverser::get_num_colliders(void) const
 */
static PyObject *Dtool_CollisionTraverser_get_num_colliders_91(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }
  // 1-int CollisionTraverser::get_num_colliders(void) const
  int return_value = (*(const CollisionTraverser*)local_this).get_num_colliders();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_num_colliders_91_comment =
  "C++ Interface:\n"
  "get_num_colliders(CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the number of CollisionNodes that have been added to the traverser\n"
  " * via add_collider().\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_get_num_colliders_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath CollisionTraverser::get_collider(int n) const
 */
static PyObject *Dtool_CollisionTraverser_get_collider_92(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }
  // 1-NodePath CollisionTraverser::get_collider(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath((*(const CollisionTraverser*)local_this).get_collider((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_collider(CollisionTraverser self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_collider_92_comment =
  "C++ Interface:\n"
  "get_collider(CollisionTraverser self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth CollisionNode that has been added to the traverser via\n"
  " * add_collider().\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_get_collider_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CollisionHandler *CollisionTraverser::get_handler(NodePath const &collider) const
 */
static PyObject *Dtool_CollisionTraverser_get_handler_94(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }
  // 1-CollisionHandler *CollisionTraverser::get_handler(NodePath const &collider) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionTraverser.get_handler", true, true);
  if (arg_this != NULL) {
    CollisionHandler *return_value = (*(const CollisionTraverser*)local_this).get_handler(*arg_this);
    if (return_value != (CollisionHandler *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (CollisionHandler *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionHandler, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_handler(CollisionTraverser self, const NodePath collider)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_handler_94_comment =
  "C++ Interface:\n"
  "get_handler(CollisionTraverser self, const NodePath collider)\n"
  "\n"
  "/**\n"
  " * Returns the handler that is currently assigned to serve the indicated\n"
  " * collision node, or NULL if the node is not on the traverser's set of active\n"
  " * nodes.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_get_handler_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::clear_colliders(void)
 */
static PyObject *Dtool_CollisionTraverser_clear_colliders_95(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.clear_colliders")) {
    return NULL;
  }
  // 1-void CollisionTraverser::clear_colliders(void)
  (*local_this).clear_colliders();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_clear_colliders_95_comment =
  "C++ Interface:\n"
  "clear_colliders(const CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Completely empties the set of collision nodes and their associated\n"
  " * handlers.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_clear_colliders_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::traverse(NodePath const &root)
 */
static PyObject *Dtool_CollisionTraverser_traverse_98(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.traverse")) {
    return NULL;
  }
  // 1-void CollisionTraverser::traverse(NodePath const &root)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionTraverser.traverse", true, true);
  if (arg_this != NULL) {
    (*local_this).traverse(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "traverse(const CollisionTraverser self, const NodePath root)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_traverse_98_comment =
  "C++ Interface:\n"
  "traverse(const CollisionTraverser self, const NodePath root)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_traverse_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::set_recorder(CollisionRecorder *recorder)
 */
static PyObject *Dtool_CollisionTraverser_set_recorder_99(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.set_recorder")) {
    return NULL;
  }
  // 1-void CollisionTraverser::set_recorder(CollisionRecorder *recorder)
  CollisionRecorder *arg_this = (CollisionRecorder *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionRecorder, 1, "CollisionTraverser.set_recorder", false, true);
  if (arg_this != NULL) {
    (*local_this).set_recorder(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_recorder(const CollisionTraverser self, CollisionRecorder recorder)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_set_recorder_99_comment =
  "C++ Interface:\n"
  "set_recorder(const CollisionTraverser self, CollisionRecorder recorder)\n"
  "\n"
  "/**\n"
  " * Uses the indicated CollisionRecorder object to start recording the\n"
  " * intersection tests made by each subsequent call to traverse() on this\n"
  " * object.  A particular CollisionRecorder object can only record one\n"
  " * traverser at a time; if this object has already been assigned to another\n"
  " * traverser, that assignment is broken.\n"
  " *\n"
  " * This is intended to be used in a debugging mode to try to determine what\n"
  " * work is being performed by the collision traversal.  Usually, attaching a\n"
  " * recorder will impose significant runtime overhead.\n"
  " *\n"
  " * This does not transfer ownership of the CollisionRecorder pointer;\n"
  " * maintenance of that remains the caller's responsibility.  If the\n"
  " * CollisionRecorder is destructed, it will cleanly remove itself from the\n"
  " * traverser.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_set_recorder_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionTraverser::has_recorder(void) const
 */
static PyObject *Dtool_CollisionTraverser_has_recorder_100(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionTraverser::has_recorder(void) const
  bool return_value = (*(const CollisionTraverser*)local_this).has_recorder();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_has_recorder_100_comment =
  "C++ Interface:\n"
  "has_recorder(CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns true if the CollisionTraverser has a CollisionRecorder object\n"
  " * currently assigned, false otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_has_recorder_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollisionRecorder *CollisionTraverser::get_recorder(void) const
 */
static PyObject *Dtool_CollisionTraverser_get_recorder_101(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CollisionRecorder *CollisionTraverser::get_recorder(void) const
  CollisionRecorder *return_value = (*(const CollisionTraverser*)local_this).get_recorder();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionRecorder, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_recorder_101_comment =
  "C++ Interface:\n"
  "get_recorder(CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the CollisionRecorder currently assigned, or NULL if no recorder is\n"
  " * assigned.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_get_recorder_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionTraverser::clear_recorder(void)
 */
static PyObject *Dtool_CollisionTraverser_clear_recorder_102(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.clear_recorder")) {
    return NULL;
  }
  // 1-inline void CollisionTraverser::clear_recorder(void)
  (*local_this).clear_recorder();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_clear_recorder_102_comment =
  "C++ Interface:\n"
  "clear_recorder(const CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Removes the CollisionRecorder from the traverser and restores normal low-\n"
  " * overhead operation.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_clear_recorder_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CollisionVisualizer *CollisionTraverser::show_collisions(NodePath const &root)
 */
static PyObject *Dtool_CollisionTraverser_show_collisions_110(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.show_collisions")) {
    return NULL;
  }
  // 1-CollisionVisualizer *CollisionTraverser::show_collisions(NodePath const &root)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionTraverser.show_collisions", true, true);
  if (arg_this != NULL) {
    CollisionVisualizer *return_value = (*local_this).show_collisions(*arg_this);
    if (return_value != (CollisionVisualizer *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (CollisionVisualizer *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionVisualizer, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "show_collisions(const CollisionTraverser self, const NodePath root)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_show_collisions_110_comment =
  "C++ Interface:\n"
  "show_collisions(const CollisionTraverser self, const NodePath root)\n"
  "\n"
  "/**\n"
  " * This is a high-level function to create a CollisionVisualizer object to\n"
  " * render the collision tests performed by this traverser.  The supplied root\n"
  " * should be any node in the scene graph; typically, the top node (e.g.\n"
  " * render).  The CollisionVisualizer will be attached to this node.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_show_collisions_110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::hide_collisions(void)
 */
static PyObject *Dtool_CollisionTraverser_hide_collisions_111(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.hide_collisions")) {
    return NULL;
  }
  // 1-void CollisionTraverser::hide_collisions(void)
  (*local_this).hide_collisions();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_hide_collisions_111_comment =
  "C++ Interface:\n"
  "hide_collisions(const CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous call to show_collisions().\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_hide_collisions_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::output(ostream &out) const
 */
static PyObject *Dtool_CollisionTraverser_output_112(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CollisionTraverser::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CollisionTraverser.output", false, true);
  if (arg_this != NULL) {
    (*(const CollisionTraverser*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CollisionTraverser self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_output_112_comment =
  "C++ Interface:\n"
  "output(CollisionTraverser self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_output_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_CollisionTraverser_write_113(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CollisionTraverser::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "CollisionTraverser.write", false, true);
    if (param1_this != NULL) {
      (*(const CollisionTraverser*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CollisionTraverser self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_write_113_comment =
  "C++ Interface:\n"
  "write(CollisionTraverser self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_write_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionTraverser::get_class_type(void)
 */
static PyObject *Dtool_CollisionTraverser_get_class_type_114(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionTraverser::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionTraverser::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_class_type_114_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionTraverser_get_class_type_114_comment = NULL;
#endif

static PyObject *Dtool_CollisionTraverser_respect_preV_transform_Getter(PyObject *self, void *) {
  const CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool CollisionTraverser::get_respect_prev_transform(void) const
  bool return_value = (*(const CollisionTraverser*)local_this).get_respect_prev_transform();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionTraverser_respect_preV_transform_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.respect_preV_transform")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete respect_preV_transform attribute");
    return -1;
  }
  // 1-inline void CollisionTraverser::set_respect_prev_transform(bool flag)
  (*local_this).set_respect_prev_transform((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_respect_prev_transform(const CollisionTraverser self, bool flag)\n");
  }
  return -1;
}

/**
 * sequence length function for property CollisionTraverser::colliders
 */
static Py_ssize_t Dtool_CollisionTraverser_colliders_Len(PyObject *self) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_colliders();
}

/**
 * sequence getter for property CollisionTraverser::colliders
 */
static PyObject *Dtool_CollisionTraverser_colliders_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_colliders()) {
    PyErr_SetString(PyExc_IndexError, "CollisionTraverser.colliders[] index out of range");
    return NULL;
  }
  // 1-NodePath CollisionTraverser::get_collider(int n) const
  NodePath *return_value = new NodePath((*(const CollisionTraverser*)local_this).get_collider(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_collider(CollisionTraverser self, index)\n");
  }
}

static PyObject *Dtool_CollisionTraverser_colliders_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_CollisionTraverser_colliders_Len;
  wrap->_getitem_func = &Dtool_CollisionTraverser_colliders_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static PyObject *Dtool_CollisionTraverser_recorder_Getter(PyObject *self, void *) {
  const CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_recorder()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline CollisionRecorder *CollisionTraverser::get_recorder(void) const
  CollisionRecorder *return_value = (*(const CollisionTraverser*)local_this).get_recorder();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionRecorder, false, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_CollisionTraverser_recorder_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.recorder")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete recorder attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_recorder();
    return 0;
  }
  // 1-void CollisionTraverser::set_recorder(CollisionRecorder *recorder)
  CollisionRecorder *arg_this = (CollisionRecorder *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionRecorder, 1, "CollisionTraverser.set_recorder", false, true);
  if (arg_this != NULL) {
    (*local_this).set_recorder(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_recorder(const CollisionTraverser self, CollisionRecorder recorder)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionTraverser::CollisionTraverser(CollisionTraverser const &) = default
 * CollisionTraverser::CollisionTraverser(std::string const &name = "ctrav")
 */
static int Dtool_Init_CollisionTraverser(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-CollisionTraverser::CollisionTraverser(std::string const &name)
      CollisionTraverser *return_value = new CollisionTraverser();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionTraverser, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline CollisionTraverser::CollisionTraverser(CollisionTraverser const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CollisionTraverser", (char **)keyword_list, &param0)) {
          CollisionTraverser const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_CollisionTraverser, (void **)&param0_this);
          if (param0_this != NULL) {
            CollisionTraverser *return_value = new CollisionTraverser(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionTraverser, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 CollisionTraverser::CollisionTraverser(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:CollisionTraverser", (char **)keyword_list, &param0_str, &param0_len)) {
          CollisionTraverser *return_value = new CollisionTraverser(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionTraverser, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline CollisionTraverser::CollisionTraverser(CollisionTraverser const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CollisionTraverser", (char **)keyword_list, &param0)) {
          CollisionTraverser const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_CollisionTraverser(param0, param0_this, param0_manage)) {
            CollisionTraverser *return_value = new CollisionTraverser(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionTraverser, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: CollisionTraverser::CollisionTraverser(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionTraverser() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionTraverser()\n"
      "CollisionTraverser(const CollisionTraverser param0)\n"
      "CollisionTraverser(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionTraverser(PyObject *args, CollisionTraverser const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionTraverser, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CollisionTraverser::CollisionTraverser(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CollisionTraverser *return_value = new CollisionTraverser(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_CollisionTraverser(PyObject *args, CollisionTraverser *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionTraverser, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CollisionTraverser::CollisionTraverser(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CollisionTraverser *return_value = new CollisionTraverser(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionTraverser_get_colliders(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_colliders();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionTraverser_get_collider_92(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionTraverser(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionTraverser) {
    printf("CollisionTraverser ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionTraverser *local_this = (CollisionTraverser *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionTraverser) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionTraverser(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionTraverser) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CollisionTraverser*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionRecorder
 */
/**
 * Python function wrapper for:
 * void CollisionRecorder::output(ostream &out) const
 */
static PyObject *Dtool_CollisionRecorder_output_107(PyObject *self, PyObject *arg) {
  CollisionRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionRecorder, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CollisionRecorder::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CollisionRecorder.output", false, true);
  if (arg_this != NULL) {
    (*(const CollisionRecorder*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CollisionRecorder self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionRecorder_output_107_comment =
  "C++ Interface:\n"
  "output(CollisionRecorder self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionRecorder_output_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionRecorder::get_class_type(void)
 */
static PyObject *Dtool_CollisionRecorder_get_class_type_108(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionRecorder::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionRecorder::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionRecorder_get_class_type_108_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionRecorder_get_class_type_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CollisionVisualizer *CollisionRecorder::downcast_to_CollisionVisualizer(void)
 */
static PyObject *Dtool_CollisionRecorder_downcast_to_CollisionVisualizer_390(PyObject *self, PyObject *) {
  CollisionRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionRecorder, (void **)&local_this, "CollisionRecorder.downcast_to_CollisionVisualizer")) {
    return NULL;
  }
  // 1-CollisionVisualizer *CollisionRecorder::downcast_to_CollisionVisualizer(void)
  CollisionVisualizer *return_value = (CollisionVisualizer *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionVisualizer, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionRecorder_downcast_to_CollisionVisualizer_390_comment =
  "C++ Interface:\n"
  "downcast_to_CollisionVisualizer(const CollisionRecorder self)\n"
  "\n"
  "downcast from CollisionRecorder to CollisionVisualizer";
#else
static const char *Dtool_CollisionRecorder_downcast_to_CollisionVisualizer_390_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollisionRecorder::CollisionRecorder(CollisionRecorder const &) = default
 */
static int Dtool_Init_CollisionRecorder(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionRecorder() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline CollisionRecorder::CollisionRecorder(CollisionRecorder const &) = default
  CollisionRecorder const *arg_this = (CollisionRecorder *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionRecorder, 0, "CollisionRecorder.CollisionRecorder", true, true);
  if (arg_this != NULL) {
    CollisionRecorder *return_value = new CollisionRecorder(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionRecorder, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionRecorder(const CollisionRecorder param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionRecorder(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionRecorder) {
    printf("CollisionRecorder ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionRecorder *local_this = (CollisionRecorder *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionRecorder) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionRecorder(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionRecorder) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionRecorder*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionEntry
 */
/**
 * Python function wrapper for:
 * inline CollisionSolid const *CollisionEntry::get_from(void) const
 */
static PyObject *Dtool_CollisionEntry_get_from_117(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CollisionSolid const *CollisionEntry::get_from(void) const
  CollisionSolid const *return_value = (*(const CollisionEntry*)local_this).get_from();
  if (return_value != (CollisionSolid const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (CollisionSolid const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionSolid, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_from_117_comment =
  "C++ Interface:\n"
  "get_from(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the CollisionSolid pointer for the particular solid that triggered\n"
  " * this collision.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_from_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_into(void) const
 */
static PyObject *Dtool_CollisionEntry_has_into_118(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionEntry::has_into(void) const
  bool return_value = (*(const CollisionEntry*)local_this).has_into();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_into_118_comment =
  "C++ Interface:\n"
  "has_into(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"into\" solid is, in fact, a CollisionSolid, and its\n"
  " * pointer is known (in which case get_into() may be called to retrieve it).\n"
  " * If this returns false, the collision was detected into a GeomNode, and\n"
  " * there is no CollisionSolid pointer to be retrieved.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_into_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollisionSolid const *CollisionEntry::get_into(void) const
 */
static PyObject *Dtool_CollisionEntry_get_into_119(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CollisionSolid const *CollisionEntry::get_into(void) const
  CollisionSolid const *return_value = (*(const CollisionEntry*)local_this).get_into();
  if (return_value != (CollisionSolid const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (CollisionSolid const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionSolid, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_into_119_comment =
  "C++ Interface:\n"
  "get_into(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the CollisionSolid pointer for the particular solid was collided\n"
  " * into.  This pointer might be NULL if the collision was into a piece of\n"
  " * visible geometry, instead of a normal CollisionSolid collision; see\n"
  " * has_into().\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_into_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollisionNode *CollisionEntry::get_from_node(void) const
 */
static PyObject *Dtool_CollisionEntry_get_from_node_120(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CollisionNode *CollisionEntry::get_from_node(void) const
  CollisionNode *return_value = (*(const CollisionEntry*)local_this).get_from_node();
  if (return_value != (CollisionNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (CollisionNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_from_node_120_comment =
  "C++ Interface:\n"
  "get_from_node(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the node that contains the CollisionSolid that triggered this\n"
  " * collision.  This will be a node that has been added to a CollisionTraverser\n"
  " * via add_collider().\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_from_node_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *CollisionEntry::get_into_node(void) const
 */
static PyObject *Dtool_CollisionEntry_get_into_node_121(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PandaNode *CollisionEntry::get_into_node(void) const
  PandaNode *return_value = (*(const CollisionEntry*)local_this).get_into_node();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_into_node_121_comment =
  "C++ Interface:\n"
  "get_into_node(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the node that contains the CollisionSolid that was collided into.\n"
  " * This returns a PandaNode pointer instead of something more specific,\n"
  " * because it might be either a CollisionNode or a GeomNode.\n"
  " *\n"
  " * Also see get_into_node_path().\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_into_node_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath CollisionEntry::get_from_node_path(void) const
 */
static PyObject *Dtool_CollisionEntry_get_from_node_path_122(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath CollisionEntry::get_from_node_path(void) const
  NodePath *return_value = new NodePath((*(const CollisionEntry*)local_this).get_from_node_path());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_from_node_path_122_comment =
  "C++ Interface:\n"
  "get_from_node_path(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath that represents the CollisionNode that contains the\n"
  " * CollisionSolid that triggered this collision.  This will be a NodePath that\n"
  " * has been added to a CollisionTraverser via add_collider().\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_from_node_path_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath CollisionEntry::get_into_node_path(void) const
 */
static PyObject *Dtool_CollisionEntry_get_into_node_path_123(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath CollisionEntry::get_into_node_path(void) const
  NodePath *return_value = new NodePath((*(const CollisionEntry*)local_this).get_into_node_path());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_into_node_path_123_comment =
  "C++ Interface:\n"
  "get_into_node_path(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath that represents the specific CollisionNode or GeomNode\n"
  " * instance that was collided into.  This is the same node returned by\n"
  " * get_into_node(), represented as a NodePath; however, it may be more useful\n"
  " * because the NodePath can resolve the particular instance of the node, if\n"
  " * there is more than one.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_into_node_path_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_t(PN_stdfloat t)
 */
static PyObject *Dtool_CollisionEntry_set_t_124(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_t")) {
    return NULL;
  }
  // 1-inline void CollisionEntry::set_t(PN_stdfloat t)
  if (PyNumber_Check(arg)) {
    (*local_this).set_t((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_t(const CollisionEntry self, float t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_t_124_comment =
  "C++ Interface:\n"
  "set_t(const CollisionEntry self, float t)\n"
  "\n"
  "/**\n"
  " * Sets a time value for this collision relative to other CollisionEntries\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_t_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionEntry::get_t(void) const
 */
static PyObject *Dtool_CollisionEntry_get_t_125(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionEntry::get_t(void) const
  PN_stdfloat return_value = (*(const CollisionEntry*)local_this).get_t();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_t_125_comment =
  "C++ Interface:\n"
  "get_t(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * returns time value for this collision relative to other CollisionEntries\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_t_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::collided(void) const
 */
static PyObject *Dtool_CollisionEntry_collided_126(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionEntry::collided(void) const
  bool return_value = (*(const CollisionEntry*)local_this).collided();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_collided_126_comment =
  "C++ Interface:\n"
  "collided(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * returns true if this represents an actual collision as opposed to a\n"
  " * potential collision, needed for iterative collision resolution where path\n"
  " * of collider changes mid-frame\n"
  " */";
#else
static const char *Dtool_CollisionEntry_collided_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::reset_collided(void)
 */
static PyObject *Dtool_CollisionEntry_reset_collided_127(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.reset_collided")) {
    return NULL;
  }
  // 1-inline void CollisionEntry::reset_collided(void)
  (*local_this).reset_collided();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_reset_collided_127_comment =
  "C++ Interface:\n"
  "reset_collided(const CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * prepare for another collision test\n"
  " */";
#else
static const char *Dtool_CollisionEntry_reset_collided_127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::get_respect_prev_transform(void) const
 */
static PyObject *Dtool_CollisionEntry_get_respect_prev_transform_128(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionEntry::get_respect_prev_transform(void) const
  bool return_value = (*(const CollisionEntry*)local_this).get_respect_prev_transform();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_respect_prev_transform_128_comment =
  "C++ Interface:\n"
  "get_respect_prev_transform(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the collision was detected by a CollisionTraverser whose\n"
  " * respect_prev_transform flag was set true, meaning we should consider motion\n"
  " * significant in evaluating collisions.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_respect_prev_transform_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_surface_point(LPoint3 const &point)
 */
static PyObject *Dtool_CollisionEntry_set_surface_point_129(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_surface_point")) {
    return NULL;
  }
  // 1-inline void CollisionEntry::set_surface_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionEntry.set_surface_point", "LPoint3f");
  }
  (*local_this).set_surface_point(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface_point(const CollisionEntry self, const LPoint3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_surface_point_129_comment =
  "C++ Interface:\n"
  "set_surface_point(const CollisionEntry self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Stores the point, on the surface of the \"into\" object, at which a collision\n"
  " * is detected.\n"
  " *\n"
  " * This point is specified in the coordinate space of the \"into\" object.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_surface_point_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_surface_normal(LVector3 const &normal)
 */
static PyObject *Dtool_CollisionEntry_set_surface_normal_130(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_surface_normal")) {
    return NULL;
  }
  // 1-inline void CollisionEntry::set_surface_normal(LVector3 const &normal)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionEntry.set_surface_normal", "LVector3f");
  }
  (*local_this).set_surface_normal(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface_normal(const CollisionEntry self, const LVector3f normal)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_surface_normal_130_comment =
  "C++ Interface:\n"
  "set_surface_normal(const CollisionEntry self, const LVector3f normal)\n"
  "\n"
  "/**\n"
  " * Stores the surface normal of the \"into\" object at the point of the\n"
  " * intersection.\n"
  " *\n"
  " * This normal is specified in the coordinate space of the \"into\" object.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_surface_normal_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_interior_point(LPoint3 const &point)
 */
static PyObject *Dtool_CollisionEntry_set_interior_point_131(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_interior_point")) {
    return NULL;
  }
  // 1-inline void CollisionEntry::set_interior_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionEntry.set_interior_point", "LPoint3f");
  }
  (*local_this).set_interior_point(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_interior_point(const CollisionEntry self, const LPoint3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_interior_point_131_comment =
  "C++ Interface:\n"
  "set_interior_point(const CollisionEntry self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Stores the point, within the interior of the \"into\" object, which\n"
  " * represents the depth to which the \"from\" object has penetrated.  This can\n"
  " * also be described as the intersection point on the surface of the \"from\"\n"
  " * object (which is inside the \"into\" object).\n"
  " *\n"
  " * This point is specified in the coordinate space of the \"into\" object.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_interior_point_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_surface_point(void) const
 */
static PyObject *Dtool_CollisionEntry_has_surface_point_132(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionEntry::has_surface_point(void) const
  bool return_value = (*(const CollisionEntry*)local_this).has_surface_point();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_surface_point_132_comment =
  "C++ Interface:\n"
  "has_surface_point(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the surface point has been specified, false otherwise.  See\n"
  " * get_surface_point().  Some types of collisions may not compute the surface\n"
  " * point.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_surface_point_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_surface_normal(void) const
 */
static PyObject *Dtool_CollisionEntry_has_surface_normal_133(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionEntry::has_surface_normal(void) const
  bool return_value = (*(const CollisionEntry*)local_this).has_surface_normal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_surface_normal_133_comment =
  "C++ Interface:\n"
  "has_surface_normal(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the surface normal has been specified, false otherwise.\n"
  " * See get_surface_normal().  Some types of collisions may not compute the\n"
  " * surface normal.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_surface_normal_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_interior_point(void) const
 */
static PyObject *Dtool_CollisionEntry_has_interior_point_134(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionEntry::has_interior_point(void) const
  bool return_value = (*(const CollisionEntry*)local_this).has_interior_point();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_interior_point_134_comment =
  "C++ Interface:\n"
  "has_interior_point(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the interior point has been specified, false otherwise.\n"
  " * See get_interior_point().  Some types of collisions may not compute the\n"
  " * interior point.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_interior_point_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_contact_pos(LPoint3 const &pos)
 */
static PyObject *Dtool_CollisionEntry_set_contact_pos_135(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_contact_pos")) {
    return NULL;
  }
  // 1-inline void CollisionEntry::set_contact_pos(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionEntry.set_contact_pos", "LPoint3f");
  }
  (*local_this).set_contact_pos(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contact_pos(const CollisionEntry self, const LPoint3f pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_contact_pos_135_comment =
  "C++ Interface:\n"
  "set_contact_pos(const CollisionEntry self, const LPoint3f pos)\n"
  "\n"
  "/**\n"
  " * Stores the position of the \"from\" object at the instant at which the\n"
  " * collision is first detected.\n"
  " *\n"
  " * This position is specified in the coordinate space of the \"into\" object.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_contact_pos_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_contact_normal(LVector3 const &normal)
 */
static PyObject *Dtool_CollisionEntry_set_contact_normal_136(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_contact_normal")) {
    return NULL;
  }
  // 1-inline void CollisionEntry::set_contact_normal(LVector3 const &normal)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionEntry.set_contact_normal", "LVector3f");
  }
  (*local_this).set_contact_normal(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contact_normal(const CollisionEntry self, const LVector3f normal)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_contact_normal_136_comment =
  "C++ Interface:\n"
  "set_contact_normal(const CollisionEntry self, const LVector3f normal)\n"
  "\n"
  "/**\n"
  " * Stores the surface normal of the \"into\" object at the contact pos.\n"
  " *\n"
  " * This normal is specified in the coordinate space of the \"into\" object.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_contact_normal_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_contact_pos(void) const
 */
static PyObject *Dtool_CollisionEntry_has_contact_pos_137(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionEntry::has_contact_pos(void) const
  bool return_value = (*(const CollisionEntry*)local_this).has_contact_pos();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_contact_pos_137_comment =
  "C++ Interface:\n"
  "has_contact_pos(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the contact position has been specified, false otherwise.\n"
  " * See get_contact_pos().  Some types of collisions may not compute the\n"
  " * contact pos.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_contact_pos_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_contact_normal(void) const
 */
static PyObject *Dtool_CollisionEntry_has_contact_normal_138(PyObject *self, PyObject *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionEntry::has_contact_normal(void) const
  bool return_value = (*(const CollisionEntry*)local_this).has_contact_normal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_contact_normal_138_comment =
  "C++ Interface:\n"
  "has_contact_normal(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the contact normal has been specified, false otherwise.\n"
  " * See get_contact_normal().  Some types of collisions may not compute the\n"
  " * contact normal.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_contact_normal_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LPoint3 CollisionEntry::get_surface_point(NodePath const &space) const
 */
static PyObject *Dtool_CollisionEntry_get_surface_point_139(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-LPoint3 CollisionEntry::get_surface_point(NodePath const &space) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_surface_point", true, true);
  if (arg_this != NULL) {
    LPoint3 *return_value = new LPoint3((*(const CollisionEntry*)local_this).get_surface_point(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_surface_point(CollisionEntry self, const NodePath space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_surface_point_139_comment =
  "C++ Interface:\n"
  "get_surface_point(CollisionEntry self, const NodePath space)\n"
  "\n"
  "/**\n"
  " * Returns the point, on the surface of the \"into\" object, at which a\n"
  " * collision is detected.  This can be thought of as the first point of\n"
  " * intersection.  However the contact point is the actual first point of\n"
  " * intersection.\n"
  " *\n"
  " * The point will be converted into whichever coordinate space the caller\n"
  " * specifies.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_surface_point_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVector3 CollisionEntry::get_surface_normal(NodePath const &space) const
 */
static PyObject *Dtool_CollisionEntry_get_surface_normal_140(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVector3 CollisionEntry::get_surface_normal(NodePath const &space) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_surface_normal", true, true);
  if (arg_this != NULL) {
    LVector3 *return_value = new LVector3((*(const CollisionEntry*)local_this).get_surface_normal(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_surface_normal(CollisionEntry self, const NodePath space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_surface_normal_140_comment =
  "C++ Interface:\n"
  "get_surface_normal(CollisionEntry self, const NodePath space)\n"
  "\n"
  "/**\n"
  " * Returns the surface normal of the \"into\" object at the point at which a\n"
  " * collision is detected.\n"
  " *\n"
  " * The normal will be converted into whichever coordinate space the caller\n"
  " * specifies.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_surface_normal_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LPoint3 CollisionEntry::get_interior_point(NodePath const &space) const
 */
static PyObject *Dtool_CollisionEntry_get_interior_point_141(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-LPoint3 CollisionEntry::get_interior_point(NodePath const &space) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_interior_point", true, true);
  if (arg_this != NULL) {
    LPoint3 *return_value = new LPoint3((*(const CollisionEntry*)local_this).get_interior_point(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_interior_point(CollisionEntry self, const NodePath space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_interior_point_141_comment =
  "C++ Interface:\n"
  "get_interior_point(CollisionEntry self, const NodePath space)\n"
  "\n"
  "/**\n"
  " * Returns the point, within the interior of the \"into\" object, which\n"
  " * represents the depth to which the \"from\" object has penetrated.  This can\n"
  " * also be described as the intersection point on the surface of the \"from\"\n"
  " * object (which is inside the \"into\" object).  It can be thought of as the\n"
  " * deepest point of intersection.\n"
  " *\n"
  " * The point will be converted into whichever coordinate space the caller\n"
  " * specifies.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_interior_point_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CollisionEntry::get_all(NodePath const &space, LPoint3 &surface_point, LVector3 &surface_normal, LPoint3 &interior_point) const
 */
static PyObject *Dtool_CollisionEntry_get_all_142(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool CollisionEntry::get_all(NodePath const &space, LPoint3 &surface_point, LVector3 &surface_normal, LPoint3 &interior_point) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  PyObject *param4;
  static const char *keyword_list[] = {"space", "surface_point", "surface_normal", "interior_point", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:get_all", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_all", true, true);
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CollisionEntry.get_all", "LPoint3f");
    }
    LVector3f param3_local;
    LVector3 *param3_this = Dtool_Coerce_LVector3f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "CollisionEntry.get_all", "LVector3f");
    }
    LPoint3f param4_local;
    LPoint3 *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
    if (!(param4_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "CollisionEntry.get_all", "LPoint3f");
    }
    if (param1_this != NULL) {
      bool return_value = (*(const CollisionEntry*)local_this).get_all(*param1_this, *param2_this, *param3_this, *param4_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_all(CollisionEntry self, const NodePath space, LPoint3f surface_point, LVector3f surface_normal, LPoint3f interior_point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_all_142_comment =
  "C++ Interface:\n"
  "get_all(CollisionEntry self, const NodePath space, LPoint3f surface_point, LVector3f surface_normal, LPoint3f interior_point)\n"
  "\n"
  "/**\n"
  " * Simultaneously transforms the surface point, surface normal, and interior\n"
  " * point of the collision into the indicated coordinate space.\n"
  " *\n"
  " * Returns true if all three properties are available, or false if any one of\n"
  " * them is not.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_all_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LPoint3 CollisionEntry::get_contact_pos(NodePath const &space) const
 */
static PyObject *Dtool_CollisionEntry_get_contact_pos_143(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-LPoint3 CollisionEntry::get_contact_pos(NodePath const &space) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_contact_pos", true, true);
  if (arg_this != NULL) {
    LPoint3 *return_value = new LPoint3((*(const CollisionEntry*)local_this).get_contact_pos(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_contact_pos(CollisionEntry self, const NodePath space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_contact_pos_143_comment =
  "C++ Interface:\n"
  "get_contact_pos(CollisionEntry self, const NodePath space)\n"
  "\n"
  "/**\n"
  " * Returns the position of the \"from\" object at the instant that a collision\n"
  " * is first detected.\n"
  " *\n"
  " * The position will be converted into whichever coordinate space the caller\n"
  " * specifies.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_contact_pos_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVector3 CollisionEntry::get_contact_normal(NodePath const &space) const
 */
static PyObject *Dtool_CollisionEntry_get_contact_normal_144(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVector3 CollisionEntry::get_contact_normal(NodePath const &space) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_contact_normal", true, true);
  if (arg_this != NULL) {
    LVector3 *return_value = new LVector3((*(const CollisionEntry*)local_this).get_contact_normal(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_contact_normal(CollisionEntry self, const NodePath space)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_contact_normal_144_comment =
  "C++ Interface:\n"
  "get_contact_normal(CollisionEntry self, const NodePath space)\n"
  "\n"
  "/**\n"
  " * Returns the surface normal of the \"into\" object at the contact position.\n"
  " *\n"
  " * The normal will be converted into whichever coordinate space the caller\n"
  " * specifies.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_contact_normal_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CollisionEntry::get_all_contact_info(NodePath const &space, LPoint3 &contact_pos, LVector3 &contact_normal) const
 */
static PyObject *Dtool_CollisionEntry_get_all_contact_info_145(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool CollisionEntry::get_all_contact_info(NodePath const &space, LPoint3 &contact_pos, LVector3 &contact_normal) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"space", "contact_pos", "contact_normal", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:get_all_contact_info", (char **)keyword_list, &param1, &param2, &param3)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_all_contact_info", true, true);
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CollisionEntry.get_all_contact_info", "LPoint3f");
    }
    LVector3f param3_local;
    LVector3 *param3_this = Dtool_Coerce_LVector3f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "CollisionEntry.get_all_contact_info", "LVector3f");
    }
    if (param1_this != NULL) {
      bool return_value = (*(const CollisionEntry*)local_this).get_all_contact_info(*param1_this, *param2_this, *param3_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_all_contact_info(CollisionEntry self, const NodePath space, LPoint3f contact_pos, LVector3f contact_normal)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_all_contact_info_145_comment =
  "C++ Interface:\n"
  "get_all_contact_info(CollisionEntry self, const NodePath space, LPoint3f contact_pos, LVector3f contact_normal)\n"
  "\n"
  "/**\n"
  " * Simultaneously transforms the contact position and contact normal of the\n"
  " * collision into the indicated coordinate space.\n"
  " *\n"
  " * Returns true if all three properties are available, or false if any one of\n"
  " * them is not.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_all_contact_info_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionEntry::output(ostream &out) const
 */
static PyObject *Dtool_CollisionEntry_output_146(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CollisionEntry::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CollisionEntry.output", false, true);
  if (arg_this != NULL) {
    (*(const CollisionEntry*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CollisionEntry self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_output_146_comment =
  "C++ Interface:\n"
  "output(CollisionEntry self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionEntry_output_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionEntry::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_CollisionEntry_write_147(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CollisionEntry::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "CollisionEntry.write", false, true);
    if (param1_this != NULL) {
      (*(const CollisionEntry*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CollisionEntry self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_write_147_comment =
  "C++ Interface:\n"
  "write(CollisionEntry self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionEntry_write_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionEntry::get_class_type(void)
 */
static PyObject *Dtool_CollisionEntry_get_class_type_162(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionEntry::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionEntry::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_class_type_162_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionEntry_get_class_type_162_comment = NULL;
#endif

static PyObject *Dtool_CollisionEntry_from_solid_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline CollisionSolid const *CollisionEntry::get_from(void) const
  CollisionSolid const *return_value = (*(const CollisionEntry*)local_this).get_from();
  if (return_value != (CollisionSolid const *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (CollisionSolid const *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionSolid, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_CollisionEntry_into_solid_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline CollisionSolid const *CollisionEntry::get_into(void) const
  CollisionSolid const *return_value = (*(const CollisionEntry*)local_this).get_into();
  if (return_value != (CollisionSolid const *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (CollisionSolid const *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionSolid, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_CollisionEntry_from_node_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline CollisionNode *CollisionEntry::get_from_node(void) const
  CollisionNode *return_value = (*(const CollisionEntry*)local_this).get_from_node();
  if (return_value != (CollisionNode *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (CollisionNode *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_CollisionEntry_into_node_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PandaNode *CollisionEntry::get_into_node(void) const
  PandaNode *return_value = (*(const CollisionEntry*)local_this).get_into_node();
  if (return_value != (PandaNode *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (PandaNode *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_CollisionEntry_from_node_path_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline NodePath CollisionEntry::get_from_node_path(void) const
  NodePath *return_value = new NodePath((*(const CollisionEntry*)local_this).get_from_node_path());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

static PyObject *Dtool_CollisionEntry_into_node_path_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline NodePath CollisionEntry::get_into_node_path(void) const
  NodePath *return_value = new NodePath((*(const CollisionEntry*)local_this).get_into_node_path());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

static PyObject *Dtool_CollisionEntry_t_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionEntry::get_t(void) const
  PN_stdfloat return_value = (*(const CollisionEntry*)local_this).get_t();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionEntry_t_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.t")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete t attribute");
    return -1;
  }
  // 1-inline void CollisionEntry::set_t(PN_stdfloat t)
  if (PyNumber_Check(arg)) {
    (*local_this).set_t((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_t(const CollisionEntry self, float t)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionEntry_respect_prev_transform_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool CollisionEntry::get_respect_prev_transform(void) const
  bool return_value = (*(const CollisionEntry*)local_this).get_respect_prev_transform();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_CollisionEntry(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CollisionEntry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionEntry) {
    printf("CollisionEntry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionEntry *local_this = (CollisionEntry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionEntry) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionEntry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionEntry) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionEntry*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionPlane
 */
/**
 * Python function wrapper for:
 * inline LVector3 CollisionPlane::get_normal(void) const
 */
static PyObject *Dtool_CollisionPlane_get_normal_166(PyObject *self, PyObject *) {
  CollisionPlane *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPlane, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 CollisionPlane::get_normal(void) const
  LVector3 *return_value = new LVector3((*(const CollisionPlane*)local_this).get_normal());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_get_normal_166_comment =
  "C++ Interface:\n"
  "get_normal(CollisionPlane self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionPlane_get_normal_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionPlane::dist_to_plane(LPoint3 const &point) const
 */
static PyObject *Dtool_CollisionPlane_dist_to_plane_167(PyObject *self, PyObject *arg) {
  CollisionPlane *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPlane, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionPlane::dist_to_plane(LPoint3 const &point) const
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionPlane.dist_to_plane", "LPoint3f");
  }
  PN_stdfloat return_value = (*(const CollisionPlane*)local_this).dist_to_plane(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dist_to_plane(CollisionPlane self, const LPoint3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_dist_to_plane_167_comment =
  "C++ Interface:\n"
  "dist_to_plane(CollisionPlane self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionPlane_dist_to_plane_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionPlane::set_plane(LPlane const &plane)
 */
static PyObject *Dtool_CollisionPlane_set_plane_168(PyObject *self, PyObject *arg) {
  CollisionPlane *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionPlane, (void **)&local_this, "CollisionPlane.set_plane")) {
    return NULL;
  }
  // 1-inline void CollisionPlane::set_plane(LPlane const &plane)
  LPlanef arg_local;
  LPlane const *arg_this = Dtool_Coerce_LPlanef(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionPlane.set_plane", "LPlanef");
  }
  (*local_this).set_plane(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_plane(const CollisionPlane self, const LPlanef plane)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_set_plane_168_comment =
  "C++ Interface:\n"
  "set_plane(const CollisionPlane self, const LPlanef plane)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionPlane_set_plane_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPlane const &CollisionPlane::get_plane(void) const
 */
static PyObject *Dtool_CollisionPlane_get_plane_169(PyObject *self, PyObject *) {
  CollisionPlane *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPlane, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPlane const &CollisionPlane::get_plane(void) const
  LPlane const *return_value = &((*(const CollisionPlane*)local_this).get_plane());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_get_plane_169_comment =
  "C++ Interface:\n"
  "get_plane(CollisionPlane self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionPlane_get_plane_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionPlane::flip(void)
 */
static PyObject *Dtool_CollisionPlane_flip_170(PyObject *self, PyObject *) {
  CollisionPlane *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionPlane, (void **)&local_this, "CollisionPlane.flip")) {
    return NULL;
  }
  // 1-inline void CollisionPlane::flip(void)
  (*local_this).flip();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_flip_170_comment =
  "C++ Interface:\n"
  "flip(const CollisionPlane self)\n"
  "\n"
  "/**\n"
  " * Convenience method to flip the plane in-place.\n"
  " */";
#else
static const char *Dtool_CollisionPlane_flip_170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionPlane::get_class_type(void)
 */
static PyObject *Dtool_CollisionPlane_get_class_type_176(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionPlane::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionPlane::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_get_class_type_176_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionPlane_get_class_type_176_comment = NULL;
#endif

static PyObject *Dtool_CollisionPlane_normal_Getter(PyObject *self, void *) {
  const CollisionPlane *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPlane, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector3 CollisionPlane::get_normal(void) const
  LVector3 *return_value = new LVector3((*(const CollisionPlane*)local_this).get_normal());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

static PyObject *Dtool_CollisionPlane_plane_Getter(PyObject *self, void *) {
  const CollisionPlane *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPlane, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPlane const &CollisionPlane::get_plane(void) const
  LPlane const *return_value = &((*(const CollisionPlane*)local_this).get_plane());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, false, true);
}

static int Dtool_CollisionPlane_plane_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionPlane *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionPlane, (void **)&local_this, "CollisionPlane.plane")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete plane attribute");
    return -1;
  }
  // 1-inline void CollisionPlane::set_plane(LPlane const &plane)
  LPlanef arg_local;
  LPlane const *arg_this = Dtool_Coerce_LPlanef(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionPlane.set_plane", "LPlanef");
    return -1;
  }
  (*local_this).set_plane(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_plane(const CollisionPlane self, const LPlanef plane)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionPlane::CollisionPlane(CollisionPlane const &copy)
 * inline CollisionPlane::CollisionPlane(LPlane const &plane)
 */
static int Dtool_Init_CollisionPlane(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionPlane() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline CollisionPlane::CollisionPlane(CollisionPlane const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CollisionPlane", (char **)keyword_list, &param0)) {
      CollisionPlane const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_CollisionPlane, (void **)&param0_this);
      if (param0_this != NULL) {
        CollisionPlane *return_value = new CollisionPlane(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPlane, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline CollisionPlane::CollisionPlane(LPlane const &plane)
    PyObject *param0;
    static const char *keyword_list[] = {"plane", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CollisionPlane", (char **)keyword_list, &param0)) {
      LPlane const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPlanef, (void **)&param0_this);
      if (param0_this != NULL) {
        CollisionPlane *return_value = new CollisionPlane(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPlane, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline CollisionPlane::CollisionPlane(CollisionPlane const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CollisionPlane", (char **)keyword_list, &param0)) {
      CPT(CollisionPlane) param0_this;
      if (Dtool_ConstCoerce_CollisionPlane(param0, param0_this)) {
        CollisionPlane *return_value = new CollisionPlane(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPlane, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline CollisionPlane::CollisionPlane(LPlane const &plane)
    PyObject *param0;
    static const char *keyword_list[] = {"plane", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CollisionPlane", (char **)keyword_list, &param0)) {
      LPlanef param0_local;
      LPlane const *param0_this = Dtool_Coerce_LPlanef(param0, param0_local);
      if ((param0_this != NULL)) {
        CollisionPlane *return_value = new CollisionPlane(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPlane, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionPlane(const CollisionPlane copy)\n"
      "CollisionPlane(const LPlanef plane)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionPlane(PyObject *args, CPT(CollisionPlane) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionPlane, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline CollisionPlane::CollisionPlane(LPlane const &plane)
    LPlane const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPlanef, (void **)&arg_this);
    if (arg_this != NULL) {
      CollisionPlane *return_value = new CollisionPlane(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_CollisionPlane(PyObject *args, PT(CollisionPlane) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionPlane, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline CollisionPlane::CollisionPlane(LPlane const &plane)
    LPlane const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPlanef, (void **)&arg_this);
    if (arg_this != NULL) {
      CollisionPlane *return_value = new CollisionPlane(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_CollisionPlane(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionPlane) {
    printf("CollisionPlane ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionPlane *local_this = (CollisionPlane *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionPlane) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionPlane(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionPlane) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionPlane*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionFloorMesh
 */
/**
 * Python function wrapper for:
 * inline void CollisionFloorMesh::add_vertex(LPoint3 const &vert)
 */
static PyObject *Dtool_CollisionFloorMesh_add_vertex_180(PyObject *self, PyObject *arg) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionFloorMesh, (void **)&local_this, "CollisionFloorMesh.add_vertex")) {
    return NULL;
  }
  // 1-inline void CollisionFloorMesh::add_vertex(LPoint3 const &vert)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionFloorMesh.add_vertex", "LPoint3f");
  }
  (*local_this).add_vertex(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const CollisionFloorMesh self, const LPoint3f vert)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_add_vertex_180_comment =
  "C++ Interface:\n"
  "add_vertex(const CollisionFloorMesh self, const LPoint3f vert)\n"
  "\n"
  "/**\n"
  " * store away a vertex to index against\n"
  " */";
#else
static const char *Dtool_CollisionFloorMesh_add_vertex_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionFloorMesh::add_triangle(unsigned int pointA, unsigned int pointB, unsigned int pointC)
 */
static PyObject *Dtool_CollisionFloorMesh_add_triangle_181(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionFloorMesh, (void **)&local_this, "CollisionFloorMesh.add_triangle")) {
    return NULL;
  }
  // 1-void CollisionFloorMesh::add_triangle(unsigned int pointA, unsigned int pointB, unsigned int pointC)
  unsigned long param1;
  unsigned long param2;
  unsigned long param3;
  static const char *keyword_list[] = {"pointA", "pointB", "pointC", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kkk:add_triangle", (char **)keyword_list, &param1, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param3 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param3);
    }
#endif
    (*local_this).add_triangle((unsigned int)param1, (unsigned int)param2, (unsigned int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_triangle(const CollisionFloorMesh self, int pointA, int pointB, int pointC)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_add_triangle_181_comment =
  "C++ Interface:\n"
  "add_triangle(const CollisionFloorMesh self, int pointA, int pointB, int pointC)\n"
  "\n"
  "/**\n"
  " * store a triangle for processing\n"
  " */";
#else
static const char *Dtool_CollisionFloorMesh_add_triangle_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int CollisionFloorMesh::get_num_vertices(void) const
 */
static PyObject *Dtool_CollisionFloorMesh_get_num_vertices_182(PyObject *self, PyObject *) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline unsigned int CollisionFloorMesh::get_num_vertices(void) const
  unsigned int return_value = (*(const CollisionFloorMesh*)local_this).get_num_vertices();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_get_num_vertices_182_comment =
  "C++ Interface:\n"
  "get_num_vertices(CollisionFloorMesh self)\n";
#else
static const char *Dtool_CollisionFloorMesh_get_num_vertices_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionFloorMesh::get_vertex(unsigned int index) const
 */
static PyObject *Dtool_CollisionFloorMesh_get_vertex_183(PyObject *self, PyObject *arg) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &CollisionFloorMesh::get_vertex(unsigned int index) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    LPoint3 const *return_value = &((*(const CollisionFloorMesh*)local_this).get_vertex((unsigned int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(CollisionFloorMesh self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_get_vertex_183_comment =
  "C++ Interface:\n"
  "get_vertex(CollisionFloorMesh self, int index)\n";
#else
static const char *Dtool_CollisionFloorMesh_get_vertex_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int CollisionFloorMesh::get_num_triangles(void) const
 */
static PyObject *Dtool_CollisionFloorMesh_get_num_triangles_185(PyObject *self, PyObject *) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline unsigned int CollisionFloorMesh::get_num_triangles(void) const
  unsigned int return_value = (*(const CollisionFloorMesh*)local_this).get_num_triangles();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_get_num_triangles_185_comment =
  "C++ Interface:\n"
  "get_num_triangles(CollisionFloorMesh self)\n";
#else
static const char *Dtool_CollisionFloorMesh_get_num_triangles_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3i CollisionFloorMesh::get_triangle(unsigned int index) const
 */
static PyObject *Dtool_CollisionFloorMesh_get_triangle_186(PyObject *self, PyObject *arg) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3i CollisionFloorMesh::get_triangle(unsigned int index) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    LPoint3i *return_value = new LPoint3i((*(const CollisionFloorMesh*)local_this).get_triangle((unsigned int)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle(CollisionFloorMesh self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_get_triangle_186_comment =
  "C++ Interface:\n"
  "get_triangle(CollisionFloorMesh self, int index)\n";
#else
static const char *Dtool_CollisionFloorMesh_get_triangle_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionFloorMesh::get_class_type(void)
 */
static PyObject *Dtool_CollisionFloorMesh_get_class_type_191(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionFloorMesh::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionFloorMesh::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_get_class_type_191_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionFloorMesh_get_class_type_191_comment = NULL;
#endif

/**
 * sequence length function for property CollisionFloorMesh::vertices
 */
static Py_ssize_t Dtool_CollisionFloorMesh_vertices_Len(PyObject *self) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_vertices();
}

/**
 * sequence getter for property CollisionFloorMesh::vertices
 */
static PyObject *Dtool_CollisionFloorMesh_vertices_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_vertices()) {
    PyErr_SetString(PyExc_IndexError, "CollisionFloorMesh.vertices[] index out of range");
    return NULL;
  }
  // 1-inline LPoint3 const &CollisionFloorMesh::get_vertex(unsigned int index) const
  LPoint3 const *return_value = &((*(const CollisionFloorMesh*)local_this).get_vertex(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(CollisionFloorMesh self, index)\n");
  }
}

static PyObject *Dtool_CollisionFloorMesh_vertices_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_CollisionFloorMesh_vertices_Len;
  wrap->_getitem_func = &Dtool_CollisionFloorMesh_vertices_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property CollisionFloorMesh::triangles
 */
static Py_ssize_t Dtool_CollisionFloorMesh_triangles_Len(PyObject *self) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_triangles();
}

/**
 * sequence getter for property CollisionFloorMesh::triangles
 */
static PyObject *Dtool_CollisionFloorMesh_triangles_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_triangles()) {
    PyErr_SetString(PyExc_IndexError, "CollisionFloorMesh.triangles[] index out of range");
    return NULL;
  }
  // 1-inline LPoint3i CollisionFloorMesh::get_triangle(unsigned int index) const
  LPoint3i *return_value = new LPoint3i((*(const CollisionFloorMesh*)local_this).get_triangle(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle(CollisionFloorMesh self, index)\n");
  }
}

static PyObject *Dtool_CollisionFloorMesh_triangles_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_CollisionFloorMesh_triangles_Len;
  wrap->_getitem_func = &Dtool_CollisionFloorMesh_triangles_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline CollisionFloorMesh::CollisionFloorMesh(void)
 */
static int Dtool_Init_CollisionFloorMesh(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionFloorMesh() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline CollisionFloorMesh::CollisionFloorMesh(void)
  CollisionFloorMesh *return_value = new CollisionFloorMesh();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionFloorMesh, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionFloorMesh()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionFloorMesh_get_vertices(PyObject *self, PyObject *) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_vertices();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionFloorMesh_get_vertex_183(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionFloorMesh_get_triangles(PyObject *self, PyObject *) {
  CollisionFloorMesh *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_triangles();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionFloorMesh_get_triangle_186(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionFloorMesh(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionFloorMesh) {
    printf("CollisionFloorMesh ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionFloorMesh *local_this = (CollisionFloorMesh *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionFloorMesh) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionFloorMesh(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionFloorMesh) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionPolygon
 */
/**
 * Python function wrapper for:
 * inline int CollisionPolygon::get_num_points(void) const
 */
static PyObject *Dtool_CollisionPolygon_get_num_points_195(PyObject *self, PyObject *) {
  CollisionPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CollisionPolygon::get_num_points(void) const
  int return_value = (*(const CollisionPolygon*)local_this).get_num_points();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_get_num_points_195_comment =
  "C++ Interface:\n"
  "get_num_points(CollisionPolygon self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices of the CollisionPolygon.\n"
  " */";
#else
static const char *Dtool_CollisionPolygon_get_num_points_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 CollisionPolygon::get_point(int n) const
 */
static PyObject *Dtool_CollisionPolygon_get_point_196(PyObject *self, PyObject *arg) {
  CollisionPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 CollisionPolygon::get_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3((*(const CollisionPolygon*)local_this).get_point((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(CollisionPolygon self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_get_point_196_comment =
  "C++ Interface:\n"
  "get_point(CollisionPolygon self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.\n"
  " */";
#else
static const char *Dtool_CollisionPolygon_get_point_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static bool CollisionPolygon::verify_points(LPoint3 const *begin, LPoint3 const *end)
 * static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c)
 * static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d)
 */
static PyObject *Dtool_CollisionPolygon_verify_points_198(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-static bool CollisionPolygon::verify_points(LPoint3 const *begin, LPoint3 const *end)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"begin", "end", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:verify_points", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.verify_points", "LPoint3f");
        }
        bool return_value = CollisionPolygon::verify_points(param0_this, param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:verify_points", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "CollisionPolygon.verify_points", "LPoint3f");
        }
        bool return_value = CollisionPolygon::verify_points(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"a", "b", "c", "d", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:verify_points", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param3_local;
        LPoint3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "CollisionPolygon.verify_points", "LPoint3f");
        }
        bool return_value = CollisionPolygon::verify_points(*param0_this, *param1_this, *param2_this, *param3_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "verify_points() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "verify_points(const LPoint3f begin, const LPoint3f end)\n"
      "verify_points(const LPoint3f a, const LPoint3f b, const LPoint3f c)\n"
      "verify_points(const LPoint3f a, const LPoint3f b, const LPoint3f c, const LPoint3f d)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_verify_points_198_comment =
  "C++ Interface:\n"
  "verify_points(const LPoint3f begin, const LPoint3f end)\n"
  "verify_points(const LPoint3f a, const LPoint3f b, const LPoint3f c)\n"
  "verify_points(const LPoint3f a, const LPoint3f b, const LPoint3f c, const LPoint3f d)\n"
  "\n"
  "/**\n"
  " * Verifies that the indicated set of points will define a valid\n"
  " * CollisionPolygon: that is, at least three non-collinear points, with no\n"
  " * points repeated.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Verifies that the indicated set of points will define a valid\n"
  " * CollisionPolygon: that is, at least three non-collinear points, with no\n"
  " * points repeated.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Verifies that the indicated set of points will define a valid\n"
  " * CollisionPolygon: that is, at least three non-collinear points, with no\n"
  " * points repeated.\n"
  " *\n"
  " * This does not check that the polygon defined is convex; that check is made\n"
  " * later, once we have projected the points to 2-d space where the decision is\n"
  " * easier.\n"
  " */";
#else
static const char *Dtool_CollisionPolygon_verify_points_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CollisionPolygon::is_valid(void) const
 */
static PyObject *Dtool_CollisionPolygon_is_valid_199(PyObject *self, PyObject *) {
  CollisionPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool CollisionPolygon::is_valid(void) const
  bool return_value = (*(const CollisionPolygon*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_is_valid_199_comment =
  "C++ Interface:\n"
  "is_valid(CollisionPolygon self)\n"
  "\n"
  "/**\n"
  " * Returns true if the CollisionPolygon is valid (that is, it has at least\n"
  " * three vertices), or false otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionPolygon_is_valid_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CollisionPolygon::is_concave(void) const
 */
static PyObject *Dtool_CollisionPolygon_is_concave_200(PyObject *self, PyObject *) {
  CollisionPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool CollisionPolygon::is_concave(void) const
  bool return_value = (*(const CollisionPolygon*)local_this).is_concave();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_is_concave_200_comment =
  "C++ Interface:\n"
  "is_concave(CollisionPolygon self)\n"
  "\n"
  "/**\n"
  " * Returns true if the CollisionPolygon appears to be concave, or false if it\n"
  " * is safely convex.\n"
  " */";
#else
static const char *Dtool_CollisionPolygon_is_concave_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionPolygon::get_class_type(void)
 */
static PyObject *Dtool_CollisionPolygon_get_class_type_204(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionPolygon::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionPolygon::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_get_class_type_204_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionPolygon_get_class_type_204_comment = NULL;
#endif

/**
 * sequence length function for property CollisionPolygon::points
 */
static Py_ssize_t Dtool_CollisionPolygon_points_Len(PyObject *self) {
  CollisionPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_points();
}

/**
 * sequence getter for property CollisionPolygon::points
 */
static PyObject *Dtool_CollisionPolygon_points_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_points()) {
    PyErr_SetString(PyExc_IndexError, "CollisionPolygon.points[] index out of range");
    return NULL;
  }
  // 1-inline LPoint3 CollisionPolygon::get_point(int n) const
  LPoint3 *return_value = new LPoint3((*(const CollisionPolygon*)local_this).get_point(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(CollisionPolygon self, index)\n");
  }
}

static PyObject *Dtool_CollisionPolygon_points_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_CollisionPolygon_points_Len;
  wrap->_getitem_func = &Dtool_CollisionPolygon_points_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static PyObject *Dtool_CollisionPolygon_valid_Getter(PyObject *self, void *) {
  const CollisionPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return NULL;
  }

  // 1-bool CollisionPolygon::is_valid(void) const
  bool return_value = (*(const CollisionPolygon*)local_this).is_valid();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CollisionPolygon_concave_Getter(PyObject *self, void *) {
  const CollisionPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return NULL;
  }

  // 1-bool CollisionPolygon::is_concave(void) const
  bool return_value = (*(const CollisionPolygon*)local_this).is_concave();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline CollisionPolygon::CollisionPolygon(LPoint3 const *begin, LPoint3 const *end)
 * inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c)
 * inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d)
 */
static int Dtool_Init_CollisionPolygon(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline CollisionPolygon::CollisionPolygon(LPoint3 const *begin, LPoint3 const *end)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"begin", "end", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:CollisionPolygon", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.CollisionPolygon", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.CollisionPolygon", "LPoint3f");
          return -1;
        }
        CollisionPolygon *return_value = new CollisionPolygon(param0_this, param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPolygon, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:CollisionPolygon", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3f param0_local;
        LVecBase3 const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          Dtool_Raise_ArgTypeError(param2, 2, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPolygon, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"a", "b", "c", "d", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:CollisionPolygon", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LVecBase3f param0_local;
        LVecBase3 const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          Dtool_Raise_ArgTypeError(param2, 2, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != NULL)) {
          Dtool_Raise_ArgTypeError(param3, 3, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this, *param3_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPolygon, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionPolygon() takes 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionPolygon(const LPoint3f begin, const LPoint3f end)\n"
      "CollisionPolygon(const LVecBase3f a, const LVecBase3f b, const LVecBase3f c)\n"
      "CollisionPolygon(const LVecBase3f a, const LVecBase3f b, const LVecBase3f c, const LVecBase3f d)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionPolygon(PyObject *args, CPT(CollisionPolygon) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionPolygon, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionPolygon::CollisionPolygon(LPoint3 const *begin, LPoint3 const *end)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LPoint3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionPolygon *return_value = new CollisionPolygon(param0_this, param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 3, 3, &param0, &param1, &param2)) {
          LVecBase3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
          LVecBase3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          LVecBase3 const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 4, 4, &param0, &param1, &param2, &param3)) {
          LVecBase3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
          LVecBase3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          LVecBase3 const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          LVecBase3 const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3f, (void **)&param3_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this, *param3_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CollisionPolygon(PyObject *args, PT(CollisionPolygon) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionPolygon, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionPolygon::CollisionPolygon(LPoint3 const *begin, LPoint3 const *end)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LPoint3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionPolygon *return_value = new CollisionPolygon(param0_this, param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 3, 3, &param0, &param1, &param2)) {
          LVecBase3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
          LVecBase3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          LVecBase3 const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 4, 4, &param0, &param1, &param2, &param3)) {
          LVecBase3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
          LVecBase3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          LVecBase3 const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          LVecBase3 const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3f, (void **)&param3_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this, *param3_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionPolygon_get_points(PyObject *self, PyObject *) {
  CollisionPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_points();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionPolygon_get_point_196(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionPolygon(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionPolygon) {
    printf("CollisionPolygon ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionPolygon *local_this = (CollisionPolygon *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionPolygon) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionPlane) {
    return (CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionPolygon(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionPolygon) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionPlane) {
    CollisionPlane* other_this = (CollisionPlane*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionPolygon*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionHandlerEvent
 */
/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::clear_in_patterns(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_clear_in_patterns_208(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.clear_in_patterns")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerEvent::clear_in_patterns(void)
  (*local_this).clear_in_patterns();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_clear_in_patterns_208_comment =
  "C++ Interface:\n"
  "clear_in_patterns(const CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Removes all of the previously-added in patterns.  See add_in_pattern.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_clear_in_patterns_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::add_in_pattern(std::string const &in_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_add_in_pattern_209(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.add_in_pattern")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerEvent::add_in_pattern(std::string const &in_pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).add_in_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_in_pattern(const CollisionHandlerEvent self, str in_pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_add_in_pattern_209_comment =
  "C++ Interface:\n"
  "add_in_pattern(const CollisionHandlerEvent self, str in_pattern)\n"
  "\n"
  "/**\n"
  " * Adds a pattern string to the list of events that will be generated in\n"
  " * response to a collision.  The pattern string describes how the event name\n"
  " * will be composed.  It is a string that may contain any of the following:\n"
  " *\n"
  " * %fn  - the name of the \"from\" object's node %in  - the name of the \"into\"\n"
  " * object's node %fs  - 't' if \"from\" is tangible, 'i' if intangible %is  -\n"
  " * 't' if \"into\" is tangible, 'i' if intangible %ig  - 'c' if the collision is\n"
  " * into a CollisionNode, 'g' if it is a geom.\n"
  " *\n"
  " * %(tag)fh - generate event only if \"from\" node has the indicated net tag.\n"
  " * %(tag)fx - generate event only if \"from\" node does not have the indicated\n"
  " * net tag.  %(tag)ih - generate event only if \"into\" node has the indicated\n"
  " * net tag.  %(tag)ix - generate event only if \"into\" node does not have the\n"
  " * indicated net tag.  %(tag)ft - the indicated net tag value of the \"from\"\n"
  " * node.  %(tag)it - the indicated net tag value of the \"into\" node.\n"
  " *\n"
  " * Parentheses in the above are literal and should be included in the actual\n"
  " * pattern.\n"
  " *\n"
  " * The event name will be based on the in_pattern string specified here, with\n"
  " * all occurrences of the above strings replaced with the corresponding\n"
  " * values.\n"
  " *\n"
  " * In general, the in_pattern event is thrown on the first detection of a\n"
  " * collision between two particular nodes.  In subsequent passes, as long as a\n"
  " * collision between those two nodes continues to be detected each frame, the\n"
  " * again_pattern is thrown.  The first frame in which the collision is no\n"
  " * longer detected, the out_pattern event is thrown.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_add_in_pattern_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::set_in_pattern(std::string const &in_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_set_in_pattern_210(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.set_in_pattern")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerEvent::set_in_pattern(std::string const &in_pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_in_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_in_pattern(const CollisionHandlerEvent self, str in_pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_set_in_pattern_210_comment =
  "C++ Interface:\n"
  "set_in_pattern(const CollisionHandlerEvent self, str in_pattern)\n"
  "\n"
  "/**\n"
  " * This method is deprecated; it completely replaces all the in patterns that\n"
  " * have previously been set with the indicated pattern.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_set_in_pattern_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionHandlerEvent::get_num_in_patterns(void) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_num_in_patterns_211(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CollisionHandlerEvent::get_num_in_patterns(void) const
  int return_value = (*(const CollisionHandlerEvent*)local_this).get_num_in_patterns();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_num_in_patterns_211_comment =
  "C++ Interface:\n"
  "get_num_in_patterns(CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Returns the number of in pattern strings that have been added.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_num_in_patterns_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string CollisionHandlerEvent::get_in_pattern(int n) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_in_pattern_212(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string CollisionHandlerEvent::get_in_pattern(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const CollisionHandlerEvent*)local_this).get_in_pattern((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_in_pattern(CollisionHandlerEvent self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_in_pattern_212_comment =
  "C++ Interface:\n"
  "get_in_pattern(CollisionHandlerEvent self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth pattern string that indicates how the event names are\n"
  " * generated for each collision detected.  See add_in_pattern().\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_in_pattern_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::clear_again_patterns(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_clear_again_patterns_214(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.clear_again_patterns")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerEvent::clear_again_patterns(void)
  (*local_this).clear_again_patterns();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_clear_again_patterns_214_comment =
  "C++ Interface:\n"
  "clear_again_patterns(const CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Removes all of the previously-added in patterns.  See add_again_pattern.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_clear_again_patterns_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::add_again_pattern(std::string const &again_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_add_again_pattern_215(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.add_again_pattern")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerEvent::add_again_pattern(std::string const &again_pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).add_again_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_again_pattern(const CollisionHandlerEvent self, str again_pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_add_again_pattern_215_comment =
  "C++ Interface:\n"
  "add_again_pattern(const CollisionHandlerEvent self, str again_pattern)\n"
  "\n"
  "/**\n"
  " * Adds the pattern string that indicates how the event names are generated\n"
  " * when a collision between two particular nodes is *still* detected.  This\n"
  " * event is thrown each consecutive time a collision between two particular\n"
  " * nodes is detected, starting with the second time.\n"
  " *\n"
  " * In general, the in_pattern event is thrown on the first detection of a\n"
  " * collision between two particular nodes.  In subsequent passes, as long as a\n"
  " * collision between those two nodes continues to be detected each frame, the\n"
  " * again_pattern is thrown.  The first frame in which the collision is no\n"
  " * longer detected, the out_pattern event is thrown.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_add_again_pattern_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::set_again_pattern(std::string const &again_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_set_again_pattern_216(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.set_again_pattern")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerEvent::set_again_pattern(std::string const &again_pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_again_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_again_pattern(const CollisionHandlerEvent self, str again_pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_set_again_pattern_216_comment =
  "C++ Interface:\n"
  "set_again_pattern(const CollisionHandlerEvent self, str again_pattern)\n"
  "\n"
  "/**\n"
  " * This method is deprecated; it completely replaces all the in patterns that\n"
  " * have previously been set with the indicated pattern.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_set_again_pattern_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionHandlerEvent::get_num_again_patterns(void) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_num_again_patterns_217(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CollisionHandlerEvent::get_num_again_patterns(void) const
  int return_value = (*(const CollisionHandlerEvent*)local_this).get_num_again_patterns();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_num_again_patterns_217_comment =
  "C++ Interface:\n"
  "get_num_again_patterns(CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Returns the number of in pattern strings that have been added.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_num_again_patterns_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string CollisionHandlerEvent::get_again_pattern(int n) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_again_pattern_218(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string CollisionHandlerEvent::get_again_pattern(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const CollisionHandlerEvent*)local_this).get_again_pattern((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_again_pattern(CollisionHandlerEvent self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_again_pattern_218_comment =
  "C++ Interface:\n"
  "get_again_pattern(CollisionHandlerEvent self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth pattern string that indicates how the event names are\n"
  " * generated for each collision detected.  See add_again_pattern().\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_again_pattern_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::clear_out_patterns(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_clear_out_patterns_220(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.clear_out_patterns")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerEvent::clear_out_patterns(void)
  (*local_this).clear_out_patterns();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_clear_out_patterns_220_comment =
  "C++ Interface:\n"
  "clear_out_patterns(const CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Removes all of the previously-added in patterns.  See add_out_pattern.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_clear_out_patterns_220_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::add_out_pattern(std::string const &out_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_add_out_pattern_221(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.add_out_pattern")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerEvent::add_out_pattern(std::string const &out_pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).add_out_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_out_pattern(const CollisionHandlerEvent self, str out_pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_add_out_pattern_221_comment =
  "C++ Interface:\n"
  "add_out_pattern(const CollisionHandlerEvent self, str out_pattern)\n"
  "\n"
  "/**\n"
  " * Adds the pattern string that indicates how the event names are generated\n"
  " * when a collision between two particular nodes is *no longer* detected.\n"
  " *\n"
  " * In general, the in_pattern event is thrown on the first detection of a\n"
  " * collision between two particular nodes.  In subsequent passes, as long as a\n"
  " * collision between those two nodes continues to be detected each frame, the\n"
  " * again_pattern is thrown.  The first frame in which the collision is no\n"
  " * longer detected, the out_pattern event is thrown.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_add_out_pattern_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::set_out_pattern(std::string const &out_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_set_out_pattern_222(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.set_out_pattern")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerEvent::set_out_pattern(std::string const &out_pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_out_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_out_pattern(const CollisionHandlerEvent self, str out_pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_set_out_pattern_222_comment =
  "C++ Interface:\n"
  "set_out_pattern(const CollisionHandlerEvent self, str out_pattern)\n"
  "\n"
  "/**\n"
  " * This method is deprecated; it completely replaces all the in patterns that\n"
  " * have previously been set with the indicated pattern.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_set_out_pattern_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionHandlerEvent::get_num_out_patterns(void) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_num_out_patterns_223(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CollisionHandlerEvent::get_num_out_patterns(void) const
  int return_value = (*(const CollisionHandlerEvent*)local_this).get_num_out_patterns();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_num_out_patterns_223_comment =
  "C++ Interface:\n"
  "get_num_out_patterns(CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Returns the number of in pattern strings that have been added.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_num_out_patterns_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string CollisionHandlerEvent::get_out_pattern(int n) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_out_pattern_224(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string CollisionHandlerEvent::get_out_pattern(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const CollisionHandlerEvent*)local_this).get_out_pattern((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_out_pattern(CollisionHandlerEvent self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_out_pattern_224_comment =
  "C++ Interface:\n"
  "get_out_pattern(CollisionHandlerEvent self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth pattern string that indicates how the event names are\n"
  " * generated for each collision detected.  See add_out_pattern().\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_out_pattern_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerEvent::clear(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_clear_231(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.clear")) {
    return NULL;
  }
  // 1-void CollisionHandlerEvent::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_clear_231_comment =
  "C++ Interface:\n"
  "clear(const CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Empties the list of elements that all colliders are known to be colliding\n"
  " * with.  No \"out\" events will be thrown; if the same collision is detected\n"
  " * next frame, a new \"in\" event will be thrown for each collision.\n"
  " *\n"
  " * This can be called each frame to defeat the persistent \"in\" event\n"
  " * mechanism, which prevents the same \"in\" event from being thrown repeatedly.\n"
  " * However, also see add_again_pattern(), which can be used to set the event\n"
  " * that is thrown when a collision is detected for two or more consecutive\n"
  " * frames.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_clear_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerEvent::flush(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_flush_232(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.flush")) {
    return NULL;
  }
  // 1-void CollisionHandlerEvent::flush(void)
  (*local_this).flush();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_flush_232_comment =
  "C++ Interface:\n"
  "flush(const CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Same as clear() except \"out\" events are thrown.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_flush_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerEvent::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_get_class_type_233(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerEvent::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionHandlerEvent::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_class_type_233_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerEvent_get_class_type_233_comment = NULL;
#endif

/**
 * sequence length function for property CollisionHandlerEvent::in_patterns
 */
static Py_ssize_t Dtool_CollisionHandlerEvent_in_patterns_Len(PyObject *self) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_in_patterns();
}

/**
 * sequence getter for property CollisionHandlerEvent::in_patterns
 */
static PyObject *Dtool_CollisionHandlerEvent_in_patterns_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_in_patterns()) {
    PyErr_SetString(PyExc_IndexError, "CollisionHandlerEvent.in_patterns[] index out of range");
    return NULL;
  }
  // 1-inline std::string CollisionHandlerEvent::get_in_pattern(int n) const
  std::string return_value = (*(const CollisionHandlerEvent*)local_this).get_in_pattern(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_in_pattern(CollisionHandlerEvent self, index)\n");
  }
}

static PyObject *Dtool_CollisionHandlerEvent_in_patterns_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_CollisionHandlerEvent_in_patterns_Len;
  wrap->_getitem_func = &Dtool_CollisionHandlerEvent_in_patterns_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property CollisionHandlerEvent::again_patterns
 */
static Py_ssize_t Dtool_CollisionHandlerEvent_again_patterns_Len(PyObject *self) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_again_patterns();
}

/**
 * sequence getter for property CollisionHandlerEvent::again_patterns
 */
static PyObject *Dtool_CollisionHandlerEvent_again_patterns_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_again_patterns()) {
    PyErr_SetString(PyExc_IndexError, "CollisionHandlerEvent.again_patterns[] index out of range");
    return NULL;
  }
  // 1-inline std::string CollisionHandlerEvent::get_out_pattern(int n) const
  std::string return_value = (*(const CollisionHandlerEvent*)local_this).get_out_pattern(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_out_pattern(CollisionHandlerEvent self, index)\n");
  }
}

static PyObject *Dtool_CollisionHandlerEvent_again_patterns_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_CollisionHandlerEvent_again_patterns_Len;
  wrap->_getitem_func = &Dtool_CollisionHandlerEvent_again_patterns_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property CollisionHandlerEvent::out_patterns
 */
static Py_ssize_t Dtool_CollisionHandlerEvent_out_patterns_Len(PyObject *self) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_out_patterns();
}

/**
 * sequence getter for property CollisionHandlerEvent::out_patterns
 */
static PyObject *Dtool_CollisionHandlerEvent_out_patterns_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_out_patterns()) {
    PyErr_SetString(PyExc_IndexError, "CollisionHandlerEvent.out_patterns[] index out of range");
    return NULL;
  }
  // 1-inline std::string CollisionHandlerEvent::get_out_pattern(int n) const
  std::string return_value = (*(const CollisionHandlerEvent*)local_this).get_out_pattern(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_out_pattern(CollisionHandlerEvent self, index)\n");
  }
}

static PyObject *Dtool_CollisionHandlerEvent_out_patterns_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_CollisionHandlerEvent_out_patterns_Len;
  wrap->_getitem_func = &Dtool_CollisionHandlerEvent_out_patterns_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * CollisionHandlerEvent::CollisionHandlerEvent(void)
 * inline CollisionHandlerEvent::CollisionHandlerEvent(CollisionHandlerEvent const &) = default
 */
static int Dtool_Init_CollisionHandlerEvent(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-CollisionHandlerEvent::CollisionHandlerEvent(void)
      CollisionHandlerEvent *return_value = new CollisionHandlerEvent();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerEvent, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline CollisionHandlerEvent::CollisionHandlerEvent(CollisionHandlerEvent const &) = default
      CollisionHandlerEvent const *arg_this = (CollisionHandlerEvent *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionHandlerEvent, 0, "CollisionHandlerEvent.CollisionHandlerEvent", true, true);
      if (arg_this != NULL) {
        CollisionHandlerEvent *return_value = new CollisionHandlerEvent(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerEvent, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerEvent() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerEvent()\n"
      "CollisionHandlerEvent(const CollisionHandlerEvent param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionHandlerEvent_get_in_patterns(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_in_patterns();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionHandlerEvent_get_in_pattern_212(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionHandlerEvent_get_again_patterns(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_again_patterns();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionHandlerEvent_get_again_pattern_218(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionHandlerEvent_get_out_patterns(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_out_patterns();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionHandlerEvent_get_out_pattern_224(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionHandlerEvent(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionHandlerEvent) {
    printf("CollisionHandlerEvent ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionHandlerEvent *local_this = (CollisionHandlerEvent *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionHandlerEvent(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerEvent*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionHandlerPhysical
 */
/**
 * Python function wrapper for:
 * void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target)
 * void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target, DriveInterface *drive_interface)
 */
static PyObject *Dtool_CollisionHandlerPhysical_add_collider_236(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionHandlerPhysical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.add_collider")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"collider", "target", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_collider", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.add_collider", true, true);
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CollisionHandlerPhysical.add_collider", true, true);
        if (param1_this != NULL && param2_this != NULL) {
          (*local_this).add_collider(*param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target, DriveInterface *drive_interface)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"collider", "target", "drive_interface", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:add_collider", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.add_collider", true, true);
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CollisionHandlerPhysical.add_collider", true, true);
        PT(DriveInterface) param3_this;
        if (!Dtool_Coerce_DriveInterface(param3, param3_this)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "CollisionHandlerPhysical.add_collider", "DriveInterface");
        }
        if (param1_this != NULL && param2_this != NULL) {
          (*local_this).add_collider(*param1_this, *param2_this, MOVE(param3_this));
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_collider() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_collider(const CollisionHandlerPhysical self, const NodePath collider, const NodePath target)\n"
      "add_collider(const CollisionHandlerPhysical self, const NodePath collider, const NodePath target, DriveInterface drive_interface)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_add_collider_236_comment =
  "C++ Interface:\n"
  "add_collider(const CollisionHandlerPhysical self, const NodePath collider, const NodePath target)\n"
  "add_collider(const CollisionHandlerPhysical self, const NodePath collider, const NodePath target, DriveInterface drive_interface)\n"
  "\n"
  "/**\n"
  " * Adds a new collider to the list with a NodePath that will be updated with\n"
  " * the collider's new position, or updates the existing collider with a new\n"
  " * NodePath object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new collider to the list with a NodePath that will be updated with\n"
  " * the collider's new position, or updates the existing collider with a new\n"
  " * NodePath object.\n"
  " *\n"
  " * The indicated DriveInterface will also be updated with the target's new\n"
  " * transform each frame.  This method should be used when the target is\n"
  " * directly controlled by a DriveInterface.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_add_collider_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CollisionHandlerPhysical::remove_collider(NodePath const &collider)
 */
static PyObject *Dtool_CollisionHandlerPhysical_remove_collider_237(PyObject *self, PyObject *arg) {
  CollisionHandlerPhysical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.remove_collider")) {
    return NULL;
  }
  // 1-bool CollisionHandlerPhysical::remove_collider(NodePath const &collider)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.remove_collider", true, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).remove_collider(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_collider(const CollisionHandlerPhysical self, const NodePath collider)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_remove_collider_237_comment =
  "C++ Interface:\n"
  "remove_collider(const CollisionHandlerPhysical self, const NodePath collider)\n"
  "\n"
  "/**\n"
  " * Removes the collider from the list of colliders that this handler knows\n"
  " * about.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_remove_collider_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CollisionHandlerPhysical::has_collider(NodePath const &collider) const
 */
static PyObject *Dtool_CollisionHandlerPhysical_has_collider_238(PyObject *self, PyObject *arg) {
  CollisionHandlerPhysical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerPhysical, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool CollisionHandlerPhysical::has_collider(NodePath const &collider) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.has_collider", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const CollisionHandlerPhysical*)local_this).has_collider(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_collider(CollisionHandlerPhysical self, const NodePath collider)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_has_collider_238_comment =
  "C++ Interface:\n"
  "has_collider(CollisionHandlerPhysical self, const NodePath collider)\n"
  "\n"
  "/**\n"
  " * Returns true if the handler knows about the indicated collider, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_has_collider_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerPhysical::clear_colliders(void)
 */
static PyObject *Dtool_CollisionHandlerPhysical_clear_colliders_239(PyObject *self, PyObject *) {
  CollisionHandlerPhysical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.clear_colliders")) {
    return NULL;
  }
  // 1-void CollisionHandlerPhysical::clear_colliders(void)
  (*local_this).clear_colliders();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_clear_colliders_239_comment =
  "C++ Interface:\n"
  "clear_colliders(const CollisionHandlerPhysical self)\n"
  "\n"
  "/**\n"
  " * Completely empties the list of colliders this handler knows about.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_clear_colliders_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerPhysical::set_center(NodePath const &center)
 */
static PyObject *Dtool_CollisionHandlerPhysical_set_center_240(PyObject *self, PyObject *arg) {
  CollisionHandlerPhysical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.set_center")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerPhysical::set_center(NodePath const &center)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.set_center", true, true);
  if (arg_this != NULL) {
    (*local_this).set_center(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center(const CollisionHandlerPhysical self, const NodePath center)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_set_center_240_comment =
  "C++ Interface:\n"
  "set_center(const CollisionHandlerPhysical self, const NodePath center)\n"
  "\n"
  "/**\n"
  " * Specifies an arbitrary NodePath that the handler is always considered to be\n"
  " * facing.  It does not detect collisions with surfaces that appear to be\n"
  " * facing away from this NodePath.  This works best when the collision\n"
  " * surfaces in question are polygons.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_set_center_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerPhysical::clear_center(void)
 */
static PyObject *Dtool_CollisionHandlerPhysical_clear_center_241(PyObject *self, PyObject *) {
  CollisionHandlerPhysical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.clear_center")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerPhysical::clear_center(void)
  (*local_this).clear_center();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_clear_center_241_comment =
  "C++ Interface:\n"
  "clear_center(const CollisionHandlerPhysical self)\n"
  "\n"
  "/**\n"
  " * Clears the center NodePath specified with set_center.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_clear_center_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CollisionHandlerPhysical::get_center(void) const
 */
static PyObject *Dtool_CollisionHandlerPhysical_get_center_242(PyObject *self, PyObject *) {
  CollisionHandlerPhysical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerPhysical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &CollisionHandlerPhysical::get_center(void) const
  NodePath const *return_value = &((*(const CollisionHandlerPhysical*)local_this).get_center());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_get_center_242_comment =
  "C++ Interface:\n"
  "get_center(CollisionHandlerPhysical self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath specified with set_center, or the empty NodePath if\n"
  " * nothing has been specified.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_get_center_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionHandlerPhysical::has_center(void) const
 */
static PyObject *Dtool_CollisionHandlerPhysical_has_center_243(PyObject *self, PyObject *) {
  CollisionHandlerPhysical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerPhysical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionHandlerPhysical::has_center(void) const
  bool return_value = (*(const CollisionHandlerPhysical*)local_this).has_center();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_has_center_243_comment =
  "C++ Interface:\n"
  "has_center(CollisionHandlerPhysical self)\n"
  "\n"
  "/**\n"
  " * Returns true if a NodePath has been specified with set_center(), false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_has_center_243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionHandlerPhysical::has_contact(void) const
 */
static PyObject *Dtool_CollisionHandlerPhysical_has_contact_244(PyObject *self, PyObject *) {
  CollisionHandlerPhysical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerPhysical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionHandlerPhysical::has_contact(void) const
  bool return_value = (*(const CollisionHandlerPhysical*)local_this).has_contact();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_has_contact_244_comment =
  "C++ Interface:\n"
  "has_contact(CollisionHandlerPhysical self)\n"
  "\n"
  "/**\n"
  " * Did the handler make any contacts with anything on the last collision pass?\n"
  " * Depending on how your world is setup, this can be used to tell if the\n"
  " * handler is out of the world (i.e.  out of bounds). That is the original use\n"
  " * of this call.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_has_contact_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerPhysical::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerPhysical_get_class_type_247(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerPhysical::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionHandlerPhysical::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_get_class_type_247_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerPhysical_get_class_type_247_comment = NULL;
#endif

static PyObject *Dtool_CollisionHandlerPhysical_center_Getter(PyObject *self, void *) {
  const CollisionHandlerPhysical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerPhysical, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_center()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline NodePath const &CollisionHandlerPhysical::get_center(void) const
  NodePath const *return_value = &((*(const CollisionHandlerPhysical*)local_this).get_center());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

static int Dtool_CollisionHandlerPhysical_center_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerPhysical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.center")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete center attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_center();
    return 0;
  }
  // 1-inline void CollisionHandlerPhysical::set_center(NodePath const &center)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.set_center", true, true);
  if (arg_this != NULL) {
    (*local_this).set_center(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_center(const CollisionHandlerPhysical self, const NodePath center)\n");
  }
  return -1;
}

static int Dtool_Init_CollisionHandlerPhysical(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerPhysical(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionHandlerPhysical) {
    printf("CollisionHandlerPhysical ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionHandlerPhysical *local_this = (CollisionHandlerPhysical *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionHandlerPhysical(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerPhysical*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerPhysical*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerPhysical*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerPhysical*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerPhysical*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionHandlerFloor
 */
/**
 * Python function wrapper for:
 * inline void CollisionHandlerFloor::set_offset(PN_stdfloat offset)
 */
static PyObject *Dtool_CollisionHandlerFloor_set_offset_250(PyObject *self, PyObject *arg) {
  CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.set_offset")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerFloor::set_offset(PN_stdfloat offset)
  if (PyNumber_Check(arg)) {
    (*local_this).set_offset((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset(const CollisionHandlerFloor self, float offset)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_set_offset_250_comment =
  "C++ Interface:\n"
  "set_offset(const CollisionHandlerFloor self, float offset)\n"
  "\n"
  "/**\n"
  " * Sets the linear offset to add to (or subtract from) the highest detected\n"
  " * collision point to determine the actual height at which to set the\n"
  " * collider.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_set_offset_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerFloor::get_offset(void) const
 */
static PyObject *Dtool_CollisionHandlerFloor_get_offset_251(PyObject *self, PyObject *) {
  CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerFloor, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionHandlerFloor::get_offset(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerFloor*)local_this).get_offset();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_get_offset_251_comment =
  "C++ Interface:\n"
  "get_offset(CollisionHandlerFloor self)\n"
  "\n"
  "/**\n"
  " * Returns the linear offset to add to (or subtract from) the highest detected\n"
  " * collision point to determine the actual height at which to set the\n"
  " * collider.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_get_offset_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerFloor::set_reach(PN_stdfloat reach)
 */
static PyObject *Dtool_CollisionHandlerFloor_set_reach_252(PyObject *self, PyObject *arg) {
  CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.set_reach")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerFloor::set_reach(PN_stdfloat reach)
  if (PyNumber_Check(arg)) {
    (*local_this).set_reach((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_reach(const CollisionHandlerFloor self, float reach)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_set_reach_252_comment =
  "C++ Interface:\n"
  "set_reach(const CollisionHandlerFloor self, float reach)\n"
  "\n"
  "/**\n"
  " * Sets the reach to add to (or subtract from) the highest collision point\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_set_reach_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerFloor::get_reach(void) const
 */
static PyObject *Dtool_CollisionHandlerFloor_get_reach_253(PyObject *self, PyObject *) {
  CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerFloor, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionHandlerFloor::get_reach(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerFloor*)local_this).get_reach();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_get_reach_253_comment =
  "C++ Interface:\n"
  "get_reach(CollisionHandlerFloor self)\n"
  "\n"
  "/**\n"
  " * Returns the reach to add to (or subtract from) the highest collision point\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_get_reach_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerFloor::set_max_velocity(PN_stdfloat max_vel)
 */
static PyObject *Dtool_CollisionHandlerFloor_set_max_velocity_254(PyObject *self, PyObject *arg) {
  CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.set_max_velocity")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerFloor::set_max_velocity(PN_stdfloat max_vel)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_velocity((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_velocity(const CollisionHandlerFloor self, float max_vel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_set_max_velocity_254_comment =
  "C++ Interface:\n"
  "set_max_velocity(const CollisionHandlerFloor self, float max_vel)\n"
  "\n"
  "/**\n"
  " * Sets the maximum speed at which the object will be allowed to descend\n"
  " * towards a floor below it, in units per second.  Set this to zero to allow\n"
  " * it to instantly teleport any distance.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_set_max_velocity_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerFloor::get_max_velocity(void) const
 */
static PyObject *Dtool_CollisionHandlerFloor_get_max_velocity_255(PyObject *self, PyObject *) {
  CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerFloor, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionHandlerFloor::get_max_velocity(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerFloor*)local_this).get_max_velocity();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_get_max_velocity_255_comment =
  "C++ Interface:\n"
  "get_max_velocity(CollisionHandlerFloor self)\n"
  "\n"
  "/**\n"
  " * Retrieves the maximum speed at which the object will be allowed to descend\n"
  " * towards a floor below it, in units per second.  See set_max_velocity().\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_get_max_velocity_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerFloor::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerFloor_get_class_type_259(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerFloor::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionHandlerFloor::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_get_class_type_259_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerFloor_get_class_type_259_comment = NULL;
#endif

static PyObject *Dtool_CollisionHandlerFloor_offset_Getter(PyObject *self, void *) {
  const CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerFloor, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionHandlerFloor::get_offset(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerFloor*)local_this).get_offset();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerFloor_offset_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.offset")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete offset attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerFloor::set_offset(PN_stdfloat offset)
  if (PyNumber_Check(arg)) {
    (*local_this).set_offset((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_offset(const CollisionHandlerFloor self, float offset)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerFloor_reach_Getter(PyObject *self, void *) {
  const CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerFloor, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionHandlerFloor::get_reach(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerFloor*)local_this).get_reach();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerFloor_reach_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.reach")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete reach attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerFloor::set_reach(PN_stdfloat reach)
  if (PyNumber_Check(arg)) {
    (*local_this).set_reach((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_reach(const CollisionHandlerFloor self, float reach)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerFloor_max_velocity_Getter(PyObject *self, void *) {
  const CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerFloor, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionHandlerFloor::get_max_velocity(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerFloor*)local_this).get_max_velocity();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerFloor_max_velocity_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerFloor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.max_velocity")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete max_velocity attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerFloor::set_max_velocity(PN_stdfloat max_vel)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_velocity((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_velocity(const CollisionHandlerFloor self, float max_vel)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * CollisionHandlerFloor::CollisionHandlerFloor(void)
 */
static int Dtool_Init_CollisionHandlerFloor(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerFloor() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CollisionHandlerFloor::CollisionHandlerFloor(void)
  CollisionHandlerFloor *return_value = new CollisionHandlerFloor();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerFloor, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerFloor()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerFloor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionHandlerFloor) {
    printf("CollisionHandlerFloor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionHandlerFloor *local_this = (CollisionHandlerFloor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionHandlerFloor) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return (CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionHandlerFloor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerFloor) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionHandlerPusher
 */
/**
 * Python function wrapper for:
 * inline void CollisionHandlerPusher::set_horizontal(bool flag)
 */
static PyObject *Dtool_CollisionHandlerPusher_set_horizontal_262(PyObject *self, PyObject *arg) {
  CollisionHandlerPusher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPusher, (void **)&local_this, "CollisionHandlerPusher.set_horizontal")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerPusher::set_horizontal(bool flag)
  (*local_this).set_horizontal((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_horizontal(const CollisionHandlerPusher self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPusher_set_horizontal_262_comment =
  "C++ Interface:\n"
  "set_horizontal(const CollisionHandlerPusher self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPusher_set_horizontal_262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionHandlerPusher::get_horizontal(void) const
 */
static PyObject *Dtool_CollisionHandlerPusher_get_horizontal_263(PyObject *self, PyObject *) {
  CollisionHandlerPusher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerPusher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionHandlerPusher::get_horizontal(void) const
  bool return_value = (*(const CollisionHandlerPusher*)local_this).get_horizontal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPusher_get_horizontal_263_comment =
  "C++ Interface:\n"
  "get_horizontal(CollisionHandlerPusher self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPusher_get_horizontal_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerPusher::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerPusher_get_class_type_265(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerPusher::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionHandlerPusher::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPusher_get_class_type_265_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerPusher_get_class_type_265_comment = NULL;
#endif

static PyObject *Dtool_CollisionHandlerPusher_horizontal_Getter(PyObject *self, void *) {
  const CollisionHandlerPusher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerPusher, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool CollisionHandlerPusher::get_horizontal(void) const
  bool return_value = (*(const CollisionHandlerPusher*)local_this).get_horizontal();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerPusher_horizontal_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerPusher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPusher, (void **)&local_this, "CollisionHandlerPusher.horizontal")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete horizontal attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerPusher::set_horizontal(bool flag)
  (*local_this).set_horizontal((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_horizontal(const CollisionHandlerPusher self, bool flag)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * CollisionHandlerPusher::CollisionHandlerPusher(void)
 */
static int Dtool_Init_CollisionHandlerPusher(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerPusher() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CollisionHandlerPusher::CollisionHandlerPusher(void)
  CollisionHandlerPusher *return_value = new CollisionHandlerPusher();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerPusher, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerPusher()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerPusher(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionHandlerPusher) {
    printf("CollisionHandlerPusher ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionHandlerPusher *local_this = (CollisionHandlerPusher *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionHandlerPusher) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return (CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionHandlerPusher(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPusher) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionHandlerFluidPusher
 */
/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerFluidPusher::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerFluidPusher_get_class_type_268(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerFluidPusher::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionHandlerFluidPusher::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFluidPusher_get_class_type_268_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerFluidPusher_get_class_type_268_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CollisionHandlerFluidPusher::CollisionHandlerFluidPusher(void)
 */
static int Dtool_Init_CollisionHandlerFluidPusher(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerFluidPusher() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CollisionHandlerFluidPusher::CollisionHandlerFluidPusher(void)
  CollisionHandlerFluidPusher *return_value = new CollisionHandlerFluidPusher();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerFluidPusher, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerFluidPusher()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerFluidPusher(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionHandlerFluidPusher) {
    printf("CollisionHandlerFluidPusher ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionHandlerFluidPusher *local_this = (CollisionHandlerFluidPusher *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionHandlerFluidPusher) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return (CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPusher) {
    return (CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionHandlerFluidPusher(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerFluidPusher) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPusher) {
    CollisionHandlerPusher* other_this = (CollisionHandlerPusher*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionHandlerGravity
 */
/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_offset(PN_stdfloat offset)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_offset_272(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_offset")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerGravity::set_offset(PN_stdfloat offset)
  if (PyNumber_Check(arg)) {
    (*local_this).set_offset((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset(const CollisionHandlerGravity self, float offset)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_offset_272_comment =
  "C++ Interface:\n"
  "set_offset(const CollisionHandlerGravity self, float offset)\n"
  "\n"
  "/**\n"
  " * Sets the linear offset to add to (or subtract from) the highest detected\n"
  " * collision point to determine the actual height at which to set the\n"
  " * collider.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_offset_272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_offset(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_offset_273(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_offset(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_offset();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_offset_273_comment =
  "C++ Interface:\n"
  "get_offset(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Returns the linear offset to add to (or subtract from) the highest detected\n"
  " * collision point to determine the actual height at which to set the\n"
  " * collider.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_offset_273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_reach(PN_stdfloat reach)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_reach_274(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_reach")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerGravity::set_reach(PN_stdfloat reach)
  if (PyNumber_Check(arg)) {
    (*local_this).set_reach((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_reach(const CollisionHandlerGravity self, float reach)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_reach_274_comment =
  "C++ Interface:\n"
  "set_reach(const CollisionHandlerGravity self, float reach)\n"
  "\n"
  "/**\n"
  " * Sets the reach to add to (or subtract from) the highest collision point\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_reach_274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_reach(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_reach_275(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_reach(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_reach();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_reach_275_comment =
  "C++ Interface:\n"
  "get_reach(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Returns the reach to add to (or subtract from) the highest collision point\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_reach_275_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_airborne_height(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_airborne_height_276(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_airborne_height(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_airborne_height();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_airborne_height_276_comment =
  "C++ Interface:\n"
  "get_airborne_height(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Return the height of the object from the ground.\n"
  " *\n"
  " * The object might not necessarily be at rest.  Use is_on_ground() if you\n"
  " * want to know whether the object is on the ground and at rest.\n"
  " *\n"
  " * See Also: is_in_outer_space()\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_airborne_height_276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionHandlerGravity::is_on_ground(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_is_on_ground_277(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionHandlerGravity::is_on_ground(void) const
  bool return_value = (*(const CollisionHandlerGravity*)local_this).is_on_ground();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_is_on_ground_277_comment =
  "C++ Interface:\n"
  "is_on_ground(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Is the object at rest?\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_is_on_ground_277_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_impact_velocity(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_impact_velocity_278(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_impact_velocity(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_impact_velocity();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_impact_velocity_278_comment =
  "C++ Interface:\n"
  "get_impact_velocity(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * How hard did the object hit the ground.  This value is set on impact with\n"
  " * the ground.  You may want to watch (poll) on is_on_groun() and when that is\n"
  " * true, call get_impact_velocity(). Normally I avoid polling, but we are\n"
  " * calling is_on_ground() frequently anyway.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_impact_velocity_278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &CollisionHandlerGravity::get_contact_normal(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_contact_normal_279(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 const &CollisionHandlerGravity::get_contact_normal(void) const
  LVector3 const *return_value = &((*(const CollisionHandlerGravity*)local_this).get_contact_normal());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_contact_normal_279_comment =
  "C++ Interface:\n"
  "get_contact_normal(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_contact_normal_279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::add_velocity(PN_stdfloat velocity)
 */
static PyObject *Dtool_CollisionHandlerGravity_add_velocity_280(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.add_velocity")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerGravity::add_velocity(PN_stdfloat velocity)
  if (PyNumber_Check(arg)) {
    (*local_this).add_velocity((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_velocity(const CollisionHandlerGravity self, float velocity)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_add_velocity_280_comment =
  "C++ Interface:\n"
  "add_velocity(const CollisionHandlerGravity self, float velocity)\n"
  "\n"
  "/**\n"
  " * Adds the sepcified amount to the current velocity.  This is mostly here\n"
  " * allow this common operation to be faster for scripting, but it's also more\n"
  " * concise even in cpp.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_add_velocity_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_velocity(PN_stdfloat velocity)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_velocity_281(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_velocity")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerGravity::set_velocity(PN_stdfloat velocity)
  if (PyNumber_Check(arg)) {
    (*local_this).set_velocity((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_velocity(const CollisionHandlerGravity self, float velocity)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_velocity_281_comment =
  "C++ Interface:\n"
  "set_velocity(const CollisionHandlerGravity self, float velocity)\n"
  "\n"
  "/**\n"
  " * Sets the current vertical velocity.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_velocity_281_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_velocity(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_velocity_282(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_velocity(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_velocity();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_velocity_282_comment =
  "C++ Interface:\n"
  "get_velocity(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Gets the current vertical velocity.\n"
  " *\n"
  " * Generally, negative values mean the object is in free fall; while postive\n"
  " * values mean the object has vertical thrust.\n"
  " *\n"
  " * A zero value does not necessarily mean the object on the ground, it may\n"
  " * also be weightless and/or at the apex of its jump.\n"
  " *\n"
  " * See Also: is_on_ground() and get_gravity()\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_velocity_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_gravity(PN_stdfloat gravity)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_gravity_283(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_gravity")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerGravity::set_gravity(PN_stdfloat gravity)
  if (PyNumber_Check(arg)) {
    (*local_this).set_gravity((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gravity(const CollisionHandlerGravity self, float gravity)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_gravity_283_comment =
  "C++ Interface:\n"
  "set_gravity(const CollisionHandlerGravity self, float gravity)\n"
  "\n"
  "/**\n"
  " * Sets the linear gravity force (always plumb).\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_gravity_283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_gravity(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_gravity_284(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_gravity(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_gravity();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_gravity_284_comment =
  "C++ Interface:\n"
  "get_gravity(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Gets the linear gravity force (always plumb).\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_gravity_284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_max_velocity(PN_stdfloat max_vel)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_max_velocity_285(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_max_velocity")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerGravity::set_max_velocity(PN_stdfloat max_vel)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_velocity((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_velocity(const CollisionHandlerGravity self, float max_vel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_max_velocity_285_comment =
  "C++ Interface:\n"
  "set_max_velocity(const CollisionHandlerGravity self, float max_vel)\n"
  "\n"
  "/**\n"
  " * Sets the maximum speed at which the object will be allowed to descend\n"
  " * towards a floor below it, in units per second.  Set this to zero to allow\n"
  " * it to instantly teleport any distance.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_max_velocity_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_max_velocity(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_max_velocity_286(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_max_velocity(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_max_velocity();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_max_velocity_286_comment =
  "C++ Interface:\n"
  "get_max_velocity(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Retrieves the maximum speed at which the object will be allowed to descend\n"
  " * towards a floor below it, in units per second.  See set_max_velocity().\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_max_velocity_286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_legacy_mode(bool legacy_mode)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_legacy_mode_287(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_legacy_mode")) {
    return NULL;
  }
  // 1-inline void CollisionHandlerGravity::set_legacy_mode(bool legacy_mode)
  (*local_this).set_legacy_mode((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_legacy_mode(const CollisionHandlerGravity self, bool legacy_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_legacy_mode_287_comment =
  "C++ Interface:\n"
  "set_legacy_mode(const CollisionHandlerGravity self, bool legacy_mode)\n"
  "\n"
  "/**\n"
  " * Enables old behavior required by Toontown (Sellbot Factory lava room is\n"
  " * good test case, lava and conveyor belt specifically). Behavior is to throw\n"
  " * enter/exit events only for floor that the toon is in contact with\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_legacy_mode_287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionHandlerGravity::get_legacy_mode(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_legacy_mode_288(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CollisionHandlerGravity::get_legacy_mode(void) const
  bool return_value = (*(const CollisionHandlerGravity*)local_this).get_legacy_mode();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_legacy_mode_288_comment =
  "C++ Interface:\n"
  "get_legacy_mode(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * returns true if legacy mode is enabled\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_legacy_mode_288_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerGravity::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerGravity_get_class_type_299(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerGravity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionHandlerGravity::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_class_type_299_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerGravity_get_class_type_299_comment = NULL;
#endif

static PyObject *Dtool_CollisionHandlerGravity_offset_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_offset(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_offset();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerGravity_offset_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.offset")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete offset attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerGravity::set_offset(PN_stdfloat offset)
  if (PyNumber_Check(arg)) {
    (*local_this).set_offset((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_offset(const CollisionHandlerGravity self, float offset)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerGravity_reach_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_reach(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_reach();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerGravity_reach_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.reach")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete reach attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerGravity::set_reach(PN_stdfloat reach)
  if (PyNumber_Check(arg)) {
    (*local_this).set_reach((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_reach(const CollisionHandlerGravity self, float reach)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerGravity_airborne_height_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_airborne_height(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_airborne_height();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CollisionHandlerGravity_on_ground_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool CollisionHandlerGravity::is_on_ground(void) const
  bool return_value = (*(const CollisionHandlerGravity*)local_this).is_on_ground();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CollisionHandlerGravity_impact_velocity_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_impact_velocity(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_impact_velocity();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CollisionHandlerGravity_contact_normal_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector3 const &CollisionHandlerGravity::get_contact_normal(void) const
  LVector3 const *return_value = &((*(const CollisionHandlerGravity*)local_this).get_contact_normal());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

static PyObject *Dtool_CollisionHandlerGravity_velocity_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_velocity(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_velocity();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerGravity_velocity_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.velocity")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete velocity attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerGravity::set_velocity(PN_stdfloat velocity)
  if (PyNumber_Check(arg)) {
    (*local_this).set_velocity((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_velocity(const CollisionHandlerGravity self, float velocity)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerGravity_gravity_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_gravity(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_gravity();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerGravity_gravity_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.gravity")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete gravity attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerGravity::set_gravity(PN_stdfloat gravity)
  if (PyNumber_Check(arg)) {
    (*local_this).set_gravity((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_gravity(const CollisionHandlerGravity self, float gravity)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerGravity_max_velocity_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_max_velocity(void) const
  PN_stdfloat return_value = (*(const CollisionHandlerGravity*)local_this).get_max_velocity();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerGravity_max_velocity_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerGravity *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.max_velocity")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete max_velocity attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerGravity::set_max_velocity(PN_stdfloat max_vel)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_velocity((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_velocity(const CollisionHandlerGravity self, float max_vel)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * CollisionHandlerGravity::CollisionHandlerGravity(void)
 */
static int Dtool_Init_CollisionHandlerGravity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerGravity() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CollisionHandlerGravity::CollisionHandlerGravity(void)
  CollisionHandlerGravity *return_value = new CollisionHandlerGravity();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerGravity, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerGravity()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerGravity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionHandlerGravity) {
    printf("CollisionHandlerGravity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionHandlerGravity *local_this = (CollisionHandlerGravity *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionHandlerGravity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return (CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionHandlerGravity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerGravity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionHandlerHighestEvent
 */
/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerHighestEvent::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerHighestEvent_get_class_type_302(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerHighestEvent::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionHandlerHighestEvent::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerHighestEvent_get_class_type_302_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerHighestEvent_get_class_type_302_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(void)
 * inline CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(CollisionHandlerHighestEvent const &) = default
 */
static int Dtool_Init_CollisionHandlerHighestEvent(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(void)
      CollisionHandlerHighestEvent *return_value = new CollisionHandlerHighestEvent();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerHighestEvent, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(CollisionHandlerHighestEvent const &) = default
      CollisionHandlerHighestEvent const *arg_this = (CollisionHandlerHighestEvent *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionHandlerHighestEvent, 0, "CollisionHandlerHighestEvent.CollisionHandlerHighestEvent", true, true);
      if (arg_this != NULL) {
        CollisionHandlerHighestEvent *return_value = new CollisionHandlerHighestEvent(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerHighestEvent, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerHighestEvent() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerHighestEvent()\n"
      "CollisionHandlerHighestEvent(const CollisionHandlerHighestEvent param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerHighestEvent(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionHandlerHighestEvent) {
    printf("CollisionHandlerHighestEvent ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionHandlerHighestEvent *local_this = (CollisionHandlerHighestEvent *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionHandlerHighestEvent) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionHandlerHighestEvent(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerHighestEvent) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerHighestEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerHighestEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerHighestEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerHighestEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerHighestEvent*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionHandlerQueue
 */
/**
 * Python function wrapper for:
 * void CollisionHandlerQueue::sort_entries(void)
 */
static PyObject *Dtool_CollisionHandlerQueue_sort_entries_306(PyObject *self, PyObject *) {
  CollisionHandlerQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerQueue, (void **)&local_this, "CollisionHandlerQueue.sort_entries")) {
    return NULL;
  }
  // 1-void CollisionHandlerQueue::sort_entries(void)
  (*local_this).sort_entries();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_sort_entries_306_comment =
  "C++ Interface:\n"
  "sort_entries(const CollisionHandlerQueue self)\n"
  "\n"
  "/**\n"
  " * Sorts all the detected collisions front-to-back by\n"
  " * from_intersection_point() so that those intersection points closest to the\n"
  " * collider's origin (e.g., the center of the CollisionSphere, or the point_a\n"
  " * of a CollisionSegment) appear first.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_sort_entries_306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerQueue::clear_entries(void)
 */
static PyObject *Dtool_CollisionHandlerQueue_clear_entries_307(PyObject *self, PyObject *) {
  CollisionHandlerQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerQueue, (void **)&local_this, "CollisionHandlerQueue.clear_entries")) {
    return NULL;
  }
  // 1-void CollisionHandlerQueue::clear_entries(void)
  (*local_this).clear_entries();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_clear_entries_307_comment =
  "C++ Interface:\n"
  "clear_entries(const CollisionHandlerQueue self)\n"
  "\n"
  "/**\n"
  " * Removes all the entries from the queue.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_clear_entries_307_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int CollisionHandlerQueue::get_num_entries(void) const
 */
static PyObject *Dtool_CollisionHandlerQueue_get_num_entries_308(PyObject *self, PyObject *) {
  CollisionHandlerQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return NULL;
  }
  // 1-int CollisionHandlerQueue::get_num_entries(void) const
  int return_value = (*(const CollisionHandlerQueue*)local_this).get_num_entries();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_get_num_entries_308_comment =
  "C++ Interface:\n"
  "get_num_entries(CollisionHandlerQueue self)\n"
  "\n"
  "/**\n"
  " * Returns the number of CollisionEntries detected last pass.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_get_num_entries_308_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CollisionEntry *CollisionHandlerQueue::get_entry(int n) const
 */
static PyObject *Dtool_CollisionHandlerQueue_get_entry_309(PyObject *self, PyObject *arg) {
  CollisionHandlerQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return NULL;
  }
  // 1-CollisionEntry *CollisionHandlerQueue::get_entry(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CollisionEntry *return_value = (*(const CollisionHandlerQueue*)local_this).get_entry((int)arg_val);
    if (return_value != (CollisionEntry *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (CollisionEntry *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionEntry, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entry(CollisionHandlerQueue self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_get_entry_309_comment =
  "C++ Interface:\n"
  "get_entry(CollisionHandlerQueue self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth CollisionEntry detected last pass.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_get_entry_309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerQueue::output(ostream &out) const
 */
static PyObject *Dtool_CollisionHandlerQueue_output_313(PyObject *self, PyObject *arg) {
  CollisionHandlerQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CollisionHandlerQueue::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "CollisionHandlerQueue.output", false, true);
  if (arg_this != NULL) {
    (*(const CollisionHandlerQueue*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CollisionHandlerQueue self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_output_313_comment =
  "C++ Interface:\n"
  "output(CollisionHandlerQueue self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_output_313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerQueue::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_CollisionHandlerQueue_write_314(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionHandlerQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CollisionHandlerQueue::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "CollisionHandlerQueue.write", false, true);
    if (param1_this != NULL) {
      (*(const CollisionHandlerQueue*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CollisionHandlerQueue self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_write_314_comment =
  "C++ Interface:\n"
  "write(CollisionHandlerQueue self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_write_314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerQueue::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerQueue_get_class_type_315(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerQueue::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionHandlerQueue::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_get_class_type_315_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerQueue_get_class_type_315_comment = NULL;
#endif

/**
 * sequence length function for property CollisionHandlerQueue::entries
 */
static Py_ssize_t Dtool_CollisionHandlerQueue_entries_Len(PyObject *self) {
  CollisionHandlerQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_entries();
}

/**
 * sequence getter for property CollisionHandlerQueue::entries
 */
static PyObject *Dtool_CollisionHandlerQueue_entries_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionHandlerQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_entries()) {
    PyErr_SetString(PyExc_IndexError, "CollisionHandlerQueue.entries[] index out of range");
    return NULL;
  }
  // 1-CollisionEntry *CollisionHandlerQueue::get_entry(int n) const
  CollisionEntry *return_value = (*(const CollisionHandlerQueue*)local_this).get_entry(index);
  if (return_value != (CollisionEntry *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (CollisionEntry *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionEntry, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entry(CollisionHandlerQueue self, index)\n");
  }
}

static PyObject *Dtool_CollisionHandlerQueue_entries_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_CollisionHandlerQueue_entries_Len;
  wrap->_getitem_func = &Dtool_CollisionHandlerQueue_entries_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * CollisionHandlerQueue::CollisionHandlerQueue(void)
 * inline CollisionHandlerQueue::CollisionHandlerQueue(CollisionHandlerQueue const &) = default
 */
static int Dtool_Init_CollisionHandlerQueue(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-CollisionHandlerQueue::CollisionHandlerQueue(void)
      CollisionHandlerQueue *return_value = new CollisionHandlerQueue();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerQueue, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline CollisionHandlerQueue::CollisionHandlerQueue(CollisionHandlerQueue const &) = default
      CollisionHandlerQueue const *arg_this = (CollisionHandlerQueue *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionHandlerQueue, 0, "CollisionHandlerQueue.CollisionHandlerQueue", true, true);
      if (arg_this != NULL) {
        CollisionHandlerQueue *return_value = new CollisionHandlerQueue(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerQueue, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerQueue() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerQueue()\n"
      "CollisionHandlerQueue(const CollisionHandlerQueue param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionHandlerQueue_get_entries(PyObject *self, PyObject *) {
  CollisionHandlerQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_entries();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionHandlerQueue_get_entry_309(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionHandlerQueue(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionHandlerQueue) {
    printf("CollisionHandlerQueue ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionHandlerQueue *local_this = (CollisionHandlerQueue *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionHandlerQueue) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionHandlerQueue(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerQueue) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerQueue*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerQueue*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerQueue*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerQueue*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionSphere
 */
/**
 * Python function wrapper for:
 * inline void CollisionSphere::set_center(LPoint3 const &center)
 * inline void CollisionSphere::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionSphere_set_center_319(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSphere, (void **)&local_this, "CollisionSphere.set_center")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "center");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'center' (pos 1) not found");
      }
      // 1-inline void CollisionSphere::set_center(LPoint3 const &center)
      LPoint3f arg_local;
      LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CollisionSphere.set_center", "LPoint3f");
      }
      (*local_this).set_center(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void CollisionSphere::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_center", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_center((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_center() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center(const CollisionSphere self, const LPoint3f center)\n"
      "set_center(const CollisionSphere self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSphere_set_center_319_comment =
  "C++ Interface:\n"
  "set_center(const CollisionSphere self, const LPoint3f center)\n"
  "set_center(const CollisionSphere self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSphere_set_center_319_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionSphere::get_center(void) const
 */
static PyObject *Dtool_CollisionSphere_get_center_320(PyObject *self, PyObject *) {
  CollisionSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSphere, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &CollisionSphere::get_center(void) const
  LPoint3 const *return_value = &((*(const CollisionSphere*)local_this).get_center());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSphere_get_center_320_comment =
  "C++ Interface:\n"
  "get_center(CollisionSphere self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSphere_get_center_320_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSphere::set_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_CollisionSphere_set_radius_321(PyObject *self, PyObject *arg) {
  CollisionSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSphere, (void **)&local_this, "CollisionSphere.set_radius")) {
    return NULL;
  }
  // 1-inline void CollisionSphere::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const CollisionSphere self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSphere_set_radius_321_comment =
  "C++ Interface:\n"
  "set_radius(const CollisionSphere self, float radius)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSphere_set_radius_321_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionSphere::get_radius(void) const
 */
static PyObject *Dtool_CollisionSphere_get_radius_322(PyObject *self, PyObject *) {
  CollisionSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSphere, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionSphere::get_radius(void) const
  PN_stdfloat return_value = (*(const CollisionSphere*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSphere_get_radius_322_comment =
  "C++ Interface:\n"
  "get_radius(CollisionSphere self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSphere_get_radius_322_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionSphere::get_class_type(void)
 */
static PyObject *Dtool_CollisionSphere_get_class_type_325(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionSphere::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionSphere::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSphere_get_class_type_325_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionSphere_get_class_type_325_comment = NULL;
#endif

static PyObject *Dtool_CollisionSphere_center_Getter(PyObject *self, void *) {
  const CollisionSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSphere, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &CollisionSphere::get_center(void) const
  LPoint3 const *return_value = &((*(const CollisionSphere*)local_this).get_center());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionSphere_center_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSphere, (void **)&local_this, "CollisionSphere.center")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete center attribute");
    return -1;
  }
  // 1-inline void CollisionSphere::set_center(LPoint3 const &center)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionSphere.set_center", "LPoint3f");
    return -1;
  }
  (*local_this).set_center(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_center(const CollisionSphere self, const LPoint3f center)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionSphere_radius_Getter(PyObject *self, void *) {
  const CollisionSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSphere, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionSphere::get_radius(void) const
  PN_stdfloat return_value = (*(const CollisionSphere*)local_this).get_radius();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionSphere_radius_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSphere, (void **)&local_this, "CollisionSphere.radius")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete radius attribute");
    return -1;
  }
  // 1-inline void CollisionSphere::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_radius(const CollisionSphere self, float radius)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionSphere::CollisionSphere(LPoint3 const &center, PN_stdfloat radius)
 * inline CollisionSphere::CollisionSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
 */
static int Dtool_Init_CollisionSphere(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline CollisionSphere::CollisionSphere(LPoint3 const &center, PN_stdfloat radius)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"center", "radius", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:CollisionSphere", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionSphere.CollisionSphere", "LPoint3f");
          return -1;
        }
        CollisionSphere *return_value = new CollisionSphere(*param0_this, (PN_stdfloat)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionSphere, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline CollisionSphere::CollisionSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"cx", "cy", "cz", "radius", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:CollisionSphere", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        CollisionSphere *return_value = new CollisionSphere((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionSphere, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionSphere() takes 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionSphere(const LPoint3f center, float radius)\n"
      "CollisionSphere(float cx, float cy, float cz, float radius)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionSphere(PyObject *args, CPT(CollisionSphere) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionSphere, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionSphere::CollisionSphere(LPoint3 const &center, PN_stdfloat radius)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:CollisionSphere", &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          if (param0_this != NULL) {
            CollisionSphere *return_value = new CollisionSphere(*param0_this, (PN_stdfloat)param1);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline CollisionSphere::CollisionSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:CollisionSphere", &param0, &param1, &param2, &param3)) {
          CollisionSphere *return_value = new CollisionSphere((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CollisionSphere(PyObject *args, PT(CollisionSphere) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionSphere, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionSphere::CollisionSphere(LPoint3 const &center, PN_stdfloat radius)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:CollisionSphere", &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          if (param0_this != NULL) {
            CollisionSphere *return_value = new CollisionSphere(*param0_this, (PN_stdfloat)param1);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline CollisionSphere::CollisionSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:CollisionSphere", &param0, &param1, &param2, &param3)) {
          CollisionSphere *return_value = new CollisionSphere((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CollisionSphere(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionSphere) {
    printf("CollisionSphere ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionSphere *local_this = (CollisionSphere *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionSphere) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionSphere(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionSphere) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionSphere*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionInvSphere
 */
/**
 * Python function wrapper for:
 * static TypeHandle CollisionInvSphere::get_class_type(void)
 */
static PyObject *Dtool_CollisionInvSphere_get_class_type_329(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionInvSphere::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionInvSphere::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionInvSphere_get_class_type_329_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionInvSphere_get_class_type_329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollisionInvSphere::CollisionInvSphere(LPoint3 const &center, PN_stdfloat radius)
 * inline CollisionInvSphere::CollisionInvSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
 */
static int Dtool_Init_CollisionInvSphere(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline CollisionInvSphere::CollisionInvSphere(LPoint3 const &center, PN_stdfloat radius)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"center", "radius", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:CollisionInvSphere", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionInvSphere.CollisionInvSphere", "LPoint3f");
          return -1;
        }
        CollisionInvSphere *return_value = new CollisionInvSphere(*param0_this, (PN_stdfloat)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionInvSphere, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline CollisionInvSphere::CollisionInvSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"cx", "cy", "cz", "radius", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:CollisionInvSphere", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        CollisionInvSphere *return_value = new CollisionInvSphere((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionInvSphere, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionInvSphere() takes 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionInvSphere(const LPoint3f center, float radius)\n"
      "CollisionInvSphere(float cx, float cy, float cz, float radius)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionInvSphere(PyObject *args, CPT(CollisionInvSphere) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionInvSphere, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionInvSphere::CollisionInvSphere(LPoint3 const &center, PN_stdfloat radius)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:CollisionInvSphere", &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          if (param0_this != NULL) {
            CollisionInvSphere *return_value = new CollisionInvSphere(*param0_this, (PN_stdfloat)param1);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline CollisionInvSphere::CollisionInvSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:CollisionInvSphere", &param0, &param1, &param2, &param3)) {
          CollisionInvSphere *return_value = new CollisionInvSphere((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CollisionInvSphere(PyObject *args, PT(CollisionInvSphere) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionInvSphere, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionInvSphere::CollisionInvSphere(LPoint3 const &center, PN_stdfloat radius)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:CollisionInvSphere", &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          if (param0_this != NULL) {
            CollisionInvSphere *return_value = new CollisionInvSphere(*param0_this, (PN_stdfloat)param1);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline CollisionInvSphere::CollisionInvSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:CollisionInvSphere", &param0, &param1, &param2, &param3)) {
          CollisionInvSphere *return_value = new CollisionInvSphere((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CollisionInvSphere(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionInvSphere) {
    printf("CollisionInvSphere ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionInvSphere *local_this = (CollisionInvSphere *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionInvSphere) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSphere) {
    return (CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionInvSphere(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionInvSphere) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSphere) {
    CollisionSphere* other_this = (CollisionSphere*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionRay
 */
/**
 * Python function wrapper for:
 * inline void CollisionRay::set_origin(LPoint3 const &origin)
 * inline void CollisionRay::set_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionRay_set_origin_333(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionRay *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionRay, (void **)&local_this, "CollisionRay.set_origin")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "origin");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'origin' (pos 1) not found");
      }
      // 1-inline void CollisionRay::set_origin(LPoint3 const &origin)
      LPoint3f arg_local;
      LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CollisionRay.set_origin", "LPoint3f");
      }
      (*local_this).set_origin(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void CollisionRay::set_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_origin", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_origin((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_origin() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_origin(const CollisionRay self, const LPoint3f origin)\n"
      "set_origin(const CollisionRay self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_set_origin_333_comment =
  "C++ Interface:\n"
  "set_origin(const CollisionRay self, const LPoint3f origin)\n"
  "set_origin(const CollisionRay self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionRay_set_origin_333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionRay::get_origin(void) const
 */
static PyObject *Dtool_CollisionRay_get_origin_334(PyObject *self, PyObject *) {
  CollisionRay *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionRay, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &CollisionRay::get_origin(void) const
  LPoint3 const *return_value = &((*(const CollisionRay*)local_this).get_origin());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_get_origin_334_comment =
  "C++ Interface:\n"
  "get_origin(CollisionRay self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionRay_get_origin_334_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionRay::set_direction(LVector3 const &direction)
 * inline void CollisionRay::set_direction(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionRay_set_direction_336(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionRay *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionRay, (void **)&local_this, "CollisionRay.set_direction")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "direction");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'direction' (pos 1) not found");
      }
      // 1-inline void CollisionRay::set_direction(LVector3 const &direction)
      LVector3f arg_local;
      LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CollisionRay.set_direction", "LVector3f");
      }
      (*local_this).set_direction(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void CollisionRay::set_direction(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_direction", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_direction((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_direction() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_direction(const CollisionRay self, const LVector3f direction)\n"
      "set_direction(const CollisionRay self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_set_direction_336_comment =
  "C++ Interface:\n"
  "set_direction(const CollisionRay self, const LVector3f direction)\n"
  "set_direction(const CollisionRay self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionRay_set_direction_336_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &CollisionRay::get_direction(void) const
 */
static PyObject *Dtool_CollisionRay_get_direction_337(PyObject *self, PyObject *) {
  CollisionRay *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionRay, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 const &CollisionRay::get_direction(void) const
  LVector3 const *return_value = &((*(const CollisionRay*)local_this).get_direction());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_get_direction_337_comment =
  "C++ Interface:\n"
  "get_direction(CollisionRay self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionRay_get_direction_337_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CollisionRay::set_from_lens(LensNode *camera, LPoint2 const &point)
 * inline bool CollisionRay::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py)
 */
static PyObject *Dtool_CollisionRay_set_from_lens_339(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionRay *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionRay, (void **)&local_this, "CollisionRay.set_from_lens")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool CollisionRay::set_from_lens(LensNode *camera, LPoint2 const &point)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"camera", "point", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_from_lens", (char **)keyword_list, &param1, &param2)) {
        PT(LensNode) param1_this;
        if (!Dtool_Coerce_LensNode(param1, param1_this)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CollisionRay.set_from_lens", "LensNode");
        }
        LPoint2f param2_local;
        LPoint2 const *param2_this = Dtool_Coerce_LPoint2f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "CollisionRay.set_from_lens", "LPoint2f");
        }
        bool return_value = (*local_this).set_from_lens(MOVE(param1_this), *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-inline bool CollisionRay::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py)
      PyObject *param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"camera", "px", "py", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:set_from_lens", (char **)keyword_list, &param1, &param2, &param3)) {
        PT(LensNode) param1_this;
        if (!Dtool_Coerce_LensNode(param1, param1_this)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CollisionRay.set_from_lens", "LensNode");
        }
        bool return_value = (*local_this).set_from_lens(MOVE(param1_this), (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_from_lens() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_lens(const CollisionRay self, LensNode camera, const LPoint2f point)\n"
      "set_from_lens(const CollisionRay self, LensNode camera, float px, float py)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_set_from_lens_339_comment =
  "C++ Interface:\n"
  "set_from_lens(const CollisionRay self, LensNode camera, const LPoint2f point)\n"
  "set_from_lens(const CollisionRay self, LensNode camera, float px, float py)\n"
  "\n"
  "/**\n"
  " * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the\n"
  " * CollisionRay so that it begins at the LensNode's near plane and extends to\n"
  " * infinity, making it suitable for picking objects from the screen given a\n"
  " * camera and a mouse location.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the\n"
  " * CollisionRay so that it begins at the LensNode's near plane and extends to\n"
  " * infinity, making it suitable for picking objects from the screen given a\n"
  " * camera and a mouse location.\n"
  " *\n"
  " * Returns true if the point was acceptable, false otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionRay_set_from_lens_339_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionRay::get_class_type(void)
 */
static PyObject *Dtool_CollisionRay_get_class_type_340(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionRay::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionRay::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_get_class_type_340_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionRay_get_class_type_340_comment = NULL;
#endif

static PyObject *Dtool_CollisionRay_origin_Getter(PyObject *self, void *) {
  const CollisionRay *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionRay, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &CollisionRay::get_origin(void) const
  LPoint3 const *return_value = &((*(const CollisionRay*)local_this).get_origin());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionRay_origin_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionRay *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionRay, (void **)&local_this, "CollisionRay.origin")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete origin attribute");
    return -1;
  }
  // 1-inline void CollisionRay::set_origin(LPoint3 const &origin)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionRay.set_origin", "LPoint3f");
    return -1;
  }
  (*local_this).set_origin(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_origin(const CollisionRay self, const LPoint3f origin)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionRay_direction_Getter(PyObject *self, void *) {
  const CollisionRay *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionRay, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector3 const &CollisionRay::get_direction(void) const
  LVector3 const *return_value = &((*(const CollisionRay*)local_this).get_direction());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

static int Dtool_CollisionRay_direction_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionRay *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionRay, (void **)&local_this, "CollisionRay.direction")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete direction attribute");
    return -1;
  }
  // 1-inline void CollisionRay::set_direction(LVector3 const &direction)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionRay.set_direction", "LVector3f");
    return -1;
  }
  (*local_this).set_direction(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_direction(const CollisionRay self, const LVector3f direction)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionRay::CollisionRay(void)
 * inline CollisionRay::CollisionRay(LPoint3 const &origin, LVector3 const &direction)
 * inline CollisionRay::CollisionRay(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
 */
static int Dtool_Init_CollisionRay(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline CollisionRay::CollisionRay(void)
      CollisionRay *return_value = new CollisionRay();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionRay, true, false);
    }
    break;
  case 2:
    {
      // 1-inline CollisionRay::CollisionRay(LPoint3 const &origin, LVector3 const &direction)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"origin", "direction", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:CollisionRay", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionRay.CollisionRay", "LPoint3f");
          return -1;
        }
        LVector3f param1_local;
        LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionRay.CollisionRay", "LVector3f");
          return -1;
        }
        CollisionRay *return_value = new CollisionRay(*param0_this, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionRay, true, false);
      }
    }
    break;
  case 6:
    {
      // 1-inline CollisionRay::CollisionRay(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"ox", "oy", "oz", "dx", "dy", "dz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:CollisionRay", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        CollisionRay *return_value = new CollisionRay((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionRay, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionRay() takes 0, 2 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionRay()\n"
      "CollisionRay(const LPoint3f origin, const LVector3f direction)\n"
      "CollisionRay(float ox, float oy, float oz, float dx, float dy, float dz)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionRay(PyObject *args, CPT(CollisionRay) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionRay, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionRay::CollisionRay(LPoint3 const &origin, LVector3 const &direction)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionRay", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LVector3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionRay *return_value = new CollisionRay(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-inline CollisionRay::CollisionRay(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
        float param0;
        float param1;
        float param2;
        float param3;
        float param4;
        float param5;
        if (PyArg_ParseTuple(args, "ffffff:CollisionRay", &param0, &param1, &param2, &param3, &param4, &param5)) {
          CollisionRay *return_value = new CollisionRay((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CollisionRay(PyObject *args, PT(CollisionRay) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionRay, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionRay::CollisionRay(LPoint3 const &origin, LVector3 const &direction)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionRay", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LVector3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionRay *return_value = new CollisionRay(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-inline CollisionRay::CollisionRay(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
        float param0;
        float param1;
        float param2;
        float param3;
        float param4;
        float param5;
        if (PyArg_ParseTuple(args, "ffffff:CollisionRay", &param0, &param1, &param2, &param3, &param4, &param5)) {
          CollisionRay *return_value = new CollisionRay((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CollisionRay(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionRay) {
    printf("CollisionRay ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionRay *local_this = (CollisionRay *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionRay) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionRay(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionRay) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionRay*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionLine
 */
/**
 * Python function wrapper for:
 * static TypeHandle CollisionLine::get_class_type(void)
 */
static PyObject *Dtool_CollisionLine_get_class_type_344(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionLine::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionLine::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionLine_get_class_type_344_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionLine_get_class_type_344_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollisionLine::CollisionLine(void)
 * inline CollisionLine::CollisionLine(LPoint3 const &origin, LVector3 const &direction)
 * inline CollisionLine::CollisionLine(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
 */
static int Dtool_Init_CollisionLine(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline CollisionLine::CollisionLine(void)
      CollisionLine *return_value = new CollisionLine();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionLine, true, false);
    }
    break;
  case 2:
    {
      // 1-inline CollisionLine::CollisionLine(LPoint3 const &origin, LVector3 const &direction)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"origin", "direction", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:CollisionLine", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionLine.CollisionLine", "LPoint3f");
          return -1;
        }
        LVector3f param1_local;
        LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionLine.CollisionLine", "LVector3f");
          return -1;
        }
        CollisionLine *return_value = new CollisionLine(*param0_this, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionLine, true, false);
      }
    }
    break;
  case 6:
    {
      // 1-inline CollisionLine::CollisionLine(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"ox", "oy", "oz", "dx", "dy", "dz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:CollisionLine", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        CollisionLine *return_value = new CollisionLine((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionLine, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionLine() takes 0, 2 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionLine()\n"
      "CollisionLine(const LPoint3f origin, const LVector3f direction)\n"
      "CollisionLine(float ox, float oy, float oz, float dx, float dy, float dz)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionLine(PyObject *args, CPT(CollisionLine) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionLine, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionLine::CollisionLine(LPoint3 const &origin, LVector3 const &direction)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionLine", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LVector3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionLine *return_value = new CollisionLine(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-inline CollisionLine::CollisionLine(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
        float param0;
        float param1;
        float param2;
        float param3;
        float param4;
        float param5;
        if (PyArg_ParseTuple(args, "ffffff:CollisionLine", &param0, &param1, &param2, &param3, &param4, &param5)) {
          CollisionLine *return_value = new CollisionLine((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CollisionLine(PyObject *args, PT(CollisionLine) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionLine, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionLine::CollisionLine(LPoint3 const &origin, LVector3 const &direction)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionLine", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LVector3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionLine *return_value = new CollisionLine(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-inline CollisionLine::CollisionLine(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
        float param0;
        float param1;
        float param2;
        float param3;
        float param4;
        float param5;
        if (PyArg_ParseTuple(args, "ffffff:CollisionLine", &param0, &param1, &param2, &param3, &param4, &param5)) {
          CollisionLine *return_value = new CollisionLine((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CollisionLine(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionLine) {
    printf("CollisionLine ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionLine *local_this = (CollisionLine *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionLine) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionRay) {
    return (CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionLine(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionLine) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionRay) {
    CollisionRay* other_this = (CollisionRay*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionLine*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionParabola
 */
/**
 * Python function wrapper for:
 * inline void CollisionParabola::set_parabola(LParabola const &parabola)
 */
static PyObject *Dtool_CollisionParabola_set_parabola_348(PyObject *self, PyObject *arg) {
  CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.set_parabola")) {
    return NULL;
  }
  // 1-inline void CollisionParabola::set_parabola(LParabola const &parabola)
  LParabolaf arg_local;
  LParabola const *arg_this = Dtool_Coerce_LParabolaf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionParabola.set_parabola", "LParabolaf");
  }
  (*local_this).set_parabola(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_parabola(const CollisionParabola self, const LParabolaf parabola)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_set_parabola_348_comment =
  "C++ Interface:\n"
  "set_parabola(const CollisionParabola self, const LParabolaf parabola)\n"
  "\n"
  "/**\n"
  " * Replaces the parabola specified by this solid.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_set_parabola_348_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LParabola const &CollisionParabola::get_parabola(void) const
 */
static PyObject *Dtool_CollisionParabola_get_parabola_349(PyObject *self, PyObject *) {
  CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionParabola, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LParabola const &CollisionParabola::get_parabola(void) const
  LParabola const *return_value = &((*(const CollisionParabola*)local_this).get_parabola());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LParabolaf, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_get_parabola_349_comment =
  "C++ Interface:\n"
  "get_parabola(CollisionParabola self)\n"
  "\n"
  "/**\n"
  " * Returns the parabola specified by this solid.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_get_parabola_349_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionParabola::set_t1(PN_stdfloat t1)
 */
static PyObject *Dtool_CollisionParabola_set_t1_350(PyObject *self, PyObject *arg) {
  CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.set_t1")) {
    return NULL;
  }
  // 1-inline void CollisionParabola::set_t1(PN_stdfloat t1)
  if (PyNumber_Check(arg)) {
    (*local_this).set_t1((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_t1(const CollisionParabola self, float t1)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_set_t1_350_comment =
  "C++ Interface:\n"
  "set_t1(const CollisionParabola self, float t1)\n"
  "\n"
  "/**\n"
  " * Changes the starting point on the parabola.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_set_t1_350_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionParabola::get_t1(void) const
 */
static PyObject *Dtool_CollisionParabola_get_t1_351(PyObject *self, PyObject *) {
  CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionParabola, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionParabola::get_t1(void) const
  PN_stdfloat return_value = (*(const CollisionParabola*)local_this).get_t1();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_get_t1_351_comment =
  "C++ Interface:\n"
  "get_t1(CollisionParabola self)\n"
  "\n"
  "/**\n"
  " * Returns the starting point on the parabola.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_get_t1_351_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionParabola::set_t2(PN_stdfloat t2)
 */
static PyObject *Dtool_CollisionParabola_set_t2_352(PyObject *self, PyObject *arg) {
  CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.set_t2")) {
    return NULL;
  }
  // 1-inline void CollisionParabola::set_t2(PN_stdfloat t2)
  if (PyNumber_Check(arg)) {
    (*local_this).set_t2((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_t2(const CollisionParabola self, float t2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_set_t2_352_comment =
  "C++ Interface:\n"
  "set_t2(const CollisionParabola self, float t2)\n"
  "\n"
  "/**\n"
  " * Changes the ending point on the parabola.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_set_t2_352_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionParabola::get_t2(void) const
 */
static PyObject *Dtool_CollisionParabola_get_t2_353(PyObject *self, PyObject *) {
  CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionParabola, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionParabola::get_t2(void) const
  PN_stdfloat return_value = (*(const CollisionParabola*)local_this).get_t2();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_get_t2_353_comment =
  "C++ Interface:\n"
  "get_t2(CollisionParabola self)\n"
  "\n"
  "/**\n"
  " * Returns the ending point on the parabola.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_get_t2_353_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionParabola::get_class_type(void)
 */
static PyObject *Dtool_CollisionParabola_get_class_type_360(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionParabola::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionParabola::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_get_class_type_360_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionParabola_get_class_type_360_comment = NULL;
#endif

static PyObject *Dtool_CollisionParabola_parabola_Getter(PyObject *self, void *) {
  const CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionParabola, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LParabola const &CollisionParabola::get_parabola(void) const
  LParabola const *return_value = &((*(const CollisionParabola*)local_this).get_parabola());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LParabolaf, false, true);
}

static int Dtool_CollisionParabola_parabola_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.parabola")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete parabola attribute");
    return -1;
  }
  // 1-inline void CollisionParabola::set_parabola(LParabola const &parabola)
  LParabolaf arg_local;
  LParabola const *arg_this = Dtool_Coerce_LParabolaf(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionParabola.set_parabola", "LParabolaf");
    return -1;
  }
  (*local_this).set_parabola(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_parabola(const CollisionParabola self, const LParabolaf parabola)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionParabola_t1_Getter(PyObject *self, void *) {
  const CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionParabola, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionParabola::get_t1(void) const
  PN_stdfloat return_value = (*(const CollisionParabola*)local_this).get_t1();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionParabola_t1_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.t1")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete t1 attribute");
    return -1;
  }
  // 1-inline void CollisionParabola::set_t1(PN_stdfloat t1)
  if (PyNumber_Check(arg)) {
    (*local_this).set_t1((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_t1(const CollisionParabola self, float t1)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionParabola_t2_Getter(PyObject *self, void *) {
  const CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionParabola, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionParabola::get_t2(void) const
  PN_stdfloat return_value = (*(const CollisionParabola*)local_this).get_t2();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionParabola_t2_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionParabola *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.t2")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete t2 attribute");
    return -1;
  }
  // 1-inline void CollisionParabola::set_t2(PN_stdfloat t2)
  if (PyNumber_Check(arg)) {
    (*local_this).set_t2((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_t2(const CollisionParabola self, float t2)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionParabola::CollisionParabola(void)
 * inline CollisionParabola::CollisionParabola(LParabola const &parabola, PN_stdfloat t1, PN_stdfloat t2)
 */
static int Dtool_Init_CollisionParabola(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline CollisionParabola::CollisionParabola(void)
      CollisionParabola *return_value = new CollisionParabola();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionParabola, true, false);
    }
    break;
  case 3:
    {
      // 1-inline CollisionParabola::CollisionParabola(LParabola const &parabola, PN_stdfloat t1, PN_stdfloat t2)
      PyObject *param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"parabola", "t1", "t2", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:CollisionParabola", (char **)keyword_list, &param0, &param1, &param2)) {
        LParabolaf param0_local;
        LParabola const *param0_this = Dtool_Coerce_LParabolaf(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionParabola.CollisionParabola", "LParabolaf");
          return -1;
        }
        CollisionParabola *return_value = new CollisionParabola(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionParabola, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionParabola() takes 0 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionParabola()\n"
      "CollisionParabola(const LParabolaf parabola, float t1, float t2)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionParabola(PyObject *args, CPT(CollisionParabola) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionParabola, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline CollisionParabola::CollisionParabola(LParabola const &parabola, PN_stdfloat t1, PN_stdfloat t2)
      PyObject *param0;
      float param1;
      float param2;
      if (PyArg_ParseTuple(args, "Off:CollisionParabola", &param0, &param1, &param2)) {
        LParabola const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LParabolaf, (void **)&param0_this);
        if (param0_this != NULL) {
          CollisionParabola *return_value = new CollisionParabola(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_CollisionParabola(PyObject *args, PT(CollisionParabola) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionParabola, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline CollisionParabola::CollisionParabola(LParabola const &parabola, PN_stdfloat t1, PN_stdfloat t2)
      PyObject *param0;
      float param1;
      float param2;
      if (PyArg_ParseTuple(args, "Off:CollisionParabola", &param0, &param1, &param2)) {
        LParabola const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LParabolaf, (void **)&param0_this);
        if (param0_this != NULL) {
          CollisionParabola *return_value = new CollisionParabola(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CollisionParabola(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionParabola) {
    printf("CollisionParabola ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionParabola *local_this = (CollisionParabola *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionParabola) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionParabola(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionParabola) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionParabola*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionSegment
 */
/**
 * Python function wrapper for:
 * inline void CollisionSegment::set_point_a(LPoint3 const &a)
 * inline void CollisionSegment::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionSegment_set_point_a_364(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSegment, (void **)&local_this, "CollisionSegment.set_point_a")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "a");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'a' (pos 1) not found");
      }
      // 1-inline void CollisionSegment::set_point_a(LPoint3 const &a)
      LPoint3f arg_local;
      LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CollisionSegment.set_point_a", "LPoint3f");
      }
      (*local_this).set_point_a(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void CollisionSegment::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_point_a", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_point_a((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_point_a() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_a(const CollisionSegment self, const LPoint3f a)\n"
      "set_point_a(const CollisionSegment self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_set_point_a_364_comment =
  "C++ Interface:\n"
  "set_point_a(const CollisionSegment self, const LPoint3f a)\n"
  "set_point_a(const CollisionSegment self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSegment_set_point_a_364_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionSegment::get_point_a(void) const
 */
static PyObject *Dtool_CollisionSegment_get_point_a_365(PyObject *self, PyObject *) {
  CollisionSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSegment, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &CollisionSegment::get_point_a(void) const
  LPoint3 const *return_value = &((*(const CollisionSegment*)local_this).get_point_a());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_get_point_a_365_comment =
  "C++ Interface:\n"
  "get_point_a(CollisionSegment self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSegment_get_point_a_365_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSegment::set_point_b(LPoint3 const &b)
 * inline void CollisionSegment::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionSegment_set_point_b_366(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSegment, (void **)&local_this, "CollisionSegment.set_point_b")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "b");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'b' (pos 1) not found");
      }
      // 1-inline void CollisionSegment::set_point_b(LPoint3 const &b)
      LPoint3f arg_local;
      LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CollisionSegment.set_point_b", "LPoint3f");
      }
      (*local_this).set_point_b(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void CollisionSegment::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_point_b", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_point_b((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_point_b() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_b(const CollisionSegment self, const LPoint3f b)\n"
      "set_point_b(const CollisionSegment self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_set_point_b_366_comment =
  "C++ Interface:\n"
  "set_point_b(const CollisionSegment self, const LPoint3f b)\n"
  "set_point_b(const CollisionSegment self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSegment_set_point_b_366_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionSegment::get_point_b(void) const
 */
static PyObject *Dtool_CollisionSegment_get_point_b_367(PyObject *self, PyObject *) {
  CollisionSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSegment, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &CollisionSegment::get_point_b(void) const
  LPoint3 const *return_value = &((*(const CollisionSegment*)local_this).get_point_b());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_get_point_b_367_comment =
  "C++ Interface:\n"
  "get_point_b(CollisionSegment self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSegment_get_point_b_367_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CollisionSegment::set_from_lens(LensNode *camera, LPoint2 const &point)
 * inline bool CollisionSegment::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py)
 */
static PyObject *Dtool_CollisionSegment_set_from_lens_368(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSegment, (void **)&local_this, "CollisionSegment.set_from_lens")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool CollisionSegment::set_from_lens(LensNode *camera, LPoint2 const &point)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"camera", "point", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_from_lens", (char **)keyword_list, &param1, &param2)) {
        PT(LensNode) param1_this;
        if (!Dtool_Coerce_LensNode(param1, param1_this)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CollisionSegment.set_from_lens", "LensNode");
        }
        LPoint2f param2_local;
        LPoint2 const *param2_this = Dtool_Coerce_LPoint2f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "CollisionSegment.set_from_lens", "LPoint2f");
        }
        bool return_value = (*local_this).set_from_lens(MOVE(param1_this), *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-inline bool CollisionSegment::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py)
      PyObject *param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"camera", "px", "py", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:set_from_lens", (char **)keyword_list, &param1, &param2, &param3)) {
        PT(LensNode) param1_this;
        if (!Dtool_Coerce_LensNode(param1, param1_this)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CollisionSegment.set_from_lens", "LensNode");
        }
        bool return_value = (*local_this).set_from_lens(MOVE(param1_this), (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_from_lens() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_lens(const CollisionSegment self, LensNode camera, const LPoint2f point)\n"
      "set_from_lens(const CollisionSegment self, LensNode camera, float px, float py)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_set_from_lens_368_comment =
  "C++ Interface:\n"
  "set_from_lens(const CollisionSegment self, LensNode camera, const LPoint2f point)\n"
  "set_from_lens(const CollisionSegment self, LensNode camera, float px, float py)\n"
  "\n"
  "/**\n"
  " * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the\n"
  " * CollisionSegment so that it begins at the LensNode's near plane and extends\n"
  " * to the far plane, making it suitable for picking objects from the screen\n"
  " * given a camera and a mouse location.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the\n"
  " * CollisionSegment so that it begins at the LensNode's near plane and extends\n"
  " * to the far plane, making it suitable for picking objects from the screen\n"
  " * given a camera and a mouse location.\n"
  " *\n"
  " * Returns true if the point was acceptable, false otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionSegment_set_from_lens_368_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionSegment::get_class_type(void)
 */
static PyObject *Dtool_CollisionSegment_get_class_type_371(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionSegment::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionSegment::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_get_class_type_371_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionSegment_get_class_type_371_comment = NULL;
#endif

static PyObject *Dtool_CollisionSegment_point_a_Getter(PyObject *self, void *) {
  const CollisionSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSegment, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &CollisionSegment::get_point_a(void) const
  LPoint3 const *return_value = &((*(const CollisionSegment*)local_this).get_point_a());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionSegment_point_a_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSegment, (void **)&local_this, "CollisionSegment.point_a")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete point_a attribute");
    return -1;
  }
  // 1-inline void CollisionSegment::set_point_a(LPoint3 const &a)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionSegment.set_point_a", "LPoint3f");
    return -1;
  }
  (*local_this).set_point_a(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point_a(const CollisionSegment self, const LPoint3f a)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionSegment_point_b_Getter(PyObject *self, void *) {
  const CollisionSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSegment, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &CollisionSegment::get_point_b(void) const
  LPoint3 const *return_value = &((*(const CollisionSegment*)local_this).get_point_b());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionSegment_point_b_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSegment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSegment, (void **)&local_this, "CollisionSegment.point_b")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete point_b attribute");
    return -1;
  }
  // 1-inline void CollisionSegment::set_point_b(LPoint3 const &b)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionSegment.set_point_b", "LPoint3f");
    return -1;
  }
  (*local_this).set_point_b(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point_b(const CollisionSegment self, const LPoint3f b)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionSegment::CollisionSegment(void)
 * inline CollisionSegment::CollisionSegment(LPoint3 const &a, LPoint3 const &db)
 * inline CollisionSegment::CollisionSegment(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz)
 */
static int Dtool_Init_CollisionSegment(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline CollisionSegment::CollisionSegment(void)
      CollisionSegment *return_value = new CollisionSegment();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionSegment, true, false);
    }
    break;
  case 2:
    {
      // 1-inline CollisionSegment::CollisionSegment(LPoint3 const &a, LPoint3 const &db)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"a", "db", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:CollisionSegment", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionSegment.CollisionSegment", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionSegment.CollisionSegment", "LPoint3f");
          return -1;
        }
        CollisionSegment *return_value = new CollisionSegment(*param0_this, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionSegment, true, false);
      }
    }
    break;
  case 6:
    {
      // 1-inline CollisionSegment::CollisionSegment(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"ax", "ay", "az", "bx", "by", "bz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:CollisionSegment", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        CollisionSegment *return_value = new CollisionSegment((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionSegment, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionSegment() takes 0, 2 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionSegment()\n"
      "CollisionSegment(const LPoint3f a, const LPoint3f db)\n"
      "CollisionSegment(float ax, float ay, float az, float bx, float by, float bz)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionSegment(PyObject *args, CPT(CollisionSegment) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionSegment, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionSegment::CollisionSegment(LPoint3 const &a, LPoint3 const &db)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionSegment", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LPoint3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionSegment *return_value = new CollisionSegment(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-inline CollisionSegment::CollisionSegment(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz)
        float param0;
        float param1;
        float param2;
        float param3;
        float param4;
        float param5;
        if (PyArg_ParseTuple(args, "ffffff:CollisionSegment", &param0, &param1, &param2, &param3, &param4, &param5)) {
          CollisionSegment *return_value = new CollisionSegment((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CollisionSegment(PyObject *args, PT(CollisionSegment) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionSegment, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionSegment::CollisionSegment(LPoint3 const &a, LPoint3 const &db)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionSegment", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LPoint3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionSegment *return_value = new CollisionSegment(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 6: {
        // 1-inline CollisionSegment::CollisionSegment(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz)
        float param0;
        float param1;
        float param2;
        float param3;
        float param4;
        float param5;
        if (PyArg_ParseTuple(args, "ffffff:CollisionSegment", &param0, &param1, &param2, &param3, &param4, &param5)) {
          CollisionSegment *return_value = new CollisionSegment((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CollisionSegment(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionSegment) {
    printf("CollisionSegment ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionSegment *local_this = (CollisionSegment *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionSegment) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionSegment(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionSegment) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionSegment*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionTube
 */
/**
 * Python function wrapper for:
 * inline void CollisionTube::set_point_a(LPoint3 const &a)
 * inline void CollisionTube::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionTube_set_point_a_375(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTube, (void **)&local_this, "CollisionTube.set_point_a")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "a");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'a' (pos 1) not found");
      }
      // 1-inline void CollisionTube::set_point_a(LPoint3 const &a)
      LPoint3f arg_local;
      LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CollisionTube.set_point_a", "LPoint3f");
      }
      (*local_this).set_point_a(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void CollisionTube::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_point_a", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_point_a((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_point_a() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_a(const CollisionTube self, const LPoint3f a)\n"
      "set_point_a(const CollisionTube self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTube_set_point_a_375_comment =
  "C++ Interface:\n"
  "set_point_a(const CollisionTube self, const LPoint3f a)\n"
  "set_point_a(const CollisionTube self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTube_set_point_a_375_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionTube::get_point_a(void) const
 */
static PyObject *Dtool_CollisionTube_get_point_a_376(PyObject *self, PyObject *) {
  CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTube, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &CollisionTube::get_point_a(void) const
  LPoint3 const *return_value = &((*(const CollisionTube*)local_this).get_point_a());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTube_get_point_a_376_comment =
  "C++ Interface:\n"
  "get_point_a(CollisionTube self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTube_get_point_a_376_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionTube::set_point_b(LPoint3 const &b)
 * inline void CollisionTube::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionTube_set_point_b_377(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTube, (void **)&local_this, "CollisionTube.set_point_b")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "b");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'b' (pos 1) not found");
      }
      // 1-inline void CollisionTube::set_point_b(LPoint3 const &b)
      LPoint3f arg_local;
      LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CollisionTube.set_point_b", "LPoint3f");
      }
      (*local_this).set_point_b(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void CollisionTube::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_point_b", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_point_b((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_point_b() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_b(const CollisionTube self, const LPoint3f b)\n"
      "set_point_b(const CollisionTube self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTube_set_point_b_377_comment =
  "C++ Interface:\n"
  "set_point_b(const CollisionTube self, const LPoint3f b)\n"
  "set_point_b(const CollisionTube self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTube_set_point_b_377_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionTube::get_point_b(void) const
 */
static PyObject *Dtool_CollisionTube_get_point_b_378(PyObject *self, PyObject *) {
  CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTube, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &CollisionTube::get_point_b(void) const
  LPoint3 const *return_value = &((*(const CollisionTube*)local_this).get_point_b());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTube_get_point_b_378_comment =
  "C++ Interface:\n"
  "get_point_b(CollisionTube self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTube_get_point_b_378_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionTube::set_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_CollisionTube_set_radius_379(PyObject *self, PyObject *arg) {
  CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTube, (void **)&local_this, "CollisionTube.set_radius")) {
    return NULL;
  }
  // 1-inline void CollisionTube::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const CollisionTube self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTube_set_radius_379_comment =
  "C++ Interface:\n"
  "set_radius(const CollisionTube self, float radius)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTube_set_radius_379_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionTube::get_radius(void) const
 */
static PyObject *Dtool_CollisionTube_get_radius_380(PyObject *self, PyObject *) {
  CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTube, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionTube::get_radius(void) const
  PN_stdfloat return_value = (*(const CollisionTube*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTube_get_radius_380_comment =
  "C++ Interface:\n"
  "get_radius(CollisionTube self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTube_get_radius_380_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionTube::get_class_type(void)
 */
static PyObject *Dtool_CollisionTube_get_class_type_384(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionTube::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionTube::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTube_get_class_type_384_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionTube_get_class_type_384_comment = NULL;
#endif

static PyObject *Dtool_CollisionTube_point_a_Getter(PyObject *self, void *) {
  const CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTube, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &CollisionTube::get_point_a(void) const
  LPoint3 const *return_value = &((*(const CollisionTube*)local_this).get_point_a());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionTube_point_a_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTube, (void **)&local_this, "CollisionTube.point_a")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete point_a attribute");
    return -1;
  }
  // 1-inline void CollisionTube::set_point_a(LPoint3 const &a)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionTube.set_point_a", "LPoint3f");
    return -1;
  }
  (*local_this).set_point_a(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point_a(const CollisionTube self, const LPoint3f a)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionTube_point_b_Getter(PyObject *self, void *) {
  const CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTube, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3 const &CollisionTube::get_point_b(void) const
  LPoint3 const *return_value = &((*(const CollisionTube*)local_this).get_point_b());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionTube_point_b_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTube, (void **)&local_this, "CollisionTube.point_b")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete point_b attribute");
    return -1;
  }
  // 1-inline void CollisionTube::set_point_b(LPoint3 const &b)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionTube.set_point_b", "LPoint3f");
    return -1;
  }
  (*local_this).set_point_b(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point_b(const CollisionTube self, const LPoint3f b)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionTube_radius_Getter(PyObject *self, void *) {
  const CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTube, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionTube::get_radius(void) const
  PN_stdfloat return_value = (*(const CollisionTube*)local_this).get_radius();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionTube_radius_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionTube *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTube, (void **)&local_this, "CollisionTube.radius")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete radius attribute");
    return -1;
  }
  // 1-inline void CollisionTube::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_radius(const CollisionTube self, float radius)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionTube::CollisionTube(LPoint3 const &a, LPoint3 const &db, PN_stdfloat radius)
 * inline CollisionTube::CollisionTube(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz, PN_stdfloat radius)
 */
static int Dtool_Init_CollisionTube(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline CollisionTube::CollisionTube(LPoint3 const &a, LPoint3 const &db, PN_stdfloat radius)
      PyObject *param0;
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"a", "db", "radius", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOf:CollisionTube", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionTube.CollisionTube", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionTube.CollisionTube", "LPoint3f");
          return -1;
        }
        CollisionTube *return_value = new CollisionTube(*param0_this, *param1_this, (PN_stdfloat)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionTube, true, false);
      }
    }
    break;
  case 7:
    {
      // 1-inline CollisionTube::CollisionTube(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz, PN_stdfloat radius)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"ax", "ay", "az", "bx", "by", "bz", "radius", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fffffff:CollisionTube", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        CollisionTube *return_value = new CollisionTube((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionTube, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionTube() takes 3 or 7 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionTube(const LPoint3f a, const LPoint3f db, float radius)\n"
      "CollisionTube(float ax, float ay, float az, float bx, float by, float bz, float radius)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionTube(PyObject *args, CPT(CollisionTube) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionTube, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 3: {
        // 1-inline CollisionTube::CollisionTube(LPoint3 const &a, LPoint3 const &db, PN_stdfloat radius)
        PyObject *param0;
        PyObject *param1;
        float param2;
        if (PyArg_ParseTuple(args, "OOf:CollisionTube", &param0, &param1, &param2)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LPoint3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionTube *return_value = new CollisionTube(*param0_this, *param1_this, (PN_stdfloat)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 7: {
        // 1-inline CollisionTube::CollisionTube(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz, PN_stdfloat radius)
        float param0;
        float param1;
        float param2;
        float param3;
        float param4;
        float param5;
        float param6;
        if (PyArg_ParseTuple(args, "fffffff:CollisionTube", &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
          CollisionTube *return_value = new CollisionTube((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CollisionTube(PyObject *args, PT(CollisionTube) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionTube, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 3: {
        // 1-inline CollisionTube::CollisionTube(LPoint3 const &a, LPoint3 const &db, PN_stdfloat radius)
        PyObject *param0;
        PyObject *param1;
        float param2;
        if (PyArg_ParseTuple(args, "OOf:CollisionTube", &param0, &param1, &param2)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LPoint3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            CollisionTube *return_value = new CollisionTube(*param0_this, *param1_this, (PN_stdfloat)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 7: {
        // 1-inline CollisionTube::CollisionTube(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz, PN_stdfloat radius)
        float param0;
        float param1;
        float param2;
        float param3;
        float param4;
        float param5;
        float param6;
        if (PyArg_ParseTuple(args, "fffffff:CollisionTube", &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
          CollisionTube *return_value = new CollisionTube((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CollisionTube(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionTube) {
    printf("CollisionTube ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionTube *local_this = (CollisionTube *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionTube) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionTube(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionTube) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionTube*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionTube*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionTube*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionTube*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionTube*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionTube*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionTube*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CollisionVisualizer
 */
/**
 * Python function wrapper for:
 * inline void CollisionVisualizer::set_point_scale(PN_stdfloat point_scale)
 */
static PyObject *Dtool_CollisionVisualizer_set_point_scale_393(PyObject *self, PyObject *arg) {
  CollisionVisualizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionVisualizer, (void **)&local_this, "CollisionVisualizer.set_point_scale")) {
    return NULL;
  }
  // 1-inline void CollisionVisualizer::set_point_scale(PN_stdfloat point_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_point_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_scale(const CollisionVisualizer self, float point_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionVisualizer_set_point_scale_393_comment =
  "C++ Interface:\n"
  "set_point_scale(const CollisionVisualizer self, float point_scale)\n"
  "\n"
  "/**\n"
  " * Scales the points that are drawn to represent the surface and interior\n"
  " * intersection points of the collisions.  By default, these objects are drawn\n"
  " * at an arbitrary scale which is appropriate if the window units are the\n"
  " * default range -1 .. 1.  Change this scale accordinatly if the window units\n"
  " * are measured on some other scale or if you need to observe these objects in\n"
  " * a smaller window.\n"
  " */";
#else
static const char *Dtool_CollisionVisualizer_set_point_scale_393_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionVisualizer::get_point_scale(void) const
 */
static PyObject *Dtool_CollisionVisualizer_get_point_scale_394(PyObject *self, PyObject *) {
  CollisionVisualizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionVisualizer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionVisualizer::get_point_scale(void) const
  PN_stdfloat return_value = (*(const CollisionVisualizer*)local_this).get_point_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionVisualizer_get_point_scale_394_comment =
  "C++ Interface:\n"
  "get_point_scale(CollisionVisualizer self)\n"
  "\n"
  "/**\n"
  " * Returns the value last set by set_point_scale().\n"
  " */";
#else
static const char *Dtool_CollisionVisualizer_get_point_scale_394_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionVisualizer::set_normal_scale(PN_stdfloat normal_scale)
 */
static PyObject *Dtool_CollisionVisualizer_set_normal_scale_395(PyObject *self, PyObject *arg) {
  CollisionVisualizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionVisualizer, (void **)&local_this, "CollisionVisualizer.set_normal_scale")) {
    return NULL;
  }
  // 1-inline void CollisionVisualizer::set_normal_scale(PN_stdfloat normal_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_normal_scale((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_normal_scale(const CollisionVisualizer self, float normal_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CollisionVisualizer_set_normal_scale_395_comment =
  "C++ Interface:\n"
  "set_normal_scale(const CollisionVisualizer self, float normal_scale)\n"
  "\n"
  "/**\n"
  " * Scales the line segments that are drawn to represent the normals of the\n"
  " * collisions.  By default, these objects are drawn at an arbitrary scale\n"
  " * which is appropriate if the scene units are measured in feet.  Change this\n"
  " * scale accordinatly if the scene units are measured on some other scale or\n"
  " * if you need to observe these normals from farther away.\n"
  " */";
#else
static const char *Dtool_CollisionVisualizer_set_normal_scale_395_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionVisualizer::get_normal_scale(void) const
 */
static PyObject *Dtool_CollisionVisualizer_get_normal_scale_396(PyObject *self, PyObject *) {
  CollisionVisualizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionVisualizer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat CollisionVisualizer::get_normal_scale(void) const
  PN_stdfloat return_value = (*(const CollisionVisualizer*)local_this).get_normal_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionVisualizer_get_normal_scale_396_comment =
  "C++ Interface:\n"
  "get_normal_scale(CollisionVisualizer self)\n"
  "\n"
  "/**\n"
  " * Returns the value last set by set_normal_scale().\n"
  " */";
#else
static const char *Dtool_CollisionVisualizer_get_normal_scale_396_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CollisionVisualizer::clear(void)
 */
static PyObject *Dtool_CollisionVisualizer_clear_397(PyObject *self, PyObject *) {
  CollisionVisualizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionVisualizer, (void **)&local_this, "CollisionVisualizer.clear")) {
    return NULL;
  }
  // 1-void CollisionVisualizer::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionVisualizer_clear_397_comment =
  "C++ Interface:\n"
  "clear(const CollisionVisualizer self)\n"
  "\n"
  "/**\n"
  " * Removes all the visualization data from a previous traversal and resets the\n"
  " * visualizer to empty.\n"
  " */";
#else
static const char *Dtool_CollisionVisualizer_clear_397_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionVisualizer::get_class_type(void)
 */
static PyObject *Dtool_CollisionVisualizer_get_class_type_400(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionVisualizer::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CollisionVisualizer::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionVisualizer_get_class_type_400_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionVisualizer_get_class_type_400_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PandaNode *CollisionVisualizer::upcast_to_PandaNode(void)
 */
static PyObject *Dtool_CollisionVisualizer_upcast_to_PandaNode_387(PyObject *self, PyObject *) {
  CollisionVisualizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionVisualizer, (void **)&local_this, "CollisionVisualizer.upcast_to_PandaNode")) {
    return NULL;
  }
  // 1-PandaNode *CollisionVisualizer::upcast_to_PandaNode(void)
  PandaNode *return_value = (PandaNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionVisualizer_upcast_to_PandaNode_387_comment =
  "C++ Interface:\n"
  "upcast_to_PandaNode(const CollisionVisualizer self)\n"
  "\n"
  "upcast from CollisionVisualizer to PandaNode";
#else
static const char *Dtool_CollisionVisualizer_upcast_to_PandaNode_387_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CollisionRecorder *CollisionVisualizer::upcast_to_CollisionRecorder(void)
 */
static PyObject *Dtool_CollisionVisualizer_upcast_to_CollisionRecorder_389(PyObject *self, PyObject *) {
  CollisionVisualizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionVisualizer, (void **)&local_this, "CollisionVisualizer.upcast_to_CollisionRecorder")) {
    return NULL;
  }
  // 1-CollisionRecorder *CollisionVisualizer::upcast_to_CollisionRecorder(void)
  CollisionRecorder *return_value = (CollisionRecorder *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionRecorder, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionVisualizer_upcast_to_CollisionRecorder_389_comment =
  "C++ Interface:\n"
  "upcast_to_CollisionRecorder(const CollisionVisualizer self)\n"
  "\n"
  "upcast from CollisionVisualizer to CollisionRecorder";
#else
static const char *Dtool_CollisionVisualizer_upcast_to_CollisionRecorder_389_comment = NULL;
#endif

static PyObject *Dtool_CollisionVisualizer_point_scale_Getter(PyObject *self, void *) {
  const CollisionVisualizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionVisualizer, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionVisualizer::get_point_scale(void) const
  PN_stdfloat return_value = (*(const CollisionVisualizer*)local_this).get_point_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionVisualizer_point_scale_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionVisualizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionVisualizer, (void **)&local_this, "CollisionVisualizer.point_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete point_scale attribute");
    return -1;
  }
  // 1-inline void CollisionVisualizer::set_point_scale(PN_stdfloat point_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_point_scale((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point_scale(const CollisionVisualizer self, float point_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionVisualizer_normal_scale_Getter(PyObject *self, void *) {
  const CollisionVisualizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionVisualizer, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat CollisionVisualizer::get_normal_scale(void) const
  PN_stdfloat return_value = (*(const CollisionVisualizer*)local_this).get_normal_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionVisualizer_normal_scale_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionVisualizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionVisualizer, (void **)&local_this, "CollisionVisualizer.normal_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete normal_scale attribute");
    return -1;
  }
  // 1-inline void CollisionVisualizer::set_normal_scale(PN_stdfloat normal_scale)
  if (PyNumber_Check(arg)) {
    (*local_this).set_normal_scale((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_normal_scale(const CollisionVisualizer self, float normal_scale)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionVisualizer::CollisionVisualizer(CollisionVisualizer const &) = default
 * CollisionVisualizer::CollisionVisualizer(std::string const &name)
 */
static int Dtool_Init_CollisionVisualizer(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionVisualizer() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline CollisionVisualizer::CollisionVisualizer(CollisionVisualizer const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CollisionVisualizer", (char **)keyword_list, &param0)) {
      CollisionVisualizer const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_CollisionVisualizer, (void **)&param0_this);
      if (param0_this != NULL) {
        CollisionVisualizer *return_value = new CollisionVisualizer(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionVisualizer, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 CollisionVisualizer::CollisionVisualizer(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:CollisionVisualizer", (char **)keyword_list, &param0_str, &param0_len)) {
      CollisionVisualizer *return_value = new CollisionVisualizer(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionVisualizer, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline CollisionVisualizer::CollisionVisualizer(CollisionVisualizer const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:CollisionVisualizer", (char **)keyword_list, &param0)) {
      CPT(CollisionVisualizer) param0_this;
      if (Dtool_ConstCoerce_CollisionVisualizer(param0, param0_this)) {
        CollisionVisualizer *return_value = new CollisionVisualizer(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionVisualizer, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: CollisionVisualizer::CollisionVisualizer(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionVisualizer(const CollisionVisualizer param0)\n"
      "CollisionVisualizer(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionVisualizer(PyObject *args, CPT(CollisionVisualizer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionVisualizer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CollisionVisualizer::CollisionVisualizer(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CollisionVisualizer *return_value = new CollisionVisualizer(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_CollisionVisualizer(PyObject *args, PT(CollisionVisualizer) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CollisionVisualizer, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CollisionVisualizer::CollisionVisualizer(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CollisionVisualizer *return_value = new CollisionVisualizer(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_CollisionVisualizer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CollisionVisualizer) {
    printf("CollisionVisualizer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CollisionVisualizer *local_this = (CollisionVisualizer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CollisionVisualizer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionRecorder) {
    return (CollisionRecorder *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CollisionVisualizer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CollisionVisualizer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionRecorder) {
    CollisionRecorder* other_this = (CollisionRecorder*)from_this;
    return (CollisionVisualizer*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CollisionVisualizer*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (CollisionVisualizer*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionVisualizer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionVisualizer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionVisualizer*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for CollisionSolid (CollisionSolid)
 */
static PyMethodDef Dtool_Methods_CollisionSolid[] = {
  {"get_collision_origin", &Dtool_CollisionSolid_get_collision_origin_3, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_collision_origin_3_comment},
  {"getCollisionOrigin", &Dtool_CollisionSolid_get_collision_origin_3, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_collision_origin_3_comment},
  {"set_tangible", &Dtool_CollisionSolid_set_tangible_7, METH_O, (const char *)Dtool_CollisionSolid_set_tangible_7_comment},
  {"setTangible", &Dtool_CollisionSolid_set_tangible_7, METH_O, (const char *)Dtool_CollisionSolid_set_tangible_7_comment},
  {"is_tangible", &Dtool_CollisionSolid_is_tangible_8, METH_NOARGS, (const char *)Dtool_CollisionSolid_is_tangible_8_comment},
  {"isTangible", &Dtool_CollisionSolid_is_tangible_8, METH_NOARGS, (const char *)Dtool_CollisionSolid_is_tangible_8_comment},
  {"set_effective_normal", &Dtool_CollisionSolid_set_effective_normal_11, METH_O, (const char *)Dtool_CollisionSolid_set_effective_normal_11_comment},
  {"setEffectiveNormal", &Dtool_CollisionSolid_set_effective_normal_11, METH_O, (const char *)Dtool_CollisionSolid_set_effective_normal_11_comment},
  {"clear_effective_normal", &Dtool_CollisionSolid_clear_effective_normal_12, METH_NOARGS, (const char *)Dtool_CollisionSolid_clear_effective_normal_12_comment},
  {"clearEffectiveNormal", &Dtool_CollisionSolid_clear_effective_normal_12, METH_NOARGS, (const char *)Dtool_CollisionSolid_clear_effective_normal_12_comment},
  {"has_effective_normal", &Dtool_CollisionSolid_has_effective_normal_13, METH_NOARGS, (const char *)Dtool_CollisionSolid_has_effective_normal_13_comment},
  {"hasEffectiveNormal", &Dtool_CollisionSolid_has_effective_normal_13, METH_NOARGS, (const char *)Dtool_CollisionSolid_has_effective_normal_13_comment},
  {"get_effective_normal", &Dtool_CollisionSolid_get_effective_normal_14, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_effective_normal_14_comment},
  {"getEffectiveNormal", &Dtool_CollisionSolid_get_effective_normal_14, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_effective_normal_14_comment},
  {"set_respect_effective_normal", &Dtool_CollisionSolid_set_respect_effective_normal_15, METH_O, (const char *)Dtool_CollisionSolid_set_respect_effective_normal_15_comment},
  {"setRespectEffectiveNormal", &Dtool_CollisionSolid_set_respect_effective_normal_15, METH_O, (const char *)Dtool_CollisionSolid_set_respect_effective_normal_15_comment},
  {"get_respect_effective_normal", &Dtool_CollisionSolid_get_respect_effective_normal_16, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_respect_effective_normal_16_comment},
  {"getRespectEffectiveNormal", &Dtool_CollisionSolid_get_respect_effective_normal_16, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_respect_effective_normal_16_comment},
  {"get_bounds", &Dtool_CollisionSolid_get_bounds_18, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_bounds_18_comment},
  {"getBounds", &Dtool_CollisionSolid_get_bounds_18, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_bounds_18_comment},
  {"set_bounds", &Dtool_CollisionSolid_set_bounds_19, METH_O, (const char *)Dtool_CollisionSolid_set_bounds_19_comment},
  {"setBounds", &Dtool_CollisionSolid_set_bounds_19, METH_O, (const char *)Dtool_CollisionSolid_set_bounds_19_comment},
  {"output", &Dtool_CollisionSolid_output_22, METH_O, (const char *)Dtool_CollisionSolid_output_22_comment},
  {"write", (PyCFunction) &Dtool_CollisionSolid_write_23, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSolid_write_23_comment},
  {"get_class_type", &Dtool_CollisionSolid_get_class_type_24, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSolid_get_class_type_24_comment},
  {"getClassType", &Dtool_CollisionSolid_get_class_type_24, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSolid_get_class_type_24_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     CollisionSolid
//////////////////
static PyObject *Dtool_Repr_CollisionSolid(PyObject *self) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CollisionSolid
//////////////////
static PyObject *Dtool_Str_CollisionSolid(PyObject *self) {
  CollisionSolid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_CollisionSolid[] = {
  {(char *)"collision_origin", &Dtool_CollisionSolid_collision_origin_Getter, NULL, NULL, NULL},
  {(char *)"tangible", &Dtool_CollisionSolid_tangible_Getter, &Dtool_CollisionSolid_tangible_Setter, NULL, NULL},
  {(char *)"respect_effective_normal", &Dtool_CollisionSolid_respect_effective_normal_Getter, &Dtool_CollisionSolid_respect_effective_normal_Setter, NULL, NULL},
  {(char *)"bounds", &Dtool_CollisionSolid_bounds_Getter, &Dtool_CollisionSolid_bounds_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionSolid = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionSolid = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionSolid = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionSolid = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionSolid = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionSolid",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionSolid,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_CollisionSolid,
    &Dtool_NumberMethods_CollisionSolid,
    &Dtool_SequenceMethods_CollisionSolid,
    &Dtool_MappingMethods_CollisionSolid,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_CollisionSolid,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionSolid,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract base class for all things that can collide with other things\n"
    " * in the world, and all the things they can collide with (except geometry).\n"
    " *\n"
    " * This class and its derivatives really work very similarly to the way\n"
    " * BoundingVolume and all of its derivatives work.  There's a different\n"
    " * subclass for each basic shape of solid, and double-dispatch function calls\n"
    " * handle the subset of the N*N intersection tests that we care about.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionSolid,
    0, // tp_members
    Dtool_Properties_CollisionSolid,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionSolid,
    PyType_GenericAlloc,
    Dtool_new_CollisionSolid,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionSolid,
  Dtool_UpcastInterface_CollisionSolid,
  Dtool_DowncastInterface_CollisionSolid,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionSolid(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CopyOnWriteObject != NULL);
    assert(Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit(NULL);
    Dtool_CollisionSolid._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CopyOnWriteObject);
    PyObject *dict = PyDict_New();
    Dtool_CollisionSolid._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionSolid) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionSolid)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionSolid);
  }
}

/**
 * Python method tables for CollisionBox (CollisionBox)
 */
static PyMethodDef Dtool_Methods_CollisionBox[] = {
  {"get_num_points", &Dtool_CollisionBox_get_num_points_27, METH_NOARGS, (const char *)Dtool_CollisionBox_get_num_points_27_comment},
  {"getNumPoints", &Dtool_CollisionBox_get_num_points_27, METH_NOARGS, (const char *)Dtool_CollisionBox_get_num_points_27_comment},
  {"get_point_aabb", &Dtool_CollisionBox_get_point_aabb_28, METH_O, (const char *)Dtool_CollisionBox_get_point_aabb_28_comment},
  {"getPointAabb", &Dtool_CollisionBox_get_point_aabb_28, METH_O, (const char *)Dtool_CollisionBox_get_point_aabb_28_comment},
  {"get_point", &Dtool_CollisionBox_get_point_29, METH_O, (const char *)Dtool_CollisionBox_get_point_29_comment},
  {"getPoint", &Dtool_CollisionBox_get_point_29, METH_O, (const char *)Dtool_CollisionBox_get_point_29_comment},
  {"get_num_planes", &Dtool_CollisionBox_get_num_planes_30, METH_NOARGS, (const char *)Dtool_CollisionBox_get_num_planes_30_comment},
  {"getNumPlanes", &Dtool_CollisionBox_get_num_planes_30, METH_NOARGS, (const char *)Dtool_CollisionBox_get_num_planes_30_comment},
  {"set_plane", &Dtool_CollisionBox_set_plane_31, METH_O, (const char *)Dtool_CollisionBox_set_plane_31_comment},
  {"setPlane", &Dtool_CollisionBox_set_plane_31, METH_O, (const char *)Dtool_CollisionBox_set_plane_31_comment},
  {"get_plane", &Dtool_CollisionBox_get_plane_32, METH_O, (const char *)Dtool_CollisionBox_get_plane_32_comment},
  {"getPlane", &Dtool_CollisionBox_get_plane_32, METH_O, (const char *)Dtool_CollisionBox_get_plane_32_comment},
  {"set_center", (PyCFunction) &Dtool_CollisionBox_set_center_33, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionBox_set_center_33_comment},
  {"setCenter", (PyCFunction) &Dtool_CollisionBox_set_center_33, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionBox_set_center_33_comment},
  {"get_center", &Dtool_CollisionBox_get_center_34, METH_NOARGS, (const char *)Dtool_CollisionBox_get_center_34_comment},
  {"getCenter", &Dtool_CollisionBox_get_center_34, METH_NOARGS, (const char *)Dtool_CollisionBox_get_center_34_comment},
  {"get_min", &Dtool_CollisionBox_get_min_35, METH_NOARGS, (const char *)Dtool_CollisionBox_get_min_35_comment},
  {"getMin", &Dtool_CollisionBox_get_min_35, METH_NOARGS, (const char *)Dtool_CollisionBox_get_min_35_comment},
  {"get_max", &Dtool_CollisionBox_get_max_36, METH_NOARGS, (const char *)Dtool_CollisionBox_get_max_36_comment},
  {"getMax", &Dtool_CollisionBox_get_max_36, METH_NOARGS, (const char *)Dtool_CollisionBox_get_max_36_comment},
  {"get_dimensions", &Dtool_CollisionBox_get_dimensions_37, METH_NOARGS, (const char *)Dtool_CollisionBox_get_dimensions_37_comment},
  {"getDimensions", &Dtool_CollisionBox_get_dimensions_37, METH_NOARGS, (const char *)Dtool_CollisionBox_get_dimensions_37_comment},
  {"get_class_type", &Dtool_CollisionBox_get_class_type_45, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionBox_get_class_type_45_comment},
  {"getClassType", &Dtool_CollisionBox_get_class_type_45, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionBox_get_class_type_45_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionBox[] = {
  {(char *)"center", &Dtool_CollisionBox_center_Getter, NULL, NULL, NULL},
  {(char *)"min", &Dtool_CollisionBox_min_Getter, NULL, NULL, NULL},
  {(char *)"max", &Dtool_CollisionBox_max_Getter, NULL, NULL, NULL},
  {(char *)"dimensions", &Dtool_CollisionBox_dimensions_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionBox = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionBox = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionBox = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionBox = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionBox = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionBox",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionBox,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionBox,
    &Dtool_SequenceMethods_CollisionBox,
    &Dtool_MappingMethods_CollisionBox,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionBox,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A cuboid collision volume or object.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionBox,
    0, // tp_members
    Dtool_Properties_CollisionBox,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionBox,
    PyType_GenericAlloc,
    Dtool_new_CollisionBox,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionBox,
  Dtool_UpcastInterface_CollisionBox,
  Dtool_DowncastInterface_CollisionBox,
  (CoerceFunction)Dtool_ConstCoerce_CollisionBox,
  (CoerceFunction)Dtool_Coerce_CollisionBox,
};

static void Dtool_PyModuleClassInit_CollisionBox(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(NULL);
    Dtool_CollisionBox._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    PyObject *dict = PyDict_New();
    Dtool_CollisionBox._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionBox) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionBox)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionBox);
  }
}

/**
 * Python method tables for CollisionHandler (CollisionHandler)
 */
static PyMethodDef Dtool_Methods_CollisionHandler[] = {
  {"get_class_type", &Dtool_CollisionHandler_get_class_type_49, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandler_get_class_type_49_comment},
  {"getClassType", &Dtool_CollisionHandler_get_class_type_49, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandler_get_class_type_49_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandler = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandler = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandler = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandler = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionHandler = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionHandler",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandler,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionHandler,
    &Dtool_SequenceMethods_CollisionHandler,
    &Dtool_MappingMethods_CollisionHandler,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionHandler,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract interface to a number of classes that decide what to do when a\n"
    " * collision is detected.  One of these must be assigned to the\n"
    " * CollisionTraverser that is processing collisions in order to specify how to\n"
    " * dispatch detected collisions.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionHandler,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionHandler,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandler,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandler,
  Dtool_UpcastInterface_CollisionHandler,
  Dtool_DowncastInterface_CollisionHandler,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionHandler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_CollisionHandler._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandler);
  }
}

/**
 * Python method tables for CollisionNode (CollisionNode)
 */
static PyMethodDef Dtool_Methods_CollisionNode[] = {
  {"set_collide_mask", &Dtool_CollisionNode_set_collide_mask_55, METH_O, (const char *)Dtool_CollisionNode_set_collide_mask_55_comment},
  {"setCollideMask", &Dtool_CollisionNode_set_collide_mask_55, METH_O, (const char *)Dtool_CollisionNode_set_collide_mask_55_comment},
  {"set_from_collide_mask", &Dtool_CollisionNode_set_from_collide_mask_56, METH_O, (const char *)Dtool_CollisionNode_set_from_collide_mask_56_comment},
  {"setFromCollideMask", &Dtool_CollisionNode_set_from_collide_mask_56, METH_O, (const char *)Dtool_CollisionNode_set_from_collide_mask_56_comment},
  {"set_into_collide_mask", &Dtool_CollisionNode_set_into_collide_mask_57, METH_O, (const char *)Dtool_CollisionNode_set_into_collide_mask_57_comment},
  {"setIntoCollideMask", &Dtool_CollisionNode_set_into_collide_mask_57, METH_O, (const char *)Dtool_CollisionNode_set_into_collide_mask_57_comment},
  {"get_from_collide_mask", &Dtool_CollisionNode_get_from_collide_mask_58, METH_NOARGS, (const char *)Dtool_CollisionNode_get_from_collide_mask_58_comment},
  {"getFromCollideMask", &Dtool_CollisionNode_get_from_collide_mask_58, METH_NOARGS, (const char *)Dtool_CollisionNode_get_from_collide_mask_58_comment},
  {"get_into_collide_mask", &Dtool_CollisionNode_get_into_collide_mask_59, METH_NOARGS, (const char *)Dtool_CollisionNode_get_into_collide_mask_59_comment},
  {"getIntoCollideMask", &Dtool_CollisionNode_get_into_collide_mask_59, METH_NOARGS, (const char *)Dtool_CollisionNode_get_into_collide_mask_59_comment},
  {"clear_solids", &Dtool_CollisionNode_clear_solids_65, METH_NOARGS, (const char *)Dtool_CollisionNode_clear_solids_65_comment},
  {"clearSolids", &Dtool_CollisionNode_clear_solids_65, METH_NOARGS, (const char *)Dtool_CollisionNode_clear_solids_65_comment},
  {"get_num_solids", &Dtool_CollisionNode_get_num_solids_66, METH_NOARGS, (const char *)Dtool_CollisionNode_get_num_solids_66_comment},
  {"getNumSolids", &Dtool_CollisionNode_get_num_solids_66, METH_NOARGS, (const char *)Dtool_CollisionNode_get_num_solids_66_comment},
  {"get_solid", &Dtool_CollisionNode_get_solid_67, METH_O, (const char *)Dtool_CollisionNode_get_solid_67_comment},
  {"getSolid", &Dtool_CollisionNode_get_solid_67, METH_O, (const char *)Dtool_CollisionNode_get_solid_67_comment},
  {"modify_solid", &Dtool_CollisionNode_modify_solid_69, METH_O, (const char *)Dtool_CollisionNode_modify_solid_69_comment},
  {"modifySolid", &Dtool_CollisionNode_modify_solid_69, METH_O, (const char *)Dtool_CollisionNode_modify_solid_69_comment},
  {"set_solid", (PyCFunction) &Dtool_CollisionNode_set_solid_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionNode_set_solid_70_comment},
  {"setSolid", (PyCFunction) &Dtool_CollisionNode_set_solid_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionNode_set_solid_70_comment},
  {"remove_solid", &Dtool_CollisionNode_remove_solid_71, METH_O, (const char *)Dtool_CollisionNode_remove_solid_71_comment},
  {"removeSolid", &Dtool_CollisionNode_remove_solid_71, METH_O, (const char *)Dtool_CollisionNode_remove_solid_71_comment},
  {"add_solid", &Dtool_CollisionNode_add_solid_72, METH_O, (const char *)Dtool_CollisionNode_add_solid_72_comment},
  {"addSolid", &Dtool_CollisionNode_add_solid_72, METH_O, (const char *)Dtool_CollisionNode_add_solid_72_comment},
  {"get_collider_sort", &Dtool_CollisionNode_get_collider_sort_75, METH_NOARGS, (const char *)Dtool_CollisionNode_get_collider_sort_75_comment},
  {"getColliderSort", &Dtool_CollisionNode_get_collider_sort_75, METH_NOARGS, (const char *)Dtool_CollisionNode_get_collider_sort_75_comment},
  {"set_collider_sort", &Dtool_CollisionNode_set_collider_sort_76, METH_O, (const char *)Dtool_CollisionNode_set_collider_sort_76_comment},
  {"setColliderSort", &Dtool_CollisionNode_set_collider_sort_76, METH_O, (const char *)Dtool_CollisionNode_set_collider_sort_76_comment},
  {"get_default_collide_mask", &Dtool_CollisionNode_get_default_collide_mask_79, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionNode_get_default_collide_mask_79_comment},
  {"getDefaultCollideMask", &Dtool_CollisionNode_get_default_collide_mask_79, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionNode_get_default_collide_mask_79_comment},
  {"get_class_type", &Dtool_CollisionNode_get_class_type_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionNode_get_class_type_80_comment},
  {"getClassType", &Dtool_CollisionNode_get_class_type_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionNode_get_class_type_80_comment},
  {"get_solids", (PyCFunction) &MakeSeq_CollisionNode_get_solids, METH_NOARGS, NULL},
  { "getSolids", (PyCFunction) &MakeSeq_CollisionNode_get_solids, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionNode[] = {
  {(char *)"from_collide_mask", &Dtool_CollisionNode_from_collide_mask_Getter, &Dtool_CollisionNode_from_collide_mask_Setter, NULL, NULL},
  {(char *)"into_collide_mask", &Dtool_CollisionNode_into_collide_mask_Getter, &Dtool_CollisionNode_into_collide_mask_Setter, NULL, NULL},
  {(char *)"solids", &Dtool_CollisionNode_solids_Getter, NULL, NULL, NULL},
  {(char *)"collider_sort", &Dtool_CollisionNode_collider_sort_Getter, &Dtool_CollisionNode_collider_sort_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionNode,
    &Dtool_SequenceMethods_CollisionNode,
    &Dtool_MappingMethods_CollisionNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node in the scene graph that can hold any number of CollisionSolids.\n"
    " * This may either represent a bit of static geometry in the scene that things\n"
    " * will collide with, or an animated object twirling around in the world and\n"
    " * running into things.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionNode,
    0, // tp_members
    Dtool_Properties_CollisionNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionNode,
    PyType_GenericAlloc,
    Dtool_new_CollisionNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionNode,
  Dtool_UpcastInterface_CollisionNode,
  Dtool_DowncastInterface_CollisionNode,
  (CoerceFunction)Dtool_ConstCoerce_CollisionNode,
  (CoerceFunction)Dtool_Coerce_CollisionNode,
};

static void Dtool_PyModuleClassInit_CollisionNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_CollisionNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_CollisionNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionNode);
  }
}

/**
 * Python method tables for CollisionTraverser (CollisionTraverser)
 */
static PyMethodDef Dtool_Methods_CollisionTraverser[] = {
  {"set_respect_prev_transform", &Dtool_CollisionTraverser_set_respect_prev_transform_85, METH_O, (const char *)Dtool_CollisionTraverser_set_respect_prev_transform_85_comment},
  {"setRespectPrevTransform", &Dtool_CollisionTraverser_set_respect_prev_transform_85, METH_O, (const char *)Dtool_CollisionTraverser_set_respect_prev_transform_85_comment},
  {"get_respect_prev_transform", &Dtool_CollisionTraverser_get_respect_prev_transform_86, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_respect_prev_transform_86_comment},
  {"getRespectPrevTransform", &Dtool_CollisionTraverser_get_respect_prev_transform_86, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_respect_prev_transform_86_comment},
  {"add_collider", (PyCFunction) &Dtool_CollisionTraverser_add_collider_88, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionTraverser_add_collider_88_comment},
  {"addCollider", (PyCFunction) &Dtool_CollisionTraverser_add_collider_88, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionTraverser_add_collider_88_comment},
  {"remove_collider", &Dtool_CollisionTraverser_remove_collider_89, METH_O, (const char *)Dtool_CollisionTraverser_remove_collider_89_comment},
  {"removeCollider", &Dtool_CollisionTraverser_remove_collider_89, METH_O, (const char *)Dtool_CollisionTraverser_remove_collider_89_comment},
  {"has_collider", &Dtool_CollisionTraverser_has_collider_90, METH_O, (const char *)Dtool_CollisionTraverser_has_collider_90_comment},
  {"hasCollider", &Dtool_CollisionTraverser_has_collider_90, METH_O, (const char *)Dtool_CollisionTraverser_has_collider_90_comment},
  {"get_num_colliders", &Dtool_CollisionTraverser_get_num_colliders_91, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_num_colliders_91_comment},
  {"getNumColliders", &Dtool_CollisionTraverser_get_num_colliders_91, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_num_colliders_91_comment},
  {"get_collider", &Dtool_CollisionTraverser_get_collider_92, METH_O, (const char *)Dtool_CollisionTraverser_get_collider_92_comment},
  {"getCollider", &Dtool_CollisionTraverser_get_collider_92, METH_O, (const char *)Dtool_CollisionTraverser_get_collider_92_comment},
  {"get_handler", &Dtool_CollisionTraverser_get_handler_94, METH_O, (const char *)Dtool_CollisionTraverser_get_handler_94_comment},
  {"getHandler", &Dtool_CollisionTraverser_get_handler_94, METH_O, (const char *)Dtool_CollisionTraverser_get_handler_94_comment},
  {"clear_colliders", &Dtool_CollisionTraverser_clear_colliders_95, METH_NOARGS, (const char *)Dtool_CollisionTraverser_clear_colliders_95_comment},
  {"clearColliders", &Dtool_CollisionTraverser_clear_colliders_95, METH_NOARGS, (const char *)Dtool_CollisionTraverser_clear_colliders_95_comment},
  {"traverse", &Dtool_CollisionTraverser_traverse_98, METH_O, (const char *)Dtool_CollisionTraverser_traverse_98_comment},
  {"set_recorder", &Dtool_CollisionTraverser_set_recorder_99, METH_O, (const char *)Dtool_CollisionTraverser_set_recorder_99_comment},
  {"setRecorder", &Dtool_CollisionTraverser_set_recorder_99, METH_O, (const char *)Dtool_CollisionTraverser_set_recorder_99_comment},
  {"has_recorder", &Dtool_CollisionTraverser_has_recorder_100, METH_NOARGS, (const char *)Dtool_CollisionTraverser_has_recorder_100_comment},
  {"hasRecorder", &Dtool_CollisionTraverser_has_recorder_100, METH_NOARGS, (const char *)Dtool_CollisionTraverser_has_recorder_100_comment},
  {"get_recorder", &Dtool_CollisionTraverser_get_recorder_101, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_recorder_101_comment},
  {"getRecorder", &Dtool_CollisionTraverser_get_recorder_101, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_recorder_101_comment},
  {"clear_recorder", &Dtool_CollisionTraverser_clear_recorder_102, METH_NOARGS, (const char *)Dtool_CollisionTraverser_clear_recorder_102_comment},
  {"clearRecorder", &Dtool_CollisionTraverser_clear_recorder_102, METH_NOARGS, (const char *)Dtool_CollisionTraverser_clear_recorder_102_comment},
  {"show_collisions", &Dtool_CollisionTraverser_show_collisions_110, METH_O, (const char *)Dtool_CollisionTraverser_show_collisions_110_comment},
  {"showCollisions", &Dtool_CollisionTraverser_show_collisions_110, METH_O, (const char *)Dtool_CollisionTraverser_show_collisions_110_comment},
  {"hide_collisions", &Dtool_CollisionTraverser_hide_collisions_111, METH_NOARGS, (const char *)Dtool_CollisionTraverser_hide_collisions_111_comment},
  {"hideCollisions", &Dtool_CollisionTraverser_hide_collisions_111, METH_NOARGS, (const char *)Dtool_CollisionTraverser_hide_collisions_111_comment},
  {"output", &Dtool_CollisionTraverser_output_112, METH_O, (const char *)Dtool_CollisionTraverser_output_112_comment},
  {"write", (PyCFunction) &Dtool_CollisionTraverser_write_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionTraverser_write_113_comment},
  {"get_class_type", &Dtool_CollisionTraverser_get_class_type_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionTraverser_get_class_type_114_comment},
  {"getClassType", &Dtool_CollisionTraverser_get_class_type_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionTraverser_get_class_type_114_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_colliders", (PyCFunction) &MakeSeq_CollisionTraverser_get_colliders, METH_NOARGS, NULL},
  { "getColliders", (PyCFunction) &MakeSeq_CollisionTraverser_get_colliders, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     CollisionTraverser
//////////////////
static PyObject *Dtool_Repr_CollisionTraverser(PyObject *self) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CollisionTraverser
//////////////////
static PyObject *Dtool_Str_CollisionTraverser(PyObject *self) {
  CollisionTraverser *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_CollisionTraverser[] = {
  {(char *)"respect_preV_transform", &Dtool_CollisionTraverser_respect_preV_transform_Getter, &Dtool_CollisionTraverser_respect_preV_transform_Setter, NULL, NULL},
  {(char *)"colliders", &Dtool_CollisionTraverser_colliders_Getter, NULL, NULL, NULL},
  {(char *)"recorder", &Dtool_CollisionTraverser_recorder_Getter, &Dtool_CollisionTraverser_recorder_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionTraverser = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionTraverser = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionTraverser = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionTraverser = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionTraverser = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionTraverser",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionTraverser,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_CollisionTraverser,
    &Dtool_NumberMethods_CollisionTraverser,
    &Dtool_SequenceMethods_CollisionTraverser,
    &Dtool_MappingMethods_CollisionTraverser,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_CollisionTraverser,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionTraverser,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class manages the traversal through the scene graph to detect\n"
    " * collisions.  It holds ownership of a number of collider objects, each of\n"
    " * which is a CollisionNode and an associated CollisionHandler.\n"
    " *\n"
    " * When traverse() is called, it begins at the indicated root and detects all\n"
    " * collisions with any of its collider objects against nodes at or below the\n"
    " * indicated root, calling the appropriate CollisionHandler for each detected\n"
    " * collision.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionTraverser,
    0, // tp_members
    Dtool_Properties_CollisionTraverser,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionTraverser,
    PyType_GenericAlloc,
    Dtool_new_CollisionTraverser,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionTraverser,
  Dtool_UpcastInterface_CollisionTraverser,
  Dtool_DowncastInterface_CollisionTraverser,
  (CoerceFunction)Dtool_ConstCoerce_CollisionTraverser,
  (CoerceFunction)Dtool_Coerce_CollisionTraverser,
};

static void Dtool_PyModuleClassInit_CollisionTraverser(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_CollisionTraverser._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_CollisionTraverser._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionTraverser) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionTraverser)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionTraverser);
  }
}

/**
 * Python method tables for CollisionRecorder (CollisionRecorder)
 */
static PyMethodDef Dtool_Methods_CollisionRecorder[] = {
  {"output", &Dtool_CollisionRecorder_output_107, METH_O, (const char *)Dtool_CollisionRecorder_output_107_comment},
  {"get_class_type", &Dtool_CollisionRecorder_get_class_type_108, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionRecorder_get_class_type_108_comment},
  {"getClassType", &Dtool_CollisionRecorder_get_class_type_108, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionRecorder_get_class_type_108_comment},
  {"downcast_to_CollisionVisualizer", &Dtool_CollisionRecorder_downcast_to_CollisionVisualizer_390, METH_NOARGS, (const char *)Dtool_CollisionRecorder_downcast_to_CollisionVisualizer_390_comment},
  {"downcastToCollisionVisualizer", &Dtool_CollisionRecorder_downcast_to_CollisionVisualizer_390, METH_NOARGS, (const char *)Dtool_CollisionRecorder_downcast_to_CollisionVisualizer_390_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     CollisionRecorder
//////////////////
static PyObject *Dtool_Repr_CollisionRecorder(PyObject *self) {
  CollisionRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionRecorder, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_CollisionRecorder = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionRecorder = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionRecorder = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionRecorder = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionRecorder = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionRecorder",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionRecorder,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_CollisionRecorder,
    &Dtool_NumberMethods_CollisionRecorder,
    &Dtool_SequenceMethods_CollisionRecorder,
    &Dtool_MappingMethods_CollisionRecorder,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_CollisionRecorder,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionRecorder,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to help debug the work the collisions system is doing.\n"
    " * It is a virtual base class that just provides an interface for recording\n"
    " * collisions tested and detected each frame.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionRecorder,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionRecorder,
    PyType_GenericAlloc,
    Dtool_new_CollisionRecorder,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionRecorder,
  Dtool_UpcastInterface_CollisionRecorder,
  Dtool_DowncastInterface_CollisionRecorder,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionRecorder(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_CollisionRecorder._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_CollisionRecorder._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionRecorder) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionRecorder)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionRecorder);
  }
}

/**
 * Python method tables for CollisionEntry (CollisionEntry)
 */
static PyMethodDef Dtool_Methods_CollisionEntry[] = {
  {"get_from", &Dtool_CollisionEntry_get_from_117, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_117_comment},
  {"getFrom", &Dtool_CollisionEntry_get_from_117, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_117_comment},
  {"has_into", &Dtool_CollisionEntry_has_into_118, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_into_118_comment},
  {"hasInto", &Dtool_CollisionEntry_has_into_118, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_into_118_comment},
  {"get_into", &Dtool_CollisionEntry_get_into_119, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_119_comment},
  {"getInto", &Dtool_CollisionEntry_get_into_119, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_119_comment},
  {"get_from_node", &Dtool_CollisionEntry_get_from_node_120, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_node_120_comment},
  {"getFromNode", &Dtool_CollisionEntry_get_from_node_120, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_node_120_comment},
  {"get_into_node", &Dtool_CollisionEntry_get_into_node_121, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_node_121_comment},
  {"getIntoNode", &Dtool_CollisionEntry_get_into_node_121, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_node_121_comment},
  {"get_from_node_path", &Dtool_CollisionEntry_get_from_node_path_122, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_node_path_122_comment},
  {"getFromNodePath", &Dtool_CollisionEntry_get_from_node_path_122, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_node_path_122_comment},
  {"get_into_node_path", &Dtool_CollisionEntry_get_into_node_path_123, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_node_path_123_comment},
  {"getIntoNodePath", &Dtool_CollisionEntry_get_into_node_path_123, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_node_path_123_comment},
  {"set_t", &Dtool_CollisionEntry_set_t_124, METH_O, (const char *)Dtool_CollisionEntry_set_t_124_comment},
  {"setT", &Dtool_CollisionEntry_set_t_124, METH_O, (const char *)Dtool_CollisionEntry_set_t_124_comment},
  {"get_t", &Dtool_CollisionEntry_get_t_125, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_t_125_comment},
  {"getT", &Dtool_CollisionEntry_get_t_125, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_t_125_comment},
  {"collided", &Dtool_CollisionEntry_collided_126, METH_NOARGS, (const char *)Dtool_CollisionEntry_collided_126_comment},
  {"reset_collided", &Dtool_CollisionEntry_reset_collided_127, METH_NOARGS, (const char *)Dtool_CollisionEntry_reset_collided_127_comment},
  {"resetCollided", &Dtool_CollisionEntry_reset_collided_127, METH_NOARGS, (const char *)Dtool_CollisionEntry_reset_collided_127_comment},
  {"get_respect_prev_transform", &Dtool_CollisionEntry_get_respect_prev_transform_128, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_respect_prev_transform_128_comment},
  {"getRespectPrevTransform", &Dtool_CollisionEntry_get_respect_prev_transform_128, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_respect_prev_transform_128_comment},
  {"set_surface_point", &Dtool_CollisionEntry_set_surface_point_129, METH_O, (const char *)Dtool_CollisionEntry_set_surface_point_129_comment},
  {"setSurfacePoint", &Dtool_CollisionEntry_set_surface_point_129, METH_O, (const char *)Dtool_CollisionEntry_set_surface_point_129_comment},
  {"set_surface_normal", &Dtool_CollisionEntry_set_surface_normal_130, METH_O, (const char *)Dtool_CollisionEntry_set_surface_normal_130_comment},
  {"setSurfaceNormal", &Dtool_CollisionEntry_set_surface_normal_130, METH_O, (const char *)Dtool_CollisionEntry_set_surface_normal_130_comment},
  {"set_interior_point", &Dtool_CollisionEntry_set_interior_point_131, METH_O, (const char *)Dtool_CollisionEntry_set_interior_point_131_comment},
  {"setInteriorPoint", &Dtool_CollisionEntry_set_interior_point_131, METH_O, (const char *)Dtool_CollisionEntry_set_interior_point_131_comment},
  {"has_surface_point", &Dtool_CollisionEntry_has_surface_point_132, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_surface_point_132_comment},
  {"hasSurfacePoint", &Dtool_CollisionEntry_has_surface_point_132, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_surface_point_132_comment},
  {"has_surface_normal", &Dtool_CollisionEntry_has_surface_normal_133, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_surface_normal_133_comment},
  {"hasSurfaceNormal", &Dtool_CollisionEntry_has_surface_normal_133, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_surface_normal_133_comment},
  {"has_interior_point", &Dtool_CollisionEntry_has_interior_point_134, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_interior_point_134_comment},
  {"hasInteriorPoint", &Dtool_CollisionEntry_has_interior_point_134, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_interior_point_134_comment},
  {"set_contact_pos", &Dtool_CollisionEntry_set_contact_pos_135, METH_O, (const char *)Dtool_CollisionEntry_set_contact_pos_135_comment},
  {"setContactPos", &Dtool_CollisionEntry_set_contact_pos_135, METH_O, (const char *)Dtool_CollisionEntry_set_contact_pos_135_comment},
  {"set_contact_normal", &Dtool_CollisionEntry_set_contact_normal_136, METH_O, (const char *)Dtool_CollisionEntry_set_contact_normal_136_comment},
  {"setContactNormal", &Dtool_CollisionEntry_set_contact_normal_136, METH_O, (const char *)Dtool_CollisionEntry_set_contact_normal_136_comment},
  {"has_contact_pos", &Dtool_CollisionEntry_has_contact_pos_137, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_contact_pos_137_comment},
  {"hasContactPos", &Dtool_CollisionEntry_has_contact_pos_137, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_contact_pos_137_comment},
  {"has_contact_normal", &Dtool_CollisionEntry_has_contact_normal_138, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_contact_normal_138_comment},
  {"hasContactNormal", &Dtool_CollisionEntry_has_contact_normal_138, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_contact_normal_138_comment},
  {"get_surface_point", &Dtool_CollisionEntry_get_surface_point_139, METH_O, (const char *)Dtool_CollisionEntry_get_surface_point_139_comment},
  {"getSurfacePoint", &Dtool_CollisionEntry_get_surface_point_139, METH_O, (const char *)Dtool_CollisionEntry_get_surface_point_139_comment},
  {"get_surface_normal", &Dtool_CollisionEntry_get_surface_normal_140, METH_O, (const char *)Dtool_CollisionEntry_get_surface_normal_140_comment},
  {"getSurfaceNormal", &Dtool_CollisionEntry_get_surface_normal_140, METH_O, (const char *)Dtool_CollisionEntry_get_surface_normal_140_comment},
  {"get_interior_point", &Dtool_CollisionEntry_get_interior_point_141, METH_O, (const char *)Dtool_CollisionEntry_get_interior_point_141_comment},
  {"getInteriorPoint", &Dtool_CollisionEntry_get_interior_point_141, METH_O, (const char *)Dtool_CollisionEntry_get_interior_point_141_comment},
  {"get_all", (PyCFunction) &Dtool_CollisionEntry_get_all_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionEntry_get_all_142_comment},
  {"getAll", (PyCFunction) &Dtool_CollisionEntry_get_all_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionEntry_get_all_142_comment},
  {"get_contact_pos", &Dtool_CollisionEntry_get_contact_pos_143, METH_O, (const char *)Dtool_CollisionEntry_get_contact_pos_143_comment},
  {"getContactPos", &Dtool_CollisionEntry_get_contact_pos_143, METH_O, (const char *)Dtool_CollisionEntry_get_contact_pos_143_comment},
  {"get_contact_normal", &Dtool_CollisionEntry_get_contact_normal_144, METH_O, (const char *)Dtool_CollisionEntry_get_contact_normal_144_comment},
  {"getContactNormal", &Dtool_CollisionEntry_get_contact_normal_144, METH_O, (const char *)Dtool_CollisionEntry_get_contact_normal_144_comment},
  {"get_all_contact_info", (PyCFunction) &Dtool_CollisionEntry_get_all_contact_info_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionEntry_get_all_contact_info_145_comment},
  {"getAllContactInfo", (PyCFunction) &Dtool_CollisionEntry_get_all_contact_info_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionEntry_get_all_contact_info_145_comment},
  {"output", &Dtool_CollisionEntry_output_146, METH_O, (const char *)Dtool_CollisionEntry_output_146_comment},
  {"write", (PyCFunction) &Dtool_CollisionEntry_write_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionEntry_write_147_comment},
  {"get_class_type", &Dtool_CollisionEntry_get_class_type_162, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionEntry_get_class_type_162_comment},
  {"getClassType", &Dtool_CollisionEntry_get_class_type_162, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionEntry_get_class_type_162_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     CollisionEntry
//////////////////
static PyObject *Dtool_Repr_CollisionEntry(PyObject *self) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CollisionEntry
//////////////////
static PyObject *Dtool_Str_CollisionEntry(PyObject *self) {
  CollisionEntry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_CollisionEntry[] = {
  {(char *)"from_solid", &Dtool_CollisionEntry_from_solid_Getter, NULL, NULL, NULL},
  {(char *)"into_solid", &Dtool_CollisionEntry_into_solid_Getter, NULL, NULL, NULL},
  {(char *)"from_node", &Dtool_CollisionEntry_from_node_Getter, NULL, NULL, NULL},
  {(char *)"into_node", &Dtool_CollisionEntry_into_node_Getter, NULL, NULL, NULL},
  {(char *)"from_node_path", &Dtool_CollisionEntry_from_node_path_Getter, NULL, NULL, NULL},
  {(char *)"into_node_path", &Dtool_CollisionEntry_into_node_path_Getter, NULL, NULL, NULL},
  {(char *)"t", &Dtool_CollisionEntry_t_Getter, &Dtool_CollisionEntry_t_Setter, NULL, NULL},
  {(char *)"respect_prev_transform", &Dtool_CollisionEntry_respect_prev_transform_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionEntry = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionEntry = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionEntry = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionEntry = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionEntry = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionEntry",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionEntry,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_CollisionEntry,
    &Dtool_NumberMethods_CollisionEntry,
    &Dtool_SequenceMethods_CollisionEntry,
    &Dtool_MappingMethods_CollisionEntry,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_CollisionEntry,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionEntry,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a single collision event.  One of these is created for each\n"
    " * collision detected by a CollisionTraverser, to be dealt with by the\n"
    " * CollisionHandler.\n"
    " *\n"
    " * A CollisionEntry provides slots for a number of data values (such as\n"
    " * intersection point and normal) that might or might not be known for each\n"
    " * collision.  It is up to the handler to determine what information is known\n"
    " * and to do the right thing with it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionEntry,
    0, // tp_members
    Dtool_Properties_CollisionEntry,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionEntry,
    PyType_GenericAlloc,
    Dtool_new_CollisionEntry,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionEntry,
  Dtool_UpcastInterface_CollisionEntry,
  Dtool_DowncastInterface_CollisionEntry,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionEntry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != NULL);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_CollisionEntry._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_CollisionEntry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionEntry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionEntry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionEntry);
  }
}

/**
 * Python method tables for CollisionPlane (CollisionPlane)
 */
static PyMethodDef Dtool_Methods_CollisionPlane[] = {
  {"get_normal", &Dtool_CollisionPlane_get_normal_166, METH_NOARGS, (const char *)Dtool_CollisionPlane_get_normal_166_comment},
  {"getNormal", &Dtool_CollisionPlane_get_normal_166, METH_NOARGS, (const char *)Dtool_CollisionPlane_get_normal_166_comment},
  {"dist_to_plane", &Dtool_CollisionPlane_dist_to_plane_167, METH_O, (const char *)Dtool_CollisionPlane_dist_to_plane_167_comment},
  {"distToPlane", &Dtool_CollisionPlane_dist_to_plane_167, METH_O, (const char *)Dtool_CollisionPlane_dist_to_plane_167_comment},
  {"set_plane", &Dtool_CollisionPlane_set_plane_168, METH_O, (const char *)Dtool_CollisionPlane_set_plane_168_comment},
  {"setPlane", &Dtool_CollisionPlane_set_plane_168, METH_O, (const char *)Dtool_CollisionPlane_set_plane_168_comment},
  {"get_plane", &Dtool_CollisionPlane_get_plane_169, METH_NOARGS, (const char *)Dtool_CollisionPlane_get_plane_169_comment},
  {"getPlane", &Dtool_CollisionPlane_get_plane_169, METH_NOARGS, (const char *)Dtool_CollisionPlane_get_plane_169_comment},
  {"flip", &Dtool_CollisionPlane_flip_170, METH_NOARGS, (const char *)Dtool_CollisionPlane_flip_170_comment},
  {"get_class_type", &Dtool_CollisionPlane_get_class_type_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionPlane_get_class_type_176_comment},
  {"getClassType", &Dtool_CollisionPlane_get_class_type_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionPlane_get_class_type_176_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionPlane[] = {
  {(char *)"normal", &Dtool_CollisionPlane_normal_Getter, NULL, NULL, NULL},
  {(char *)"plane", &Dtool_CollisionPlane_plane_Getter, &Dtool_CollisionPlane_plane_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionPlane = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionPlane = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionPlane = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionPlane = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionPlane = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionPlane",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionPlane,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionPlane,
    &Dtool_SequenceMethods_CollisionPlane,
    &Dtool_MappingMethods_CollisionPlane,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionPlane,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionPlane,
    0, // tp_members
    Dtool_Properties_CollisionPlane,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionPlane,
    PyType_GenericAlloc,
    Dtool_new_CollisionPlane,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionPlane,
  Dtool_UpcastInterface_CollisionPlane,
  Dtool_DowncastInterface_CollisionPlane,
  (CoerceFunction)Dtool_ConstCoerce_CollisionPlane,
  (CoerceFunction)Dtool_Coerce_CollisionPlane,
};

static void Dtool_PyModuleClassInit_CollisionPlane(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(NULL);
    Dtool_CollisionPlane._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    PyObject *dict = PyDict_New();
    Dtool_CollisionPlane._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionPlane) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionPlane)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionPlane);
  }
}

/**
 * Python method tables for CollisionFloorMesh (CollisionFloorMesh)
 */
static PyMethodDef Dtool_Methods_CollisionFloorMesh[] = {
  {"add_vertex", &Dtool_CollisionFloorMesh_add_vertex_180, METH_O, (const char *)Dtool_CollisionFloorMesh_add_vertex_180_comment},
  {"addVertex", &Dtool_CollisionFloorMesh_add_vertex_180, METH_O, (const char *)Dtool_CollisionFloorMesh_add_vertex_180_comment},
  {"add_triangle", (PyCFunction) &Dtool_CollisionFloorMesh_add_triangle_181, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionFloorMesh_add_triangle_181_comment},
  {"addTriangle", (PyCFunction) &Dtool_CollisionFloorMesh_add_triangle_181, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionFloorMesh_add_triangle_181_comment},
  {"get_num_vertices", &Dtool_CollisionFloorMesh_get_num_vertices_182, METH_NOARGS, (const char *)Dtool_CollisionFloorMesh_get_num_vertices_182_comment},
  {"getNumVertices", &Dtool_CollisionFloorMesh_get_num_vertices_182, METH_NOARGS, (const char *)Dtool_CollisionFloorMesh_get_num_vertices_182_comment},
  {"get_vertex", &Dtool_CollisionFloorMesh_get_vertex_183, METH_O, (const char *)Dtool_CollisionFloorMesh_get_vertex_183_comment},
  {"getVertex", &Dtool_CollisionFloorMesh_get_vertex_183, METH_O, (const char *)Dtool_CollisionFloorMesh_get_vertex_183_comment},
  {"get_num_triangles", &Dtool_CollisionFloorMesh_get_num_triangles_185, METH_NOARGS, (const char *)Dtool_CollisionFloorMesh_get_num_triangles_185_comment},
  {"getNumTriangles", &Dtool_CollisionFloorMesh_get_num_triangles_185, METH_NOARGS, (const char *)Dtool_CollisionFloorMesh_get_num_triangles_185_comment},
  {"get_triangle", &Dtool_CollisionFloorMesh_get_triangle_186, METH_O, (const char *)Dtool_CollisionFloorMesh_get_triangle_186_comment},
  {"getTriangle", &Dtool_CollisionFloorMesh_get_triangle_186, METH_O, (const char *)Dtool_CollisionFloorMesh_get_triangle_186_comment},
  {"get_class_type", &Dtool_CollisionFloorMesh_get_class_type_191, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionFloorMesh_get_class_type_191_comment},
  {"getClassType", &Dtool_CollisionFloorMesh_get_class_type_191, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionFloorMesh_get_class_type_191_comment},
  {"get_vertices", (PyCFunction) &MakeSeq_CollisionFloorMesh_get_vertices, METH_NOARGS, NULL},
  { "getVertices", (PyCFunction) &MakeSeq_CollisionFloorMesh_get_vertices, METH_NOARGS, NULL},
  {"get_triangles", (PyCFunction) &MakeSeq_CollisionFloorMesh_get_triangles, METH_NOARGS, NULL},
  { "getTriangles", (PyCFunction) &MakeSeq_CollisionFloorMesh_get_triangles, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionFloorMesh[] = {
  {(char *)"vertices", &Dtool_CollisionFloorMesh_vertices_Getter, NULL, NULL, NULL},
  {(char *)"triangles", &Dtool_CollisionFloorMesh_triangles_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionFloorMesh = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionFloorMesh = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionFloorMesh = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionFloorMesh = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionFloorMesh = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionFloorMesh",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionFloorMesh,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionFloorMesh,
    &Dtool_SequenceMethods_CollisionFloorMesh,
    &Dtool_MappingMethods_CollisionFloorMesh,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionFloorMesh,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object represents a solid made entirely of triangles, which will only\n"
    " * be tested again z axis aligned rays\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionFloorMesh,
    0, // tp_members
    Dtool_Properties_CollisionFloorMesh,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionFloorMesh,
    PyType_GenericAlloc,
    Dtool_new_CollisionFloorMesh,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionFloorMesh,
  Dtool_UpcastInterface_CollisionFloorMesh,
  Dtool_DowncastInterface_CollisionFloorMesh,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionFloorMesh(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(NULL);
    Dtool_CollisionFloorMesh._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    PyObject *dict = PyDict_New();
    Dtool_CollisionFloorMesh._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionFloorMesh) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionFloorMesh)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionFloorMesh);
  }
}

/**
 * Python method tables for CollisionPolygon (CollisionPolygon)
 */
static PyMethodDef Dtool_Methods_CollisionPolygon[] = {
  {"get_num_points", &Dtool_CollisionPolygon_get_num_points_195, METH_NOARGS, (const char *)Dtool_CollisionPolygon_get_num_points_195_comment},
  {"getNumPoints", &Dtool_CollisionPolygon_get_num_points_195, METH_NOARGS, (const char *)Dtool_CollisionPolygon_get_num_points_195_comment},
  {"get_point", &Dtool_CollisionPolygon_get_point_196, METH_O, (const char *)Dtool_CollisionPolygon_get_point_196_comment},
  {"getPoint", &Dtool_CollisionPolygon_get_point_196, METH_O, (const char *)Dtool_CollisionPolygon_get_point_196_comment},
  {"verify_points", (PyCFunction) &Dtool_CollisionPolygon_verify_points_198, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_CollisionPolygon_verify_points_198_comment},
  {"verifyPoints", (PyCFunction) &Dtool_CollisionPolygon_verify_points_198, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_CollisionPolygon_verify_points_198_comment},
  {"is_valid", &Dtool_CollisionPolygon_is_valid_199, METH_NOARGS, (const char *)Dtool_CollisionPolygon_is_valid_199_comment},
  {"isValid", &Dtool_CollisionPolygon_is_valid_199, METH_NOARGS, (const char *)Dtool_CollisionPolygon_is_valid_199_comment},
  {"is_concave", &Dtool_CollisionPolygon_is_concave_200, METH_NOARGS, (const char *)Dtool_CollisionPolygon_is_concave_200_comment},
  {"isConcave", &Dtool_CollisionPolygon_is_concave_200, METH_NOARGS, (const char *)Dtool_CollisionPolygon_is_concave_200_comment},
  {"get_class_type", &Dtool_CollisionPolygon_get_class_type_204, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionPolygon_get_class_type_204_comment},
  {"getClassType", &Dtool_CollisionPolygon_get_class_type_204, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionPolygon_get_class_type_204_comment},
  {"get_points", (PyCFunction) &MakeSeq_CollisionPolygon_get_points, METH_NOARGS, NULL},
  { "getPoints", (PyCFunction) &MakeSeq_CollisionPolygon_get_points, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionPolygon[] = {
  {(char *)"points", &Dtool_CollisionPolygon_points_Getter, NULL, NULL, NULL},
  {(char *)"valid", &Dtool_CollisionPolygon_valid_Getter, NULL, NULL, NULL},
  {(char *)"concave", &Dtool_CollisionPolygon_concave_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionPolygon = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionPolygon = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionPolygon = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionPolygon = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionPolygon = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionPolygon",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionPolygon,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionPolygon,
    &Dtool_SequenceMethods_CollisionPolygon,
    &Dtool_MappingMethods_CollisionPolygon,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionPolygon,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionPolygon,
    0, // tp_members
    Dtool_Properties_CollisionPolygon,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionPolygon,
    PyType_GenericAlloc,
    Dtool_new_CollisionPolygon,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionPolygon,
  Dtool_UpcastInterface_CollisionPolygon,
  Dtool_DowncastInterface_CollisionPolygon,
  (CoerceFunction)Dtool_ConstCoerce_CollisionPolygon,
  (CoerceFunction)Dtool_Coerce_CollisionPolygon,
};

static void Dtool_PyModuleClassInit_CollisionPolygon(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionPlane(NULL);
    Dtool_CollisionPolygon._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionPlane);
    PyObject *dict = PyDict_New();
    Dtool_CollisionPolygon._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionPolygon) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionPolygon)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionPolygon);
  }
}

/**
 * Python method tables for CollisionHandlerEvent (CollisionHandlerEvent)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerEvent[] = {
  {"clear_in_patterns", &Dtool_CollisionHandlerEvent_clear_in_patterns_208, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_in_patterns_208_comment},
  {"clearInPatterns", &Dtool_CollisionHandlerEvent_clear_in_patterns_208, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_in_patterns_208_comment},
  {"add_in_pattern", &Dtool_CollisionHandlerEvent_add_in_pattern_209, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_in_pattern_209_comment},
  {"addInPattern", &Dtool_CollisionHandlerEvent_add_in_pattern_209, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_in_pattern_209_comment},
  {"set_in_pattern", &Dtool_CollisionHandlerEvent_set_in_pattern_210, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_in_pattern_210_comment},
  {"setInPattern", &Dtool_CollisionHandlerEvent_set_in_pattern_210, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_in_pattern_210_comment},
  {"get_num_in_patterns", &Dtool_CollisionHandlerEvent_get_num_in_patterns_211, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_in_patterns_211_comment},
  {"getNumInPatterns", &Dtool_CollisionHandlerEvent_get_num_in_patterns_211, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_in_patterns_211_comment},
  {"get_in_pattern", &Dtool_CollisionHandlerEvent_get_in_pattern_212, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_in_pattern_212_comment},
  {"getInPattern", &Dtool_CollisionHandlerEvent_get_in_pattern_212, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_in_pattern_212_comment},
  {"clear_again_patterns", &Dtool_CollisionHandlerEvent_clear_again_patterns_214, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_again_patterns_214_comment},
  {"clearAgainPatterns", &Dtool_CollisionHandlerEvent_clear_again_patterns_214, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_again_patterns_214_comment},
  {"add_again_pattern", &Dtool_CollisionHandlerEvent_add_again_pattern_215, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_again_pattern_215_comment},
  {"addAgainPattern", &Dtool_CollisionHandlerEvent_add_again_pattern_215, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_again_pattern_215_comment},
  {"set_again_pattern", &Dtool_CollisionHandlerEvent_set_again_pattern_216, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_again_pattern_216_comment},
  {"setAgainPattern", &Dtool_CollisionHandlerEvent_set_again_pattern_216, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_again_pattern_216_comment},
  {"get_num_again_patterns", &Dtool_CollisionHandlerEvent_get_num_again_patterns_217, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_again_patterns_217_comment},
  {"getNumAgainPatterns", &Dtool_CollisionHandlerEvent_get_num_again_patterns_217, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_again_patterns_217_comment},
  {"get_again_pattern", &Dtool_CollisionHandlerEvent_get_again_pattern_218, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_again_pattern_218_comment},
  {"getAgainPattern", &Dtool_CollisionHandlerEvent_get_again_pattern_218, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_again_pattern_218_comment},
  {"clear_out_patterns", &Dtool_CollisionHandlerEvent_clear_out_patterns_220, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_out_patterns_220_comment},
  {"clearOutPatterns", &Dtool_CollisionHandlerEvent_clear_out_patterns_220, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_out_patterns_220_comment},
  {"add_out_pattern", &Dtool_CollisionHandlerEvent_add_out_pattern_221, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_out_pattern_221_comment},
  {"addOutPattern", &Dtool_CollisionHandlerEvent_add_out_pattern_221, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_out_pattern_221_comment},
  {"set_out_pattern", &Dtool_CollisionHandlerEvent_set_out_pattern_222, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_out_pattern_222_comment},
  {"setOutPattern", &Dtool_CollisionHandlerEvent_set_out_pattern_222, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_out_pattern_222_comment},
  {"get_num_out_patterns", &Dtool_CollisionHandlerEvent_get_num_out_patterns_223, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_out_patterns_223_comment},
  {"getNumOutPatterns", &Dtool_CollisionHandlerEvent_get_num_out_patterns_223, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_out_patterns_223_comment},
  {"get_out_pattern", &Dtool_CollisionHandlerEvent_get_out_pattern_224, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_out_pattern_224_comment},
  {"getOutPattern", &Dtool_CollisionHandlerEvent_get_out_pattern_224, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_out_pattern_224_comment},
  {"clear", &Dtool_CollisionHandlerEvent_clear_231, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_231_comment},
  {"flush", &Dtool_CollisionHandlerEvent_flush_232, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_flush_232_comment},
  {"get_class_type", &Dtool_CollisionHandlerEvent_get_class_type_233, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerEvent_get_class_type_233_comment},
  {"getClassType", &Dtool_CollisionHandlerEvent_get_class_type_233, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerEvent_get_class_type_233_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_in_patterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_in_patterns, METH_NOARGS, NULL},
  { "getInPatterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_in_patterns, METH_NOARGS, NULL},
  {"get_again_patterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_again_patterns, METH_NOARGS, NULL},
  { "getAgainPatterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_again_patterns, METH_NOARGS, NULL},
  {"get_out_patterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_out_patterns, METH_NOARGS, NULL},
  { "getOutPatterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_out_patterns, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionHandlerEvent[] = {
  {(char *)"in_patterns", &Dtool_CollisionHandlerEvent_in_patterns_Getter, NULL, NULL, NULL},
  {(char *)"again_patterns", &Dtool_CollisionHandlerEvent_again_patterns_Getter, NULL, NULL, NULL},
  {(char *)"out_patterns", &Dtool_CollisionHandlerEvent_out_patterns_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerEvent = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerEvent = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerEvent = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerEvent = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionHandlerEvent = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionHandlerEvent",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerEvent,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionHandlerEvent,
    &Dtool_SequenceMethods_CollisionHandlerEvent,
    &Dtool_MappingMethods_CollisionHandlerEvent,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionHandlerEvent,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that throws an event for each\n"
    " * collision detected.  The event thrown may be based on the name of the\n"
    " * moving object or the struck object, or both.  The first parameter of the\n"
    " * event will be a pointer to the CollisionEntry that triggered it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionHandlerEvent,
    0, // tp_members
    Dtool_Properties_CollisionHandlerEvent,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerEvent,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerEvent,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerEvent,
  Dtool_UpcastInterface_CollisionHandlerEvent,
  Dtool_DowncastInterface_CollisionHandlerEvent,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionHandlerEvent(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandler(NULL);
    Dtool_CollisionHandlerEvent._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandler);
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerEvent._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerEvent) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerEvent)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerEvent);
  }
}

/**
 * Python method tables for CollisionHandlerPhysical (CollisionHandlerPhysical)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerPhysical[] = {
  {"add_collider", (PyCFunction) &Dtool_CollisionHandlerPhysical_add_collider_236, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionHandlerPhysical_add_collider_236_comment},
  {"addCollider", (PyCFunction) &Dtool_CollisionHandlerPhysical_add_collider_236, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionHandlerPhysical_add_collider_236_comment},
  {"remove_collider", &Dtool_CollisionHandlerPhysical_remove_collider_237, METH_O, (const char *)Dtool_CollisionHandlerPhysical_remove_collider_237_comment},
  {"removeCollider", &Dtool_CollisionHandlerPhysical_remove_collider_237, METH_O, (const char *)Dtool_CollisionHandlerPhysical_remove_collider_237_comment},
  {"has_collider", &Dtool_CollisionHandlerPhysical_has_collider_238, METH_O, (const char *)Dtool_CollisionHandlerPhysical_has_collider_238_comment},
  {"hasCollider", &Dtool_CollisionHandlerPhysical_has_collider_238, METH_O, (const char *)Dtool_CollisionHandlerPhysical_has_collider_238_comment},
  {"clear_colliders", &Dtool_CollisionHandlerPhysical_clear_colliders_239, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_clear_colliders_239_comment},
  {"clearColliders", &Dtool_CollisionHandlerPhysical_clear_colliders_239, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_clear_colliders_239_comment},
  {"set_center", &Dtool_CollisionHandlerPhysical_set_center_240, METH_O, (const char *)Dtool_CollisionHandlerPhysical_set_center_240_comment},
  {"setCenter", &Dtool_CollisionHandlerPhysical_set_center_240, METH_O, (const char *)Dtool_CollisionHandlerPhysical_set_center_240_comment},
  {"clear_center", &Dtool_CollisionHandlerPhysical_clear_center_241, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_clear_center_241_comment},
  {"clearCenter", &Dtool_CollisionHandlerPhysical_clear_center_241, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_clear_center_241_comment},
  {"get_center", &Dtool_CollisionHandlerPhysical_get_center_242, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_get_center_242_comment},
  {"getCenter", &Dtool_CollisionHandlerPhysical_get_center_242, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_get_center_242_comment},
  {"has_center", &Dtool_CollisionHandlerPhysical_has_center_243, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_has_center_243_comment},
  {"hasCenter", &Dtool_CollisionHandlerPhysical_has_center_243, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_has_center_243_comment},
  {"has_contact", &Dtool_CollisionHandlerPhysical_has_contact_244, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_has_contact_244_comment},
  {"hasContact", &Dtool_CollisionHandlerPhysical_has_contact_244, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_has_contact_244_comment},
  {"get_class_type", &Dtool_CollisionHandlerPhysical_get_class_type_247, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerPhysical_get_class_type_247_comment},
  {"getClassType", &Dtool_CollisionHandlerPhysical_get_class_type_247, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerPhysical_get_class_type_247_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionHandlerPhysical[] = {
  {(char *)"center", &Dtool_CollisionHandlerPhysical_center_Getter, &Dtool_CollisionHandlerPhysical_center_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerPhysical = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerPhysical = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerPhysical = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerPhysical = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionHandlerPhysical = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionHandlerPhysical",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerPhysical,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionHandlerPhysical,
    &Dtool_SequenceMethods_CollisionHandlerPhysical,
    &Dtool_MappingMethods_CollisionHandlerPhysical,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionHandlerPhysical,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract base class for a number of CollisionHandlers that have some\n"
    " * physical effect on their moving bodies: they need to update the nodes'\n"
    " * positions based on the effects of the collision.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionHandlerPhysical,
    0, // tp_members
    Dtool_Properties_CollisionHandlerPhysical,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerPhysical,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerPhysical,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerPhysical,
  Dtool_UpcastInterface_CollisionHandlerPhysical,
  Dtool_DowncastInterface_CollisionHandlerPhysical,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionHandlerPhysical(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerEvent(NULL);
    Dtool_CollisionHandlerPhysical._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerEvent);
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerPhysical._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerPhysical) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerPhysical)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerPhysical);
  }
}

/**
 * Python method tables for CollisionHandlerFloor (CollisionHandlerFloor)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerFloor[] = {
  {"set_offset", &Dtool_CollisionHandlerFloor_set_offset_250, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_offset_250_comment},
  {"setOffset", &Dtool_CollisionHandlerFloor_set_offset_250, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_offset_250_comment},
  {"get_offset", &Dtool_CollisionHandlerFloor_get_offset_251, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_offset_251_comment},
  {"getOffset", &Dtool_CollisionHandlerFloor_get_offset_251, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_offset_251_comment},
  {"set_reach", &Dtool_CollisionHandlerFloor_set_reach_252, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_reach_252_comment},
  {"setReach", &Dtool_CollisionHandlerFloor_set_reach_252, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_reach_252_comment},
  {"get_reach", &Dtool_CollisionHandlerFloor_get_reach_253, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_reach_253_comment},
  {"getReach", &Dtool_CollisionHandlerFloor_get_reach_253, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_reach_253_comment},
  {"set_max_velocity", &Dtool_CollisionHandlerFloor_set_max_velocity_254, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_max_velocity_254_comment},
  {"setMaxVelocity", &Dtool_CollisionHandlerFloor_set_max_velocity_254, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_max_velocity_254_comment},
  {"get_max_velocity", &Dtool_CollisionHandlerFloor_get_max_velocity_255, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_max_velocity_255_comment},
  {"getMaxVelocity", &Dtool_CollisionHandlerFloor_get_max_velocity_255, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_max_velocity_255_comment},
  {"get_class_type", &Dtool_CollisionHandlerFloor_get_class_type_259, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerFloor_get_class_type_259_comment},
  {"getClassType", &Dtool_CollisionHandlerFloor_get_class_type_259, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerFloor_get_class_type_259_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionHandlerFloor[] = {
  {(char *)"offset", &Dtool_CollisionHandlerFloor_offset_Getter, &Dtool_CollisionHandlerFloor_offset_Setter, NULL, NULL},
  {(char *)"reach", &Dtool_CollisionHandlerFloor_reach_Getter, &Dtool_CollisionHandlerFloor_reach_Setter, NULL, NULL},
  {(char *)"max_velocity", &Dtool_CollisionHandlerFloor_max_velocity_Getter, &Dtool_CollisionHandlerFloor_max_velocity_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerFloor = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerFloor = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerFloor = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerFloor = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionHandlerFloor = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionHandlerFloor",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerFloor,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionHandlerFloor,
    &Dtool_SequenceMethods_CollisionHandlerFloor,
    &Dtool_MappingMethods_CollisionHandlerFloor,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionHandlerFloor,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that sets the Z height of the\n"
    " * collider to a fixed linear offset from the highest detected collision point\n"
    " * each frame.  It's intended to implement walking around on a floor of\n"
    " * varying height by casting a ray down from the avatar's head.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionHandlerFloor,
    0, // tp_members
    Dtool_Properties_CollisionHandlerFloor,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerFloor,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerFloor,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerFloor,
  Dtool_UpcastInterface_CollisionHandlerFloor,
  Dtool_DowncastInterface_CollisionHandlerFloor,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionHandlerFloor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerPhysical(NULL);
    Dtool_CollisionHandlerFloor._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerPhysical);
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerFloor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerFloor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerFloor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerFloor);
  }
}

/**
 * Python method tables for CollisionHandlerPusher (CollisionHandlerPusher)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerPusher[] = {
  {"set_horizontal", &Dtool_CollisionHandlerPusher_set_horizontal_262, METH_O, (const char *)Dtool_CollisionHandlerPusher_set_horizontal_262_comment},
  {"setHorizontal", &Dtool_CollisionHandlerPusher_set_horizontal_262, METH_O, (const char *)Dtool_CollisionHandlerPusher_set_horizontal_262_comment},
  {"get_horizontal", &Dtool_CollisionHandlerPusher_get_horizontal_263, METH_NOARGS, (const char *)Dtool_CollisionHandlerPusher_get_horizontal_263_comment},
  {"getHorizontal", &Dtool_CollisionHandlerPusher_get_horizontal_263, METH_NOARGS, (const char *)Dtool_CollisionHandlerPusher_get_horizontal_263_comment},
  {"get_class_type", &Dtool_CollisionHandlerPusher_get_class_type_265, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerPusher_get_class_type_265_comment},
  {"getClassType", &Dtool_CollisionHandlerPusher_get_class_type_265, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerPusher_get_class_type_265_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionHandlerPusher[] = {
  {(char *)"horizontal", &Dtool_CollisionHandlerPusher_horizontal_Getter, &Dtool_CollisionHandlerPusher_horizontal_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerPusher = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerPusher = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerPusher = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerPusher = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionHandlerPusher = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionHandlerPusher",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerPusher,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionHandlerPusher,
    &Dtool_SequenceMethods_CollisionHandlerPusher,
    &Dtool_MappingMethods_CollisionHandlerPusher,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionHandlerPusher,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that simply pushes back on things\n"
    " * that attempt to move into solid walls.  This is the simplest kind of \"real-\n"
    " * world\" collisions you can have.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionHandlerPusher,
    0, // tp_members
    Dtool_Properties_CollisionHandlerPusher,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerPusher,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerPusher,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerPusher,
  Dtool_UpcastInterface_CollisionHandlerPusher,
  Dtool_DowncastInterface_CollisionHandlerPusher,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionHandlerPusher(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerPhysical(NULL);
    Dtool_CollisionHandlerPusher._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerPhysical);
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerPusher._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerPusher) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerPusher)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerPusher);
  }
}

/**
 * Python method tables for CollisionHandlerFluidPusher (CollisionHandlerFluidPusher)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerFluidPusher[] = {
  {"get_class_type", &Dtool_CollisionHandlerFluidPusher_get_class_type_268, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerFluidPusher_get_class_type_268_comment},
  {"getClassType", &Dtool_CollisionHandlerFluidPusher_get_class_type_268, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerFluidPusher_get_class_type_268_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerFluidPusher = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerFluidPusher = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerFluidPusher = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerFluidPusher = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionHandlerFluidPusher = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionHandlerFluidPusher",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerFluidPusher,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionHandlerFluidPusher,
    &Dtool_SequenceMethods_CollisionHandlerFluidPusher,
    &Dtool_MappingMethods_CollisionHandlerFluidPusher,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionHandlerFluidPusher,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A CollisionHandlerPusher that makes use of timing and spatial information\n"
    " * from fluid collisions to improve collision response\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionHandlerFluidPusher,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerFluidPusher,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerFluidPusher,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerFluidPusher,
  Dtool_UpcastInterface_CollisionHandlerFluidPusher,
  Dtool_DowncastInterface_CollisionHandlerFluidPusher,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionHandlerFluidPusher(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerPusher(NULL);
    Dtool_CollisionHandlerFluidPusher._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerPusher);
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerFluidPusher._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerFluidPusher) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerFluidPusher)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerFluidPusher);
  }
}

/**
 * Python method tables for CollisionHandlerGravity (CollisionHandlerGravity)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerGravity[] = {
  {"set_offset", &Dtool_CollisionHandlerGravity_set_offset_272, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_offset_272_comment},
  {"setOffset", &Dtool_CollisionHandlerGravity_set_offset_272, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_offset_272_comment},
  {"get_offset", &Dtool_CollisionHandlerGravity_get_offset_273, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_offset_273_comment},
  {"getOffset", &Dtool_CollisionHandlerGravity_get_offset_273, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_offset_273_comment},
  {"set_reach", &Dtool_CollisionHandlerGravity_set_reach_274, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_reach_274_comment},
  {"setReach", &Dtool_CollisionHandlerGravity_set_reach_274, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_reach_274_comment},
  {"get_reach", &Dtool_CollisionHandlerGravity_get_reach_275, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_reach_275_comment},
  {"getReach", &Dtool_CollisionHandlerGravity_get_reach_275, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_reach_275_comment},
  {"get_airborne_height", &Dtool_CollisionHandlerGravity_get_airborne_height_276, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_airborne_height_276_comment},
  {"getAirborneHeight", &Dtool_CollisionHandlerGravity_get_airborne_height_276, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_airborne_height_276_comment},
  {"is_on_ground", &Dtool_CollisionHandlerGravity_is_on_ground_277, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_is_on_ground_277_comment},
  {"isOnGround", &Dtool_CollisionHandlerGravity_is_on_ground_277, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_is_on_ground_277_comment},
  {"get_impact_velocity", &Dtool_CollisionHandlerGravity_get_impact_velocity_278, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_impact_velocity_278_comment},
  {"getImpactVelocity", &Dtool_CollisionHandlerGravity_get_impact_velocity_278, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_impact_velocity_278_comment},
  {"get_contact_normal", &Dtool_CollisionHandlerGravity_get_contact_normal_279, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_contact_normal_279_comment},
  {"getContactNormal", &Dtool_CollisionHandlerGravity_get_contact_normal_279, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_contact_normal_279_comment},
  {"add_velocity", &Dtool_CollisionHandlerGravity_add_velocity_280, METH_O, (const char *)Dtool_CollisionHandlerGravity_add_velocity_280_comment},
  {"addVelocity", &Dtool_CollisionHandlerGravity_add_velocity_280, METH_O, (const char *)Dtool_CollisionHandlerGravity_add_velocity_280_comment},
  {"set_velocity", &Dtool_CollisionHandlerGravity_set_velocity_281, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_velocity_281_comment},
  {"setVelocity", &Dtool_CollisionHandlerGravity_set_velocity_281, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_velocity_281_comment},
  {"get_velocity", &Dtool_CollisionHandlerGravity_get_velocity_282, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_velocity_282_comment},
  {"getVelocity", &Dtool_CollisionHandlerGravity_get_velocity_282, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_velocity_282_comment},
  {"set_gravity", &Dtool_CollisionHandlerGravity_set_gravity_283, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_gravity_283_comment},
  {"setGravity", &Dtool_CollisionHandlerGravity_set_gravity_283, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_gravity_283_comment},
  {"get_gravity", &Dtool_CollisionHandlerGravity_get_gravity_284, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_gravity_284_comment},
  {"getGravity", &Dtool_CollisionHandlerGravity_get_gravity_284, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_gravity_284_comment},
  {"set_max_velocity", &Dtool_CollisionHandlerGravity_set_max_velocity_285, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_max_velocity_285_comment},
  {"setMaxVelocity", &Dtool_CollisionHandlerGravity_set_max_velocity_285, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_max_velocity_285_comment},
  {"get_max_velocity", &Dtool_CollisionHandlerGravity_get_max_velocity_286, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_max_velocity_286_comment},
  {"getMaxVelocity", &Dtool_CollisionHandlerGravity_get_max_velocity_286, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_max_velocity_286_comment},
  {"set_legacy_mode", &Dtool_CollisionHandlerGravity_set_legacy_mode_287, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_legacy_mode_287_comment},
  {"setLegacyMode", &Dtool_CollisionHandlerGravity_set_legacy_mode_287, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_legacy_mode_287_comment},
  {"get_legacy_mode", &Dtool_CollisionHandlerGravity_get_legacy_mode_288, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_legacy_mode_288_comment},
  {"getLegacyMode", &Dtool_CollisionHandlerGravity_get_legacy_mode_288, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_legacy_mode_288_comment},
  {"get_class_type", &Dtool_CollisionHandlerGravity_get_class_type_299, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerGravity_get_class_type_299_comment},
  {"getClassType", &Dtool_CollisionHandlerGravity_get_class_type_299, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerGravity_get_class_type_299_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionHandlerGravity[] = {
  {(char *)"offset", &Dtool_CollisionHandlerGravity_offset_Getter, &Dtool_CollisionHandlerGravity_offset_Setter, NULL, NULL},
  {(char *)"reach", &Dtool_CollisionHandlerGravity_reach_Getter, &Dtool_CollisionHandlerGravity_reach_Setter, NULL, NULL},
  {(char *)"airborne_height", &Dtool_CollisionHandlerGravity_airborne_height_Getter, NULL, NULL, NULL},
  {(char *)"on_ground", &Dtool_CollisionHandlerGravity_on_ground_Getter, NULL, NULL, NULL},
  {(char *)"impact_velocity", &Dtool_CollisionHandlerGravity_impact_velocity_Getter, NULL, NULL, NULL},
  {(char *)"contact_normal", &Dtool_CollisionHandlerGravity_contact_normal_Getter, NULL, NULL, NULL},
  {(char *)"velocity", &Dtool_CollisionHandlerGravity_velocity_Getter, &Dtool_CollisionHandlerGravity_velocity_Setter, NULL, NULL},
  {(char *)"gravity", &Dtool_CollisionHandlerGravity_gravity_Getter, &Dtool_CollisionHandlerGravity_gravity_Setter, NULL, NULL},
  {(char *)"max_velocity", &Dtool_CollisionHandlerGravity_max_velocity_Getter, &Dtool_CollisionHandlerGravity_max_velocity_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerGravity = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerGravity = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerGravity = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerGravity = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionHandlerGravity = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionHandlerGravity",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerGravity,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionHandlerGravity,
    &Dtool_SequenceMethods_CollisionHandlerGravity,
    &Dtool_MappingMethods_CollisionHandlerGravity,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionHandlerGravity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that sets the Z height of the\n"
    " * collider to a fixed linear offset from the highest detected collision point\n"
    " * each frame.  It's intended to implement walking around on a floor of\n"
    " * varying height by casting a ray down from the avatar's head.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionHandlerGravity,
    0, // tp_members
    Dtool_Properties_CollisionHandlerGravity,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerGravity,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerGravity,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerGravity,
  Dtool_UpcastInterface_CollisionHandlerGravity,
  Dtool_DowncastInterface_CollisionHandlerGravity,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionHandlerGravity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerPhysical(NULL);
    Dtool_CollisionHandlerGravity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerPhysical);
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerGravity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerGravity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerGravity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerGravity);
  }
}

/**
 * Python method tables for CollisionHandlerHighestEvent (CollisionHandlerHighestEvent)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerHighestEvent[] = {
  {"get_class_type", &Dtool_CollisionHandlerHighestEvent_get_class_type_302, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerHighestEvent_get_class_type_302_comment},
  {"getClassType", &Dtool_CollisionHandlerHighestEvent_get_class_type_302, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerHighestEvent_get_class_type_302_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerHighestEvent = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerHighestEvent = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerHighestEvent = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerHighestEvent = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionHandlerHighestEvent = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionHandlerHighestEvent",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerHighestEvent,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionHandlerHighestEvent,
    &Dtool_SequenceMethods_CollisionHandlerHighestEvent,
    &Dtool_MappingMethods_CollisionHandlerHighestEvent,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionHandlerHighestEvent,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that throws an event for each\n"
    " * collision detected.  The event thrown may be based on the name of the\n"
    " * moving object or the struck object, or both.  The first parameter of the\n"
    " * event will be a pointer to the CollisionEntry that triggered it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionHandlerHighestEvent,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerHighestEvent,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerHighestEvent,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerHighestEvent,
  Dtool_UpcastInterface_CollisionHandlerHighestEvent,
  Dtool_DowncastInterface_CollisionHandlerHighestEvent,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionHandlerHighestEvent(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerEvent(NULL);
    Dtool_CollisionHandlerHighestEvent._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerEvent);
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerHighestEvent._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerHighestEvent) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerHighestEvent)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerHighestEvent);
  }
}

/**
 * Python method tables for CollisionHandlerQueue (CollisionHandlerQueue)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerQueue[] = {
  {"sort_entries", &Dtool_CollisionHandlerQueue_sort_entries_306, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_sort_entries_306_comment},
  {"sortEntries", &Dtool_CollisionHandlerQueue_sort_entries_306, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_sort_entries_306_comment},
  {"clear_entries", &Dtool_CollisionHandlerQueue_clear_entries_307, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_clear_entries_307_comment},
  {"clearEntries", &Dtool_CollisionHandlerQueue_clear_entries_307, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_clear_entries_307_comment},
  {"get_num_entries", &Dtool_CollisionHandlerQueue_get_num_entries_308, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_get_num_entries_308_comment},
  {"getNumEntries", &Dtool_CollisionHandlerQueue_get_num_entries_308, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_get_num_entries_308_comment},
  {"get_entry", &Dtool_CollisionHandlerQueue_get_entry_309, METH_O, (const char *)Dtool_CollisionHandlerQueue_get_entry_309_comment},
  {"getEntry", &Dtool_CollisionHandlerQueue_get_entry_309, METH_O, (const char *)Dtool_CollisionHandlerQueue_get_entry_309_comment},
  {"output", &Dtool_CollisionHandlerQueue_output_313, METH_O, (const char *)Dtool_CollisionHandlerQueue_output_313_comment},
  {"write", (PyCFunction) &Dtool_CollisionHandlerQueue_write_314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionHandlerQueue_write_314_comment},
  {"get_class_type", &Dtool_CollisionHandlerQueue_get_class_type_315, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerQueue_get_class_type_315_comment},
  {"getClassType", &Dtool_CollisionHandlerQueue_get_class_type_315, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerQueue_get_class_type_315_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_entries", (PyCFunction) &MakeSeq_CollisionHandlerQueue_get_entries, METH_NOARGS, NULL},
  { "getEntries", (PyCFunction) &MakeSeq_CollisionHandlerQueue_get_entries, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     CollisionHandlerQueue
//////////////////
static PyObject *Dtool_Repr_CollisionHandlerQueue(PyObject *self) {
  CollisionHandlerQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CollisionHandlerQueue
//////////////////
static PyObject *Dtool_Str_CollisionHandlerQueue(PyObject *self) {
  CollisionHandlerQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_CollisionHandlerQueue[] = {
  {(char *)"entries", &Dtool_CollisionHandlerQueue_entries_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerQueue = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerQueue = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerQueue = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerQueue = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionHandlerQueue = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionHandlerQueue",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerQueue,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_CollisionHandlerQueue,
    &Dtool_NumberMethods_CollisionHandlerQueue,
    &Dtool_SequenceMethods_CollisionHandlerQueue,
    &Dtool_MappingMethods_CollisionHandlerQueue,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_CollisionHandlerQueue,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionHandlerQueue,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special kind of CollisionHandler that does nothing except remember the\n"
    " * CollisionEntries detected the last pass.  This set of CollisionEntries may\n"
    " * then be queried by the calling function.  It's primarily useful when a\n"
    " * simple intersection test is being made, e.g.  for picking from the window.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionHandlerQueue,
    0, // tp_members
    Dtool_Properties_CollisionHandlerQueue,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerQueue,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerQueue,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerQueue,
  Dtool_UpcastInterface_CollisionHandlerQueue,
  Dtool_DowncastInterface_CollisionHandlerQueue,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CollisionHandlerQueue(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandler(NULL);
    Dtool_CollisionHandlerQueue._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandler);
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerQueue._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerQueue) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerQueue)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerQueue);
  }
}

/**
 * Python method tables for CollisionSphere (CollisionSphere)
 */
static PyMethodDef Dtool_Methods_CollisionSphere[] = {
  {"set_center", (PyCFunction) &Dtool_CollisionSphere_set_center_319, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSphere_set_center_319_comment},
  {"setCenter", (PyCFunction) &Dtool_CollisionSphere_set_center_319, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSphere_set_center_319_comment},
  {"get_center", &Dtool_CollisionSphere_get_center_320, METH_NOARGS, (const char *)Dtool_CollisionSphere_get_center_320_comment},
  {"getCenter", &Dtool_CollisionSphere_get_center_320, METH_NOARGS, (const char *)Dtool_CollisionSphere_get_center_320_comment},
  {"set_radius", &Dtool_CollisionSphere_set_radius_321, METH_O, (const char *)Dtool_CollisionSphere_set_radius_321_comment},
  {"setRadius", &Dtool_CollisionSphere_set_radius_321, METH_O, (const char *)Dtool_CollisionSphere_set_radius_321_comment},
  {"get_radius", &Dtool_CollisionSphere_get_radius_322, METH_NOARGS, (const char *)Dtool_CollisionSphere_get_radius_322_comment},
  {"getRadius", &Dtool_CollisionSphere_get_radius_322, METH_NOARGS, (const char *)Dtool_CollisionSphere_get_radius_322_comment},
  {"get_class_type", &Dtool_CollisionSphere_get_class_type_325, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSphere_get_class_type_325_comment},
  {"getClassType", &Dtool_CollisionSphere_get_class_type_325, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSphere_get_class_type_325_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionSphere[] = {
  {(char *)"center", &Dtool_CollisionSphere_center_Getter, &Dtool_CollisionSphere_center_Setter, NULL, NULL},
  {(char *)"radius", &Dtool_CollisionSphere_radius_Getter, &Dtool_CollisionSphere_radius_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionSphere = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionSphere = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionSphere = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionSphere = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionSphere = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionSphere",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionSphere,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionSphere,
    &Dtool_SequenceMethods_CollisionSphere,
    &Dtool_MappingMethods_CollisionSphere,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionSphere,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A spherical collision volume or object.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionSphere,
    0, // tp_members
    Dtool_Properties_CollisionSphere,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionSphere,
    PyType_GenericAlloc,
    Dtool_new_CollisionSphere,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionSphere,
  Dtool_UpcastInterface_CollisionSphere,
  Dtool_DowncastInterface_CollisionSphere,
  (CoerceFunction)Dtool_ConstCoerce_CollisionSphere,
  (CoerceFunction)Dtool_Coerce_CollisionSphere,
};

static void Dtool_PyModuleClassInit_CollisionSphere(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(NULL);
    Dtool_CollisionSphere._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    PyObject *dict = PyDict_New();
    Dtool_CollisionSphere._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionSphere) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionSphere)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionSphere);
  }
}

/**
 * Python method tables for CollisionInvSphere (CollisionInvSphere)
 */
static PyMethodDef Dtool_Methods_CollisionInvSphere[] = {
  {"get_class_type", &Dtool_CollisionInvSphere_get_class_type_329, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionInvSphere_get_class_type_329_comment},
  {"getClassType", &Dtool_CollisionInvSphere_get_class_type_329, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionInvSphere_get_class_type_329_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CollisionInvSphere = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionInvSphere = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionInvSphere = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionInvSphere = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionInvSphere = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionInvSphere",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionInvSphere,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionInvSphere,
    &Dtool_SequenceMethods_CollisionInvSphere,
    &Dtool_MappingMethods_CollisionInvSphere,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionInvSphere,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An inverted sphere: this is a sphere whose collision surface is the inside\n"
    " * surface of the sphere.  Everything outside the sphere is solid matter;\n"
    " * everything inside is empty space.  Useful for constraining objects to\n"
    " * remain within a spherical perimeter.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionInvSphere,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionInvSphere,
    PyType_GenericAlloc,
    Dtool_new_CollisionInvSphere,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionInvSphere,
  Dtool_UpcastInterface_CollisionInvSphere,
  Dtool_DowncastInterface_CollisionInvSphere,
  (CoerceFunction)Dtool_ConstCoerce_CollisionInvSphere,
  (CoerceFunction)Dtool_Coerce_CollisionInvSphere,
};

static void Dtool_PyModuleClassInit_CollisionInvSphere(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSphere(NULL);
    Dtool_CollisionInvSphere._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSphere);
    PyObject *dict = PyDict_New();
    Dtool_CollisionInvSphere._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionInvSphere) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionInvSphere)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionInvSphere);
  }
}

/**
 * Python method tables for CollisionRay (CollisionRay)
 */
static PyMethodDef Dtool_Methods_CollisionRay[] = {
  {"set_origin", (PyCFunction) &Dtool_CollisionRay_set_origin_333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_origin_333_comment},
  {"setOrigin", (PyCFunction) &Dtool_CollisionRay_set_origin_333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_origin_333_comment},
  {"get_origin", &Dtool_CollisionRay_get_origin_334, METH_NOARGS, (const char *)Dtool_CollisionRay_get_origin_334_comment},
  {"getOrigin", &Dtool_CollisionRay_get_origin_334, METH_NOARGS, (const char *)Dtool_CollisionRay_get_origin_334_comment},
  {"set_direction", (PyCFunction) &Dtool_CollisionRay_set_direction_336, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_direction_336_comment},
  {"setDirection", (PyCFunction) &Dtool_CollisionRay_set_direction_336, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_direction_336_comment},
  {"get_direction", &Dtool_CollisionRay_get_direction_337, METH_NOARGS, (const char *)Dtool_CollisionRay_get_direction_337_comment},
  {"getDirection", &Dtool_CollisionRay_get_direction_337, METH_NOARGS, (const char *)Dtool_CollisionRay_get_direction_337_comment},
  {"set_from_lens", (PyCFunction) &Dtool_CollisionRay_set_from_lens_339, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_from_lens_339_comment},
  {"setFromLens", (PyCFunction) &Dtool_CollisionRay_set_from_lens_339, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_from_lens_339_comment},
  {"get_class_type", &Dtool_CollisionRay_get_class_type_340, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionRay_get_class_type_340_comment},
  {"getClassType", &Dtool_CollisionRay_get_class_type_340, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionRay_get_class_type_340_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionRay[] = {
  {(char *)"origin", &Dtool_CollisionRay_origin_Getter, &Dtool_CollisionRay_origin_Setter, NULL, NULL},
  {(char *)"direction", &Dtool_CollisionRay_direction_Getter, &Dtool_CollisionRay_direction_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionRay = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionRay = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionRay = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionRay = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionRay = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionRay",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionRay,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionRay,
    &Dtool_SequenceMethods_CollisionRay,
    &Dtool_MappingMethods_CollisionRay,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionRay,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An infinite ray, with a specific origin and direction.  It begins at its\n"
    " * origin and continues in one direction to infinity, and it has no radius.\n"
    " * Useful for picking from a window, or for gravity effects.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionRay,
    0, // tp_members
    Dtool_Properties_CollisionRay,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionRay,
    PyType_GenericAlloc,
    Dtool_new_CollisionRay,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionRay,
  Dtool_UpcastInterface_CollisionRay,
  Dtool_DowncastInterface_CollisionRay,
  (CoerceFunction)Dtool_ConstCoerce_CollisionRay,
  (CoerceFunction)Dtool_Coerce_CollisionRay,
};

static void Dtool_PyModuleClassInit_CollisionRay(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(NULL);
    Dtool_CollisionRay._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    PyObject *dict = PyDict_New();
    Dtool_CollisionRay._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionRay) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionRay)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionRay);
  }
}

/**
 * Python method tables for CollisionLine (CollisionLine)
 */
static PyMethodDef Dtool_Methods_CollisionLine[] = {
  {"get_class_type", &Dtool_CollisionLine_get_class_type_344, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionLine_get_class_type_344_comment},
  {"getClassType", &Dtool_CollisionLine_get_class_type_344, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionLine_get_class_type_344_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CollisionLine = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionLine = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionLine = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionLine = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionLine = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionLine",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionLine,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionLine,
    &Dtool_SequenceMethods_CollisionLine,
    &Dtool_MappingMethods_CollisionLine,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionLine,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An infinite line, similar to a CollisionRay, except that it extends in both\n"
    " * directions.  It is, however, directional.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionLine,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionLine,
    PyType_GenericAlloc,
    Dtool_new_CollisionLine,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionLine,
  Dtool_UpcastInterface_CollisionLine,
  Dtool_DowncastInterface_CollisionLine,
  (CoerceFunction)Dtool_ConstCoerce_CollisionLine,
  (CoerceFunction)Dtool_Coerce_CollisionLine,
};

static void Dtool_PyModuleClassInit_CollisionLine(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionRay(NULL);
    Dtool_CollisionLine._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionRay);
    PyObject *dict = PyDict_New();
    Dtool_CollisionLine._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionLine) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionLine)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionLine);
  }
}

/**
 * Python method tables for CollisionParabola (CollisionParabola)
 */
static PyMethodDef Dtool_Methods_CollisionParabola[] = {
  {"set_parabola", &Dtool_CollisionParabola_set_parabola_348, METH_O, (const char *)Dtool_CollisionParabola_set_parabola_348_comment},
  {"setParabola", &Dtool_CollisionParabola_set_parabola_348, METH_O, (const char *)Dtool_CollisionParabola_set_parabola_348_comment},
  {"get_parabola", &Dtool_CollisionParabola_get_parabola_349, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_parabola_349_comment},
  {"getParabola", &Dtool_CollisionParabola_get_parabola_349, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_parabola_349_comment},
  {"set_t1", &Dtool_CollisionParabola_set_t1_350, METH_O, (const char *)Dtool_CollisionParabola_set_t1_350_comment},
  {"setT1", &Dtool_CollisionParabola_set_t1_350, METH_O, (const char *)Dtool_CollisionParabola_set_t1_350_comment},
  {"get_t1", &Dtool_CollisionParabola_get_t1_351, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_t1_351_comment},
  {"getT1", &Dtool_CollisionParabola_get_t1_351, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_t1_351_comment},
  {"set_t2", &Dtool_CollisionParabola_set_t2_352, METH_O, (const char *)Dtool_CollisionParabola_set_t2_352_comment},
  {"setT2", &Dtool_CollisionParabola_set_t2_352, METH_O, (const char *)Dtool_CollisionParabola_set_t2_352_comment},
  {"get_t2", &Dtool_CollisionParabola_get_t2_353, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_t2_353_comment},
  {"getT2", &Dtool_CollisionParabola_get_t2_353, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_t2_353_comment},
  {"get_class_type", &Dtool_CollisionParabola_get_class_type_360, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionParabola_get_class_type_360_comment},
  {"getClassType", &Dtool_CollisionParabola_get_class_type_360, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionParabola_get_class_type_360_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionParabola[] = {
  {(char *)"parabola", &Dtool_CollisionParabola_parabola_Getter, &Dtool_CollisionParabola_parabola_Setter, NULL, NULL},
  {(char *)"t1", &Dtool_CollisionParabola_t1_Getter, &Dtool_CollisionParabola_t1_Setter, NULL, NULL},
  {(char *)"t2", &Dtool_CollisionParabola_t2_Getter, &Dtool_CollisionParabola_t2_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionParabola = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionParabola = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionParabola = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionParabola = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionParabola = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionParabola",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionParabola,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionParabola,
    &Dtool_SequenceMethods_CollisionParabola,
    &Dtool_MappingMethods_CollisionParabola,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionParabola,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines a parabolic arc, or subset of an arc, similar to the path of a\n"
    " * projectile or falling object.  It is finite, having a specific beginning\n"
    " * and end, but it is infinitely thin.\n"
    " *\n"
    " * Think of it as a wire bending from point t1 to point t2 along the path of a\n"
    " * pre-defined parabola.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionParabola,
    0, // tp_members
    Dtool_Properties_CollisionParabola,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionParabola,
    PyType_GenericAlloc,
    Dtool_new_CollisionParabola,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionParabola,
  Dtool_UpcastInterface_CollisionParabola,
  Dtool_DowncastInterface_CollisionParabola,
  (CoerceFunction)Dtool_ConstCoerce_CollisionParabola,
  (CoerceFunction)Dtool_Coerce_CollisionParabola,
};

static void Dtool_PyModuleClassInit_CollisionParabola(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(NULL);
    Dtool_CollisionParabola._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    PyObject *dict = PyDict_New();
    Dtool_CollisionParabola._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionParabola) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionParabola)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionParabola);
  }
}

/**
 * Python method tables for CollisionSegment (CollisionSegment)
 */
static PyMethodDef Dtool_Methods_CollisionSegment[] = {
  {"set_point_a", (PyCFunction) &Dtool_CollisionSegment_set_point_a_364, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_point_a_364_comment},
  {"setPointA", (PyCFunction) &Dtool_CollisionSegment_set_point_a_364, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_point_a_364_comment},
  {"get_point_a", &Dtool_CollisionSegment_get_point_a_365, METH_NOARGS, (const char *)Dtool_CollisionSegment_get_point_a_365_comment},
  {"getPointA", &Dtool_CollisionSegment_get_point_a_365, METH_NOARGS, (const char *)Dtool_CollisionSegment_get_point_a_365_comment},
  {"set_point_b", (PyCFunction) &Dtool_CollisionSegment_set_point_b_366, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_point_b_366_comment},
  {"setPointB", (PyCFunction) &Dtool_CollisionSegment_set_point_b_366, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_point_b_366_comment},
  {"get_point_b", &Dtool_CollisionSegment_get_point_b_367, METH_NOARGS, (const char *)Dtool_CollisionSegment_get_point_b_367_comment},
  {"getPointB", &Dtool_CollisionSegment_get_point_b_367, METH_NOARGS, (const char *)Dtool_CollisionSegment_get_point_b_367_comment},
  {"set_from_lens", (PyCFunction) &Dtool_CollisionSegment_set_from_lens_368, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_from_lens_368_comment},
  {"setFromLens", (PyCFunction) &Dtool_CollisionSegment_set_from_lens_368, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_from_lens_368_comment},
  {"get_class_type", &Dtool_CollisionSegment_get_class_type_371, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSegment_get_class_type_371_comment},
  {"getClassType", &Dtool_CollisionSegment_get_class_type_371, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSegment_get_class_type_371_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionSegment[] = {
  {(char *)"point_a", &Dtool_CollisionSegment_point_a_Getter, &Dtool_CollisionSegment_point_a_Setter, NULL, NULL},
  {(char *)"point_b", &Dtool_CollisionSegment_point_b_Getter, &Dtool_CollisionSegment_point_b_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionSegment = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionSegment = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionSegment = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionSegment = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionSegment = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionSegment",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionSegment,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionSegment,
    &Dtool_SequenceMethods_CollisionSegment,
    &Dtool_MappingMethods_CollisionSegment,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionSegment,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A finite line segment, with two specific endpoints but no thickness.  It's\n"
    " * similar to a CollisionRay, except it does not continue to infinity.\n"
    " *\n"
    " * It does have an ordering, from point A to point B. If more than a single\n"
    " * point of the segment is intersecting a solid, the reported intersection\n"
    " * point is generally the closest on the segment to point A.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionSegment,
    0, // tp_members
    Dtool_Properties_CollisionSegment,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionSegment,
    PyType_GenericAlloc,
    Dtool_new_CollisionSegment,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionSegment,
  Dtool_UpcastInterface_CollisionSegment,
  Dtool_DowncastInterface_CollisionSegment,
  (CoerceFunction)Dtool_ConstCoerce_CollisionSegment,
  (CoerceFunction)Dtool_Coerce_CollisionSegment,
};

static void Dtool_PyModuleClassInit_CollisionSegment(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(NULL);
    Dtool_CollisionSegment._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    PyObject *dict = PyDict_New();
    Dtool_CollisionSegment._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionSegment) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionSegment)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionSegment);
  }
}

/**
 * Python method tables for CollisionTube (CollisionTube)
 */
static PyMethodDef Dtool_Methods_CollisionTube[] = {
  {"set_point_a", (PyCFunction) &Dtool_CollisionTube_set_point_a_375, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionTube_set_point_a_375_comment},
  {"setPointA", (PyCFunction) &Dtool_CollisionTube_set_point_a_375, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionTube_set_point_a_375_comment},
  {"get_point_a", &Dtool_CollisionTube_get_point_a_376, METH_NOARGS, (const char *)Dtool_CollisionTube_get_point_a_376_comment},
  {"getPointA", &Dtool_CollisionTube_get_point_a_376, METH_NOARGS, (const char *)Dtool_CollisionTube_get_point_a_376_comment},
  {"set_point_b", (PyCFunction) &Dtool_CollisionTube_set_point_b_377, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionTube_set_point_b_377_comment},
  {"setPointB", (PyCFunction) &Dtool_CollisionTube_set_point_b_377, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionTube_set_point_b_377_comment},
  {"get_point_b", &Dtool_CollisionTube_get_point_b_378, METH_NOARGS, (const char *)Dtool_CollisionTube_get_point_b_378_comment},
  {"getPointB", &Dtool_CollisionTube_get_point_b_378, METH_NOARGS, (const char *)Dtool_CollisionTube_get_point_b_378_comment},
  {"set_radius", &Dtool_CollisionTube_set_radius_379, METH_O, (const char *)Dtool_CollisionTube_set_radius_379_comment},
  {"setRadius", &Dtool_CollisionTube_set_radius_379, METH_O, (const char *)Dtool_CollisionTube_set_radius_379_comment},
  {"get_radius", &Dtool_CollisionTube_get_radius_380, METH_NOARGS, (const char *)Dtool_CollisionTube_get_radius_380_comment},
  {"getRadius", &Dtool_CollisionTube_get_radius_380, METH_NOARGS, (const char *)Dtool_CollisionTube_get_radius_380_comment},
  {"get_class_type", &Dtool_CollisionTube_get_class_type_384, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionTube_get_class_type_384_comment},
  {"getClassType", &Dtool_CollisionTube_get_class_type_384, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionTube_get_class_type_384_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionTube[] = {
  {(char *)"point_a", &Dtool_CollisionTube_point_a_Getter, &Dtool_CollisionTube_point_a_Setter, NULL, NULL},
  {(char *)"point_b", &Dtool_CollisionTube_point_b_Getter, &Dtool_CollisionTube_point_b_Setter, NULL, NULL},
  {(char *)"radius", &Dtool_CollisionTube_radius_Getter, &Dtool_CollisionTube_radius_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionTube = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionTube = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionTube = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionTube = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionTube = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionTube",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionTube,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionTube,
    &Dtool_SequenceMethods_CollisionTube,
    &Dtool_MappingMethods_CollisionTube,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionTube,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This implements a solid roughly in cylindrical shape.  It's not called a\n"
    " * CollisionCylinder because it's not a true cylinder; specifically, it has\n"
    " * rounded ends instead of flat ends.  It looks more like a Contac pill.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionTube,
    0, // tp_members
    Dtool_Properties_CollisionTube,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionTube,
    PyType_GenericAlloc,
    Dtool_new_CollisionTube,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionTube,
  Dtool_UpcastInterface_CollisionTube,
  Dtool_DowncastInterface_CollisionTube,
  (CoerceFunction)Dtool_ConstCoerce_CollisionTube,
  (CoerceFunction)Dtool_Coerce_CollisionTube,
};

static void Dtool_PyModuleClassInit_CollisionTube(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(NULL);
    Dtool_CollisionTube._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    PyObject *dict = PyDict_New();
    Dtool_CollisionTube._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionTube) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionTube)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionTube);
  }
}

/**
 * Python method tables for CollisionVisualizer (CollisionVisualizer)
 */
static PyMethodDef Dtool_Methods_CollisionVisualizer[] = {
  {"set_point_scale", &Dtool_CollisionVisualizer_set_point_scale_393, METH_O, (const char *)Dtool_CollisionVisualizer_set_point_scale_393_comment},
  {"setPointScale", &Dtool_CollisionVisualizer_set_point_scale_393, METH_O, (const char *)Dtool_CollisionVisualizer_set_point_scale_393_comment},
  {"get_point_scale", &Dtool_CollisionVisualizer_get_point_scale_394, METH_NOARGS, (const char *)Dtool_CollisionVisualizer_get_point_scale_394_comment},
  {"getPointScale", &Dtool_CollisionVisualizer_get_point_scale_394, METH_NOARGS, (const char *)Dtool_CollisionVisualizer_get_point_scale_394_comment},
  {"set_normal_scale", &Dtool_CollisionVisualizer_set_normal_scale_395, METH_O, (const char *)Dtool_CollisionVisualizer_set_normal_scale_395_comment},
  {"setNormalScale", &Dtool_CollisionVisualizer_set_normal_scale_395, METH_O, (const char *)Dtool_CollisionVisualizer_set_normal_scale_395_comment},
  {"get_normal_scale", &Dtool_CollisionVisualizer_get_normal_scale_396, METH_NOARGS, (const char *)Dtool_CollisionVisualizer_get_normal_scale_396_comment},
  {"getNormalScale", &Dtool_CollisionVisualizer_get_normal_scale_396, METH_NOARGS, (const char *)Dtool_CollisionVisualizer_get_normal_scale_396_comment},
  {"clear", &Dtool_CollisionVisualizer_clear_397, METH_NOARGS, (const char *)Dtool_CollisionVisualizer_clear_397_comment},
  {"get_class_type", &Dtool_CollisionVisualizer_get_class_type_400, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionVisualizer_get_class_type_400_comment},
  {"getClassType", &Dtool_CollisionVisualizer_get_class_type_400, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionVisualizer_get_class_type_400_comment},
  {"upcast_to_PandaNode", &Dtool_CollisionVisualizer_upcast_to_PandaNode_387, METH_NOARGS, (const char *)Dtool_CollisionVisualizer_upcast_to_PandaNode_387_comment},
  {"upcastToPandaNode", &Dtool_CollisionVisualizer_upcast_to_PandaNode_387, METH_NOARGS, (const char *)Dtool_CollisionVisualizer_upcast_to_PandaNode_387_comment},
  {"upcast_to_CollisionRecorder", &Dtool_CollisionVisualizer_upcast_to_CollisionRecorder_389, METH_NOARGS, (const char *)Dtool_CollisionVisualizer_upcast_to_CollisionRecorder_389_comment},
  {"upcastToCollisionRecorder", &Dtool_CollisionVisualizer_upcast_to_CollisionRecorder_389, METH_NOARGS, (const char *)Dtool_CollisionVisualizer_upcast_to_CollisionRecorder_389_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_CollisionVisualizer[] = {
  {(char *)"point_scale", &Dtool_CollisionVisualizer_point_scale_Getter, &Dtool_CollisionVisualizer_point_scale_Setter, NULL, NULL},
  {(char *)"normal_scale", &Dtool_CollisionVisualizer_normal_scale_Getter, &Dtool_CollisionVisualizer_normal_scale_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_CollisionVisualizer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionVisualizer = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CollisionVisualizer = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CollisionVisualizer = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CollisionVisualizer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CollisionVisualizer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionVisualizer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CollisionVisualizer,
    &Dtool_SequenceMethods_CollisionVisualizer,
    &Dtool_MappingMethods_CollisionVisualizer,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CollisionVisualizer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to help debug the work the collisions system is doing.\n"
    " * It shows the polygons that are detected as collisions, as well as those\n"
    " * that are simply considered for collisions.\n"
    " *\n"
    " * It may be parented anywhere in the scene graph where it will be rendered to\n"
    " * achieve this.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CollisionVisualizer,
    0, // tp_members
    Dtool_Properties_CollisionVisualizer,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CollisionVisualizer,
    PyType_GenericAlloc,
    Dtool_new_CollisionVisualizer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionVisualizer,
  Dtool_UpcastInterface_CollisionVisualizer,
  Dtool_DowncastInterface_CollisionVisualizer,
  (CoerceFunction)Dtool_ConstCoerce_CollisionVisualizer,
  (CoerceFunction)Dtool_Coerce_CollisionVisualizer,
};

static void Dtool_PyModuleClassInit_CollisionVisualizer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_PyModuleClassInit_CollisionRecorder(NULL);
    Dtool_CollisionVisualizer._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_PandaNode, (PyTypeObject *)&Dtool_CollisionRecorder);
    PyObject *dict = PyDict_New();
    Dtool_CollisionVisualizer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionVisualizer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionVisualizer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionVisualizer);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3collide_RegisterTypes() {
  Dtool_CollisionSolid._type = CollisionSolid::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionSolid);
  Dtool_CollisionBox._type = CollisionBox::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionBox);
  Dtool_CollisionHandler._type = CollisionHandler::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionHandler);
  Dtool_CollisionNode._type = CollisionNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionNode);
  Dtool_CollisionTraverser._type = CollisionTraverser::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionTraverser);
  Dtool_CollisionRecorder._type = CollisionRecorder::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionRecorder);
  Dtool_CollisionEntry._type = CollisionEntry::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionEntry);
  Dtool_CollisionPlane._type = CollisionPlane::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionPlane);
  Dtool_CollisionFloorMesh._type = CollisionFloorMesh::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionFloorMesh);
  Dtool_CollisionPolygon._type = CollisionPolygon::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionPolygon);
  Dtool_CollisionHandlerEvent._type = CollisionHandlerEvent::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionHandlerEvent);
  Dtool_CollisionHandlerPhysical._type = CollisionHandlerPhysical::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionHandlerPhysical);
  Dtool_CollisionHandlerFloor._type = CollisionHandlerFloor::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionHandlerFloor);
  Dtool_CollisionHandlerPusher._type = CollisionHandlerPusher::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionHandlerPusher);
  Dtool_CollisionHandlerFluidPusher._type = CollisionHandlerFluidPusher::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionHandlerFluidPusher);
  Dtool_CollisionHandlerGravity._type = CollisionHandlerGravity::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionHandlerGravity);
  Dtool_CollisionHandlerHighestEvent._type = CollisionHandlerHighestEvent::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionHandlerHighestEvent);
  Dtool_CollisionHandlerQueue._type = CollisionHandlerQueue::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionHandlerQueue);
  Dtool_CollisionSphere._type = CollisionSphere::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionSphere);
  Dtool_CollisionInvSphere._type = CollisionInvSphere::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionInvSphere);
  Dtool_CollisionRay._type = CollisionRay::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionRay);
  Dtool_CollisionLine._type = CollisionLine::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionLine);
  Dtool_CollisionParabola._type = CollisionParabola::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionParabola);
  Dtool_CollisionSegment._type = CollisionSegment::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionSegment);
  Dtool_CollisionTube._type = CollisionTube::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionTube);
  Dtool_CollisionVisualizer._type = CollisionVisualizer::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CollisionVisualizer);
}

void Dtool_libp3collide_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_CachedTypedWritableReferenceCount = LookupRuntimeTypedClass(CachedTypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_CopyOnWriteObject = LookupRuntimeTypedClass(CopyOnWriteObject::get_class_type());
  Dtool_Ptr_LPoint2f = LookupRuntimeTypedClass(LPoint2f::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LVector3f = LookupRuntimeTypedClass(LVector3f::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_LPoint3i = LookupRuntimeTypedClass(LPoint3i::get_class_type());
  Dtool_Ptr_BitMask_uint32_t_32 = LookupRuntimeTypedClass(BitMask< uint32_t, 32 >::get_class_type());
  Dtool_Ptr_BoundingVolume = LookupRuntimeTypedClass(BoundingVolume::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_LParabolaf = LookupNamedClass("LParabolaf");
  Dtool_Ptr_LPlanef = LookupNamedClass("LPlanef");
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_DriveInterface = LookupRuntimeTypedClass(DriveInterface::get_class_type());
  Dtool_Ptr_LensNode = LookupRuntimeTypedClass(LensNode::get_class_type());
#endif
}

void Dtool_libp3collide_BuildInstants(PyObject *module) {
  (void) module;
  // CollisionSolid
  Dtool_PyModuleClassInit_CollisionSolid(module);
  PyModule_AddObject(module, "CollisionSolid", (PyObject *)&Dtool_CollisionSolid);
  // CollisionBox
  Dtool_PyModuleClassInit_CollisionBox(module);
  PyModule_AddObject(module, "CollisionBox", (PyObject *)&Dtool_CollisionBox);
  // CollisionHandler
  Dtool_PyModuleClassInit_CollisionHandler(module);
  PyModule_AddObject(module, "CollisionHandler", (PyObject *)&Dtool_CollisionHandler);
  // CollisionNode
  Dtool_PyModuleClassInit_CollisionNode(module);
  PyModule_AddObject(module, "CollisionNode", (PyObject *)&Dtool_CollisionNode);
  // CollisionTraverser
  Dtool_PyModuleClassInit_CollisionTraverser(module);
  PyModule_AddObject(module, "CollisionTraverser", (PyObject *)&Dtool_CollisionTraverser);
  // CollisionRecorder
  Dtool_PyModuleClassInit_CollisionRecorder(module);
  PyModule_AddObject(module, "CollisionRecorder", (PyObject *)&Dtool_CollisionRecorder);
  // CollisionEntry
  Dtool_PyModuleClassInit_CollisionEntry(module);
  PyModule_AddObject(module, "CollisionEntry", (PyObject *)&Dtool_CollisionEntry);
  // CollisionPlane
  Dtool_PyModuleClassInit_CollisionPlane(module);
  PyModule_AddObject(module, "CollisionPlane", (PyObject *)&Dtool_CollisionPlane);
  // CollisionFloorMesh
  Dtool_PyModuleClassInit_CollisionFloorMesh(module);
  PyModule_AddObject(module, "CollisionFloorMesh", (PyObject *)&Dtool_CollisionFloorMesh);
  // CollisionPolygon
  Dtool_PyModuleClassInit_CollisionPolygon(module);
  PyModule_AddObject(module, "CollisionPolygon", (PyObject *)&Dtool_CollisionPolygon);
  // CollisionHandlerEvent
  Dtool_PyModuleClassInit_CollisionHandlerEvent(module);
  PyModule_AddObject(module, "CollisionHandlerEvent", (PyObject *)&Dtool_CollisionHandlerEvent);
  // CollisionHandlerPhysical
  Dtool_PyModuleClassInit_CollisionHandlerPhysical(module);
  PyModule_AddObject(module, "CollisionHandlerPhysical", (PyObject *)&Dtool_CollisionHandlerPhysical);
  // CollisionHandlerFloor
  Dtool_PyModuleClassInit_CollisionHandlerFloor(module);
  PyModule_AddObject(module, "CollisionHandlerFloor", (PyObject *)&Dtool_CollisionHandlerFloor);
  // CollisionHandlerPusher
  Dtool_PyModuleClassInit_CollisionHandlerPusher(module);
  PyModule_AddObject(module, "CollisionHandlerPusher", (PyObject *)&Dtool_CollisionHandlerPusher);
  // CollisionHandlerFluidPusher
  Dtool_PyModuleClassInit_CollisionHandlerFluidPusher(module);
  PyModule_AddObject(module, "CollisionHandlerFluidPusher", (PyObject *)&Dtool_CollisionHandlerFluidPusher);
  // CollisionHandlerGravity
  Dtool_PyModuleClassInit_CollisionHandlerGravity(module);
  PyModule_AddObject(module, "CollisionHandlerGravity", (PyObject *)&Dtool_CollisionHandlerGravity);
  // CollisionHandlerHighestEvent
  Dtool_PyModuleClassInit_CollisionHandlerHighestEvent(module);
  PyModule_AddObject(module, "CollisionHandlerHighestEvent", (PyObject *)&Dtool_CollisionHandlerHighestEvent);
  // CollisionHandlerQueue
  Dtool_PyModuleClassInit_CollisionHandlerQueue(module);
  PyModule_AddObject(module, "CollisionHandlerQueue", (PyObject *)&Dtool_CollisionHandlerQueue);
  // CollisionSphere
  Dtool_PyModuleClassInit_CollisionSphere(module);
  PyModule_AddObject(module, "CollisionSphere", (PyObject *)&Dtool_CollisionSphere);
  // CollisionInvSphere
  Dtool_PyModuleClassInit_CollisionInvSphere(module);
  PyModule_AddObject(module, "CollisionInvSphere", (PyObject *)&Dtool_CollisionInvSphere);
  // CollisionRay
  Dtool_PyModuleClassInit_CollisionRay(module);
  PyModule_AddObject(module, "CollisionRay", (PyObject *)&Dtool_CollisionRay);
  // CollisionLine
  Dtool_PyModuleClassInit_CollisionLine(module);
  PyModule_AddObject(module, "CollisionLine", (PyObject *)&Dtool_CollisionLine);
  // CollisionParabola
  Dtool_PyModuleClassInit_CollisionParabola(module);
  PyModule_AddObject(module, "CollisionParabola", (PyObject *)&Dtool_CollisionParabola);
  // CollisionSegment
  Dtool_PyModuleClassInit_CollisionSegment(module);
  PyModule_AddObject(module, "CollisionSegment", (PyObject *)&Dtool_CollisionSegment);
  // CollisionTube
  Dtool_PyModuleClassInit_CollisionTube(module);
  PyModule_AddObject(module, "CollisionTube", (PyObject *)&Dtool_CollisionTube);
  // CollisionVisualizer
  Dtool_PyModuleClassInit_CollisionVisualizer(module);
  PyModule_AddObject(module, "CollisionVisualizer", (PyObject *)&Dtool_CollisionVisualizer);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3collide_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478213434,  /* file_identifier */
  "libp3collide",  /* library_name */
  "dlaq",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3collide.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  779  /* next_index */
};

Configure(_in_configure_libp3collide);
ConfigureFn(_in_configure_libp3collide) {
  interrogate_request_module(&_in_module_def);
}

