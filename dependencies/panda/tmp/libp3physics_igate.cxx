/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/physics -Ipanda/src/physics -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3physics_igate.cxx -od built/pandac/input/libp3physics.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/physics -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.physics -library libp3physics actorNode.h angularEulerIntegrator.h angularForce.h angularIntegrator.h angularVectorForce.h baseForce.h baseIntegrator.h config_physics.h forceNode.h linearControlForce.h linearCylinderVortexForce.h linearDistanceForce.h linearEulerIntegrator.h linearForce.h linearFrictionForce.h linearIntegrator.h linearJitterForce.h linearNoiseForce.h linearRandomForce.h linearSinkForce.h linearSourceForce.h linearUserDefinedForce.h linearVectorForce.h p3physics_composite1.cxx p3physics_composite2.cxx physical.h physicalNode.h physicsCollisionHandler.h physicsManager.h physicsObject.h physicsObjectCollection.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3physics
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "actorNode.h"
#include "angularEulerIntegrator.h"
#include "angularForce.h"
#include "angularIntegrator.h"
#include "angularVectorForce.h"
#include "baseForce.h"
#include "baseIntegrator.h"
#include "configVariableInt.h"
#include "config_physics.h"
#include "forceNode.h"
#include "linearControlForce.h"
#include "linearCylinderVortexForce.h"
#include "linearDistanceForce.h"
#include "linearEulerIntegrator.h"
#include "linearForce.h"
#include "linearFrictionForce.h"
#include "linearIntegrator.h"
#include "linearJitterForce.h"
#include "linearNoiseForce.h"
#include "linearRandomForce.h"
#include "linearSinkForce.h"
#include "linearSourceForce.h"
#include "linearUserDefinedForce.h"
#include "linearVectorForce.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "physical.h"
#include "physicalNode.h"
#include "physicsCollisionHandler.h"
#include "physicsManager.h"
#include "physicsObject.h"
#include "physicsObjectCollection.h"
#include "pvector.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class PhysicsObject
 */
typedef PhysicsObject PhysicsObject_localtype;
Define_Module_ClassRef(panda3d.physics, PhysicsObject, PhysicsObject_localtype, PhysicsObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PhysicsObject = &Dtool_PhysicsObject;
static void Dtool_PyModuleClassInit_PhysicsObject(PyObject *module);

/**
 * Forward declarations for top-level class PhysicsObjectCollection
 */
typedef PhysicsObjectCollection PhysicsObjectCollection_localtype;
Define_Module_Class(panda3d.physics, PhysicsObjectCollection, PhysicsObjectCollection_localtype, PhysicsObjectCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PhysicsObjectCollection = &Dtool_PhysicsObjectCollection;
static void Dtool_PyModuleClassInit_PhysicsObjectCollection(PyObject *module);

/**
 * Forward declarations for top-level class BaseForce
 */
typedef BaseForce BaseForce_localtype;
Define_Module_ClassRef(panda3d.physics, BaseForce, BaseForce_localtype, BaseForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BaseForce = &Dtool_BaseForce;
static void Dtool_PyModuleClassInit_BaseForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearForce
 */
typedef LinearForce LinearForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearForce, LinearForce_localtype, LinearForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearForce = &Dtool_LinearForce;
static void Dtool_PyModuleClassInit_LinearForce(PyObject *module);

/**
 * Forward declarations for top-level class AngularForce
 */
typedef AngularForce AngularForce_localtype;
Define_Module_ClassRef(panda3d.physics, AngularForce, AngularForce_localtype, AngularForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AngularForce = &Dtool_AngularForce;
static void Dtool_PyModuleClassInit_AngularForce(PyObject *module);

/**
 * Forward declarations for top-level class Physical
 */
typedef Physical Physical_localtype;
Define_Module_ClassRef(panda3d.physics, Physical, Physical_localtype, Physical);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Physical = &Dtool_Physical;
static void Dtool_PyModuleClassInit_Physical(PyObject *module);
bool Dtool_ConstCoerce_Physical(PyObject *args, CPT(Physical) &coerced);
bool Dtool_Coerce_Physical(PyObject *args, PT(Physical) &coerced);

/**
 * Forward declarations for top-level class PhysicalNode
 */
typedef PhysicalNode PhysicalNode_localtype;
Define_Module_ClassRef(panda3d.physics, PhysicalNode, PhysicalNode_localtype, PhysicalNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PhysicalNode = &Dtool_PhysicalNode;
static void Dtool_PyModuleClassInit_PhysicalNode(PyObject *module);
bool Dtool_ConstCoerce_PhysicalNode(PyObject *args, CPT(PhysicalNode) &coerced);
bool Dtool_Coerce_PhysicalNode(PyObject *args, PT(PhysicalNode) &coerced);

/**
 * Forward declarations for top-level class ActorNode
 */
typedef ActorNode ActorNode_localtype;
Define_Module_ClassRef(panda3d.physics, ActorNode, ActorNode_localtype, ActorNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ActorNode = &Dtool_ActorNode;
static void Dtool_PyModuleClassInit_ActorNode(PyObject *module);
bool Dtool_ConstCoerce_ActorNode(PyObject *args, CPT(ActorNode) &coerced);
bool Dtool_Coerce_ActorNode(PyObject *args, PT(ActorNode) &coerced);

/**
 * Forward declarations for top-level class BaseIntegrator
 */
typedef BaseIntegrator BaseIntegrator_localtype;
Define_Module_ClassRef(panda3d.physics, BaseIntegrator, BaseIntegrator_localtype, BaseIntegrator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BaseIntegrator = &Dtool_BaseIntegrator;
static void Dtool_PyModuleClassInit_BaseIntegrator(PyObject *module);

/**
 * Forward declarations for top-level class AngularIntegrator
 */
typedef AngularIntegrator AngularIntegrator_localtype;
Define_Module_ClassRef(panda3d.physics, AngularIntegrator, AngularIntegrator_localtype, AngularIntegrator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AngularIntegrator = &Dtool_AngularIntegrator;
static void Dtool_PyModuleClassInit_AngularIntegrator(PyObject *module);

/**
 * Forward declarations for top-level class AngularEulerIntegrator
 */
typedef AngularEulerIntegrator AngularEulerIntegrator_localtype;
Define_Module_ClassRef(panda3d.physics, AngularEulerIntegrator, AngularEulerIntegrator_localtype, AngularEulerIntegrator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AngularEulerIntegrator = &Dtool_AngularEulerIntegrator;
static void Dtool_PyModuleClassInit_AngularEulerIntegrator(PyObject *module);

/**
 * Forward declarations for top-level class AngularVectorForce
 */
typedef AngularVectorForce AngularVectorForce_localtype;
Define_Module_ClassRef(panda3d.physics, AngularVectorForce, AngularVectorForce_localtype, AngularVectorForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AngularVectorForce = &Dtool_AngularVectorForce;
static void Dtool_PyModuleClassInit_AngularVectorForce(PyObject *module);
bool Dtool_ConstCoerce_AngularVectorForce(PyObject *args, CPT(AngularVectorForce) &coerced);
bool Dtool_Coerce_AngularVectorForce(PyObject *args, PT(AngularVectorForce) &coerced);

/**
 * Forward declarations for top-level class ForceNode
 */
typedef ForceNode ForceNode_localtype;
Define_Module_ClassRef(panda3d.physics, ForceNode, ForceNode_localtype, ForceNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ForceNode = &Dtool_ForceNode;
static void Dtool_PyModuleClassInit_ForceNode(PyObject *module);
bool Dtool_ConstCoerce_ForceNode(PyObject *args, CPT(ForceNode) &coerced);
bool Dtool_Coerce_ForceNode(PyObject *args, PT(ForceNode) &coerced);

/**
 * Forward declarations for top-level class LinearControlForce
 */
typedef LinearControlForce LinearControlForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearControlForce, LinearControlForce_localtype, LinearControlForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearControlForce = &Dtool_LinearControlForce;
static void Dtool_PyModuleClassInit_LinearControlForce(PyObject *module);
bool Dtool_ConstCoerce_LinearControlForce(PyObject *args, CPT(LinearControlForce) &coerced);
bool Dtool_Coerce_LinearControlForce(PyObject *args, PT(LinearControlForce) &coerced);

/**
 * Forward declarations for top-level class LinearCylinderVortexForce
 */
typedef LinearCylinderVortexForce LinearCylinderVortexForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearCylinderVortexForce, LinearCylinderVortexForce_localtype, LinearCylinderVortexForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearCylinderVortexForce = &Dtool_LinearCylinderVortexForce;
static void Dtool_PyModuleClassInit_LinearCylinderVortexForce(PyObject *module);
bool Dtool_ConstCoerce_LinearCylinderVortexForce(PyObject *args, CPT(LinearCylinderVortexForce) &coerced);
bool Dtool_Coerce_LinearCylinderVortexForce(PyObject *args, PT(LinearCylinderVortexForce) &coerced);

/**
 * Forward declarations for top-level class LinearDistanceForce
 */
typedef LinearDistanceForce LinearDistanceForce_localtype;
Define_Module_ClassRef_Private(panda3d.physics, LinearDistanceForce, LinearDistanceForce_localtype, LinearDistanceForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearDistanceForce = &Dtool_LinearDistanceForce;
static void Dtool_PyModuleClassInit_LinearDistanceForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearIntegrator
 */
typedef LinearIntegrator LinearIntegrator_localtype;
Define_Module_ClassRef(panda3d.physics, LinearIntegrator, LinearIntegrator_localtype, LinearIntegrator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearIntegrator = &Dtool_LinearIntegrator;
static void Dtool_PyModuleClassInit_LinearIntegrator(PyObject *module);

/**
 * Forward declarations for top-level class LinearEulerIntegrator
 */
typedef LinearEulerIntegrator LinearEulerIntegrator_localtype;
Define_Module_ClassRef(panda3d.physics, LinearEulerIntegrator, LinearEulerIntegrator_localtype, LinearEulerIntegrator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearEulerIntegrator = &Dtool_LinearEulerIntegrator;
static void Dtool_PyModuleClassInit_LinearEulerIntegrator(PyObject *module);

/**
 * Forward declarations for top-level class LinearFrictionForce
 */
typedef LinearFrictionForce LinearFrictionForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearFrictionForce, LinearFrictionForce_localtype, LinearFrictionForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearFrictionForce = &Dtool_LinearFrictionForce;
static void Dtool_PyModuleClassInit_LinearFrictionForce(PyObject *module);
bool Dtool_ConstCoerce_LinearFrictionForce(PyObject *args, CPT(LinearFrictionForce) &coerced);
bool Dtool_Coerce_LinearFrictionForce(PyObject *args, PT(LinearFrictionForce) &coerced);

/**
 * Forward declarations for top-level class LinearRandomForce
 */
typedef LinearRandomForce LinearRandomForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearRandomForce, LinearRandomForce_localtype, LinearRandomForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearRandomForce = &Dtool_LinearRandomForce;
static void Dtool_PyModuleClassInit_LinearRandomForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearJitterForce
 */
typedef LinearJitterForce LinearJitterForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearJitterForce, LinearJitterForce_localtype, LinearJitterForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearJitterForce = &Dtool_LinearJitterForce;
static void Dtool_PyModuleClassInit_LinearJitterForce(PyObject *module);
bool Dtool_ConstCoerce_LinearJitterForce(PyObject *args, CPT(LinearJitterForce) &coerced);
bool Dtool_Coerce_LinearJitterForce(PyObject *args, PT(LinearJitterForce) &coerced);

/**
 * Forward declarations for top-level class LinearNoiseForce
 */
typedef LinearNoiseForce LinearNoiseForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearNoiseForce, LinearNoiseForce_localtype, LinearNoiseForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearNoiseForce = &Dtool_LinearNoiseForce;
static void Dtool_PyModuleClassInit_LinearNoiseForce(PyObject *module);
bool Dtool_ConstCoerce_LinearNoiseForce(PyObject *args, CPT(LinearNoiseForce) &coerced);
bool Dtool_Coerce_LinearNoiseForce(PyObject *args, PT(LinearNoiseForce) &coerced);

/**
 * Forward declarations for top-level class LinearSinkForce
 */
typedef LinearSinkForce LinearSinkForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearSinkForce, LinearSinkForce_localtype, LinearSinkForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearSinkForce = &Dtool_LinearSinkForce;
static void Dtool_PyModuleClassInit_LinearSinkForce(PyObject *module);
bool Dtool_ConstCoerce_LinearSinkForce(PyObject *args, CPT(LinearSinkForce) &coerced);
bool Dtool_Coerce_LinearSinkForce(PyObject *args, PT(LinearSinkForce) &coerced);

/**
 * Forward declarations for top-level class LinearSourceForce
 */
typedef LinearSourceForce LinearSourceForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearSourceForce, LinearSourceForce_localtype, LinearSourceForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearSourceForce = &Dtool_LinearSourceForce;
static void Dtool_PyModuleClassInit_LinearSourceForce(PyObject *module);
bool Dtool_ConstCoerce_LinearSourceForce(PyObject *args, CPT(LinearSourceForce) &coerced);
bool Dtool_Coerce_LinearSourceForce(PyObject *args, PT(LinearSourceForce) &coerced);

/**
 * Forward declarations for top-level class LinearUserDefinedForce
 */
typedef LinearUserDefinedForce LinearUserDefinedForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearUserDefinedForce, LinearUserDefinedForce_localtype, LinearUserDefinedForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearUserDefinedForce = &Dtool_LinearUserDefinedForce;
static void Dtool_PyModuleClassInit_LinearUserDefinedForce(PyObject *module);
bool Dtool_ConstCoerce_LinearUserDefinedForce(PyObject *args, CPT(LinearUserDefinedForce) &coerced);
bool Dtool_Coerce_LinearUserDefinedForce(PyObject *args, PT(LinearUserDefinedForce) &coerced);

/**
 * Forward declarations for top-level class LinearVectorForce
 */
typedef LinearVectorForce LinearVectorForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearVectorForce, LinearVectorForce_localtype, LinearVectorForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearVectorForce = &Dtool_LinearVectorForce;
static void Dtool_PyModuleClassInit_LinearVectorForce(PyObject *module);
bool Dtool_ConstCoerce_LinearVectorForce(PyObject *args, CPT(LinearVectorForce) &coerced);
bool Dtool_Coerce_LinearVectorForce(PyObject *args, PT(LinearVectorForce) &coerced);

/**
 * Forward declarations for top-level class PhysicsCollisionHandler
 */
typedef PhysicsCollisionHandler PhysicsCollisionHandler_localtype;
Define_Module_ClassRef(panda3d.physics, PhysicsCollisionHandler, PhysicsCollisionHandler_localtype, PhysicsCollisionHandler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PhysicsCollisionHandler = &Dtool_PhysicsCollisionHandler;
static void Dtool_PyModuleClassInit_PhysicsCollisionHandler(PyObject *module);

/**
 * Forward declarations for top-level class PhysicsManager
 */
typedef PhysicsManager PhysicsManager_localtype;
Define_Module_Class(panda3d.physics, PhysicsManager, PhysicsManager_localtype, PhysicsManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PhysicsManager = &Dtool_PhysicsManager;
static void Dtool_PyModuleClassInit_PhysicsManager(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3f;
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != NULL, NULL);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LRotationf
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LRotationf;
inline static LRotationf *Dtool_Coerce_LRotationf(PyObject *args, LRotationf &coerced) {
  nassertr(Dtool_Ptr_LRotationf != NULL, NULL);
  nassertr(Dtool_Ptr_LRotationf->_Dtool_Coerce != NULL, NULL);
  return ((LRotationf *(*)(PyObject *, LRotationf &))Dtool_Ptr_LRotationf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LRotationf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LRotationf = &Dtool_LRotationf;
extern LRotationf *Dtool_Coerce_LRotationf(PyObject *args, LRotationf &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LOrientationf
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LOrientationf;
inline static LOrientationf *Dtool_Coerce_LOrientationf(PyObject *args, LOrientationf &coerced) {
  nassertr(Dtool_Ptr_LOrientationf != NULL, NULL);
  nassertr(Dtool_Ptr_LOrientationf->_Dtool_Coerce != NULL, NULL);
  return ((LOrientationf *(*)(PyObject *, LOrientationf &))Dtool_Ptr_LOrientationf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LOrientationf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LOrientationf = &Dtool_LOrientationf;
extern LOrientationf *Dtool_Coerce_LOrientationf(PyObject *args, LOrientationf &coerced);
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// CollisionHandler
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CollisionHandler;
#else
extern struct Dtool_PyTypedObject Dtool_CollisionHandler;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandler = &Dtool_CollisionHandler;
#endif
// CollisionHandlerEvent
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CollisionHandlerEvent;
#else
extern struct Dtool_PyTypedObject Dtool_CollisionHandlerEvent;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerEvent = &Dtool_CollisionHandlerEvent;
#endif
// CollisionHandlerPusher
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CollisionHandlerPusher;
#else
extern struct Dtool_PyTypedObject Dtool_CollisionHandlerPusher;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerPusher = &Dtool_CollisionHandlerPusher;
#endif
// CollisionHandlerPhysical
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_CollisionHandlerPhysical;
#else
extern struct Dtool_PyTypedObject Dtool_CollisionHandlerPhysical;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerPhysical = &Dtool_CollisionHandlerPhysical;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class PhysicsObject
 */
/**
 * Python function wrapper for:
 * PhysicsObject const &PhysicsObject::operator =(PhysicsObject const &other)
 */
static PyObject *Dtool_PhysicsObject_operator_4(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.assign")) {
    return NULL;
  }
  // 1-PhysicsObject const &PhysicsObject::operator =(PhysicsObject const &other)
  PhysicsObject const *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "PhysicsObject.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    PhysicsObject *return_value = local_this;
    if (return_value != (PhysicsObject *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (PhysicsObject *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PhysicsObject, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PhysicsObject self, const PhysicsObject other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_operator_4_comment =
  "C++ Interface:\n"
  "assign(const PhysicsObject self, const PhysicsObject other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PhysicsObject_operator_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_active(bool flag)
 */
static PyObject *Dtool_PhysicsObject_set_active_5(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_active")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::set_active(bool flag)
  (*local_this).set_active((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const PhysicsObject self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_active_5_comment =
  "C++ Interface:\n"
  "set_active(const PhysicsObject self, bool flag)\n"
  "\n"
  "/**\n"
  " * Process Flag assignment\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_active_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PhysicsObject::get_active(void) const
 */
static PyObject *Dtool_PhysicsObject_get_active_6(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PhysicsObject::get_active(void) const
  bool return_value = (*(const PhysicsObject*)local_this).get_active();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_active_6_comment =
  "C++ Interface:\n"
  "get_active(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Process Flag Query\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_active_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_mass(PN_stdfloat )
 */
static PyObject *Dtool_PhysicsObject_set_mass_7(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_mass")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::set_mass(PN_stdfloat )
  if (PyNumber_Check(arg)) {
    (*local_this).set_mass((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mass(const PhysicsObject self, float param0)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_mass_7_comment =
  "C++ Interface:\n"
  "set_mass(const PhysicsObject self, float param0)\n"
  "\n"
  "/**\n"
  " * Set the mass in slugs (or kilograms).\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_mass_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsObject::get_mass(void) const
 */
static PyObject *Dtool_PhysicsObject_get_mass_8(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PhysicsObject::get_mass(void) const
  PN_stdfloat return_value = (*(const PhysicsObject*)local_this).get_mass();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_mass_8_comment =
  "C++ Interface:\n"
  "get_mass(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Get the mass in slugs (or kilograms).\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_mass_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_position(LPoint3 const &pos)
 * inline void PhysicsObject::set_position(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_PhysicsObject_set_position_9(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_position")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline void PhysicsObject::set_position(LPoint3 const &pos)
      LPoint3f arg_local;
      LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.set_position", "LPoint3f");
      }
      (*local_this).set_position(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void PhysicsObject::set_position(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_position", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_position((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_position() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_position(const PhysicsObject self, const LPoint3f pos)\n"
      "set_position(const PhysicsObject self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_position_9_comment =
  "C++ Interface:\n"
  "set_position(const PhysicsObject self, const LPoint3f pos)\n"
  "set_position(const PhysicsObject self, float x, float y, float z)\n"
  "\n"
  "// INLINE void set_center_of_mass(const LPoint3 &pos); use set_position.\n"
  "\n"
  "/**\n"
  " * Vector position assignment.  This is also used as the center of mass.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Piecewise position assignment\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_position_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 PhysicsObject::get_position(void) const
 */
static PyObject *Dtool_PhysicsObject_get_position_10(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 PhysicsObject::get_position(void) const
  LPoint3 *return_value = new LPoint3((*(const PhysicsObject*)local_this).get_position());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_position_10_comment =
  "C++ Interface:\n"
  "get_position(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Position Query\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_position_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::reset_position(LPoint3 const &pos)
 */
static PyObject *Dtool_PhysicsObject_reset_position_11(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.reset_position")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::reset_position(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.reset_position", "LPoint3f");
  }
  (*local_this).reset_position(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_position(const PhysicsObject self, const LPoint3f pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_reset_position_11_comment =
  "C++ Interface:\n"
  "reset_position(const PhysicsObject self, const LPoint3f pos)\n"
  "\n"
  "/**\n"
  " * use this to place an object in a completely new position, that has nothing\n"
  " * to do with its last position.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_reset_position_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_last_position(LPoint3 const &pos)
 */
static PyObject *Dtool_PhysicsObject_set_last_position_12(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_last_position")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::set_last_position(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.set_last_position", "LPoint3f");
  }
  (*local_this).set_last_position(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_last_position(const PhysicsObject self, const LPoint3f pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_last_position_12_comment =
  "C++ Interface:\n"
  "set_last_position(const PhysicsObject self, const LPoint3f pos)\n"
  "\n"
  "/**\n"
  " * Last position assignment\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_last_position_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 PhysicsObject::get_last_position(void) const
 */
static PyObject *Dtool_PhysicsObject_get_last_position_13(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 PhysicsObject::get_last_position(void) const
  LPoint3 *return_value = new LPoint3((*(const PhysicsObject*)local_this).get_last_position());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_last_position_13_comment =
  "C++ Interface:\n"
  "get_last_position(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Get the position of the physics object at the start of the most recent\n"
  " * do_physics.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_last_position_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_velocity(LVector3 const &vel)
 * inline void PhysicsObject::set_velocity(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_PhysicsObject_set_velocity_14(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_velocity")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "vel");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'vel' (pos 1) not found");
      }
      // 1-inline void PhysicsObject::set_velocity(LVector3 const &vel)
      LVector3f arg_local;
      LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.set_velocity", "LVector3f");
      }
      (*local_this).set_velocity(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void PhysicsObject::set_velocity(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_velocity", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_velocity((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_velocity() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_velocity(const PhysicsObject self, const LVector3f vel)\n"
      "set_velocity(const PhysicsObject self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_velocity_14_comment =
  "C++ Interface:\n"
  "set_velocity(const PhysicsObject self, const LVector3f vel)\n"
  "set_velocity(const PhysicsObject self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Vector velocity assignment\n"
  " */\n"
  "\n"
  "/**\n"
  " * Piecewise velocity assignment\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_velocity_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 PhysicsObject::get_velocity(void) const
 */
static PyObject *Dtool_PhysicsObject_get_velocity_15(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 PhysicsObject::get_velocity(void) const
  LVector3 *return_value = new LVector3((*(const PhysicsObject*)local_this).get_velocity());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_velocity_15_comment =
  "C++ Interface:\n"
  "get_velocity(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Velocity Query per second\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_velocity_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 PhysicsObject::get_implicit_velocity(void) const
 */
static PyObject *Dtool_PhysicsObject_get_implicit_velocity_16(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 PhysicsObject::get_implicit_velocity(void) const
  LVector3 *return_value = new LVector3((*(const PhysicsObject*)local_this).get_implicit_velocity());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_implicit_velocity_16_comment =
  "C++ Interface:\n"
  "get_implicit_velocity(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Velocity Query over the last dt\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_implicit_velocity_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::add_torque(LRotation const &torque)
 */
static PyObject *Dtool_PhysicsObject_add_torque_17(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_torque")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::add_torque(LRotation const &torque)
  LRotationf arg_local;
  LRotation const *arg_this = Dtool_Coerce_LRotationf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.add_torque", "LRotationf");
  }
  (*local_this).add_torque(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torque(const PhysicsObject self, const LRotationf torque)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_torque_17_comment =
  "C++ Interface:\n"
  "add_torque(const PhysicsObject self, const LRotationf torque)\n"
  "\n"
  "// Global instantanious forces\n"
  "\n"
  "/**\n"
  " * Adds an torque force (i.e.  an instantanious change in velocity).  This is\n"
  " * a quicker way to get the angular velocity, add a vector to it and set that\n"
  " * value to be the new angular velocity.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_torque_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::add_impulse(LVector3 const &impulse)
 */
static PyObject *Dtool_PhysicsObject_add_impulse_18(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_impulse")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::add_impulse(LVector3 const &impulse)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.add_impulse", "LVector3f");
  }
  (*local_this).add_impulse(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_impulse(const PhysicsObject self, const LVector3f impulse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_impulse_18_comment =
  "C++ Interface:\n"
  "add_impulse(const PhysicsObject self, const LVector3f impulse)\n"
  "\n"
  "/**\n"
  " * Adds an impulse force (i.e.  an instantanious change in velocity).  This is\n"
  " * a quicker way to get the velocity, add a vector to it and set that value to\n"
  " * be the new velocity.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_impulse_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsObject::add_impact(LPoint3 const &offset_from_center_of_mass, LVector3 const &impulse)
 */
static PyObject *Dtool_PhysicsObject_add_impact_19(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_impact")) {
    return NULL;
  }
  // 1-virtual void PhysicsObject::add_impact(LPoint3 const &offset_from_center_of_mass, LVector3 const &impulse)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"offset_from_center_of_mass", "impulse", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_impact", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PhysicsObject.add_impact", "LPoint3f");
    }
    LVector3f param2_local;
    LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PhysicsObject.add_impact", "LVector3f");
    }
    (*local_this).add_impact(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_impact(const PhysicsObject self, const LPoint3f offset_from_center_of_mass, const LVector3f impulse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_impact_19_comment =
  "C++ Interface:\n"
  "add_impact(const PhysicsObject self, const LPoint3f offset_from_center_of_mass, const LVector3f impulse)\n"
  "\n"
  "/**\n"
  " * Adds an impulse and/or torque (i.e.  an instantanious change in velocity)\n"
  " * based on how well the offset and impulse align with the center of mass (aka\n"
  " * position). If you wanted to immitate this function you could work out the\n"
  " * impulse and torque and call add_impulse and add_torque respectively.\n"
  " * offset and force are in global (or parent) coordinates.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_impact_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::add_local_torque(LRotation const &torque)
 */
static PyObject *Dtool_PhysicsObject_add_local_torque_20(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_local_torque")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::add_local_torque(LRotation const &torque)
  LRotationf arg_local;
  LRotation const *arg_this = Dtool_Coerce_LRotationf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.add_local_torque", "LRotationf");
  }
  (*local_this).add_local_torque(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_local_torque(const PhysicsObject self, const LRotationf torque)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_local_torque_20_comment =
  "C++ Interface:\n"
  "add_local_torque(const PhysicsObject self, const LRotationf torque)\n"
  "\n"
  "// Local instantanious forces\n"
  "\n"
  "/**\n"
  " * Adds an torque force (i.e.  an instantanious change in velocity).  This is\n"
  " * a quicker way to get the angular velocity, add a vector to it and set that\n"
  " * value to be the new angular velocity.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_local_torque_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::add_local_impulse(LVector3 const &impulse)
 */
static PyObject *Dtool_PhysicsObject_add_local_impulse_21(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_local_impulse")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::add_local_impulse(LVector3 const &impulse)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.add_local_impulse", "LVector3f");
  }
  (*local_this).add_local_impulse(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_local_impulse(const PhysicsObject self, const LVector3f impulse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_local_impulse_21_comment =
  "C++ Interface:\n"
  "add_local_impulse(const PhysicsObject self, const LVector3f impulse)\n"
  "\n"
  "/**\n"
  " * Adds an impulse force (i.e.  an instantanious change in velocity).  This is\n"
  " * a quicker way to get the velocity, add a vector to it and set that value to\n"
  " * be the new velocity.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_local_impulse_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsObject::add_local_impact(LPoint3 const &offset_from_center_of_mass, LVector3 const &impulse)
 */
static PyObject *Dtool_PhysicsObject_add_local_impact_22(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_local_impact")) {
    return NULL;
  }
  // 1-virtual void PhysicsObject::add_local_impact(LPoint3 const &offset_from_center_of_mass, LVector3 const &impulse)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"offset_from_center_of_mass", "impulse", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_local_impact", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PhysicsObject.add_local_impact", "LPoint3f");
    }
    LVector3f param2_local;
    LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PhysicsObject.add_local_impact", "LVector3f");
    }
    (*local_this).add_local_impact(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_local_impact(const PhysicsObject self, const LPoint3f offset_from_center_of_mass, const LVector3f impulse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_local_impact_22_comment =
  "C++ Interface:\n"
  "add_local_impact(const PhysicsObject self, const LPoint3f offset_from_center_of_mass, const LVector3f impulse)\n"
  "\n"
  "/**\n"
  " * Adds an impulse and/or torque (i.e.  an instantanious change in velocity)\n"
  " * based on how well the offset and impulse align with the center of mass (aka\n"
  " * position). If you wanted to immitate this function you could work out the\n"
  " * impulse and torque and call add_impulse and add_torque respectively.\n"
  " * offset and force are in local coordinates.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_local_impact_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_terminal_velocity(PN_stdfloat tv)
 */
static PyObject *Dtool_PhysicsObject_set_terminal_velocity_23(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_terminal_velocity")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::set_terminal_velocity(PN_stdfloat tv)
  if (PyNumber_Check(arg)) {
    (*local_this).set_terminal_velocity((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_terminal_velocity(const PhysicsObject self, float tv)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_terminal_velocity_23_comment =
  "C++ Interface:\n"
  "set_terminal_velocity(const PhysicsObject self, float tv)\n"
  "\n"
  "/**\n"
  " * tv assignment\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_terminal_velocity_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsObject::get_terminal_velocity(void) const
 */
static PyObject *Dtool_PhysicsObject_get_terminal_velocity_24(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PhysicsObject::get_terminal_velocity(void) const
  PN_stdfloat return_value = (*(const PhysicsObject*)local_this).get_terminal_velocity();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_terminal_velocity_24_comment =
  "C++ Interface:\n"
  "get_terminal_velocity(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * tv query\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_terminal_velocity_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_oriented(bool flag)
 */
static PyObject *Dtool_PhysicsObject_set_oriented_25(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_oriented")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::set_oriented(bool flag)
  (*local_this).set_oriented((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_oriented(const PhysicsObject self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_oriented_25_comment =
  "C++ Interface:\n"
  "set_oriented(const PhysicsObject self, bool flag)\n"
  "\n"
  "/**\n"
  " * Set flag to determine whether this object should do any rotation or\n"
  " * orientation calculations.  Optimization.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_oriented_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PhysicsObject::get_oriented(void) const
 */
static PyObject *Dtool_PhysicsObject_get_oriented_26(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PhysicsObject::get_oriented(void) const
  bool return_value = (*(const PhysicsObject*)local_this).get_oriented();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_oriented_26_comment =
  "C++ Interface:\n"
  "get_oriented(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * See set_oriented().\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_oriented_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_orientation(LOrientation const &orientation)
 */
static PyObject *Dtool_PhysicsObject_set_orientation_27(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_orientation")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::set_orientation(LOrientation const &orientation)
  LOrientationf arg_local;
  LOrientation const *arg_this = Dtool_Coerce_LOrientationf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.set_orientation", "LOrientationf");
  }
  (*local_this).set_orientation(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_orientation(const PhysicsObject self, const LOrientationf orientation)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_orientation_27_comment =
  "C++ Interface:\n"
  "set_orientation(const PhysicsObject self, const LOrientationf orientation)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_orientation_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LOrientation PhysicsObject::get_orientation(void) const
 */
static PyObject *Dtool_PhysicsObject_get_orientation_28(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LOrientation PhysicsObject::get_orientation(void) const
  LOrientation *return_value = new LOrientation((*(const PhysicsObject*)local_this).get_orientation());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationf, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_orientation_28_comment =
  "C++ Interface:\n"
  "get_orientation(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * get current orientation.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_orientation_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::reset_orientation(LOrientation const &orientation)
 */
static PyObject *Dtool_PhysicsObject_reset_orientation_29(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.reset_orientation")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::reset_orientation(LOrientation const &orientation)
  LOrientationf arg_local;
  LOrientation const *arg_this = Dtool_Coerce_LOrientationf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.reset_orientation", "LOrientationf");
  }
  (*local_this).reset_orientation(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_orientation(const PhysicsObject self, const LOrientationf orientation)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_reset_orientation_29_comment =
  "C++ Interface:\n"
  "reset_orientation(const PhysicsObject self, const LOrientationf orientation)\n"
  "\n"
  "/**\n"
  " * set the orientation while clearing the rotation velocity.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_reset_orientation_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_rotation(LRotation const &rotation)
 */
static PyObject *Dtool_PhysicsObject_set_rotation_30(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_rotation")) {
    return NULL;
  }
  // 1-inline void PhysicsObject::set_rotation(LRotation const &rotation)
  LRotationf arg_local;
  LRotation const *arg_this = Dtool_Coerce_LRotationf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.set_rotation", "LRotationf");
  }
  (*local_this).set_rotation(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotation(const PhysicsObject self, const LRotationf rotation)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_rotation_30_comment =
  "C++ Interface:\n"
  "set_rotation(const PhysicsObject self, const LRotationf rotation)\n"
  "\n"
  "/**\n"
  " * set rotation as a quaternion delta per second.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_rotation_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LRotation PhysicsObject::get_rotation(void) const
 */
static PyObject *Dtool_PhysicsObject_get_rotation_31(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LRotation PhysicsObject::get_rotation(void) const
  LRotation *return_value = new LRotation((*(const PhysicsObject*)local_this).get_rotation());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationf, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_rotation_31_comment =
  "C++ Interface:\n"
  "get_rotation(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * get rotation per second.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_rotation_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual LMatrix4 PhysicsObject::get_inertial_tensor(void) const
 */
static PyObject *Dtool_PhysicsObject_get_inertial_tensor_32(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual LMatrix4 PhysicsObject::get_inertial_tensor(void) const
  LMatrix4 *return_value = new LMatrix4((*(const PhysicsObject*)local_this).get_inertial_tensor());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_inertial_tensor_32_comment =
  "C++ Interface:\n"
  "get_inertial_tensor(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * returns a transform matrix that represents the object's willingness to be\n"
  " * forced.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_inertial_tensor_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual LMatrix4 PhysicsObject::get_lcs(void) const
 */
static PyObject *Dtool_PhysicsObject_get_lcs_33(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual LMatrix4 PhysicsObject::get_lcs(void) const
  LMatrix4 *return_value = new LMatrix4((*(const PhysicsObject*)local_this).get_lcs());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_lcs_33_comment =
  "C++ Interface:\n"
  "get_lcs(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * returns a transform matrix to this object's local coordinate system.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_lcs_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PhysicsObject *PhysicsObject::make_copy(void) const
 */
static PyObject *Dtool_PhysicsObject_make_copy_34(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PhysicsObject *PhysicsObject::make_copy(void) const
  PhysicsObject *return_value = (*(const PhysicsObject*)local_this).make_copy();
  if (return_value != (PhysicsObject *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PhysicsObject *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PhysicsObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_make_copy_34_comment =
  "C++ Interface:\n"
  "make_copy(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * dynamic copy.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_make_copy_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObject::set_name(std::string const &name)
 */
static PyObject *Dtool_PhysicsObject_set_name_35(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_name")) {
    return NULL;
  }
  // 1-void PhysicsObject::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const PhysicsObject self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_name_35_comment =
  "C++ Interface:\n"
  "set_name(const PhysicsObject self, str name)\n";
#else
static const char *Dtool_PhysicsObject_set_name_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string const &PhysicsObject::get_name(void)
 */
static PyObject *Dtool_PhysicsObject_get_name_36(PyObject *self, PyObject *) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.get_name")) {
    return NULL;
  }
  // 1-std::string const &PhysicsObject::get_name(void)
  std::string const &return_value = (*local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_name_36_comment =
  "C++ Interface:\n"
  "get_name(const PhysicsObject self)\n";
#else
static const char *Dtool_PhysicsObject_get_name_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsObject::output(ostream &out) const
 */
static PyObject *Dtool_PhysicsObject_output_37(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PhysicsObject::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PhysicsObject.output", false, true);
  if (arg_this != NULL) {
    (*(const PhysicsObject*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PhysicsObject self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_output_37_comment =
  "C++ Interface:\n"
  "output(PhysicsObject self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_output_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsObject::write(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_PhysicsObject_write_38(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PhysicsObject::write(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PhysicsObject.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const PhysicsObject*)local_this).write(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PhysicsObject self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_write_38_comment =
  "C++ Interface:\n"
  "write(PhysicsObject self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_write_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PhysicsObject::get_class_type(void)
 */
static PyObject *Dtool_PhysicsObject_get_class_type_39(PyObject *, PyObject *) {
  // 1-static TypeHandle PhysicsObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PhysicsObject::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_class_type_39_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PhysicsObject_get_class_type_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PhysicsObject::PhysicsObject(void)
 * PhysicsObject::PhysicsObject(PhysicsObject const &copy)
 */
static int Dtool_Init_PhysicsObject(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PhysicsObject::PhysicsObject(void)
      PhysicsObject *return_value = new PhysicsObject();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsObject, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-PhysicsObject::PhysicsObject(PhysicsObject const &copy)
      PhysicsObject const *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 0, "PhysicsObject.PhysicsObject", true, true);
      if (arg_this != NULL) {
        PhysicsObject *return_value = new PhysicsObject(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsObject, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PhysicsObject() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PhysicsObject()\n"
      "PhysicsObject(const PhysicsObject copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PhysicsObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PhysicsObject) {
    printf("PhysicsObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PhysicsObject *local_this = (PhysicsObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PhysicsObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PhysicsObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PhysicsObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PhysicsObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PhysicsObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PhysicsObject*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PhysicsObjectCollection
 */
/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::operator =(PhysicsObjectCollection const &copy)
 */
static PyObject *Dtool_PhysicsObjectCollection_operator_42(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.assign")) {
    return NULL;
  }
  // 1-void PhysicsObjectCollection::operator =(PhysicsObjectCollection const &copy)
  PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 1, "PhysicsObjectCollection.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    PhysicsObjectCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PhysicsObjectCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PhysicsObjectCollection self, const PhysicsObjectCollection copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_operator_42_comment =
  "C++ Interface:\n"
  "assign(const PhysicsObjectCollection self, const PhysicsObjectCollection copy)\n";
#else
static const char *Dtool_PhysicsObjectCollection_operator_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::add_physics_object(PointerTo< PhysicsObject > physics_object)
 */
static PyObject *Dtool_PhysicsObjectCollection_add_physics_object_44(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.add_physics_object")) {
    return NULL;
  }
  // 1-void PhysicsObjectCollection::add_physics_object(PointerTo< PhysicsObject > physics_object)
  PhysicsObject *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "PhysicsObjectCollection.add_physics_object", false, true);
  if (arg_this != NULL) {
    (*local_this).add_physics_object(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_physics_object(const PhysicsObjectCollection self, PhysicsObject physics_object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_add_physics_object_44_comment =
  "C++ Interface:\n"
  "add_physics_object(const PhysicsObjectCollection self, PhysicsObject physics_object)\n"
  "\n"
  "/**\n"
  " * Adds a new PhysicsObject to the collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_add_physics_object_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PhysicsObjectCollection::remove_physics_object(PointerTo< PhysicsObject > physics_object)
 */
static PyObject *Dtool_PhysicsObjectCollection_remove_physics_object_45(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.remove_physics_object")) {
    return NULL;
  }
  // 1-bool PhysicsObjectCollection::remove_physics_object(PointerTo< PhysicsObject > physics_object)
  PhysicsObject *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "PhysicsObjectCollection.remove_physics_object", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).remove_physics_object(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_physics_object(const PhysicsObjectCollection self, PhysicsObject physics_object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_remove_physics_object_45_comment =
  "C++ Interface:\n"
  "remove_physics_object(const PhysicsObjectCollection self, PhysicsObject physics_object)\n"
  "\n"
  "/**\n"
  " * Removes the indicated PhysicsObject from the collection.  Returns true if\n"
  " * the physics_object was removed, false if it was not a member of the\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_remove_physics_object_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::add_physics_objects_from(PhysicsObjectCollection const &other)
 */
static PyObject *Dtool_PhysicsObjectCollection_add_physics_objects_from_46(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.add_physics_objects_from")) {
    return NULL;
  }
  // 1-void PhysicsObjectCollection::add_physics_objects_from(PhysicsObjectCollection const &other)
  PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 1, "PhysicsObjectCollection.add_physics_objects_from", true, true);
  if (arg_this != NULL) {
    (*local_this).add_physics_objects_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_physics_objects_from(const PhysicsObjectCollection self, const PhysicsObjectCollection other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_add_physics_objects_from_46_comment =
  "C++ Interface:\n"
  "add_physics_objects_from(const PhysicsObjectCollection self, const PhysicsObjectCollection other)\n"
  "\n"
  "/**\n"
  " * Adds all the PhysicsObjects indicated in the other collection to this\n"
  " * collection.  The other physics_objects are simply appended to the end of\n"
  " * the physics_objects in this list; duplicates are not automatically removed.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_add_physics_objects_from_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::remove_physics_objects_from(PhysicsObjectCollection const &other)
 */
static PyObject *Dtool_PhysicsObjectCollection_remove_physics_objects_from_47(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.remove_physics_objects_from")) {
    return NULL;
  }
  // 1-void PhysicsObjectCollection::remove_physics_objects_from(PhysicsObjectCollection const &other)
  PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 1, "PhysicsObjectCollection.remove_physics_objects_from", true, true);
  if (arg_this != NULL) {
    (*local_this).remove_physics_objects_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_physics_objects_from(const PhysicsObjectCollection self, const PhysicsObjectCollection other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_remove_physics_objects_from_47_comment =
  "C++ Interface:\n"
  "remove_physics_objects_from(const PhysicsObjectCollection self, const PhysicsObjectCollection other)\n"
  "\n"
  "/**\n"
  " * Removes from this collection all of the PhysicsObjects listed in the other\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_remove_physics_objects_from_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::remove_duplicate_physics_objects(void)
 */
static PyObject *Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48(PyObject *self, PyObject *) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.remove_duplicate_physics_objects")) {
    return NULL;
  }
  // 1-void PhysicsObjectCollection::remove_duplicate_physics_objects(void)
  (*local_this).remove_duplicate_physics_objects();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48_comment =
  "C++ Interface:\n"
  "remove_duplicate_physics_objects(const PhysicsObjectCollection self)\n"
  "\n"
  "/**\n"
  " * Removes any duplicate entries of the same PhysicsObjects on this\n"
  " * collection.  If a PhysicsObject appears multiple times, the first\n"
  " * appearance is retained; subsequent appearances are removed.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PhysicsObjectCollection::has_physics_object(PointerTo< PhysicsObject > physics_object) const
 */
static PyObject *Dtool_PhysicsObjectCollection_has_physics_object_49(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PhysicsObjectCollection::has_physics_object(PointerTo< PhysicsObject > physics_object) const
  PhysicsObject *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "PhysicsObjectCollection.has_physics_object", false, true);
  if (arg_this != NULL) {
    bool return_value = (*(const PhysicsObjectCollection*)local_this).has_physics_object(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_physics_object(PhysicsObjectCollection self, PhysicsObject physics_object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_has_physics_object_49_comment =
  "C++ Interface:\n"
  "has_physics_object(PhysicsObjectCollection self, PhysicsObject physics_object)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated PhysicsObject appears in this collection,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_has_physics_object_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::clear(void)
 */
static PyObject *Dtool_PhysicsObjectCollection_clear_50(PyObject *self, PyObject *) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.clear")) {
    return NULL;
  }
  // 1-void PhysicsObjectCollection::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_clear_50_comment =
  "C++ Interface:\n"
  "clear(const PhysicsObjectCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all PhysicsObjects from the collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_clear_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PhysicsObjectCollection::is_empty(void) const
 */
static PyObject *Dtool_PhysicsObjectCollection_is_empty_51(PyObject *self, PyObject *) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PhysicsObjectCollection::is_empty(void) const
  bool return_value = (*(const PhysicsObjectCollection*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_is_empty_51_comment =
  "C++ Interface:\n"
  "is_empty(PhysicsObjectCollection self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are no PhysicsObjects in the collection, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_is_empty_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int PhysicsObjectCollection::get_num_physics_objects(void) const
 */
static PyObject *Dtool_PhysicsObjectCollection_get_num_physics_objects_52(PyObject *self, PyObject *) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-int PhysicsObjectCollection::get_num_physics_objects(void) const
  int return_value = (*(const PhysicsObjectCollection*)local_this).get_num_physics_objects();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_get_num_physics_objects_52_comment =
  "C++ Interface:\n"
  "get_num_physics_objects(PhysicsObjectCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of PhysicsObjects in the collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_get_num_physics_objects_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PhysicsObject > PhysicsObjectCollection::get_physics_object(int index) const
 */
static PyObject *Dtool_PhysicsObjectCollection_get_physics_object_53(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-PointerTo< PhysicsObject > PhysicsObjectCollection::get_physics_object(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< PhysicsObject > return_value = (*(const PhysicsObjectCollection*)local_this).get_physics_object((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    PhysicsObject *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PhysicsObject, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_physics_object(PhysicsObjectCollection self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_get_physics_object_53_comment =
  "C++ Interface:\n"
  "get_physics_object(PhysicsObjectCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth PhysicsObject in the collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_get_physics_object_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::output(ostream &out) const
 */
static PyObject *Dtool_PhysicsObjectCollection_output_59(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PhysicsObjectCollection::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PhysicsObjectCollection.output", false, true);
  if (arg_this != NULL) {
    (*(const PhysicsObjectCollection*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PhysicsObjectCollection self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_output_59_comment =
  "C++ Interface:\n"
  "output(PhysicsObjectCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the PhysicsObjectCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_output_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_PhysicsObjectCollection_write_60(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PhysicsObjectCollection::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PhysicsObjectCollection.write", false, true);
    if (param1_this != NULL) {
      (*(const PhysicsObjectCollection*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PhysicsObjectCollection self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_write_60_comment =
  "C++ Interface:\n"
  "write(PhysicsObjectCollection self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the PhysicsObjectCollection to\n"
  " * the indicated output stream.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_write_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PhysicsObjectCollection::PhysicsObjectCollection(void)
 * PhysicsObjectCollection::PhysicsObjectCollection(PhysicsObjectCollection const &copy)
 */
static int Dtool_Init_PhysicsObjectCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PhysicsObjectCollection::PhysicsObjectCollection(void)
      PhysicsObjectCollection *return_value = new PhysicsObjectCollection();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsObjectCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-PhysicsObjectCollection::PhysicsObjectCollection(PhysicsObjectCollection const &copy)
      PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 0, "PhysicsObjectCollection.PhysicsObjectCollection", true, true);
      if (arg_this != NULL) {
        PhysicsObjectCollection *return_value = new PhysicsObjectCollection(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsObjectCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PhysicsObjectCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PhysicsObjectCollection()\n"
      "PhysicsObjectCollection(const PhysicsObjectCollection copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PhysicsObjectCollection_get_physics_objects(PyObject *self, PyObject *) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_physics_objects();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PhysicsObjectCollection_get_physics_object_53(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PhysicsObjectCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PhysicsObjectCollection) {
    printf("PhysicsObjectCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PhysicsObjectCollection *local_this = (PhysicsObjectCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PhysicsObjectCollection) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PhysicsObjectCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PhysicsObjectCollection) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BaseForce
 */
/**
 * Python function wrapper for:
 * inline bool BaseForce::get_active(void) const
 */
static PyObject *Dtool_BaseForce_get_active_62(PyObject *self, PyObject *) {
  BaseForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BaseForce::get_active(void) const
  bool return_value = (*(const BaseForce*)local_this).get_active();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_get_active_62_comment =
  "C++ Interface:\n"
  "get_active(BaseForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_BaseForce_get_active_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BaseForce::set_active(bool active)
 */
static PyObject *Dtool_BaseForce_set_active_63(PyObject *self, PyObject *arg) {
  BaseForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseForce, (void **)&local_this, "BaseForce.set_active")) {
    return NULL;
  }
  // 1-inline void BaseForce::set_active(bool active)
  (*local_this).set_active((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const BaseForce self, bool active)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_set_active_63_comment =
  "C++ Interface:\n"
  "set_active(const BaseForce self, bool active)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_BaseForce_set_active_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool BaseForce::is_linear(void) const = 0
 */
static PyObject *Dtool_BaseForce_is_linear_64(PyObject *self, PyObject *) {
  BaseForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool BaseForce::is_linear(void) const = 0
  bool return_value = (*(const BaseForce*)local_this).is_linear();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_is_linear_64_comment =
  "C++ Interface:\n"
  "is_linear(BaseForce self)\n";
#else
static const char *Dtool_BaseForce_is_linear_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ForceNode *BaseForce::get_force_node(void) const
 */
static PyObject *Dtool_BaseForce_get_force_node_65(PyObject *self, PyObject *) {
  BaseForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ForceNode *BaseForce::get_force_node(void) const
  ForceNode *return_value = (*(const BaseForce*)local_this).get_force_node();
  if (return_value != (ForceNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (ForceNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ForceNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_get_force_node_65_comment =
  "C++ Interface:\n"
  "get_force_node(BaseForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_BaseForce_get_force_node_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath BaseForce::get_force_node_path(void) const
 */
static PyObject *Dtool_BaseForce_get_force_node_path_66(PyObject *self, PyObject *) {
  BaseForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath BaseForce::get_force_node_path(void) const
  NodePath *return_value = new NodePath((*(const BaseForce*)local_this).get_force_node_path());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_get_force_node_path_66_comment =
  "C++ Interface:\n"
  "get_force_node_path(BaseForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_BaseForce_get_force_node_path_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseForce::output(ostream &out) const
 */
static PyObject *Dtool_BaseForce_output_67(PyObject *self, PyObject *arg) {
  BaseForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseForce::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "BaseForce.output", false, true);
  if (arg_this != NULL) {
    (*(const BaseForce*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BaseForce self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_output_67_comment =
  "C++ Interface:\n"
  "output(BaseForce self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseForce_output_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseForce::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BaseForce_write_68(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseForce::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BaseForce.write", false, true);
    if (param1_this != NULL) {
      (*(const BaseForce*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BaseForce self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_write_68_comment =
  "C++ Interface:\n"
  "write(BaseForce self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseForce_write_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BaseForce::get_class_type(void)
 */
static PyObject *Dtool_BaseForce_get_class_type_69(PyObject *, PyObject *) {
  // 1-static TypeHandle BaseForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BaseForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_get_class_type_69_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BaseForce_get_class_type_69_comment = NULL;
#endif

static int Dtool_Init_BaseForce(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BaseForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BaseForce) {
    printf("BaseForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BaseForce *local_this = (BaseForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BaseForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BaseForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BaseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BaseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BaseForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearForce
 */
/**
 * Python function wrapper for:
 * inline void LinearForce::set_amplitude(PN_stdfloat const a)
 */
static PyObject *Dtool_LinearForce_set_amplitude_71(PyObject *self, PyObject *arg) {
  LinearForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.set_amplitude")) {
    return NULL;
  }
  // 1-inline void LinearForce::set_amplitude(PN_stdfloat const a)
  if (PyNumber_Check(arg)) {
    (*local_this).set_amplitude((PN_stdfloat const)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_amplitude(const LinearForce self, float a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_set_amplitude_71_comment =
  "C++ Interface:\n"
  "set_amplitude(const LinearForce self, float a)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_set_amplitude_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LinearForce::set_mass_dependent(bool m)
 */
static PyObject *Dtool_LinearForce_set_mass_dependent_72(PyObject *self, PyObject *arg) {
  LinearForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.set_mass_dependent")) {
    return NULL;
  }
  // 1-inline void LinearForce::set_mass_dependent(bool m)
  (*local_this).set_mass_dependent((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mass_dependent(const LinearForce self, bool m)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_set_mass_dependent_72_comment =
  "C++ Interface:\n"
  "set_mass_dependent(const LinearForce self, bool m)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_set_mass_dependent_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearForce::get_amplitude(void) const
 */
static PyObject *Dtool_LinearForce_get_amplitude_73(PyObject *self, PyObject *) {
  LinearForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat LinearForce::get_amplitude(void) const
  PN_stdfloat return_value = (*(const LinearForce*)local_this).get_amplitude();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_get_amplitude_73_comment =
  "C++ Interface:\n"
  "get_amplitude(LinearForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_get_amplitude_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LinearForce::get_mass_dependent(void) const
 */
static PyObject *Dtool_LinearForce_get_mass_dependent_74(PyObject *self, PyObject *) {
  LinearForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LinearForce::get_mass_dependent(void) const
  bool return_value = (*(const LinearForce*)local_this).get_mass_dependent();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_get_mass_dependent_74_comment =
  "C++ Interface:\n"
  "get_mass_dependent(LinearForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_get_mass_dependent_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LinearForce::set_vector_masks(bool x, bool y, bool z)
 */
static PyObject *Dtool_LinearForce_set_vector_masks_75(PyObject *self, PyObject *args, PyObject *kwds) {
  LinearForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.set_vector_masks")) {
    return NULL;
  }
  // 1-inline void LinearForce::set_vector_masks(bool x, bool y, bool z)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"x", "y", "z", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_vector_masks", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_vector_masks((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vector_masks(const LinearForce self, bool x, bool y, bool z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_set_vector_masks_75_comment =
  "C++ Interface:\n"
  "set_vector_masks(const LinearForce self, bool x, bool y, bool z)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_set_vector_masks_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 LinearForce::get_vector_masks(void)
 */
static PyObject *Dtool_LinearForce_get_vector_masks_76(PyObject *self, PyObject *) {
  LinearForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.get_vector_masks")) {
    return NULL;
  }
  // 1-inline LVector3 LinearForce::get_vector_masks(void)
  LVector3 *return_value = new LVector3((*local_this).get_vector_masks());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_get_vector_masks_76_comment =
  "C++ Interface:\n"
  "get_vector_masks(const LinearForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_get_vector_masks_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVector3 LinearForce::get_vector(PhysicsObject const *po)
 */
static PyObject *Dtool_LinearForce_get_vector_77(PyObject *self, PyObject *arg) {
  LinearForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.get_vector")) {
    return NULL;
  }
  // 1-LVector3 LinearForce::get_vector(PhysicsObject const *po)
  PhysicsObject const *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "LinearForce.get_vector", true, true);
  if (arg_this != NULL) {
    LVector3 *return_value = new LVector3((*local_this).get_vector(arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vector(const LinearForce self, const PhysicsObject po)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_get_vector_77_comment =
  "C++ Interface:\n"
  "get_vector(const LinearForce self, const PhysicsObject po)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_get_vector_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual LinearForce *LinearForce::make_copy(void) = 0
 */
static PyObject *Dtool_LinearForce_make_copy_78(PyObject *self, PyObject *) {
  LinearForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.make_copy")) {
    return NULL;
  }
  // 1-virtual LinearForce *LinearForce::make_copy(void) = 0
  LinearForce *return_value = (*local_this).make_copy();
  if (return_value != (LinearForce *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (LinearForce *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LinearForce, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_make_copy_78_comment =
  "C++ Interface:\n"
  "make_copy(const LinearForce self)\n";
#else
static const char *Dtool_LinearForce_make_copy_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void LinearForce::write(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_LinearForce_write_79(PyObject *self, PyObject *args, PyObject *kwds) {
  LinearForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void LinearForce::write(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "LinearForce.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const LinearForce*)local_this).write(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LinearForce self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_write_79_comment =
  "C++ Interface:\n"
  "write(LinearForce self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_LinearForce_write_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearForce::get_class_type(void)
 */
static PyObject *Dtool_LinearForce_get_class_type_80(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_get_class_type_80_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearForce_get_class_type_80_comment = NULL;
#endif

static int Dtool_Init_LinearForce(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LinearForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearForce) {
    printf("LinearForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearForce *local_this = (LinearForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AngularForce
 */
/**
 * Python function wrapper for:
 * virtual AngularForce *AngularForce::make_copy(void) const = 0
 */
static PyObject *Dtool_AngularForce_make_copy_82(PyObject *self, PyObject *) {
  AngularForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AngularForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual AngularForce *AngularForce::make_copy(void) const = 0
  AngularForce *return_value = (*(const AngularForce*)local_this).make_copy();
  if (return_value != (AngularForce *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (AngularForce *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AngularForce, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AngularForce_make_copy_82_comment =
  "C++ Interface:\n"
  "make_copy(AngularForce self)\n";
#else
static const char *Dtool_AngularForce_make_copy_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LRotation AngularForce::get_quat(PhysicsObject const *po)
 */
static PyObject *Dtool_AngularForce_get_quat_83(PyObject *self, PyObject *arg) {
  AngularForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AngularForce, (void **)&local_this, "AngularForce.get_quat")) {
    return NULL;
  }
  // 1-LRotation AngularForce::get_quat(PhysicsObject const *po)
  PhysicsObject const *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "AngularForce.get_quat", true, true);
  if (arg_this != NULL) {
    LRotation *return_value = new LRotation((*local_this).get_quat(arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationf, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_quat(const AngularForce self, const PhysicsObject po)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AngularForce_get_quat_83_comment =
  "C++ Interface:\n"
  "get_quat(const AngularForce self, const PhysicsObject po)\n"
  "\n"
  "/**\n"
  " * access query\n"
  " */";
#else
static const char *Dtool_AngularForce_get_quat_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AngularForce::write(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_AngularForce_write_84(PyObject *self, PyObject *args, PyObject *kwds) {
  AngularForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AngularForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AngularForce::write(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "AngularForce.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const AngularForce*)local_this).write(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AngularForce self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AngularForce_write_84_comment =
  "C++ Interface:\n"
  "write(AngularForce self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_AngularForce_write_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AngularForce::get_class_type(void)
 */
static PyObject *Dtool_AngularForce_get_class_type_85(PyObject *, PyObject *) {
  // 1-static TypeHandle AngularForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AngularForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AngularForce_get_class_type_85_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AngularForce_get_class_type_85_comment = NULL;
#endif

static int Dtool_Init_AngularForce(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AngularForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AngularForce) {
    printf("AngularForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AngularForce *local_this = (AngularForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AngularForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AngularForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AngularForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (AngularForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AngularForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AngularForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AngularForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Physical
 */
/**
 * Python function wrapper for:
 * inline PhysicsManager *Physical::get_physics_manager(void) const
 */
static PyObject *Dtool_Physical_get_physics_manager_88(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PhysicsManager *Physical::get_physics_manager(void) const
  PhysicsManager *return_value = (*(const Physical*)local_this).get_physics_manager();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PhysicsManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_physics_manager_88_comment =
  "C++ Interface:\n"
  "get_physics_manager(Physical self)\n"
  "\n"
  "// helpers\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_physics_manager_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PhysicalNode *Physical::get_physical_node(void) const
 */
static PyObject *Dtool_Physical_get_physical_node_89(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PhysicalNode *Physical::get_physical_node(void) const
  PhysicalNode *return_value = (*(const Physical*)local_this).get_physical_node();
  if (return_value != (PhysicalNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PhysicalNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PhysicalNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_physical_node_89_comment =
  "C++ Interface:\n"
  "get_physical_node(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_physical_node_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath Physical::get_physical_node_path(void) const
 */
static PyObject *Dtool_Physical_get_physical_node_path_90(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath Physical::get_physical_node_path(void) const
  NodePath *return_value = new NodePath((*(const Physical*)local_this).get_physical_node_path());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_physical_node_path_90_comment =
  "C++ Interface:\n"
  "get_physical_node_path(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_physical_node_path_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PhysicsObject *Physical::get_phys_body(void) const
 */
static PyObject *Dtool_Physical_get_phys_body_91(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PhysicsObject *Physical::get_phys_body(void) const
  PhysicsObject *return_value = (*(const Physical*)local_this).get_phys_body();
  if (return_value != (PhysicsObject *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PhysicsObject *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PhysicsObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_phys_body_91_comment =
  "C++ Interface:\n"
  "get_phys_body(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_phys_body_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::clear_linear_forces(void)
 */
static PyObject *Dtool_Physical_clear_linear_forces_92(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.clear_linear_forces")) {
    return NULL;
  }
  // 1-inline void Physical::clear_linear_forces(void)
  (*local_this).clear_linear_forces();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Physical_clear_linear_forces_92_comment =
  "C++ Interface:\n"
  "clear_linear_forces(const Physical self)\n"
  "\n"
  "/**\n"
  " * Erases the linear force list\n"
  " */";
#else
static const char *Dtool_Physical_clear_linear_forces_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::clear_angular_forces(void)
 */
static PyObject *Dtool_Physical_clear_angular_forces_93(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.clear_angular_forces")) {
    return NULL;
  }
  // 1-inline void Physical::clear_angular_forces(void)
  (*local_this).clear_angular_forces();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Physical_clear_angular_forces_93_comment =
  "C++ Interface:\n"
  "clear_angular_forces(const Physical self)\n"
  "\n"
  "/**\n"
  " * Erases the angular force list\n"
  " */";
#else
static const char *Dtool_Physical_clear_angular_forces_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::clear_physics_objects(void)
 */
static PyObject *Dtool_Physical_clear_physics_objects_94(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.clear_physics_objects")) {
    return NULL;
  }
  // 1-inline void Physical::clear_physics_objects(void)
  (*local_this).clear_physics_objects();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Physical_clear_physics_objects_94_comment =
  "C++ Interface:\n"
  "clear_physics_objects(const Physical self)\n"
  "\n"
  "/**\n"
  " * Erases the object list\n"
  " */";
#else
static const char *Dtool_Physical_clear_physics_objects_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::add_linear_force(LinearForce *f)
 */
static PyObject *Dtool_Physical_add_linear_force_95(PyObject *self, PyObject *arg) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.add_linear_force")) {
    return NULL;
  }
  // 1-inline void Physical::add_linear_force(LinearForce *f)
  LinearForce *arg_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearForce, 1, "Physical.add_linear_force", false, true);
  if (arg_this != NULL) {
    (*local_this).add_linear_force(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_linear_force(const Physical self, LinearForce f)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_add_linear_force_95_comment =
  "C++ Interface:\n"
  "add_linear_force(const Physical self, LinearForce f)\n"
  "\n"
  "/**\n"
  " * Adds a linear force to the force list\n"
  " */";
#else
static const char *Dtool_Physical_add_linear_force_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::add_angular_force(AngularForce *f)
 */
static PyObject *Dtool_Physical_add_angular_force_96(PyObject *self, PyObject *arg) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.add_angular_force")) {
    return NULL;
  }
  // 1-inline void Physical::add_angular_force(AngularForce *f)
  AngularForce *arg_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AngularForce, 1, "Physical.add_angular_force", false, true);
  if (arg_this != NULL) {
    (*local_this).add_angular_force(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_angular_force(const Physical self, AngularForce f)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_add_angular_force_96_comment =
  "C++ Interface:\n"
  "add_angular_force(const Physical self, AngularForce f)\n"
  "\n"
  "/**\n"
  " * Adds an angular force to the force list\n"
  " */";
#else
static const char *Dtool_Physical_add_angular_force_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::add_physics_object(PhysicsObject *po)
 */
static PyObject *Dtool_Physical_add_physics_object_97(PyObject *self, PyObject *arg) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.add_physics_object")) {
    return NULL;
  }
  // 1-inline void Physical::add_physics_object(PhysicsObject *po)
  PhysicsObject *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "Physical.add_physics_object", false, true);
  if (arg_this != NULL) {
    (*local_this).add_physics_object(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_physics_object(const Physical self, PhysicsObject po)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_add_physics_object_97_comment =
  "C++ Interface:\n"
  "add_physics_object(const Physical self, PhysicsObject po)\n"
  "\n"
  "/**\n"
  " * Adds an object to the physics object vector\n"
  " */";
#else
static const char *Dtool_Physical_add_physics_object_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::remove_linear_force(LinearForce *f)
 */
static PyObject *Dtool_Physical_remove_linear_force_98(PyObject *self, PyObject *arg) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.remove_linear_force")) {
    return NULL;
  }
  // 1-inline void Physical::remove_linear_force(LinearForce *f)
  LinearForce *arg_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearForce, 1, "Physical.remove_linear_force", false, true);
  if (arg_this != NULL) {
    (*local_this).remove_linear_force(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_linear_force(const Physical self, LinearForce f)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_remove_linear_force_98_comment =
  "C++ Interface:\n"
  "remove_linear_force(const Physical self, LinearForce f)\n"
  "\n"
  "/**\n"
  " * removes a linear force from the force list\n"
  " */";
#else
static const char *Dtool_Physical_remove_linear_force_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::remove_angular_force(AngularForce *f)
 */
static PyObject *Dtool_Physical_remove_angular_force_99(PyObject *self, PyObject *arg) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.remove_angular_force")) {
    return NULL;
  }
  // 1-inline void Physical::remove_angular_force(AngularForce *f)
  AngularForce *arg_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AngularForce, 1, "Physical.remove_angular_force", false, true);
  if (arg_this != NULL) {
    (*local_this).remove_angular_force(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_angular_force(const Physical self, AngularForce f)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_remove_angular_force_99_comment =
  "C++ Interface:\n"
  "remove_angular_force(const Physical self, AngularForce f)\n"
  "\n"
  "/**\n"
  " * removes an angular force from the force list\n"
  " */";
#else
static const char *Dtool_Physical_remove_angular_force_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Physical::get_num_linear_forces(void) const
 */
static PyObject *Dtool_Physical_get_num_linear_forces_100(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int Physical::get_num_linear_forces(void) const
  int return_value = (*(const Physical*)local_this).get_num_linear_forces();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_num_linear_forces_100_comment =
  "C++ Interface:\n"
  "get_num_linear_forces(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_num_linear_forces_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< LinearForce > Physical::get_linear_force(int index) const
 */
static PyObject *Dtool_Physical_get_linear_force_101(PyObject *self, PyObject *arg) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PointerTo< LinearForce > Physical::get_linear_force(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< LinearForce > return_value = (*(const Physical*)local_this).get_linear_force((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    LinearForce *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LinearForce, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_linear_force(Physical self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_linear_force_101_comment =
  "C++ Interface:\n"
  "get_linear_force(Physical self, int index)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_linear_force_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Physical::get_num_angular_forces(void) const
 */
static PyObject *Dtool_Physical_get_num_angular_forces_103(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int Physical::get_num_angular_forces(void) const
  int return_value = (*(const Physical*)local_this).get_num_angular_forces();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_num_angular_forces_103_comment =
  "C++ Interface:\n"
  "get_num_angular_forces(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_num_angular_forces_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< AngularForce > Physical::get_angular_force(int index) const
 */
static PyObject *Dtool_Physical_get_angular_force_104(PyObject *self, PyObject *arg) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PointerTo< AngularForce > Physical::get_angular_force(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< AngularForce > return_value = (*(const Physical*)local_this).get_angular_force((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    AngularForce *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AngularForce, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_angular_force(Physical self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_angular_force_104_comment =
  "C++ Interface:\n"
  "get_angular_force(Physical self, int index)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_angular_force_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::set_viscosity(PN_stdfloat viscosity)
 */
static PyObject *Dtool_Physical_set_viscosity_106(PyObject *self, PyObject *arg) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.set_viscosity")) {
    return NULL;
  }
  // 1-inline void Physical::set_viscosity(PN_stdfloat viscosity)
  if (PyNumber_Check(arg)) {
    (*local_this).set_viscosity((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_viscosity(const Physical self, float viscosity)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_set_viscosity_106_comment =
  "C++ Interface:\n"
  "set_viscosity(const Physical self, float viscosity)\n"
  "\n"
  "/**\n"
  " * Set the local viscosity.\n"
  " */";
#else
static const char *Dtool_Physical_set_viscosity_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Physical::get_viscosity(void) const
 */
static PyObject *Dtool_Physical_get_viscosity_107(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat Physical::get_viscosity(void) const
  PN_stdfloat return_value = (*(const Physical*)local_this).get_viscosity();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_viscosity_107_comment =
  "C++ Interface:\n"
  "get_viscosity(Physical self)\n"
  "\n"
  "/**\n"
  " * Get the local viscosity.\n"
  " */";
#else
static const char *Dtool_Physical_get_viscosity_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PhysicsObjectCollection const Physical::get_objects(void) const
 */
static PyObject *Dtool_Physical_get_objects_108(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  // 1-PhysicsObjectCollection const Physical::get_objects(void) const
  PhysicsObjectCollection const *return_value = new PhysicsObjectCollection const((*(const Physical*)local_this).get_objects());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PhysicsObjectCollection, true, true);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_objects_108_comment =
  "C++ Interface:\n"
  "get_objects(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_objects_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void Physical::output(ostream &out = ::cout) const
 */
static PyObject *Dtool_Physical_output_109(PyObject *self, PyObject *args, PyObject *kwds) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual void Physical::output(ostream &out) const
      (*(const Physical*)local_this).output();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "out");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'out' (pos 1) not found");
      }
      // 1-virtual void Physical::output(ostream &out) const
      ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Physical.output", false, true);
      if (arg_this != NULL) {
        (*(const Physical*)local_this).output(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "output() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Physical self)\n"
      "output(Physical self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_output_109_comment =
  "C++ Interface:\n"
  "output(Physical self)\n"
  "output(Physical self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Physical_output_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void Physical::write_physics_objects(ostream &out = ::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_Physical_write_physics_objects_110(PyObject *self, PyObject *args, PyObject *kwds) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual void Physical::write_physics_objects(ostream &out, unsigned int indent) const
      (*(const Physical*)local_this).write_physics_objects();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-virtual void Physical::write_physics_objects(ostream &out, unsigned int indent = 0) const
      PyObject *param1;
      unsigned long param2 = 0;
      static const char *keyword_list[] = {"out", "indent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write_physics_objects", (char **)keyword_list, &param1, &param2)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "Physical.write_physics_objects", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param2 > UINT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %lu out of range for unsigned integer",
                              param2);
        }
#endif
        if (param1_this != NULL) {
          (*(const Physical*)local_this).write_physics_objects(*param1_this, (unsigned int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write_physics_objects() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_physics_objects(Physical self)\n"
      "write_physics_objects(Physical self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_write_physics_objects_110_comment =
  "C++ Interface:\n"
  "write_physics_objects(Physical self)\n"
  "write_physics_objects(Physical self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Physical_write_physics_objects_110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void Physical::write_linear_forces(ostream &out = ::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_Physical_write_linear_forces_111(PyObject *self, PyObject *args, PyObject *kwds) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual void Physical::write_linear_forces(ostream &out, unsigned int indent) const
      (*(const Physical*)local_this).write_linear_forces();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-virtual void Physical::write_linear_forces(ostream &out, unsigned int indent = 0) const
      PyObject *param1;
      unsigned long param2 = 0;
      static const char *keyword_list[] = {"out", "indent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write_linear_forces", (char **)keyword_list, &param1, &param2)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "Physical.write_linear_forces", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param2 > UINT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %lu out of range for unsigned integer",
                              param2);
        }
#endif
        if (param1_this != NULL) {
          (*(const Physical*)local_this).write_linear_forces(*param1_this, (unsigned int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write_linear_forces() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_linear_forces(Physical self)\n"
      "write_linear_forces(Physical self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_write_linear_forces_111_comment =
  "C++ Interface:\n"
  "write_linear_forces(Physical self)\n"
  "write_linear_forces(Physical self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Physical_write_linear_forces_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void Physical::write_angular_forces(ostream &out = ::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_Physical_write_angular_forces_112(PyObject *self, PyObject *args, PyObject *kwds) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual void Physical::write_angular_forces(ostream &out, unsigned int indent) const
      (*(const Physical*)local_this).write_angular_forces();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-virtual void Physical::write_angular_forces(ostream &out, unsigned int indent = 0) const
      PyObject *param1;
      unsigned long param2 = 0;
      static const char *keyword_list[] = {"out", "indent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write_angular_forces", (char **)keyword_list, &param1, &param2)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "Physical.write_angular_forces", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param2 > UINT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %lu out of range for unsigned integer",
                              param2);
        }
#endif
        if (param1_this != NULL) {
          (*(const Physical*)local_this).write_angular_forces(*param1_this, (unsigned int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write_angular_forces() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_angular_forces(Physical self)\n"
      "write_angular_forces(Physical self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_write_angular_forces_112_comment =
  "C++ Interface:\n"
  "write_angular_forces(Physical self)\n"
  "write_angular_forces(Physical self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Physical_write_angular_forces_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void Physical::write(ostream &out = ::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_Physical_write_113(PyObject *self, PyObject *args, PyObject *kwds) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual void Physical::write(ostream &out, unsigned int indent) const
      (*(const Physical*)local_this).write();
      return Dtool_Return_None();
    }
    break;
  case 1:
  case 2:
    {
      // 1-virtual void Physical::write(ostream &out, unsigned int indent = 0) const
      PyObject *param1;
      unsigned long param2 = 0;
      static const char *keyword_list[] = {"out", "indent", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
        ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "Physical.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param2 > UINT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %lu out of range for unsigned integer",
                              param2);
        }
#endif
        if (param1_this != NULL) {
          (*(const Physical*)local_this).write(*param1_this, (unsigned int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(Physical self)\n"
      "write(Physical self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Physical_write_113_comment =
  "C++ Interface:\n"
  "write(Physical self)\n"
  "write(Physical self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Physical_write_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Physical::get_class_type(void)
 */
static PyObject *Dtool_Physical_get_class_type_114(PyObject *, PyObject *) {
  // 1-static TypeHandle Physical::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Physical::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_class_type_114_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Physical_get_class_type_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Physical::Physical(Physical const &copy)
 * Physical::Physical(int total_objects = 1, bool pre_alloc = false)
 */
static int Dtool_Init_Physical(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-Physical::Physical(int total_objects, bool pre_alloc)
      Physical *return_value = new Physical();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Physical, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 Physical::Physical(int total_objects, bool pre_alloc = false)
        int param0;
        PyObject *param1 = Py_False;
        static const char *keyword_list[] = {"total_objects", "pre_alloc", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:Physical", (char **)keyword_list, &param0, &param1)) {
          Physical *return_value = new Physical((int)param0, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Physical, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: Physical::Physical(int total_objects, bool pre_alloc = false)
      {
        // -2 Physical::Physical(Physical const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Physical", (char **)keyword_list, &param0)) {
          CPT(Physical) param0_this;
          if (Dtool_ConstCoerce_Physical(param0, param0_this)) {
            Physical *return_value = new Physical(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Physical, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Physical() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Physical()\n"
      "Physical(int total_objects, bool pre_alloc)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Physical(PyObject *args, CPT(Physical) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Physical, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Physical::Physical(int total_objects, bool pre_alloc)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      Physical *return_value = new Physical((int)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-Physical::Physical(int total_objects, bool pre_alloc)
      int param0;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "iO:Physical", &param0, &param1)) {
        Physical *return_value = new Physical((int)param0, (PyObject_IsTrue(param1) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_Physical(PyObject *args, PT(Physical) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Physical, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Physical::Physical(int total_objects, bool pre_alloc)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      Physical *return_value = new Physical((int)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-Physical::Physical(int total_objects, bool pre_alloc)
      int param0;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "iO:Physical", &param0, &param1)) {
        Physical *return_value = new Physical((int)param0, (PyObject_IsTrue(param1) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Physical_get_linear_forces(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_linear_forces();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Physical_get_linear_force_101(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Physical_get_angular_forces(PyObject *self, PyObject *) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_angular_forces();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Physical_get_angular_force_104(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Physical(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Physical) {
    printf("Physical ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Physical *local_this = (Physical *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Physical) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Physical(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Physical) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Physical*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Physical*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (Physical*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PhysicalNode
 */
/**
 * Python function wrapper for:
 * inline void PhysicalNode::clear(void)
 */
static PyObject *Dtool_PhysicalNode_clear_118(PyObject *self, PyObject *) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.clear")) {
    return NULL;
  }
  // 1-inline void PhysicalNode::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_clear_118_comment =
  "C++ Interface:\n"
  "clear(const PhysicalNode self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PhysicalNode_clear_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Physical *PhysicalNode::get_physical(std::size_t index) const
 */
static PyObject *Dtool_PhysicalNode_get_physical_119(PyObject *self, PyObject *arg) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicalNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Physical *PhysicalNode::get_physical(std::size_t index) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_physical", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    Physical *return_value = (*(const PhysicalNode*)local_this).get_physical((std::size_t)param1);
    if (return_value != (Physical *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (Physical *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Physical, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_physical(PhysicalNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_get_physical_119_comment =
  "C++ Interface:\n"
  "get_physical(PhysicalNode self, int index)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PhysicalNode_get_physical_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t PhysicalNode::get_num_physicals(void) const
 */
static PyObject *Dtool_PhysicalNode_get_num_physicals_120(PyObject *self, PyObject *) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicalNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t PhysicalNode::get_num_physicals(void) const
  std::size_t return_value = (*(const PhysicalNode*)local_this).get_num_physicals();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_get_num_physicals_120_comment =
  "C++ Interface:\n"
  "get_num_physicals(PhysicalNode self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PhysicalNode_get_num_physicals_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicalNode::add_physical(Physical *physical)
 */
static PyObject *Dtool_PhysicalNode_add_physical_122(PyObject *self, PyObject *arg) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.add_physical")) {
    return NULL;
  }
  // 1-inline void PhysicalNode::add_physical(Physical *physical)
  PT(Physical) arg_this;
  if (!Dtool_Coerce_Physical(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicalNode.add_physical", "Physical");
  }
  (*local_this).add_physical(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_physical(const PhysicalNode self, Physical physical)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_add_physical_122_comment =
  "C++ Interface:\n"
  "add_physical(const PhysicalNode self, Physical physical)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PhysicalNode_add_physical_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicalNode::add_physicals_from(PhysicalNode const &other)
 */
static PyObject *Dtool_PhysicalNode_add_physicals_from_123(PyObject *self, PyObject *arg) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.add_physicals_from")) {
    return NULL;
  }
  // 1-void PhysicalNode::add_physicals_from(PhysicalNode const &other)
  CPT(PhysicalNode) arg_this;
  if (!Dtool_ConstCoerce_PhysicalNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicalNode.add_physicals_from", "PhysicalNode");
  }
  (*local_this).add_physicals_from(*MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_physicals_from(const PhysicalNode self, const PhysicalNode other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_add_physicals_from_123_comment =
  "C++ Interface:\n"
  "add_physicals_from(const PhysicalNode self, const PhysicalNode other)\n"
  "\n"
  "/**\n"
  " * append operation\n"
  " */";
#else
static const char *Dtool_PhysicalNode_add_physicals_from_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicalNode::set_physical(std::size_t index, Physical *physical)
 */
static PyObject *Dtool_PhysicalNode_set_physical_124(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.set_physical")) {
    return NULL;
  }
  // 1-void PhysicalNode::set_physical(std::size_t index, Physical *physical)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "physical", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_physical", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    PT(Physical) param2_this;
    if (!Dtool_Coerce_Physical(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PhysicalNode.set_physical", "Physical");
    }
    (*local_this).set_physical((std::size_t)param1, MOVE(param2_this));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_physical(const PhysicalNode self, int index, Physical physical)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_set_physical_124_comment =
  "C++ Interface:\n"
  "set_physical(const PhysicalNode self, int index, Physical physical)\n"
  "\n"
  "/**\n"
  " * replace operation\n"
  " */";
#else
static const char *Dtool_PhysicalNode_set_physical_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicalNode::remove_physical(Physical *physical)
 * void PhysicalNode::remove_physical(std::size_t index)
 */
static PyObject *Dtool_PhysicalNode_remove_physical_125(PyObject *self, PyObject *arg) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.remove_physical")) {
    return NULL;
  }
  {
    // -2 void PhysicalNode::remove_physical(Physical *physical)
    Physical *arg_this = (Physical *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Physical, 1, "PhysicalNode.remove_physical", false, false);
    if (arg_this != NULL) {
      (*local_this).remove_physical(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PhysicalNode::remove_physical(std::size_t index)
    Py_ssize_t param1;
    if (PyArg_Parse(arg, "n:remove_physical", &param1)) {
#ifndef NDEBUG
      if (param1 < 0) {
        return PyErr_Format(PyExc_OverflowError,
                            "can't convert negative value %zd to size_t",
                            param1);
      }
#endif
      (*local_this).remove_physical((std::size_t)param1);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void PhysicalNode::remove_physical(Physical *physical)
    PT(Physical) arg_this;
    if (Dtool_Coerce_Physical(arg, arg_this)) {
      (*local_this).remove_physical(MOVE(arg_this));
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void PhysicalNode::remove_physical(std::size_t index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_physical(const PhysicalNode self, Physical physical)\n"
      "remove_physical(const PhysicalNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_remove_physical_125_comment =
  "C++ Interface:\n"
  "remove_physical(const PhysicalNode self, Physical physical)\n"
  "remove_physical(const PhysicalNode self, int index)\n"
  "\n"
  "/**\n"
  " * remove operation\n"
  " */\n"
  "\n"
  "/**\n"
  " * remove operation\n"
  " */";
#else
static const char *Dtool_PhysicalNode_remove_physical_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicalNode::write(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_PhysicalNode_write_128(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicalNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PhysicalNode::write(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PhysicalNode.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const PhysicalNode*)local_this).write(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PhysicalNode self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_write_128_comment =
  "C++ Interface:\n"
  "write(PhysicalNode self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicalNode_write_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PhysicalNode::get_class_type(void)
 */
static PyObject *Dtool_PhysicalNode_get_class_type_129(PyObject *, PyObject *) {
  // 1-static TypeHandle PhysicalNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PhysicalNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_get_class_type_129_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PhysicalNode_get_class_type_129_comment = NULL;
#endif

/**
 * sequence length function for property PhysicalNode::physicals
 */
static Py_ssize_t Dtool_PhysicalNode_physicals_Len(PyObject *self) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicalNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_physicals();
}

/**
 * sequence getter for property PhysicalNode::physicals
 */
static PyObject *Dtool_PhysicalNode_physicals_Getitem(PyObject *self, Py_ssize_t index) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicalNode, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_physicals()) {
    PyErr_SetString(PyExc_IndexError, "PhysicalNode.physicals[] index out of range");
    return NULL;
  }
  // 1-inline Physical *PhysicalNode::get_physical(std::size_t index) const
  Physical *return_value = (*(const PhysicalNode*)local_this).get_physical(index);
  if (return_value != (Physical *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (Physical *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Physical, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_physical(PhysicalNode self, index)\n");
  }
}

static int Dtool_PhysicalNode_physicals_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.physicals")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    local_this->remove_physical(index);
    return 0;
  }
  // 1-void PhysicalNode::set_physical(std::size_t index, Physical *physical)
  PT(Physical) arg_this;
  if (!Dtool_Coerce_Physical(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 2, "PhysicalNode.set_physical", "Physical");
    return -1;
  }
  (*local_this).set_physical(index, MOVE(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_physical(const PhysicalNode self, index, Physical physical)\n");
  }
  return -1;
}

static PyObject *Dtool_PhysicalNode_physicals_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_PhysicalNode_physicals_Len;
  wrap->_getitem_func = &Dtool_PhysicalNode_physicals_Getitem;
  wrap->_setitem_func = &Dtool_PhysicalNode_physicals_Setitem;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * PhysicalNode::PhysicalNode(std::string const &name)
 */
static int Dtool_Init_PhysicalNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PhysicalNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-PhysicalNode::PhysicalNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    PhysicalNode *return_value = new PhysicalNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicalNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PhysicalNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PhysicalNode(PyObject *args, CPT(PhysicalNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PhysicalNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PhysicalNode::PhysicalNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PhysicalNode *return_value = new PhysicalNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PhysicalNode(PyObject *args, PT(PhysicalNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PhysicalNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PhysicalNode::PhysicalNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      PhysicalNode *return_value = new PhysicalNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PhysicalNode_get_physicals(PyObject *self, PyObject *) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicalNode, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_physicals();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PhysicalNode_get_physical_119(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PhysicalNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PhysicalNode) {
    printf("PhysicalNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PhysicalNode *local_this = (PhysicalNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PhysicalNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PhysicalNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PhysicalNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PhysicalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PhysicalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PhysicalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PhysicalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PhysicalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PhysicalNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ActorNode
 */
/**
 * Python function wrapper for:
 * PhysicsObject *ActorNode::get_physics_object(void)
 */
static PyObject *Dtool_ActorNode_get_physics_object_132(PyObject *self, PyObject *) {
  ActorNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ActorNode, (void **)&local_this, "ActorNode.get_physics_object")) {
    return NULL;
  }
  // 1-PhysicsObject *ActorNode::get_physics_object(void)
  PhysicsObject *return_value = (*local_this).get_physics_object();
  if (return_value != (PhysicsObject *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (PhysicsObject *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PhysicsObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_get_physics_object_132_comment =
  "C++ Interface:\n"
  "get_physics_object(const ActorNode self)\n";
#else
static const char *Dtool_ActorNode_get_physics_object_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ActorNode::set_contact_vector(LVector3 const &contact_vector)
 */
static PyObject *Dtool_ActorNode_set_contact_vector_133(PyObject *self, PyObject *arg) {
  ActorNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ActorNode, (void **)&local_this, "ActorNode.set_contact_vector")) {
    return NULL;
  }
  // 1-void ActorNode::set_contact_vector(LVector3 const &contact_vector)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ActorNode.set_contact_vector", "LVector3f");
  }
  (*local_this).set_contact_vector(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contact_vector(const ActorNode self, const LVector3f contact_vector)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_set_contact_vector_133_comment =
  "C++ Interface:\n"
  "set_contact_vector(const ActorNode self, const LVector3f contact_vector)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ActorNode_set_contact_vector_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVector3 const &ActorNode::get_contact_vector(void) const
 */
static PyObject *Dtool_ActorNode_get_contact_vector_134(PyObject *self, PyObject *) {
  ActorNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ActorNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVector3 const &ActorNode::get_contact_vector(void) const
  LVector3 const *return_value = &((*(const ActorNode*)local_this).get_contact_vector());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_get_contact_vector_134_comment =
  "C++ Interface:\n"
  "get_contact_vector(ActorNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ActorNode_get_contact_vector_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ActorNode::update_transform(void)
 */
static PyObject *Dtool_ActorNode_update_transform_135(PyObject *self, PyObject *) {
  ActorNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ActorNode, (void **)&local_this, "ActorNode.update_transform")) {
    return NULL;
  }
  // 1-void ActorNode::update_transform(void)
  (*local_this).update_transform();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_update_transform_135_comment =
  "C++ Interface:\n"
  "update_transform(const ActorNode self)\n"
  "\n"
  "// update the parent scene graph node with PhysicsObject information i.e.\n"
  "// copy from PhysicsObject to PandaNode\n"
  "\n"
  "/**\n"
  " * this sets the transform generated by the contained Physical, moving the\n"
  " * node and subsequent geometry.  i.e.  copy from PhysicsObject to PandaNode\n"
  " */";
#else
static const char *Dtool_ActorNode_update_transform_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ActorNode::set_transform_limit(PN_stdfloat limit)
 */
static PyObject *Dtool_ActorNode_set_transform_limit_136(PyObject *self, PyObject *arg) {
  ActorNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ActorNode, (void **)&local_this, "ActorNode.set_transform_limit")) {
    return NULL;
  }
  // 1-void ActorNode::set_transform_limit(PN_stdfloat limit)
  if (PyNumber_Check(arg)) {
    (*local_this).set_transform_limit((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform_limit(const ActorNode self, float limit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_set_transform_limit_136_comment =
  "C++ Interface:\n"
  "set_transform_limit(const ActorNode self, float limit)\n";
#else
static const char *Dtool_ActorNode_set_transform_limit_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ActorNode::get_class_type(void)
 */
static PyObject *Dtool_ActorNode_get_class_type_137(PyObject *, PyObject *) {
  // 1-static TypeHandle ActorNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ActorNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_get_class_type_137_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ActorNode_get_class_type_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ActorNode::ActorNode(ActorNode const &copy)
 * ActorNode::ActorNode(std::string const &name = "")
 */
static int Dtool_Init_ActorNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ActorNode::ActorNode(std::string const &name)
      ActorNode *return_value = new ActorNode();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ActorNode, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 ActorNode::ActorNode(ActorNode const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ActorNode", (char **)keyword_list, &param0)) {
          ActorNode const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ActorNode, (void **)&param0_this);
          if (param0_this != NULL) {
            ActorNode *return_value = new ActorNode(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ActorNode, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 ActorNode::ActorNode(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ActorNode", (char **)keyword_list, &param0_str, &param0_len)) {
          ActorNode *return_value = new ActorNode(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ActorNode, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 ActorNode::ActorNode(ActorNode const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ActorNode", (char **)keyword_list, &param0)) {
          CPT(ActorNode) param0_this;
          if (Dtool_ConstCoerce_ActorNode(param0, param0_this)) {
            ActorNode *return_value = new ActorNode(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ActorNode, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: ActorNode::ActorNode(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ActorNode() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ActorNode()\n"
      "ActorNode(const ActorNode copy)\n"
      "ActorNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ActorNode(PyObject *args, CPT(ActorNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ActorNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ActorNode::ActorNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ActorNode *return_value = new ActorNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_ActorNode(PyObject *args, PT(ActorNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ActorNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ActorNode::ActorNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ActorNode *return_value = new ActorNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_ActorNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ActorNode) {
    printf("ActorNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ActorNode *local_this = (ActorNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ActorNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PhysicalNode) {
    return (PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(PhysicalNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ActorNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ActorNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PhysicalNode) {
    PhysicalNode* other_this = (PhysicalNode*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ActorNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BaseIntegrator
 */
/**
 * Python function wrapper for:
 * virtual void BaseIntegrator::output(ostream &out) const
 */
static PyObject *Dtool_BaseIntegrator_output_140(PyObject *self, PyObject *arg) {
  BaseIntegrator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseIntegrator, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseIntegrator::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "BaseIntegrator.output", false, true);
  if (arg_this != NULL) {
    (*(const BaseIntegrator*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BaseIntegrator self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseIntegrator_output_140_comment =
  "C++ Interface:\n"
  "output(BaseIntegrator self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseIntegrator_output_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseIntegrator::write_precomputed_linear_matrices(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_BaseIntegrator_write_precomputed_linear_matrices_141(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseIntegrator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseIntegrator, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseIntegrator::write_precomputed_linear_matrices(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write_precomputed_linear_matrices", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BaseIntegrator.write_precomputed_linear_matrices", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const BaseIntegrator*)local_this).write_precomputed_linear_matrices(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_precomputed_linear_matrices(BaseIntegrator self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseIntegrator_write_precomputed_linear_matrices_141_comment =
  "C++ Interface:\n"
  "write_precomputed_linear_matrices(BaseIntegrator self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseIntegrator_write_precomputed_linear_matrices_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseIntegrator::write_precomputed_angular_matrices(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_BaseIntegrator_write_precomputed_angular_matrices_142(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseIntegrator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseIntegrator, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseIntegrator::write_precomputed_angular_matrices(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write_precomputed_angular_matrices", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BaseIntegrator.write_precomputed_angular_matrices", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const BaseIntegrator*)local_this).write_precomputed_angular_matrices(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_precomputed_angular_matrices(BaseIntegrator self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseIntegrator_write_precomputed_angular_matrices_142_comment =
  "C++ Interface:\n"
  "write_precomputed_angular_matrices(BaseIntegrator self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseIntegrator_write_precomputed_angular_matrices_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseIntegrator::write(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_BaseIntegrator_write_143(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseIntegrator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseIntegrator, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BaseIntegrator::write(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BaseIntegrator.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const BaseIntegrator*)local_this).write(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BaseIntegrator self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BaseIntegrator_write_143_comment =
  "C++ Interface:\n"
  "write(BaseIntegrator self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseIntegrator_write_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BaseIntegrator::BaseIntegrator(BaseIntegrator const &) = default
 */
static int Dtool_Init_BaseIntegrator(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BaseIntegrator() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline BaseIntegrator::BaseIntegrator(BaseIntegrator const &) = default
  BaseIntegrator const *arg_this = (BaseIntegrator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BaseIntegrator, 0, "BaseIntegrator.BaseIntegrator", true, true);
  if (arg_this != NULL) {
    BaseIntegrator *return_value = new BaseIntegrator(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BaseIntegrator, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BaseIntegrator(const BaseIntegrator param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BaseIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BaseIntegrator) {
    printf("BaseIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BaseIntegrator *local_this = (BaseIntegrator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BaseIntegrator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BaseIntegrator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BaseIntegrator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BaseIntegrator*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AngularIntegrator
 */
static int Dtool_Init_AngularIntegrator(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AngularIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AngularIntegrator) {
    printf("AngularIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AngularIntegrator *local_this = (AngularIntegrator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AngularIntegrator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseIntegrator) {
    return (BaseIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseIntegrator *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AngularIntegrator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AngularIntegrator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseIntegrator) {
    BaseIntegrator* other_this = (BaseIntegrator*)from_this;
    return (AngularIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AngularIntegrator*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AngularEulerIntegrator
 */
/**
 * Python function wrapper for:
 * AngularEulerIntegrator::AngularEulerIntegrator(void)
 */
static int Dtool_Init_AngularEulerIntegrator(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AngularEulerIntegrator() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-AngularEulerIntegrator::AngularEulerIntegrator(void)
  AngularEulerIntegrator *return_value = new AngularEulerIntegrator();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AngularEulerIntegrator, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AngularEulerIntegrator()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AngularEulerIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AngularEulerIntegrator) {
    printf("AngularEulerIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AngularEulerIntegrator *local_this = (AngularEulerIntegrator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AngularEulerIntegrator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AngularIntegrator) {
    return (AngularIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_BaseIntegrator) {
    return (BaseIntegrator *)(AngularIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseIntegrator *)(AngularIntegrator *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AngularEulerIntegrator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AngularEulerIntegrator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AngularIntegrator) {
    AngularIntegrator* other_this = (AngularIntegrator*)from_this;
    return (AngularEulerIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_BaseIntegrator) {
    BaseIntegrator* other_this = (BaseIntegrator*)from_this;
    return (AngularEulerIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AngularEulerIntegrator*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AngularVectorForce
 */
/**
 * Python function wrapper for:
 * inline void AngularVectorForce::set_quat(LRotation const &quat)
 */
static PyObject *Dtool_AngularVectorForce_set_quat_150(PyObject *self, PyObject *arg) {
  AngularVectorForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AngularVectorForce, (void **)&local_this, "AngularVectorForce.set_quat")) {
    return NULL;
  }
  // 1-inline void AngularVectorForce::set_quat(LRotation const &quat)
  LRotationf arg_local;
  LRotation const *arg_this = Dtool_Coerce_LRotationf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AngularVectorForce.set_quat", "LRotationf");
  }
  (*local_this).set_quat(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quat(const AngularVectorForce self, const LRotationf quat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AngularVectorForce_set_quat_150_comment =
  "C++ Interface:\n"
  "set_quat(const AngularVectorForce self, const LRotationf quat)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_AngularVectorForce_set_quat_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AngularVectorForce::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_AngularVectorForce_set_hpr_151(PyObject *self, PyObject *args, PyObject *kwds) {
  AngularVectorForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AngularVectorForce, (void **)&local_this, "AngularVectorForce.set_hpr")) {
    return NULL;
  }
  // 1-inline void AngularVectorForce::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"h", "p", "r", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_hpr", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_hpr((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hpr(const AngularVectorForce self, float h, float p, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AngularVectorForce_set_hpr_151_comment =
  "C++ Interface:\n"
  "set_hpr(const AngularVectorForce self, float h, float p, float r)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_AngularVectorForce_set_hpr_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LRotation AngularVectorForce::get_local_quat(void) const
 */
static PyObject *Dtool_AngularVectorForce_get_local_quat_152(PyObject *self, PyObject *) {
  AngularVectorForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AngularVectorForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LRotation AngularVectorForce::get_local_quat(void) const
  LRotation *return_value = new LRotation((*(const AngularVectorForce*)local_this).get_local_quat());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationf, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AngularVectorForce_get_local_quat_152_comment =
  "C++ Interface:\n"
  "get_local_quat(AngularVectorForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_AngularVectorForce_get_local_quat_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AngularVectorForce::get_class_type(void)
 */
static PyObject *Dtool_AngularVectorForce_get_class_type_153(PyObject *, PyObject *) {
  // 1-static TypeHandle AngularVectorForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AngularVectorForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AngularVectorForce_get_class_type_153_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AngularVectorForce_get_class_type_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AngularVectorForce::AngularVectorForce(AngularVectorForce const &copy)
 * AngularVectorForce::AngularVectorForce(LRotation const &quat)
 * AngularVectorForce::AngularVectorForce(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static int Dtool_Init_AngularVectorForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 AngularVectorForce::AngularVectorForce(AngularVectorForce const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:AngularVectorForce", (char **)keyword_list, &param0)) {
          AngularVectorForce const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_AngularVectorForce, (void **)&param0_this);
          if (param0_this != NULL) {
            AngularVectorForce *return_value = new AngularVectorForce(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AngularVectorForce, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 AngularVectorForce::AngularVectorForce(LRotation const &quat)
        PyObject *param0;
        static const char *keyword_list[] = {"quat", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:AngularVectorForce", (char **)keyword_list, &param0)) {
          LRotation const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LRotationf, (void **)&param0_this);
          if (param0_this != NULL) {
            AngularVectorForce *return_value = new AngularVectorForce(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AngularVectorForce, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 AngularVectorForce::AngularVectorForce(AngularVectorForce const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:AngularVectorForce", (char **)keyword_list, &param0)) {
          CPT(AngularVectorForce) param0_this;
          if (Dtool_ConstCoerce_AngularVectorForce(param0, param0_this)) {
            AngularVectorForce *return_value = new AngularVectorForce(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AngularVectorForce, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 AngularVectorForce::AngularVectorForce(LRotation const &quat)
        PyObject *param0;
        static const char *keyword_list[] = {"quat", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:AngularVectorForce", (char **)keyword_list, &param0)) {
          LRotationf param0_local;
          LRotation const *param0_this = Dtool_Coerce_LRotationf(param0, param0_local);
          if ((param0_this != NULL)) {
            AngularVectorForce *return_value = new AngularVectorForce(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AngularVectorForce, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
    {
      // 1-AngularVectorForce::AngularVectorForce(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"h", "p", "r", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:AngularVectorForce", (char **)keyword_list, &param0, &param1, &param2)) {
        AngularVectorForce *return_value = new AngularVectorForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AngularVectorForce, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AngularVectorForce() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AngularVectorForce(const AngularVectorForce copy)\n"
      "AngularVectorForce(const LRotationf quat)\n"
      "AngularVectorForce(float h, float p, float r)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AngularVectorForce(PyObject *args, CPT(AngularVectorForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AngularVectorForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AngularVectorForce::AngularVectorForce(LRotation const &quat)
    LRotation const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LRotationf, (void **)&arg_this);
    if (arg_this != NULL) {
      AngularVectorForce *return_value = new AngularVectorForce(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-AngularVectorForce::AngularVectorForce(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param0;
      float param1;
      float param2;
      if (PyArg_ParseTuple(args, "fff:AngularVectorForce", &param0, &param1, &param2)) {
        AngularVectorForce *return_value = new AngularVectorForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_AngularVectorForce(PyObject *args, PT(AngularVectorForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AngularVectorForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AngularVectorForce::AngularVectorForce(LRotation const &quat)
    LRotation const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LRotationf, (void **)&arg_this);
    if (arg_this != NULL) {
      AngularVectorForce *return_value = new AngularVectorForce(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-AngularVectorForce::AngularVectorForce(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param0;
      float param1;
      float param2;
      if (PyArg_ParseTuple(args, "fff:AngularVectorForce", &param0, &param1, &param2)) {
        AngularVectorForce *return_value = new AngularVectorForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_AngularVectorForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AngularVectorForce) {
    printf("AngularVectorForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AngularVectorForce *local_this = (AngularVectorForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AngularVectorForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AngularForce) {
    return (AngularForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(AngularForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(AngularForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(AngularForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(AngularForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AngularVectorForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AngularVectorForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AngularForce) {
    AngularForce* other_this = (AngularForce*)from_this;
    return (AngularVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (AngularVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AngularVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AngularVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AngularVectorForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ForceNode
 */
/**
 * Python function wrapper for:
 * inline void ForceNode::clear(void)
 */
static PyObject *Dtool_ForceNode_clear_156(PyObject *self, PyObject *) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.clear")) {
    return NULL;
  }
  // 1-inline void ForceNode::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_clear_156_comment =
  "C++ Interface:\n"
  "clear(const ForceNode self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ForceNode_clear_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BaseForce *ForceNode::get_force(std::size_t index) const
 */
static PyObject *Dtool_ForceNode_get_force_157(PyObject *self, PyObject *arg) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ForceNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline BaseForce *ForceNode::get_force(std::size_t index) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_force", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    BaseForce *return_value = (*(const ForceNode*)local_this).get_force((std::size_t)param1);
    if (return_value != (BaseForce *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (BaseForce *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BaseForce, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_force(ForceNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_get_force_157_comment =
  "C++ Interface:\n"
  "get_force(ForceNode self, int index)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ForceNode_get_force_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ForceNode::get_num_forces(void) const
 */
static PyObject *Dtool_ForceNode_get_num_forces_158(PyObject *self, PyObject *) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ForceNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ForceNode::get_num_forces(void) const
  std::size_t return_value = (*(const ForceNode*)local_this).get_num_forces();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_get_num_forces_158_comment =
  "C++ Interface:\n"
  "get_num_forces(ForceNode self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ForceNode_get_num_forces_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ForceNode::add_force(BaseForce *force)
 */
static PyObject *Dtool_ForceNode_add_force_160(PyObject *self, PyObject *arg) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.add_force")) {
    return NULL;
  }
  // 1-inline void ForceNode::add_force(BaseForce *force)
  BaseForce *arg_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BaseForce, 1, "ForceNode.add_force", false, true);
  if (arg_this != NULL) {
    (*local_this).add_force(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_force(const ForceNode self, BaseForce force)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_add_force_160_comment =
  "C++ Interface:\n"
  "add_force(const ForceNode self, BaseForce force)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ForceNode_add_force_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ForceNode::add_forces_from(ForceNode const &other)
 */
static PyObject *Dtool_ForceNode_add_forces_from_161(PyObject *self, PyObject *arg) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.add_forces_from")) {
    return NULL;
  }
  // 1-void ForceNode::add_forces_from(ForceNode const &other)
  CPT(ForceNode) arg_this;
  if (!Dtool_ConstCoerce_ForceNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ForceNode.add_forces_from", "ForceNode");
  }
  (*local_this).add_forces_from(*MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_forces_from(const ForceNode self, const ForceNode other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_add_forces_from_161_comment =
  "C++ Interface:\n"
  "add_forces_from(const ForceNode self, const ForceNode other)\n"
  "\n"
  "/**\n"
  " * append operation\n"
  " */";
#else
static const char *Dtool_ForceNode_add_forces_from_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ForceNode::set_force(std::size_t index, BaseForce *force)
 */
static PyObject *Dtool_ForceNode_set_force_162(PyObject *self, PyObject *args, PyObject *kwds) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.set_force")) {
    return NULL;
  }
  // 1-void ForceNode::set_force(std::size_t index, BaseForce *force)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "force", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_force", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    BaseForce *param2_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_BaseForce, 2, "ForceNode.set_force", false, true);
    if (param2_this != NULL) {
      (*local_this).set_force((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_force(const ForceNode self, int index, BaseForce force)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_set_force_162_comment =
  "C++ Interface:\n"
  "set_force(const ForceNode self, int index, BaseForce force)\n"
  "\n"
  "/**\n"
  " * replace operation\n"
  " */";
#else
static const char *Dtool_ForceNode_set_force_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ForceNode::remove_force(BaseForce *force)
 * void ForceNode::remove_force(std::size_t index)
 */
static PyObject *Dtool_ForceNode_remove_force_163(PyObject *self, PyObject *arg) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.remove_force")) {
    return NULL;
  }
  {
    // -2 void ForceNode::remove_force(BaseForce *force)
    BaseForce *arg_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BaseForce, 1, "ForceNode.remove_force", false, false);
    if (arg_this != NULL) {
      (*local_this).remove_force(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void ForceNode::remove_force(std::size_t index)
    Py_ssize_t param1;
    if (PyArg_Parse(arg, "n:remove_force", &param1)) {
#ifndef NDEBUG
      if (param1 < 0) {
        return PyErr_Format(PyExc_OverflowError,
                            "can't convert negative value %zd to size_t",
                            param1);
      }
#endif
      (*local_this).remove_force((std::size_t)param1);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: void ForceNode::remove_force(BaseForce *force)
  // No coercion possible: void ForceNode::remove_force(std::size_t index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_force(const ForceNode self, BaseForce force)\n"
      "remove_force(const ForceNode self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_remove_force_163_comment =
  "C++ Interface:\n"
  "remove_force(const ForceNode self, BaseForce force)\n"
  "remove_force(const ForceNode self, int index)\n"
  "\n"
  "/**\n"
  " * remove operation\n"
  " */\n"
  "\n"
  "/**\n"
  " * remove operation\n"
  " */";
#else
static const char *Dtool_ForceNode_remove_force_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void ForceNode::write_forces(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_ForceNode_write_forces_166(PyObject *self, PyObject *args, PyObject *kwds) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ForceNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void ForceNode::write_forces(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write_forces", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "ForceNode.write_forces", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const ForceNode*)local_this).write_forces(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_forces(ForceNode self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_write_forces_166_comment =
  "C++ Interface:\n"
  "write_forces(ForceNode self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_ForceNode_write_forces_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void ForceNode::write(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_ForceNode_write_167(PyObject *self, PyObject *args, PyObject *kwds) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ForceNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void ForceNode::write(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "ForceNode.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const ForceNode*)local_this).write(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ForceNode self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_write_167_comment =
  "C++ Interface:\n"
  "write(ForceNode self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_ForceNode_write_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ForceNode::get_class_type(void)
 */
static PyObject *Dtool_ForceNode_get_class_type_168(PyObject *, PyObject *) {
  // 1-static TypeHandle ForceNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ForceNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_get_class_type_168_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ForceNode_get_class_type_168_comment = NULL;
#endif

/**
 * sequence length function for property ForceNode::forces
 */
static Py_ssize_t Dtool_ForceNode_forces_Len(PyObject *self) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ForceNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_forces();
}

/**
 * sequence getter for property ForceNode::forces
 */
static PyObject *Dtool_ForceNode_forces_Getitem(PyObject *self, Py_ssize_t index) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ForceNode, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_forces()) {
    PyErr_SetString(PyExc_IndexError, "ForceNode.forces[] index out of range");
    return NULL;
  }
  // 1-inline BaseForce *ForceNode::get_force(std::size_t index) const
  BaseForce *return_value = (*(const ForceNode*)local_this).get_force(index);
  if (return_value != (BaseForce *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (BaseForce *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BaseForce, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_force(ForceNode self, index)\n");
  }
}

static int Dtool_ForceNode_forces_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.forces")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    local_this->remove_force(index);
    return 0;
  }
  // 1-void ForceNode::set_force(std::size_t index, BaseForce *force)
  BaseForce *arg_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BaseForce, 2, "ForceNode.set_force", false, true);
  if (arg_this != NULL) {
    (*local_this).set_force(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_force(const ForceNode self, index, BaseForce force)\n");
  }
  return -1;
}

static PyObject *Dtool_ForceNode_forces_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ForceNode_forces_Len;
  wrap->_getitem_func = &Dtool_ForceNode_forces_Getitem;
  wrap->_setitem_func = &Dtool_ForceNode_forces_Setitem;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * ForceNode::ForceNode(std::string const &name)
 */
static int Dtool_Init_ForceNode(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ForceNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-ForceNode::ForceNode(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    ForceNode *return_value = new ForceNode(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ForceNode, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ForceNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ForceNode(PyObject *args, CPT(ForceNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ForceNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ForceNode::ForceNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ForceNode *return_value = new ForceNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_ForceNode(PyObject *args, PT(ForceNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ForceNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ForceNode::ForceNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ForceNode *return_value = new ForceNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ForceNode_get_forces(PyObject *self, PyObject *) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ForceNode, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_forces();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ForceNode_get_force_157(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ForceNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ForceNode) {
    printf("ForceNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ForceNode *local_this = (ForceNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ForceNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ForceNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ForceNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ForceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ForceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ForceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ForceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ForceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ForceNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearControlForce
 */
/**
 * Python function wrapper for:
 * inline void LinearControlForce::clear_physics_object(void)
 */
static PyObject *Dtool_LinearControlForce_clear_physics_object_171(PyObject *self, PyObject *) {
  LinearControlForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearControlForce, (void **)&local_this, "LinearControlForce.clear_physics_object")) {
    return NULL;
  }
  // 1-inline void LinearControlForce::clear_physics_object(void)
  (*local_this).clear_physics_object();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_clear_physics_object_171_comment =
  "C++ Interface:\n"
  "clear_physics_object(const LinearControlForce self)\n"
  "\n"
  "/**\n"
  " * encapsulating wrapper\n"
  " */";
#else
static const char *Dtool_LinearControlForce_clear_physics_object_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LinearControlForce::set_physics_object(PhysicsObject const *po)
 */
static PyObject *Dtool_LinearControlForce_set_physics_object_172(PyObject *self, PyObject *arg) {
  LinearControlForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearControlForce, (void **)&local_this, "LinearControlForce.set_physics_object")) {
    return NULL;
  }
  // 1-inline void LinearControlForce::set_physics_object(PhysicsObject const *po)
  PhysicsObject const *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "LinearControlForce.set_physics_object", true, true);
  if (arg_this != NULL) {
    (*local_this).set_physics_object(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_physics_object(const LinearControlForce self, const PhysicsObject po)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_set_physics_object_172_comment =
  "C++ Interface:\n"
  "set_physics_object(const LinearControlForce self, const PhysicsObject po)\n"
  "\n"
  "/**\n"
  " * encapsulating wrapper\n"
  " */";
#else
static const char *Dtool_LinearControlForce_set_physics_object_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< PhysicsObject > LinearControlForce::get_physics_object(void) const
 */
static PyObject *Dtool_LinearControlForce_get_physics_object_173(PyObject *self, PyObject *) {
  LinearControlForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearControlForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConstPointerTo< PhysicsObject > LinearControlForce::get_physics_object(void) const
  ConstPointerTo< PhysicsObject > return_value = (*(const LinearControlForce*)local_this).get_physics_object();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  PhysicsObject const *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PhysicsObject, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_get_physics_object_173_comment =
  "C++ Interface:\n"
  "get_physics_object(LinearControlForce self)\n"
  "\n"
  "/**\n"
  " * piecewise encapsulating wrapper\n"
  " */";
#else
static const char *Dtool_LinearControlForce_get_physics_object_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LinearControlForce::set_vector(LVector3 const &v)
 * inline void LinearControlForce::set_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_LinearControlForce_set_vector_174(PyObject *self, PyObject *args, PyObject *kwds) {
  LinearControlForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearControlForce, (void **)&local_this, "LinearControlForce.set_vector")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "v");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'v' (pos 1) not found");
      }
      // 1-inline void LinearControlForce::set_vector(LVector3 const &v)
      LVector3f arg_local;
      LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LinearControlForce.set_vector", "LVector3f");
      }
      (*local_this).set_vector(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void LinearControlForce::set_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_vector", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_vector((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_vector() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vector(const LinearControlForce self, const LVector3f v)\n"
      "set_vector(const LinearControlForce self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_set_vector_174_comment =
  "C++ Interface:\n"
  "set_vector(const LinearControlForce self, const LVector3f v)\n"
  "set_vector(const LinearControlForce self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * encapsulating wrapper\n"
  " */\n"
  "\n"
  "/**\n"
  " * piecewise encapsulating wrapper\n"
  " */";
#else
static const char *Dtool_LinearControlForce_set_vector_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 LinearControlForce::get_local_vector(void) const
 */
static PyObject *Dtool_LinearControlForce_get_local_vector_175(PyObject *self, PyObject *) {
  LinearControlForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearControlForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 LinearControlForce::get_local_vector(void) const
  LVector3 *return_value = new LVector3((*(const LinearControlForce*)local_this).get_local_vector());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_get_local_vector_175_comment =
  "C++ Interface:\n"
  "get_local_vector(LinearControlForce self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LinearControlForce_get_local_vector_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearControlForce::get_class_type(void)
 */
static PyObject *Dtool_LinearControlForce_get_class_type_176(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearControlForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearControlForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_get_class_type_176_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearControlForce_get_class_type_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LinearControlForce::LinearControlForce(LinearControlForce const &copy)
 * LinearControlForce::LinearControlForce(PhysicsObject const *po = 0, PN_stdfloat a = 1.0, bool mass = false)
 */
static int Dtool_Init_LinearControlForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LinearControlForce::LinearControlForce(PhysicsObject const *po, PN_stdfloat a, bool mass)
      LinearControlForce *return_value = new LinearControlForce();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearControlForce, true, false);
    }
    break;
  case 1:
  case 2:
  case 3:
    {
      {
        // -2 LinearControlForce::LinearControlForce(PhysicsObject const *po, PN_stdfloat a = 1.0, bool mass = false)
        PyObject *param0;
        float param1 = 1.0;
        PyObject *param2 = Py_False;
        static const char *keyword_list[] = {"po", "a", "mass", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|fO:LinearControlForce", (char **)keyword_list, &param0, &param1, &param2)) {
          PhysicsObject const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PhysicsObject, (void **)&param0_this);
          if (param0_this != NULL) {
            LinearControlForce *return_value = new LinearControlForce(param0_this, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearControlForce, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: LinearControlForce::LinearControlForce(PhysicsObject const *po, PN_stdfloat a = 1.0, bool mass = false)
      {
        // -2 LinearControlForce::LinearControlForce(LinearControlForce const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LinearControlForce", (char **)keyword_list, &param0)) {
          CPT(LinearControlForce) param0_this;
          if (Dtool_ConstCoerce_LinearControlForce(param0, param0_this)) {
            LinearControlForce *return_value = new LinearControlForce(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearControlForce, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearControlForce() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearControlForce()\n"
      "LinearControlForce(const PhysicsObject po, float a, bool mass)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LinearControlForce(PyObject *args, CPT(LinearControlForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearControlForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LinearControlForce::LinearControlForce(PhysicsObject const *po, PN_stdfloat a, bool mass)
    PhysicsObject const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PhysicsObject, (void **)&arg_this);
    if (arg_this != NULL) {
      LinearControlForce *return_value = new LinearControlForce(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-LinearControlForce::LinearControlForce(PhysicsObject const *po, PN_stdfloat a, bool mass = false)
      PyObject *param0;
      float param1;
      PyObject *param2 = Py_False;
      if (PyArg_ParseTuple(args, "Of|O:LinearControlForce", &param0, &param1, &param2)) {
        PhysicsObject const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PhysicsObject, (void **)&param0_this);
        if (param0_this != NULL) {
          LinearControlForce *return_value = new LinearControlForce(param0_this, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LinearControlForce(PyObject *args, PT(LinearControlForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearControlForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LinearControlForce::LinearControlForce(PhysicsObject const *po, PN_stdfloat a, bool mass)
    PhysicsObject const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PhysicsObject, (void **)&arg_this);
    if (arg_this != NULL) {
      LinearControlForce *return_value = new LinearControlForce(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-LinearControlForce::LinearControlForce(PhysicsObject const *po, PN_stdfloat a, bool mass = false)
      PyObject *param0;
      float param1;
      PyObject *param2 = Py_False;
      if (PyArg_ParseTuple(args, "Of|O:LinearControlForce", &param0, &param1, &param2)) {
        PhysicsObject const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PhysicsObject, (void **)&param0_this);
        if (param0_this != NULL) {
          LinearControlForce *return_value = new LinearControlForce(param0_this, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LinearControlForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearControlForce) {
    printf("LinearControlForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearControlForce *local_this = (LinearControlForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearControlForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearControlForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearControlForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearControlForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearControlForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearControlForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearControlForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearControlForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearCylinderVortexForce
 */
/**
 * Python function wrapper for:
 * inline void LinearCylinderVortexForce::set_coef(PN_stdfloat coef)
 */
static PyObject *Dtool_LinearCylinderVortexForce_set_coef_179(PyObject *self, PyObject *arg) {
  LinearCylinderVortexForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearCylinderVortexForce, (void **)&local_this, "LinearCylinderVortexForce.set_coef")) {
    return NULL;
  }
  // 1-inline void LinearCylinderVortexForce::set_coef(PN_stdfloat coef)
  if (PyNumber_Check(arg)) {
    (*local_this).set_coef((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coef(const LinearCylinderVortexForce self, float coef)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_set_coef_179_comment =
  "C++ Interface:\n"
  "set_coef(const LinearCylinderVortexForce self, float coef)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_set_coef_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearCylinderVortexForce::get_coef(void) const
 */
static PyObject *Dtool_LinearCylinderVortexForce_get_coef_180(PyObject *self, PyObject *) {
  LinearCylinderVortexForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearCylinderVortexForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat LinearCylinderVortexForce::get_coef(void) const
  PN_stdfloat return_value = (*(const LinearCylinderVortexForce*)local_this).get_coef();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_get_coef_180_comment =
  "C++ Interface:\n"
  "get_coef(LinearCylinderVortexForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_get_coef_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LinearCylinderVortexForce::set_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_LinearCylinderVortexForce_set_radius_181(PyObject *self, PyObject *arg) {
  LinearCylinderVortexForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearCylinderVortexForce, (void **)&local_this, "LinearCylinderVortexForce.set_radius")) {
    return NULL;
  }
  // 1-inline void LinearCylinderVortexForce::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const LinearCylinderVortexForce self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_set_radius_181_comment =
  "C++ Interface:\n"
  "set_radius(const LinearCylinderVortexForce self, float radius)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_set_radius_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearCylinderVortexForce::get_radius(void) const
 */
static PyObject *Dtool_LinearCylinderVortexForce_get_radius_182(PyObject *self, PyObject *) {
  LinearCylinderVortexForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearCylinderVortexForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat LinearCylinderVortexForce::get_radius(void) const
  PN_stdfloat return_value = (*(const LinearCylinderVortexForce*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_get_radius_182_comment =
  "C++ Interface:\n"
  "get_radius(LinearCylinderVortexForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_get_radius_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LinearCylinderVortexForce::set_length(PN_stdfloat length)
 */
static PyObject *Dtool_LinearCylinderVortexForce_set_length_183(PyObject *self, PyObject *arg) {
  LinearCylinderVortexForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearCylinderVortexForce, (void **)&local_this, "LinearCylinderVortexForce.set_length")) {
    return NULL;
  }
  // 1-inline void LinearCylinderVortexForce::set_length(PN_stdfloat length)
  if (PyNumber_Check(arg)) {
    (*local_this).set_length((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_length(const LinearCylinderVortexForce self, float length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_set_length_183_comment =
  "C++ Interface:\n"
  "set_length(const LinearCylinderVortexForce self, float length)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_set_length_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearCylinderVortexForce::get_length(void) const
 */
static PyObject *Dtool_LinearCylinderVortexForce_get_length_184(PyObject *self, PyObject *) {
  LinearCylinderVortexForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearCylinderVortexForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat LinearCylinderVortexForce::get_length(void) const
  PN_stdfloat return_value = (*(const LinearCylinderVortexForce*)local_this).get_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_get_length_184_comment =
  "C++ Interface:\n"
  "get_length(LinearCylinderVortexForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_get_length_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearCylinderVortexForce::get_class_type(void)
 */
static PyObject *Dtool_LinearCylinderVortexForce_get_class_type_185(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearCylinderVortexForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearCylinderVortexForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_get_class_type_185_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearCylinderVortexForce_get_class_type_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LinearCylinderVortexForce::LinearCylinderVortexForce(LinearCylinderVortexForce const &copy)
 * LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius = 1.0, PN_stdfloat length = 0.0, PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool md = false)
 */
static int Dtool_Init_LinearCylinderVortexForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius, PN_stdfloat length, PN_stdfloat coef, PN_stdfloat a, bool md)
      LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearCylinderVortexForce, true, false);
    }
    break;
  case 1:
  case 2:
  case 3:
  case 4:
  case 5:
    {
      {
        // -2 LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius, PN_stdfloat length = 0.0, PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool md = false)
        float param0;
        float param1 = 0.0;
        float param2 = 1.0;
        float param3 = 1.0;
        PyObject *param4 = Py_False;
        static const char *keyword_list[] = {"radius", "length", "coef", "a", "md", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f|fffO:LinearCylinderVortexForce", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearCylinderVortexForce, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius, PN_stdfloat length = 0.0, PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool md = false)
      {
        // -2 LinearCylinderVortexForce::LinearCylinderVortexForce(LinearCylinderVortexForce const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LinearCylinderVortexForce", (char **)keyword_list, &param0)) {
          CPT(LinearCylinderVortexForce) param0_this;
          if (Dtool_ConstCoerce_LinearCylinderVortexForce(param0, param0_this)) {
            LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearCylinderVortexForce, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearCylinderVortexForce() takes 0, 1, 2, 3, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearCylinderVortexForce()\n"
      "LinearCylinderVortexForce(float radius, float length, float coef, float a, bool md)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LinearCylinderVortexForce(PyObject *args, CPT(LinearCylinderVortexForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearCylinderVortexForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius, PN_stdfloat length, PN_stdfloat coef, PN_stdfloat a, bool md)
    if (PyNumber_Check(arg)) {
      LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce((PN_stdfloat)PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 5) {
      // 1-LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius, PN_stdfloat length, PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool md = false)
      float param0;
      float param1;
      float param2 = 1.0;
      float param3 = 1.0;
      PyObject *param4 = Py_False;
      if (PyArg_ParseTuple(args, "ff|ffO:LinearCylinderVortexForce", &param0, &param1, &param2, &param3, &param4)) {
        LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LinearCylinderVortexForce(PyObject *args, PT(LinearCylinderVortexForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearCylinderVortexForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius, PN_stdfloat length, PN_stdfloat coef, PN_stdfloat a, bool md)
    if (PyNumber_Check(arg)) {
      LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce((PN_stdfloat)PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 5) {
      // 1-LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius, PN_stdfloat length, PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool md = false)
      float param0;
      float param1;
      float param2 = 1.0;
      float param3 = 1.0;
      PyObject *param4 = Py_False;
      if (PyArg_ParseTuple(args, "ff|ffO:LinearCylinderVortexForce", &param0, &param1, &param2, &param3, &param4)) {
        LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LinearCylinderVortexForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearCylinderVortexForce) {
    printf("LinearCylinderVortexForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearCylinderVortexForce *local_this = (LinearCylinderVortexForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearCylinderVortexForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearCylinderVortexForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearCylinderVortexForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearCylinderVortexForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearCylinderVortexForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearCylinderVortexForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearCylinderVortexForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearCylinderVortexForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearDistanceForce
 */
/**
 * Python function wrapper for:
 * inline void LinearDistanceForce::set_radius(PN_stdfloat r)
 */
static PyObject *Dtool_LinearDistanceForce_set_radius_188(PyObject *self, PyObject *arg) {
  LinearDistanceForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearDistanceForce, (void **)&local_this, "LinearDistanceForce.set_radius")) {
    return NULL;
  }
  // 1-inline void LinearDistanceForce::set_radius(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const LinearDistanceForce self, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_set_radius_188_comment =
  "C++ Interface:\n"
  "set_radius(const LinearDistanceForce self, float r)\n"
  "\n"
  "/**\n"
  " * set the radius\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_set_radius_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LinearDistanceForce::set_falloff_type(LinearDistanceForce::FalloffType ft)
 */
static PyObject *Dtool_LinearDistanceForce_set_falloff_type_189(PyObject *self, PyObject *arg) {
  LinearDistanceForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearDistanceForce, (void **)&local_this, "LinearDistanceForce.set_falloff_type")) {
    return NULL;
  }
  // 1-inline void LinearDistanceForce::set_falloff_type(LinearDistanceForce::FalloffType ft)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_falloff_type((LinearDistanceForce::FalloffType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_falloff_type(const LinearDistanceForce self, int ft)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_set_falloff_type_189_comment =
  "C++ Interface:\n"
  "set_falloff_type(const LinearDistanceForce self, int ft)\n"
  "\n"
  "/**\n"
  " * falloff_type encapsulating wrap\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_set_falloff_type_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LinearDistanceForce::set_force_center(LPoint3 const &p)
 */
static PyObject *Dtool_LinearDistanceForce_set_force_center_190(PyObject *self, PyObject *arg) {
  LinearDistanceForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearDistanceForce, (void **)&local_this, "LinearDistanceForce.set_force_center")) {
    return NULL;
  }
  // 1-inline void LinearDistanceForce::set_force_center(LPoint3 const &p)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LinearDistanceForce.set_force_center", "LPoint3f");
  }
  (*local_this).set_force_center(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_force_center(const LinearDistanceForce self, const LPoint3f p)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_set_force_center_190_comment =
  "C++ Interface:\n"
  "set_force_center(const LinearDistanceForce self, const LPoint3f p)\n"
  "\n"
  "/**\n"
  " * set the force center\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_set_force_center_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearDistanceForce::get_radius(void) const
 */
static PyObject *Dtool_LinearDistanceForce_get_radius_191(PyObject *self, PyObject *) {
  LinearDistanceForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearDistanceForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat LinearDistanceForce::get_radius(void) const
  PN_stdfloat return_value = (*(const LinearDistanceForce*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_get_radius_191_comment =
  "C++ Interface:\n"
  "get_radius(LinearDistanceForce self)\n"
  "\n"
  "/**\n"
  " * radius query\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_get_radius_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LinearDistanceForce::FalloffType LinearDistanceForce::get_falloff_type(void) const
 */
static PyObject *Dtool_LinearDistanceForce_get_falloff_type_192(PyObject *self, PyObject *) {
  LinearDistanceForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearDistanceForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LinearDistanceForce::FalloffType LinearDistanceForce::get_falloff_type(void) const
  LinearDistanceForce::FalloffType return_value = (*(const LinearDistanceForce*)local_this).get_falloff_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_get_falloff_type_192_comment =
  "C++ Interface:\n"
  "get_falloff_type(LinearDistanceForce self)\n"
  "\n"
  "/**\n"
  " * falloff_type query\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_get_falloff_type_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 LinearDistanceForce::get_force_center(void) const
 */
static PyObject *Dtool_LinearDistanceForce_get_force_center_193(PyObject *self, PyObject *) {
  LinearDistanceForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearDistanceForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 LinearDistanceForce::get_force_center(void) const
  LPoint3 *return_value = new LPoint3((*(const LinearDistanceForce*)local_this).get_force_center());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_get_force_center_193_comment =
  "C++ Interface:\n"
  "get_force_center(LinearDistanceForce self)\n"
  "\n"
  "/**\n"
  " * force_center query\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_get_force_center_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearDistanceForce::get_scalar_term(void) const
 */
static PyObject *Dtool_LinearDistanceForce_get_scalar_term_194(PyObject *self, PyObject *) {
  LinearDistanceForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearDistanceForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat LinearDistanceForce::get_scalar_term(void) const
  PN_stdfloat return_value = (*(const LinearDistanceForce*)local_this).get_scalar_term();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_get_scalar_term_194_comment =
  "C++ Interface:\n"
  "get_scalar_term(LinearDistanceForce self)\n"
  "\n"
  "/**\n"
  " * calculate the term based on falloff\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_get_scalar_term_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearDistanceForce::get_class_type(void)
 */
static PyObject *Dtool_LinearDistanceForce_get_class_type_195(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearDistanceForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearDistanceForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_get_class_type_195_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearDistanceForce_get_class_type_195_comment = NULL;
#endif

static int Dtool_Init_LinearDistanceForce(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LinearDistanceForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearDistanceForce) {
    printf("LinearDistanceForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearDistanceForce *local_this = (LinearDistanceForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearDistanceForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearDistanceForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearDistanceForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearDistanceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearDistanceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearDistanceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearDistanceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearDistanceForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearIntegrator
 */
static int Dtool_Init_LinearIntegrator(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LinearIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearIntegrator) {
    printf("LinearIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearIntegrator *local_this = (LinearIntegrator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearIntegrator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseIntegrator) {
    return (BaseIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseIntegrator *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearIntegrator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearIntegrator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseIntegrator) {
    BaseIntegrator* other_this = (BaseIntegrator*)from_this;
    return (LinearIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearIntegrator*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearEulerIntegrator
 */
/**
 * Python function wrapper for:
 * LinearEulerIntegrator::LinearEulerIntegrator(void)
 */
static int Dtool_Init_LinearEulerIntegrator(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "LinearEulerIntegrator() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-LinearEulerIntegrator::LinearEulerIntegrator(void)
  LinearEulerIntegrator *return_value = new LinearEulerIntegrator();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearEulerIntegrator, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearEulerIntegrator()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LinearEulerIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearEulerIntegrator) {
    printf("LinearEulerIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearEulerIntegrator *local_this = (LinearEulerIntegrator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearEulerIntegrator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseIntegrator) {
    return (BaseIntegrator *)(LinearIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearIntegrator) {
    return (LinearIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseIntegrator *)(LinearIntegrator *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearEulerIntegrator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearEulerIntegrator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseIntegrator) {
    BaseIntegrator* other_this = (BaseIntegrator*)from_this;
    return (LinearEulerIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearIntegrator) {
    LinearIntegrator* other_this = (LinearIntegrator*)from_this;
    return (LinearEulerIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearEulerIntegrator*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearFrictionForce
 */
/**
 * Python function wrapper for:
 * inline void LinearFrictionForce::set_coef(PN_stdfloat coef)
 */
static PyObject *Dtool_LinearFrictionForce_set_coef_201(PyObject *self, PyObject *arg) {
  LinearFrictionForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearFrictionForce, (void **)&local_this, "LinearFrictionForce.set_coef")) {
    return NULL;
  }
  // 1-inline void LinearFrictionForce::set_coef(PN_stdfloat coef)
  if (PyNumber_Check(arg)) {
    (*local_this).set_coef((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coef(const LinearFrictionForce self, float coef)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearFrictionForce_set_coef_201_comment =
  "C++ Interface:\n"
  "set_coef(const LinearFrictionForce self, float coef)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearFrictionForce_set_coef_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearFrictionForce::get_coef(void) const
 */
static PyObject *Dtool_LinearFrictionForce_get_coef_202(PyObject *self, PyObject *) {
  LinearFrictionForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearFrictionForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat LinearFrictionForce::get_coef(void) const
  PN_stdfloat return_value = (*(const LinearFrictionForce*)local_this).get_coef();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearFrictionForce_get_coef_202_comment =
  "C++ Interface:\n"
  "get_coef(LinearFrictionForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearFrictionForce_get_coef_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearFrictionForce::get_class_type(void)
 */
static PyObject *Dtool_LinearFrictionForce_get_class_type_203(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearFrictionForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearFrictionForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearFrictionForce_get_class_type_203_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearFrictionForce_get_class_type_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LinearFrictionForce::LinearFrictionForce(LinearFrictionForce const &copy)
 * LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool m = false)
 */
static int Dtool_Init_LinearFrictionForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef, PN_stdfloat a, bool m)
      LinearFrictionForce *return_value = new LinearFrictionForce();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearFrictionForce, true, false);
    }
    break;
  case 1:
  case 2:
  case 3:
    {
      {
        // -2 LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef, PN_stdfloat a = 1.0, bool m = false)
        float param0;
        float param1 = 1.0;
        PyObject *param2 = Py_False;
        static const char *keyword_list[] = {"coef", "a", "m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f|fO:LinearFrictionForce", (char **)keyword_list, &param0, &param1, &param2)) {
          LinearFrictionForce *return_value = new LinearFrictionForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearFrictionForce, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef, PN_stdfloat a = 1.0, bool m = false)
      {
        // -2 LinearFrictionForce::LinearFrictionForce(LinearFrictionForce const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LinearFrictionForce", (char **)keyword_list, &param0)) {
          CPT(LinearFrictionForce) param0_this;
          if (Dtool_ConstCoerce_LinearFrictionForce(param0, param0_this)) {
            LinearFrictionForce *return_value = new LinearFrictionForce(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearFrictionForce, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearFrictionForce() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearFrictionForce()\n"
      "LinearFrictionForce(float coef, float a, bool m)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LinearFrictionForce(PyObject *args, CPT(LinearFrictionForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearFrictionForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef, PN_stdfloat a, bool m)
    if (PyNumber_Check(arg)) {
      LinearFrictionForce *return_value = new LinearFrictionForce((PN_stdfloat)PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef, PN_stdfloat a, bool m = false)
      float param0;
      float param1;
      PyObject *param2 = Py_False;
      if (PyArg_ParseTuple(args, "ff|O:LinearFrictionForce", &param0, &param1, &param2)) {
        LinearFrictionForce *return_value = new LinearFrictionForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LinearFrictionForce(PyObject *args, PT(LinearFrictionForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearFrictionForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef, PN_stdfloat a, bool m)
    if (PyNumber_Check(arg)) {
      LinearFrictionForce *return_value = new LinearFrictionForce((PN_stdfloat)PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef, PN_stdfloat a, bool m = false)
      float param0;
      float param1;
      PyObject *param2 = Py_False;
      if (PyArg_ParseTuple(args, "ff|O:LinearFrictionForce", &param0, &param1, &param2)) {
        LinearFrictionForce *return_value = new LinearFrictionForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LinearFrictionForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearFrictionForce) {
    printf("LinearFrictionForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearFrictionForce *local_this = (LinearFrictionForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearFrictionForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearFrictionForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearFrictionForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearFrictionForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearFrictionForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearFrictionForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearFrictionForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearFrictionForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearRandomForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearRandomForce::get_class_type(void)
 */
static PyObject *Dtool_LinearRandomForce_get_class_type_205(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearRandomForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearRandomForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearRandomForce_get_class_type_205_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearRandomForce_get_class_type_205_comment = NULL;
#endif

static int Dtool_Init_LinearRandomForce(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LinearRandomForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearRandomForce) {
    printf("LinearRandomForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearRandomForce *local_this = (LinearRandomForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearRandomForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearRandomForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearRandomForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearRandomForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearRandomForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearRandomForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearRandomForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearRandomForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearJitterForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearJitterForce::get_class_type(void)
 */
static PyObject *Dtool_LinearJitterForce_get_class_type_208(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearJitterForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearJitterForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearJitterForce_get_class_type_208_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearJitterForce_get_class_type_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LinearJitterForce::LinearJitterForce(LinearJitterForce const &copy)
 * LinearJitterForce::LinearJitterForce(PN_stdfloat a = 1.0, bool m = false)
 */
static int Dtool_Init_LinearJitterForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LinearJitterForce::LinearJitterForce(PN_stdfloat a, bool m)
      LinearJitterForce *return_value = new LinearJitterForce();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearJitterForce, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 LinearJitterForce::LinearJitterForce(PN_stdfloat a, bool m = false)
        float param0;
        PyObject *param1 = Py_False;
        static const char *keyword_list[] = {"a", "m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f|O:LinearJitterForce", (char **)keyword_list, &param0, &param1)) {
          LinearJitterForce *return_value = new LinearJitterForce((PN_stdfloat)param0, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearJitterForce, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: LinearJitterForce::LinearJitterForce(PN_stdfloat a, bool m = false)
      {
        // -2 LinearJitterForce::LinearJitterForce(LinearJitterForce const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LinearJitterForce", (char **)keyword_list, &param0)) {
          CPT(LinearJitterForce) param0_this;
          if (Dtool_ConstCoerce_LinearJitterForce(param0, param0_this)) {
            LinearJitterForce *return_value = new LinearJitterForce(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearJitterForce, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearJitterForce() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearJitterForce()\n"
      "LinearJitterForce(float a, bool m)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LinearJitterForce(PyObject *args, CPT(LinearJitterForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearJitterForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LinearJitterForce::LinearJitterForce(PN_stdfloat a, bool m)
    if (PyNumber_Check(arg)) {
      LinearJitterForce *return_value = new LinearJitterForce((PN_stdfloat)PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LinearJitterForce::LinearJitterForce(PN_stdfloat a, bool m)
      float param0;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "fO:LinearJitterForce", &param0, &param1)) {
        LinearJitterForce *return_value = new LinearJitterForce((PN_stdfloat)param0, (PyObject_IsTrue(param1) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LinearJitterForce(PyObject *args, PT(LinearJitterForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearJitterForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LinearJitterForce::LinearJitterForce(PN_stdfloat a, bool m)
    if (PyNumber_Check(arg)) {
      LinearJitterForce *return_value = new LinearJitterForce((PN_stdfloat)PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LinearJitterForce::LinearJitterForce(PN_stdfloat a, bool m)
      float param0;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "fO:LinearJitterForce", &param0, &param1)) {
        LinearJitterForce *return_value = new LinearJitterForce((PN_stdfloat)param0, (PyObject_IsTrue(param1) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LinearJitterForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearJitterForce) {
    printf("LinearJitterForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearJitterForce *local_this = (LinearJitterForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearJitterForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearRandomForce) {
    return (LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearJitterForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearJitterForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearJitterForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearJitterForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearRandomForce) {
    LinearRandomForce* other_this = (LinearRandomForce*)from_this;
    return (LinearJitterForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearJitterForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearJitterForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearJitterForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearNoiseForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearNoiseForce::get_class_type(void)
 */
static PyObject *Dtool_LinearNoiseForce_get_class_type_211(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearNoiseForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearNoiseForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearNoiseForce_get_class_type_211_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearNoiseForce_get_class_type_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LinearNoiseForce::LinearNoiseForce(LinearNoiseForce const &copy)
 * LinearNoiseForce::LinearNoiseForce(PN_stdfloat a = 1.0, bool m = false)
 */
static int Dtool_Init_LinearNoiseForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LinearNoiseForce::LinearNoiseForce(PN_stdfloat a, bool m)
      LinearNoiseForce *return_value = new LinearNoiseForce();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearNoiseForce, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 LinearNoiseForce::LinearNoiseForce(PN_stdfloat a, bool m = false)
        float param0;
        PyObject *param1 = Py_False;
        static const char *keyword_list[] = {"a", "m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f|O:LinearNoiseForce", (char **)keyword_list, &param0, &param1)) {
          LinearNoiseForce *return_value = new LinearNoiseForce((PN_stdfloat)param0, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearNoiseForce, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: LinearNoiseForce::LinearNoiseForce(PN_stdfloat a, bool m = false)
      {
        // -2 LinearNoiseForce::LinearNoiseForce(LinearNoiseForce const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LinearNoiseForce", (char **)keyword_list, &param0)) {
          CPT(LinearNoiseForce) param0_this;
          if (Dtool_ConstCoerce_LinearNoiseForce(param0, param0_this)) {
            LinearNoiseForce *return_value = new LinearNoiseForce(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearNoiseForce, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearNoiseForce() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearNoiseForce()\n"
      "LinearNoiseForce(float a, bool m)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LinearNoiseForce(PyObject *args, CPT(LinearNoiseForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearNoiseForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LinearNoiseForce::LinearNoiseForce(PN_stdfloat a, bool m)
    if (PyNumber_Check(arg)) {
      LinearNoiseForce *return_value = new LinearNoiseForce((PN_stdfloat)PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LinearNoiseForce::LinearNoiseForce(PN_stdfloat a, bool m)
      float param0;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "fO:LinearNoiseForce", &param0, &param1)) {
        LinearNoiseForce *return_value = new LinearNoiseForce((PN_stdfloat)param0, (PyObject_IsTrue(param1) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LinearNoiseForce(PyObject *args, PT(LinearNoiseForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearNoiseForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LinearNoiseForce::LinearNoiseForce(PN_stdfloat a, bool m)
    if (PyNumber_Check(arg)) {
      LinearNoiseForce *return_value = new LinearNoiseForce((PN_stdfloat)PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LinearNoiseForce::LinearNoiseForce(PN_stdfloat a, bool m)
      float param0;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "fO:LinearNoiseForce", &param0, &param1)) {
        LinearNoiseForce *return_value = new LinearNoiseForce((PN_stdfloat)param0, (PyObject_IsTrue(param1) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LinearNoiseForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearNoiseForce) {
    printf("LinearNoiseForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearNoiseForce *local_this = (LinearNoiseForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearNoiseForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearRandomForce) {
    return (LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearNoiseForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearNoiseForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearRandomForce) {
    LinearRandomForce* other_this = (LinearRandomForce*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearSinkForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearSinkForce::get_class_type(void)
 */
static PyObject *Dtool_LinearSinkForce_get_class_type_214(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearSinkForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearSinkForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearSinkForce_get_class_type_214_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearSinkForce_get_class_type_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LinearSinkForce::LinearSinkForce(void)
 * LinearSinkForce::LinearSinkForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool m = true)
 * LinearSinkForce::LinearSinkForce(LinearSinkForce const &copy)
 */
static int Dtool_Init_LinearSinkForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LinearSinkForce::LinearSinkForce(void)
      LinearSinkForce *return_value = new LinearSinkForce();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSinkForce, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-LinearSinkForce::LinearSinkForce(LinearSinkForce const &copy)
      CPT(LinearSinkForce) arg_this;
      if (!Dtool_ConstCoerce_LinearSinkForce(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "LinearSinkForce.LinearSinkForce", "LinearSinkForce");
        return -1;
      }
      LinearSinkForce *return_value = new LinearSinkForce(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSinkForce, true, false);
    }
    break;
  case 3:
  case 4:
  case 5:
    {
      // 1-LinearSinkForce::LinearSinkForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool m = true)
      PyObject *param0;
      int param1;
      float param2;
      float param3 = 1.0;
      PyObject *param4 = Py_True;
      static const char *keyword_list[] = {"p", "f", "r", "a", "m", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oif|fO:LinearSinkForce", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LinearSinkForce.LinearSinkForce", "LPoint3f");
          return -1;
        }
        LinearSinkForce *return_value = new LinearSinkForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSinkForce, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearSinkForce() takes 0, 1, 3, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearSinkForce()\n"
      "LinearSinkForce(const LinearSinkForce copy)\n"
      "LinearSinkForce(const LPoint3f p, int f, float r, float a, bool m)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LinearSinkForce(PyObject *args, CPT(LinearSinkForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearSinkForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 5) {
      // 1-LinearSinkForce::LinearSinkForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool m = true)
      PyObject *param0;
      int param1;
      float param2;
      float param3 = 1.0;
      PyObject *param4 = Py_True;
      if (PyArg_ParseTuple(args, "Oif|fO:LinearSinkForce", &param0, &param1, &param2, &param3, &param4)) {
        LPoint3 const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
        if (param0_this != NULL) {
          LinearSinkForce *return_value = new LinearSinkForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LinearSinkForce(PyObject *args, PT(LinearSinkForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearSinkForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 5) {
      // 1-LinearSinkForce::LinearSinkForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool m = true)
      PyObject *param0;
      int param1;
      float param2;
      float param3 = 1.0;
      PyObject *param4 = Py_True;
      if (PyArg_ParseTuple(args, "Oif|fO:LinearSinkForce", &param0, &param1, &param2, &param3, &param4)) {
        LPoint3 const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
        if (param0_this != NULL) {
          LinearSinkForce *return_value = new LinearSinkForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LinearSinkForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearSinkForce) {
    printf("LinearSinkForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearSinkForce *local_this = (LinearSinkForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearSinkForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearDistanceForce) {
    return (LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearSinkForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearSinkForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearSinkForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearDistanceForce) {
    LinearDistanceForce* other_this = (LinearDistanceForce*)from_this;
    return (LinearSinkForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearSinkForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearSinkForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearSinkForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearSinkForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearSourceForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearSourceForce::get_class_type(void)
 */
static PyObject *Dtool_LinearSourceForce_get_class_type_217(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearSourceForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearSourceForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearSourceForce_get_class_type_217_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearSourceForce_get_class_type_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LinearSourceForce::LinearSourceForce(void)
 * LinearSourceForce::LinearSourceForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool mass = true)
 * LinearSourceForce::LinearSourceForce(LinearSourceForce const &copy)
 */
static int Dtool_Init_LinearSourceForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LinearSourceForce::LinearSourceForce(void)
      LinearSourceForce *return_value = new LinearSourceForce();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSourceForce, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-LinearSourceForce::LinearSourceForce(LinearSourceForce const &copy)
      CPT(LinearSourceForce) arg_this;
      if (!Dtool_ConstCoerce_LinearSourceForce(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "LinearSourceForce.LinearSourceForce", "LinearSourceForce");
        return -1;
      }
      LinearSourceForce *return_value = new LinearSourceForce(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSourceForce, true, false);
    }
    break;
  case 3:
  case 4:
  case 5:
    {
      // 1-LinearSourceForce::LinearSourceForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool mass = true)
      PyObject *param0;
      int param1;
      float param2;
      float param3 = 1.0;
      PyObject *param4 = Py_True;
      static const char *keyword_list[] = {"p", "f", "r", "a", "mass", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oif|fO:LinearSourceForce", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LinearSourceForce.LinearSourceForce", "LPoint3f");
          return -1;
        }
        LinearSourceForce *return_value = new LinearSourceForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSourceForce, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearSourceForce() takes 0, 1, 3, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearSourceForce()\n"
      "LinearSourceForce(const LinearSourceForce copy)\n"
      "LinearSourceForce(const LPoint3f p, int f, float r, float a, bool mass)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LinearSourceForce(PyObject *args, CPT(LinearSourceForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearSourceForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 5) {
      // 1-LinearSourceForce::LinearSourceForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool mass = true)
      PyObject *param0;
      int param1;
      float param2;
      float param3 = 1.0;
      PyObject *param4 = Py_True;
      if (PyArg_ParseTuple(args, "Oif|fO:LinearSourceForce", &param0, &param1, &param2, &param3, &param4)) {
        LPoint3 const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
        if (param0_this != NULL) {
          LinearSourceForce *return_value = new LinearSourceForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LinearSourceForce(PyObject *args, PT(LinearSourceForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearSourceForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 5) {
      // 1-LinearSourceForce::LinearSourceForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool mass = true)
      PyObject *param0;
      int param1;
      float param2;
      float param3 = 1.0;
      PyObject *param4 = Py_True;
      if (PyArg_ParseTuple(args, "Oif|fO:LinearSourceForce", &param0, &param1, &param2, &param3, &param4)) {
        LPoint3 const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
        if (param0_this != NULL) {
          LinearSourceForce *return_value = new LinearSourceForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LinearSourceForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearSourceForce) {
    printf("LinearSourceForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearSourceForce *local_this = (LinearSourceForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearSourceForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearDistanceForce) {
    return (LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearSourceForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearSourceForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearSourceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearDistanceForce) {
    LinearDistanceForce* other_this = (LinearDistanceForce*)from_this;
    return (LinearSourceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearSourceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearSourceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearSourceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearSourceForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearUserDefinedForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearUserDefinedForce::get_class_type(void)
 */
static PyObject *Dtool_LinearUserDefinedForce_get_class_type_221(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearUserDefinedForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearUserDefinedForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearUserDefinedForce_get_class_type_221_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearUserDefinedForce_get_class_type_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LinearUserDefinedForce::LinearUserDefinedForce(LinearUserDefinedForce const &copy)
 */
static int Dtool_Init_LinearUserDefinedForce(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "LinearUserDefinedForce() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "copy");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
    return -1;
  }
  // 1-LinearUserDefinedForce::LinearUserDefinedForce(LinearUserDefinedForce const &copy)
  CPT(LinearUserDefinedForce) arg_this;
  if (!Dtool_ConstCoerce_LinearUserDefinedForce(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 0, "LinearUserDefinedForce.LinearUserDefinedForce", "LinearUserDefinedForce");
    return -1;
  }
  LinearUserDefinedForce *return_value = new LinearUserDefinedForce(*MOVE(arg_this));
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearUserDefinedForce, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearUserDefinedForce(const LinearUserDefinedForce copy)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LinearUserDefinedForce(PyObject *args, CPT(LinearUserDefinedForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearUserDefinedForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_LinearUserDefinedForce(PyObject *args, PT(LinearUserDefinedForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearUserDefinedForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LinearUserDefinedForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearUserDefinedForce) {
    printf("LinearUserDefinedForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearUserDefinedForce *local_this = (LinearUserDefinedForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearUserDefinedForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearUserDefinedForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearUserDefinedForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearUserDefinedForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearUserDefinedForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearUserDefinedForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearUserDefinedForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearUserDefinedForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LinearVectorForce
 */
/**
 * Python function wrapper for:
 * inline void LinearVectorForce::set_vector(LVector3 const &v)
 * inline void LinearVectorForce::set_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_LinearVectorForce_set_vector_224(PyObject *self, PyObject *args, PyObject *kwds) {
  LinearVectorForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearVectorForce, (void **)&local_this, "LinearVectorForce.set_vector")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "v");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'v' (pos 1) not found");
      }
      // 1-inline void LinearVectorForce::set_vector(LVector3 const &v)
      LVector3f arg_local;
      LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LinearVectorForce.set_vector", "LVector3f");
      }
      (*local_this).set_vector(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void LinearVectorForce::set_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_vector", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_vector((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_vector() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vector(const LinearVectorForce self, const LVector3f v)\n"
      "set_vector(const LinearVectorForce self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LinearVectorForce_set_vector_224_comment =
  "C++ Interface:\n"
  "set_vector(const LinearVectorForce self, const LVector3f v)\n"
  "set_vector(const LinearVectorForce self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * encapsulating wrapper\n"
  " */\n"
  "\n"
  "/**\n"
  " * piecewise encapsulating wrapper\n"
  " */";
#else
static const char *Dtool_LinearVectorForce_set_vector_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 LinearVectorForce::get_local_vector(void) const
 */
static PyObject *Dtool_LinearVectorForce_get_local_vector_225(PyObject *self, PyObject *) {
  LinearVectorForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearVectorForce, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3 LinearVectorForce::get_local_vector(void) const
  LVector3 *return_value = new LVector3((*(const LinearVectorForce*)local_this).get_local_vector());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearVectorForce_get_local_vector_225_comment =
  "C++ Interface:\n"
  "get_local_vector(LinearVectorForce self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LinearVectorForce_get_local_vector_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearVectorForce::get_class_type(void)
 */
static PyObject *Dtool_LinearVectorForce_get_class_type_226(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearVectorForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LinearVectorForce::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearVectorForce_get_class_type_226_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearVectorForce_get_class_type_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LinearVectorForce::LinearVectorForce(LVector3 const &vec, PN_stdfloat a = 1.0, bool mass = false)
 * LinearVectorForce::LinearVectorForce(LinearVectorForce const &copy)
 * LinearVectorForce::LinearVectorForce(PN_stdfloat x = 0.0, PN_stdfloat y = 0.0, PN_stdfloat z = 0.0, PN_stdfloat a = 1.0, bool mass = false)
 */
static int Dtool_Init_LinearVectorForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LinearVectorForce::LinearVectorForce(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat a, bool mass)
      LinearVectorForce *return_value = new LinearVectorForce();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearVectorForce, true, false);
    }
    break;
  case 1:
  case 2:
  case 3:
  case 4:
  case 5:
    {
      {
        // -2 LinearVectorForce::LinearVectorForce(PN_stdfloat x, PN_stdfloat y = 0.0, PN_stdfloat z = 0.0, PN_stdfloat a = 1.0, bool mass = false)
        float param0;
        float param1 = 0.0;
        float param2 = 0.0;
        float param3 = 1.0;
        PyObject *param4 = Py_False;
        static const char *keyword_list[] = {"x", "y", "z", "a", "mass", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f|fffO:LinearVectorForce", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LinearVectorForce *return_value = new LinearVectorForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearVectorForce, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 LinearVectorForce::LinearVectorForce(LVector3 const &vec, PN_stdfloat a = 1.0, bool mass = false)
        PyObject *param0;
        float param1 = 1.0;
        PyObject *param2 = Py_False;
        static const char *keyword_list[] = {"vec", "a", "mass", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|fO:LinearVectorForce", (char **)keyword_list, &param0, &param1, &param2)) {
          LVector3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LinearVectorForce *return_value = new LinearVectorForce(*param0_this, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearVectorForce, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LinearVectorForce::LinearVectorForce(LinearVectorForce const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LinearVectorForce", (char **)keyword_list, &param0)) {
          LinearVectorForce const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LinearVectorForce, (void **)&param0_this);
          if (param0_this != NULL) {
            LinearVectorForce *return_value = new LinearVectorForce(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearVectorForce, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: LinearVectorForce::LinearVectorForce(PN_stdfloat x, PN_stdfloat y = 0.0, PN_stdfloat z = 0.0, PN_stdfloat a = 1.0, bool mass = false)
      {
        // -2 LinearVectorForce::LinearVectorForce(LVector3 const &vec, PN_stdfloat a = 1.0, bool mass = false)
        PyObject *param0;
        float param1 = 1.0;
        PyObject *param2 = Py_False;
        static const char *keyword_list[] = {"vec", "a", "mass", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|fO:LinearVectorForce", (char **)keyword_list, &param0, &param1, &param2)) {
          LVector3f param0_local;
          LVector3 const *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
          if ((param0_this != NULL)) {
            LinearVectorForce *return_value = new LinearVectorForce(*param0_this, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearVectorForce, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LinearVectorForce::LinearVectorForce(LinearVectorForce const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LinearVectorForce", (char **)keyword_list, &param0)) {
          CPT(LinearVectorForce) param0_this;
          if (Dtool_ConstCoerce_LinearVectorForce(param0, param0_this)) {
            LinearVectorForce *return_value = new LinearVectorForce(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearVectorForce, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearVectorForce() takes 0, 1, 2, 3, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearVectorForce()\n"
      "LinearVectorForce(float x, float y, float z, float a, bool mass)\n"
      "LinearVectorForce(const LVector3f vec, float a, bool mass)\n"
      "LinearVectorForce(const LinearVectorForce copy)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LinearVectorForce(PyObject *args, CPT(LinearVectorForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearVectorForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 LinearVectorForce::LinearVectorForce(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat a, bool mass)
      if (PyNumber_Check(arg)) {
        LinearVectorForce *return_value = new LinearVectorForce((PN_stdfloat)PyFloat_AsDouble(arg));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

    {
      // -2 LinearVectorForce::LinearVectorForce(LVector3 const &vec, PN_stdfloat a, bool mass)
      LVector3 const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3f, (void **)&arg_this);
      if (arg_this != NULL) {
        LinearVectorForce *return_value = new LinearVectorForce(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 5) {
      {
        // -2 LinearVectorForce::LinearVectorForce(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z = 0.0, PN_stdfloat a = 1.0, bool mass = false)
        float param0;
        float param1;
        float param2 = 0.0;
        float param3 = 1.0;
        PyObject *param4 = Py_False;
        if (PyArg_ParseTuple(args, "ff|ffO:LinearVectorForce", &param0, &param1, &param2, &param3, &param4)) {
          LinearVectorForce *return_value = new LinearVectorForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LinearVectorForce::LinearVectorForce(LVector3 const &vec, PN_stdfloat a = 1.0, bool mass = false)
        PyObject *param0;
        float param1;
        PyObject *param2 = Py_False;
        if (PyArg_ParseTuple(args, "Of|O:LinearVectorForce", &param0, &param1, &param2)) {
          LVector3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LinearVectorForce *return_value = new LinearVectorForce(*param0_this, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_LinearVectorForce(PyObject *args, PT(LinearVectorForce) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LinearVectorForce, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 LinearVectorForce::LinearVectorForce(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat a, bool mass)
      if (PyNumber_Check(arg)) {
        LinearVectorForce *return_value = new LinearVectorForce((PN_stdfloat)PyFloat_AsDouble(arg));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

    {
      // -2 LinearVectorForce::LinearVectorForce(LVector3 const &vec, PN_stdfloat a, bool mass)
      LVector3 const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3f, (void **)&arg_this);
      if (arg_this != NULL) {
        LinearVectorForce *return_value = new LinearVectorForce(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 5) {
      {
        // -2 LinearVectorForce::LinearVectorForce(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z = 0.0, PN_stdfloat a = 1.0, bool mass = false)
        float param0;
        float param1;
        float param2 = 0.0;
        float param3 = 1.0;
        PyObject *param4 = Py_False;
        if (PyArg_ParseTuple(args, "ff|ffO:LinearVectorForce", &param0, &param1, &param2, &param3, &param4)) {
          LinearVectorForce *return_value = new LinearVectorForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LinearVectorForce::LinearVectorForce(LVector3 const &vec, PN_stdfloat a = 1.0, bool mass = false)
        PyObject *param0;
        float param1;
        PyObject *param2 = Py_False;
        if (PyArg_ParseTuple(args, "Of|O:LinearVectorForce", &param0, &param1, &param2)) {
          LVector3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LinearVectorForce *return_value = new LinearVectorForce(*param0_this, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LinearVectorForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LinearVectorForce) {
    printf("LinearVectorForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LinearVectorForce *local_this = (LinearVectorForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LinearVectorForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LinearVectorForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LinearVectorForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearVectorForce*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PhysicsCollisionHandler
 */
/**
 * Python function wrapper for:
 * inline void PhysicsCollisionHandler::set_almost_stationary_speed(PN_stdfloat speed)
 */
static PyObject *Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_230(PyObject *self, PyObject *arg) {
  PhysicsCollisionHandler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.set_almost_stationary_speed")) {
    return NULL;
  }
  // 1-inline void PhysicsCollisionHandler::set_almost_stationary_speed(PN_stdfloat speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_almost_stationary_speed((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_almost_stationary_speed(const PhysicsCollisionHandler self, float speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_230_comment =
  "C++ Interface:\n"
  "set_almost_stationary_speed(const PhysicsCollisionHandler self, float speed)\n"
  "\n"
  "// These setters and getter are a bit of a hack:";
#else
static const char *Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsCollisionHandler::get_almost_stationary_speed(void)
 */
static PyObject *Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_231(PyObject *self, PyObject *) {
  PhysicsCollisionHandler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.get_almost_stationary_speed")) {
    return NULL;
  }
  // 1-inline PN_stdfloat PhysicsCollisionHandler::get_almost_stationary_speed(void)
  PN_stdfloat return_value = (*local_this).get_almost_stationary_speed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_231_comment =
  "C++ Interface:\n"
  "get_almost_stationary_speed(const PhysicsCollisionHandler self)\n";
#else
static const char *Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCollisionHandler::set_static_friction_coef(PN_stdfloat coef)
 */
static PyObject *Dtool_PhysicsCollisionHandler_set_static_friction_coef_232(PyObject *self, PyObject *arg) {
  PhysicsCollisionHandler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.set_static_friction_coef")) {
    return NULL;
  }
  // 1-inline void PhysicsCollisionHandler::set_static_friction_coef(PN_stdfloat coef)
  if (PyNumber_Check(arg)) {
    (*local_this).set_static_friction_coef((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_static_friction_coef(const PhysicsCollisionHandler self, float coef)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_set_static_friction_coef_232_comment =
  "C++ Interface:\n"
  "set_static_friction_coef(const PhysicsCollisionHandler self, float coef)\n";
#else
static const char *Dtool_PhysicsCollisionHandler_set_static_friction_coef_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsCollisionHandler::get_static_friction_coef(void)
 */
static PyObject *Dtool_PhysicsCollisionHandler_get_static_friction_coef_233(PyObject *self, PyObject *) {
  PhysicsCollisionHandler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.get_static_friction_coef")) {
    return NULL;
  }
  // 1-inline PN_stdfloat PhysicsCollisionHandler::get_static_friction_coef(void)
  PN_stdfloat return_value = (*local_this).get_static_friction_coef();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_get_static_friction_coef_233_comment =
  "C++ Interface:\n"
  "get_static_friction_coef(const PhysicsCollisionHandler self)\n";
#else
static const char *Dtool_PhysicsCollisionHandler_get_static_friction_coef_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCollisionHandler::set_dynamic_friction_coef(PN_stdfloat coef)
 */
static PyObject *Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_234(PyObject *self, PyObject *arg) {
  PhysicsCollisionHandler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.set_dynamic_friction_coef")) {
    return NULL;
  }
  // 1-inline void PhysicsCollisionHandler::set_dynamic_friction_coef(PN_stdfloat coef)
  if (PyNumber_Check(arg)) {
    (*local_this).set_dynamic_friction_coef((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dynamic_friction_coef(const PhysicsCollisionHandler self, float coef)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_234_comment =
  "C++ Interface:\n"
  "set_dynamic_friction_coef(const PhysicsCollisionHandler self, float coef)\n";
#else
static const char *Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsCollisionHandler::get_dynamic_friction_coef(void)
 */
static PyObject *Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_235(PyObject *self, PyObject *) {
  PhysicsCollisionHandler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.get_dynamic_friction_coef")) {
    return NULL;
  }
  // 1-inline PN_stdfloat PhysicsCollisionHandler::get_dynamic_friction_coef(void)
  PN_stdfloat return_value = (*local_this).get_dynamic_friction_coef();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_235_comment =
  "C++ Interface:\n"
  "get_dynamic_friction_coef(const PhysicsCollisionHandler self)\n";
#else
static const char *Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_235_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PhysicsCollisionHandler::get_class_type(void)
 */
static PyObject *Dtool_PhysicsCollisionHandler_get_class_type_236(PyObject *, PyObject *) {
  // 1-static TypeHandle PhysicsCollisionHandler::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PhysicsCollisionHandler::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_get_class_type_236_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PhysicsCollisionHandler_get_class_type_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PhysicsCollisionHandler::PhysicsCollisionHandler(void)
 */
static int Dtool_Init_PhysicsCollisionHandler(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PhysicsCollisionHandler() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-PhysicsCollisionHandler::PhysicsCollisionHandler(void)
  PhysicsCollisionHandler *return_value = new PhysicsCollisionHandler();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsCollisionHandler, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PhysicsCollisionHandler()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PhysicsCollisionHandler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PhysicsCollisionHandler) {
    printf("PhysicsCollisionHandler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PhysicsCollisionHandler *local_this = (PhysicsCollisionHandler *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PhysicsCollisionHandler) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return (CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPusher) {
    return (CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PhysicsCollisionHandler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PhysicsCollisionHandler) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPusher) {
    CollisionHandlerPusher* other_this = (CollisionHandlerPusher*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PhysicsManager
 */
/**
 * Python function wrapper for:
 * inline void PhysicsManager::attach_linear_integrator(LinearIntegrator *i)
 */
static PyObject *Dtool_PhysicsManager_attach_linear_integrator_240(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.attach_linear_integrator")) {
    return NULL;
  }
  // 1-inline void PhysicsManager::attach_linear_integrator(LinearIntegrator *i)
  LinearIntegrator *arg_this = (LinearIntegrator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearIntegrator, 1, "PhysicsManager.attach_linear_integrator", false, true);
  if (arg_this != NULL) {
    (*local_this).attach_linear_integrator(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_linear_integrator(const PhysicsManager self, LinearIntegrator i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_attach_linear_integrator_240_comment =
  "C++ Interface:\n"
  "attach_linear_integrator(const PhysicsManager self, LinearIntegrator i)\n"
  "\n"
  "/**\n"
  " * Hooks a linear integrator into the manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_attach_linear_integrator_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::attach_angular_integrator(AngularIntegrator *i)
 */
static PyObject *Dtool_PhysicsManager_attach_angular_integrator_241(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.attach_angular_integrator")) {
    return NULL;
  }
  // 1-inline void PhysicsManager::attach_angular_integrator(AngularIntegrator *i)
  AngularIntegrator *arg_this = (AngularIntegrator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AngularIntegrator, 1, "PhysicsManager.attach_angular_integrator", false, true);
  if (arg_this != NULL) {
    (*local_this).attach_angular_integrator(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_angular_integrator(const PhysicsManager self, AngularIntegrator i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_attach_angular_integrator_241_comment =
  "C++ Interface:\n"
  "attach_angular_integrator(const PhysicsManager self, AngularIntegrator i)\n"
  "\n"
  "/**\n"
  " * Hooks an angular integrator into the manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_attach_angular_integrator_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::attach_physical(Physical *p)
 */
static PyObject *Dtool_PhysicsManager_attach_physical_242(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.attach_physical")) {
    return NULL;
  }
  // 1-inline void PhysicsManager::attach_physical(Physical *p)
  PT(Physical) arg_this;
  if (!Dtool_Coerce_Physical(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsManager.attach_physical", "Physical");
  }
  (*local_this).attach_physical(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_physical(const PhysicsManager self, Physical p)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_attach_physical_242_comment =
  "C++ Interface:\n"
  "attach_physical(const PhysicsManager self, Physical p)\n"
  "\n"
  "/**\n"
  " * Registers a Physical class with the manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_attach_physical_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::attach_physicalnode(PhysicalNode *p)
 */
static PyObject *Dtool_PhysicsManager_attach_physicalnode_243(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.attach_physicalnode")) {
    return NULL;
  }
  // 1-inline void PhysicsManager::attach_physicalnode(PhysicalNode *p)
  PT(PhysicalNode) arg_this;
  if (!Dtool_Coerce_PhysicalNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsManager.attach_physicalnode", "PhysicalNode");
  }
  (*local_this).attach_physicalnode(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_physicalnode(const PhysicsManager self, PhysicalNode p)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_attach_physicalnode_243_comment =
  "C++ Interface:\n"
  "attach_physicalnode(const PhysicsManager self, PhysicalNode p)\n"
  "\n"
  "// use attach_physical_node instead.\n"
  "\n"
  "/**\n"
  " * Please call attach_physical_node instead.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_attach_physicalnode_243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::attach_physical_node(PhysicalNode *p)
 */
static PyObject *Dtool_PhysicsManager_attach_physical_node_244(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.attach_physical_node")) {
    return NULL;
  }
  // 1-inline void PhysicsManager::attach_physical_node(PhysicalNode *p)
  PT(PhysicalNode) arg_this;
  if (!Dtool_Coerce_PhysicalNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsManager.attach_physical_node", "PhysicalNode");
  }
  (*local_this).attach_physical_node(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_physical_node(const PhysicsManager self, PhysicalNode p)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_attach_physical_node_244_comment =
  "C++ Interface:\n"
  "attach_physical_node(const PhysicsManager self, PhysicalNode p)\n"
  "\n"
  "// use attach_physical_node instead.\n"
  "\n"
  "/**\n"
  " * Registers a physicalnode with the manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_attach_physical_node_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::add_linear_force(LinearForce *f)
 */
static PyObject *Dtool_PhysicsManager_add_linear_force_245(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.add_linear_force")) {
    return NULL;
  }
  // 1-inline void PhysicsManager::add_linear_force(LinearForce *f)
  LinearForce *arg_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearForce, 1, "PhysicsManager.add_linear_force", false, true);
  if (arg_this != NULL) {
    (*local_this).add_linear_force(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_linear_force(const PhysicsManager self, LinearForce f)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_add_linear_force_245_comment =
  "C++ Interface:\n"
  "add_linear_force(const PhysicsManager self, LinearForce f)\n"
  "\n"
  "/**\n"
  " * Adds a global linear force to the physics manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_add_linear_force_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::add_angular_force(AngularForce *f)
 */
static PyObject *Dtool_PhysicsManager_add_angular_force_246(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.add_angular_force")) {
    return NULL;
  }
  // 1-inline void PhysicsManager::add_angular_force(AngularForce *f)
  AngularForce *arg_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AngularForce, 1, "PhysicsManager.add_angular_force", false, true);
  if (arg_this != NULL) {
    (*local_this).add_angular_force(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_angular_force(const PhysicsManager self, AngularForce f)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_add_angular_force_246_comment =
  "C++ Interface:\n"
  "add_angular_force(const PhysicsManager self, AngularForce f)\n"
  "\n"
  "/**\n"
  " * Adds a global angular force to the physics manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_add_angular_force_246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::clear_linear_forces(void)
 */
static PyObject *Dtool_PhysicsManager_clear_linear_forces_247(PyObject *self, PyObject *) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.clear_linear_forces")) {
    return NULL;
  }
  // 1-inline void PhysicsManager::clear_linear_forces(void)
  (*local_this).clear_linear_forces();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_clear_linear_forces_247_comment =
  "C++ Interface:\n"
  "clear_linear_forces(const PhysicsManager self)\n"
  "\n"
  "/**\n"
  " * Resets the physics manager force vector\n"
  " */";
#else
static const char *Dtool_PhysicsManager_clear_linear_forces_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::clear_angular_forces(void)
 */
static PyObject *Dtool_PhysicsManager_clear_angular_forces_248(PyObject *self, PyObject *) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.clear_angular_forces")) {
    return NULL;
  }
  // 1-inline void PhysicsManager::clear_angular_forces(void)
  (*local_this).clear_angular_forces();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_clear_angular_forces_248_comment =
  "C++ Interface:\n"
  "clear_angular_forces(const PhysicsManager self)\n"
  "\n"
  "/**\n"
  " * Resets the physics manager force vector\n"
  " */";
#else
static const char *Dtool_PhysicsManager_clear_angular_forces_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::clear_physicals(void)
 */
static PyObject *Dtool_PhysicsManager_clear_physicals_249(PyObject *self, PyObject *) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.clear_physicals")) {
    return NULL;
  }
  // 1-inline void PhysicsManager::clear_physicals(void)
  (*local_this).clear_physicals();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_clear_physicals_249_comment =
  "C++ Interface:\n"
  "clear_physicals(const PhysicsManager self)\n"
  "\n"
  "/**\n"
  " * Resets the physics manager objects vector\n"
  " */";
#else
static const char *Dtool_PhysicsManager_clear_physicals_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::set_viscosity(PN_stdfloat viscosity)
 */
static PyObject *Dtool_PhysicsManager_set_viscosity_250(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.set_viscosity")) {
    return NULL;
  }
  // 1-inline void PhysicsManager::set_viscosity(PN_stdfloat viscosity)
  if (PyNumber_Check(arg)) {
    (*local_this).set_viscosity((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_viscosity(const PhysicsManager self, float viscosity)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_set_viscosity_250_comment =
  "C++ Interface:\n"
  "set_viscosity(const PhysicsManager self, float viscosity)\n"
  "\n"
  "/**\n"
  " * Set the global viscosity.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_set_viscosity_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsManager::get_viscosity(void) const
 */
static PyObject *Dtool_PhysicsManager_get_viscosity_251(PyObject *self, PyObject *) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat PhysicsManager::get_viscosity(void) const
  PN_stdfloat return_value = (*(const PhysicsManager*)local_this).get_viscosity();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_get_viscosity_251_comment =
  "C++ Interface:\n"
  "get_viscosity(PhysicsManager self)\n"
  "\n"
  "/**\n"
  " * Get the global viscosity.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_get_viscosity_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::remove_physical(Physical *p)
 */
static PyObject *Dtool_PhysicsManager_remove_physical_252(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.remove_physical")) {
    return NULL;
  }
  // 1-void PhysicsManager::remove_physical(Physical *p)
  PT(Physical) arg_this;
  if (!Dtool_Coerce_Physical(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsManager.remove_physical", "Physical");
  }
  (*local_this).remove_physical(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_physical(const PhysicsManager self, Physical p)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_remove_physical_252_comment =
  "C++ Interface:\n"
  "remove_physical(const PhysicsManager self, Physical p)\n"
  "\n"
  "/**\n"
  " * takes a physical out of the object list\n"
  " */";
#else
static const char *Dtool_PhysicsManager_remove_physical_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::remove_physical_node(PhysicalNode *p)
 */
static PyObject *Dtool_PhysicsManager_remove_physical_node_253(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.remove_physical_node")) {
    return NULL;
  }
  // 1-void PhysicsManager::remove_physical_node(PhysicalNode *p)
  PT(PhysicalNode) arg_this;
  if (!Dtool_Coerce_PhysicalNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsManager.remove_physical_node", "PhysicalNode");
  }
  (*local_this).remove_physical_node(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_physical_node(const PhysicsManager self, PhysicalNode p)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_remove_physical_node_253_comment =
  "C++ Interface:\n"
  "remove_physical_node(const PhysicsManager self, PhysicalNode p)\n"
  "\n"
  "/**\n"
  " * Removes a physicalnode from the manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_remove_physical_node_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::remove_linear_force(LinearForce *f)
 */
static PyObject *Dtool_PhysicsManager_remove_linear_force_254(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.remove_linear_force")) {
    return NULL;
  }
  // 1-void PhysicsManager::remove_linear_force(LinearForce *f)
  LinearForce *arg_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearForce, 1, "PhysicsManager.remove_linear_force", false, true);
  if (arg_this != NULL) {
    (*local_this).remove_linear_force(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_linear_force(const PhysicsManager self, LinearForce f)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_remove_linear_force_254_comment =
  "C++ Interface:\n"
  "remove_linear_force(const PhysicsManager self, LinearForce f)\n"
  "\n"
  "/**\n"
  " * takes a linear force out of the physics list\n"
  " */";
#else
static const char *Dtool_PhysicsManager_remove_linear_force_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::remove_angular_force(AngularForce *f)
 */
static PyObject *Dtool_PhysicsManager_remove_angular_force_255(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.remove_angular_force")) {
    return NULL;
  }
  // 1-void PhysicsManager::remove_angular_force(AngularForce *f)
  AngularForce *arg_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AngularForce, 1, "PhysicsManager.remove_angular_force", false, true);
  if (arg_this != NULL) {
    (*local_this).remove_angular_force(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_angular_force(const PhysicsManager self, AngularForce f)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_remove_angular_force_255_comment =
  "C++ Interface:\n"
  "remove_angular_force(const PhysicsManager self, AngularForce f)\n"
  "\n"
  "/**\n"
  " * takes an angular force out of the physics list\n"
  " */";
#else
static const char *Dtool_PhysicsManager_remove_angular_force_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::do_physics(PN_stdfloat dt)
 * void PhysicsManager::do_physics(PN_stdfloat dt, Physical *p)
 */
static PyObject *Dtool_PhysicsManager_do_physics_256(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.do_physics")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "dt");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'dt' (pos 1) not found");
      }
      // 1-void PhysicsManager::do_physics(PN_stdfloat dt)
      if (PyNumber_Check(arg)) {
        (*local_this).do_physics((PN_stdfloat)PyFloat_AsDouble(arg));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void PhysicsManager::do_physics(PN_stdfloat dt, Physical *p)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"dt", "p", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:do_physics", (char **)keyword_list, &param1, &param2)) {
        PT(Physical) param2_this;
        if (!Dtool_Coerce_Physical(param2, param2_this)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "PhysicsManager.do_physics", "Physical");
        }
        (*local_this).do_physics((PN_stdfloat)param1, MOVE(param2_this));
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "do_physics() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "do_physics(const PhysicsManager self, float dt)\n"
      "do_physics(const PhysicsManager self, float dt, Physical p)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_do_physics_256_comment =
  "C++ Interface:\n"
  "do_physics(const PhysicsManager self, float dt)\n"
  "do_physics(const PhysicsManager self, float dt, Physical p)\n"
  "\n"
  "/**\n"
  " * This is the main high-level API call.  Performs integration on every\n"
  " * attached Physical.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This is the main high-level API call.  Performs integration on a single\n"
  " * physical.  Make sure its associated forces are active.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_do_physics_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::init_random_seed(void)
 */
static PyObject *Dtool_PhysicsManager_init_random_seed_257(PyObject *self, PyObject *) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.init_random_seed")) {
    return NULL;
  }
  // 1-void PhysicsManager::init_random_seed(void)
  (*local_this).init_random_seed();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_init_random_seed_257_comment =
  "C++ Interface:\n"
  "init_random_seed(const PhysicsManager self)\n"
  "\n"
  "/**\n"
  " * One-time config function, sets up the random seed used by the physics and\n"
  " * particle systems.  For synchronizing across distributed computers\n"
  " */";
#else
static const char *Dtool_PhysicsManager_init_random_seed_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::output(ostream &out) const
 */
static PyObject *Dtool_PhysicsManager_output_258(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PhysicsManager::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PhysicsManager.output", false, true);
  if (arg_this != NULL) {
    (*(const PhysicsManager*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PhysicsManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_output_258_comment =
  "C++ Interface:\n"
  "output(PhysicsManager self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_output_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::write_physicals(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_PhysicsManager_write_physicals_259(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PhysicsManager::write_physicals(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write_physicals", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PhysicsManager.write_physicals", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const PhysicsManager*)local_this).write_physicals(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_physicals(PhysicsManager self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_write_physicals_259_comment =
  "C++ Interface:\n"
  "write_physicals(PhysicsManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_write_physicals_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::write_linear_forces(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_PhysicsManager_write_linear_forces_260(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PhysicsManager::write_linear_forces(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write_linear_forces", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PhysicsManager.write_linear_forces", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const PhysicsManager*)local_this).write_linear_forces(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_linear_forces(PhysicsManager self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_write_linear_forces_260_comment =
  "C++ Interface:\n"
  "write_linear_forces(PhysicsManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_write_linear_forces_260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::write_angular_forces(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_PhysicsManager_write_angular_forces_261(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PhysicsManager::write_angular_forces(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write_angular_forces", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PhysicsManager.write_angular_forces", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const PhysicsManager*)local_this).write_angular_forces(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_angular_forces(PhysicsManager self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_write_angular_forces_261_comment =
  "C++ Interface:\n"
  "write_angular_forces(PhysicsManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_write_angular_forces_261_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::write(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_PhysicsManager_write_262(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PhysicsManager::write(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PhysicsManager.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const PhysicsManager*)local_this).write(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PhysicsManager self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_write_262_comment =
  "C++ Interface:\n"
  "write(PhysicsManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_write_262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::debug_output(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_PhysicsManager_debug_output_263(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void PhysicsManager::debug_output(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:debug_output", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "PhysicsManager.debug_output", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const PhysicsManager*)local_this).debug_output(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "debug_output(PhysicsManager self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_debug_output_263_comment =
  "C++ Interface:\n"
  "debug_output(PhysicsManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_debug_output_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PhysicsManager::PhysicsManager(void)
 * inline PhysicsManager::PhysicsManager(PhysicsManager const &) = default
 */
static int Dtool_Init_PhysicsManager(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PhysicsManager::PhysicsManager(void)
      PhysicsManager *return_value = new PhysicsManager();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsManager, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline PhysicsManager::PhysicsManager(PhysicsManager const &) = default
      PhysicsManager const *arg_this = (PhysicsManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsManager, 0, "PhysicsManager.PhysicsManager", true, true);
      if (arg_this != NULL) {
        PhysicsManager *return_value = new PhysicsManager(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsManager, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PhysicsManager() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PhysicsManager()\n"
      "PhysicsManager(const PhysicsManager param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PhysicsManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PhysicsManager) {
    printf("PhysicsManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PhysicsManager *local_this = (PhysicsManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PhysicsManager) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PhysicsManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PhysicsManager) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for PhysicsObject (PhysicsObject)
 */
static PyMethodDef Dtool_Methods_PhysicsObject[] = {
  {"assign", &Dtool_PhysicsObject_operator_4, METH_O, (const char *)Dtool_PhysicsObject_operator_4_comment},
  {"set_active", &Dtool_PhysicsObject_set_active_5, METH_O, (const char *)Dtool_PhysicsObject_set_active_5_comment},
  {"setActive", &Dtool_PhysicsObject_set_active_5, METH_O, (const char *)Dtool_PhysicsObject_set_active_5_comment},
  {"get_active", &Dtool_PhysicsObject_get_active_6, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_active_6_comment},
  {"getActive", &Dtool_PhysicsObject_get_active_6, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_active_6_comment},
  {"set_mass", &Dtool_PhysicsObject_set_mass_7, METH_O, (const char *)Dtool_PhysicsObject_set_mass_7_comment},
  {"setMass", &Dtool_PhysicsObject_set_mass_7, METH_O, (const char *)Dtool_PhysicsObject_set_mass_7_comment},
  {"get_mass", &Dtool_PhysicsObject_get_mass_8, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_mass_8_comment},
  {"getMass", &Dtool_PhysicsObject_get_mass_8, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_mass_8_comment},
  {"set_position", (PyCFunction) &Dtool_PhysicsObject_set_position_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_set_position_9_comment},
  {"setPosition", (PyCFunction) &Dtool_PhysicsObject_set_position_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_set_position_9_comment},
  {"get_position", &Dtool_PhysicsObject_get_position_10, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_position_10_comment},
  {"getPosition", &Dtool_PhysicsObject_get_position_10, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_position_10_comment},
  {"reset_position", &Dtool_PhysicsObject_reset_position_11, METH_O, (const char *)Dtool_PhysicsObject_reset_position_11_comment},
  {"resetPosition", &Dtool_PhysicsObject_reset_position_11, METH_O, (const char *)Dtool_PhysicsObject_reset_position_11_comment},
  {"set_last_position", &Dtool_PhysicsObject_set_last_position_12, METH_O, (const char *)Dtool_PhysicsObject_set_last_position_12_comment},
  {"setLastPosition", &Dtool_PhysicsObject_set_last_position_12, METH_O, (const char *)Dtool_PhysicsObject_set_last_position_12_comment},
  {"get_last_position", &Dtool_PhysicsObject_get_last_position_13, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_last_position_13_comment},
  {"getLastPosition", &Dtool_PhysicsObject_get_last_position_13, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_last_position_13_comment},
  {"set_velocity", (PyCFunction) &Dtool_PhysicsObject_set_velocity_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_set_velocity_14_comment},
  {"setVelocity", (PyCFunction) &Dtool_PhysicsObject_set_velocity_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_set_velocity_14_comment},
  {"get_velocity", &Dtool_PhysicsObject_get_velocity_15, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_velocity_15_comment},
  {"getVelocity", &Dtool_PhysicsObject_get_velocity_15, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_velocity_15_comment},
  {"get_implicit_velocity", &Dtool_PhysicsObject_get_implicit_velocity_16, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_implicit_velocity_16_comment},
  {"getImplicitVelocity", &Dtool_PhysicsObject_get_implicit_velocity_16, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_implicit_velocity_16_comment},
  {"add_torque", &Dtool_PhysicsObject_add_torque_17, METH_O, (const char *)Dtool_PhysicsObject_add_torque_17_comment},
  {"addTorque", &Dtool_PhysicsObject_add_torque_17, METH_O, (const char *)Dtool_PhysicsObject_add_torque_17_comment},
  {"add_impulse", &Dtool_PhysicsObject_add_impulse_18, METH_O, (const char *)Dtool_PhysicsObject_add_impulse_18_comment},
  {"addImpulse", &Dtool_PhysicsObject_add_impulse_18, METH_O, (const char *)Dtool_PhysicsObject_add_impulse_18_comment},
  {"add_impact", (PyCFunction) &Dtool_PhysicsObject_add_impact_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_add_impact_19_comment},
  {"addImpact", (PyCFunction) &Dtool_PhysicsObject_add_impact_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_add_impact_19_comment},
  {"add_local_torque", &Dtool_PhysicsObject_add_local_torque_20, METH_O, (const char *)Dtool_PhysicsObject_add_local_torque_20_comment},
  {"addLocalTorque", &Dtool_PhysicsObject_add_local_torque_20, METH_O, (const char *)Dtool_PhysicsObject_add_local_torque_20_comment},
  {"add_local_impulse", &Dtool_PhysicsObject_add_local_impulse_21, METH_O, (const char *)Dtool_PhysicsObject_add_local_impulse_21_comment},
  {"addLocalImpulse", &Dtool_PhysicsObject_add_local_impulse_21, METH_O, (const char *)Dtool_PhysicsObject_add_local_impulse_21_comment},
  {"add_local_impact", (PyCFunction) &Dtool_PhysicsObject_add_local_impact_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_add_local_impact_22_comment},
  {"addLocalImpact", (PyCFunction) &Dtool_PhysicsObject_add_local_impact_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_add_local_impact_22_comment},
  {"set_terminal_velocity", &Dtool_PhysicsObject_set_terminal_velocity_23, METH_O, (const char *)Dtool_PhysicsObject_set_terminal_velocity_23_comment},
  {"setTerminalVelocity", &Dtool_PhysicsObject_set_terminal_velocity_23, METH_O, (const char *)Dtool_PhysicsObject_set_terminal_velocity_23_comment},
  {"get_terminal_velocity", &Dtool_PhysicsObject_get_terminal_velocity_24, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_terminal_velocity_24_comment},
  {"getTerminalVelocity", &Dtool_PhysicsObject_get_terminal_velocity_24, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_terminal_velocity_24_comment},
  {"set_oriented", &Dtool_PhysicsObject_set_oriented_25, METH_O, (const char *)Dtool_PhysicsObject_set_oriented_25_comment},
  {"setOriented", &Dtool_PhysicsObject_set_oriented_25, METH_O, (const char *)Dtool_PhysicsObject_set_oriented_25_comment},
  {"get_oriented", &Dtool_PhysicsObject_get_oriented_26, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_oriented_26_comment},
  {"getOriented", &Dtool_PhysicsObject_get_oriented_26, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_oriented_26_comment},
  {"set_orientation", &Dtool_PhysicsObject_set_orientation_27, METH_O, (const char *)Dtool_PhysicsObject_set_orientation_27_comment},
  {"setOrientation", &Dtool_PhysicsObject_set_orientation_27, METH_O, (const char *)Dtool_PhysicsObject_set_orientation_27_comment},
  {"get_orientation", &Dtool_PhysicsObject_get_orientation_28, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_orientation_28_comment},
  {"getOrientation", &Dtool_PhysicsObject_get_orientation_28, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_orientation_28_comment},
  {"reset_orientation", &Dtool_PhysicsObject_reset_orientation_29, METH_O, (const char *)Dtool_PhysicsObject_reset_orientation_29_comment},
  {"resetOrientation", &Dtool_PhysicsObject_reset_orientation_29, METH_O, (const char *)Dtool_PhysicsObject_reset_orientation_29_comment},
  {"set_rotation", &Dtool_PhysicsObject_set_rotation_30, METH_O, (const char *)Dtool_PhysicsObject_set_rotation_30_comment},
  {"setRotation", &Dtool_PhysicsObject_set_rotation_30, METH_O, (const char *)Dtool_PhysicsObject_set_rotation_30_comment},
  {"get_rotation", &Dtool_PhysicsObject_get_rotation_31, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_rotation_31_comment},
  {"getRotation", &Dtool_PhysicsObject_get_rotation_31, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_rotation_31_comment},
  {"get_inertial_tensor", &Dtool_PhysicsObject_get_inertial_tensor_32, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_inertial_tensor_32_comment},
  {"getInertialTensor", &Dtool_PhysicsObject_get_inertial_tensor_32, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_inertial_tensor_32_comment},
  {"get_lcs", &Dtool_PhysicsObject_get_lcs_33, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_lcs_33_comment},
  {"getLcs", &Dtool_PhysicsObject_get_lcs_33, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_lcs_33_comment},
  {"make_copy", &Dtool_PhysicsObject_make_copy_34, METH_NOARGS, (const char *)Dtool_PhysicsObject_make_copy_34_comment},
  {"makeCopy", &Dtool_PhysicsObject_make_copy_34, METH_NOARGS, (const char *)Dtool_PhysicsObject_make_copy_34_comment},
  {"set_name", &Dtool_PhysicsObject_set_name_35, METH_O, (const char *)Dtool_PhysicsObject_set_name_35_comment},
  {"setName", &Dtool_PhysicsObject_set_name_35, METH_O, (const char *)Dtool_PhysicsObject_set_name_35_comment},
  {"get_name", &Dtool_PhysicsObject_get_name_36, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_name_36_comment},
  {"getName", &Dtool_PhysicsObject_get_name_36, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_name_36_comment},
  {"output", &Dtool_PhysicsObject_output_37, METH_O, (const char *)Dtool_PhysicsObject_output_37_comment},
  {"write", (PyCFunction) &Dtool_PhysicsObject_write_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_write_38_comment},
  {"get_class_type", &Dtool_PhysicsObject_get_class_type_39, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicsObject_get_class_type_39_comment},
  {"getClassType", &Dtool_PhysicsObject_get_class_type_39, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicsObject_get_class_type_39_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PhysicsObject
//////////////////
static PyObject *Dtool_Repr_PhysicsObject(PyObject *self) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     PhysicsObject
//////////////////
static PyObject *Dtool_Str_PhysicsObject(PyObject *self) {
  PhysicsObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PhysicsObject = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PhysicsObject = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PhysicsObject = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PhysicsObject = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PhysicsObject = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.PhysicsObject",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PhysicsObject,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PhysicsObject,
    &Dtool_NumberMethods_PhysicsObject,
    &Dtool_SequenceMethods_PhysicsObject,
    &Dtool_MappingMethods_PhysicsObject,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_PhysicsObject,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PhysicsObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A body on which physics will be applied.  If you're looking to add physical\n"
    " * motion to your class, do NOT derive from this.  Derive from Physical\n"
    " * instead.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PhysicsObject,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PhysicsObject,
    PyType_GenericAlloc,
    Dtool_new_PhysicsObject,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PhysicsObject,
  Dtool_UpcastInterface_PhysicsObject,
  Dtool_DowncastInterface_PhysicsObject,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PhysicsObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_PhysicsObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_PhysicsObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PhysicsObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PhysicsObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PhysicsObject);
  }
}

/**
 * Python method tables for PhysicsObjectCollection (PhysicsObjectCollection)
 */
static PyMethodDef Dtool_Methods_PhysicsObjectCollection[] = {
  {"assign", &Dtool_PhysicsObjectCollection_operator_42, METH_O, (const char *)Dtool_PhysicsObjectCollection_operator_42_comment},
  {"add_physics_object", &Dtool_PhysicsObjectCollection_add_physics_object_44, METH_O, (const char *)Dtool_PhysicsObjectCollection_add_physics_object_44_comment},
  {"addPhysicsObject", &Dtool_PhysicsObjectCollection_add_physics_object_44, METH_O, (const char *)Dtool_PhysicsObjectCollection_add_physics_object_44_comment},
  {"remove_physics_object", &Dtool_PhysicsObjectCollection_remove_physics_object_45, METH_O, (const char *)Dtool_PhysicsObjectCollection_remove_physics_object_45_comment},
  {"removePhysicsObject", &Dtool_PhysicsObjectCollection_remove_physics_object_45, METH_O, (const char *)Dtool_PhysicsObjectCollection_remove_physics_object_45_comment},
  {"add_physics_objects_from", &Dtool_PhysicsObjectCollection_add_physics_objects_from_46, METH_O, (const char *)Dtool_PhysicsObjectCollection_add_physics_objects_from_46_comment},
  {"addPhysicsObjectsFrom", &Dtool_PhysicsObjectCollection_add_physics_objects_from_46, METH_O, (const char *)Dtool_PhysicsObjectCollection_add_physics_objects_from_46_comment},
  {"remove_physics_objects_from", &Dtool_PhysicsObjectCollection_remove_physics_objects_from_47, METH_O, (const char *)Dtool_PhysicsObjectCollection_remove_physics_objects_from_47_comment},
  {"removePhysicsObjectsFrom", &Dtool_PhysicsObjectCollection_remove_physics_objects_from_47, METH_O, (const char *)Dtool_PhysicsObjectCollection_remove_physics_objects_from_47_comment},
  {"remove_duplicate_physics_objects", &Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48_comment},
  {"removeDuplicatePhysicsObjects", &Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48_comment},
  {"has_physics_object", &Dtool_PhysicsObjectCollection_has_physics_object_49, METH_O, (const char *)Dtool_PhysicsObjectCollection_has_physics_object_49_comment},
  {"hasPhysicsObject", &Dtool_PhysicsObjectCollection_has_physics_object_49, METH_O, (const char *)Dtool_PhysicsObjectCollection_has_physics_object_49_comment},
  {"clear", &Dtool_PhysicsObjectCollection_clear_50, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_clear_50_comment},
  {"is_empty", &Dtool_PhysicsObjectCollection_is_empty_51, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_is_empty_51_comment},
  {"isEmpty", &Dtool_PhysicsObjectCollection_is_empty_51, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_is_empty_51_comment},
  {"get_num_physics_objects", &Dtool_PhysicsObjectCollection_get_num_physics_objects_52, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_get_num_physics_objects_52_comment},
  {"getNumPhysicsObjects", &Dtool_PhysicsObjectCollection_get_num_physics_objects_52, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_get_num_physics_objects_52_comment},
  {"get_physics_object", &Dtool_PhysicsObjectCollection_get_physics_object_53, METH_O, (const char *)Dtool_PhysicsObjectCollection_get_physics_object_53_comment},
  {"getPhysicsObject", &Dtool_PhysicsObjectCollection_get_physics_object_53, METH_O, (const char *)Dtool_PhysicsObjectCollection_get_physics_object_53_comment},
  {"output", &Dtool_PhysicsObjectCollection_output_59, METH_O, (const char *)Dtool_PhysicsObjectCollection_output_59_comment},
  {"write", (PyCFunction) &Dtool_PhysicsObjectCollection_write_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObjectCollection_write_60_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_physics_objects", (PyCFunction) &MakeSeq_PhysicsObjectCollection_get_physics_objects, METH_NOARGS, NULL},
  { "getPhysicsObjects", (PyCFunction) &MakeSeq_PhysicsObjectCollection_get_physics_objects, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PhysicsObjectCollection slot nb_add -> operator +
//////////////////
static PyObject *Dtool_PhysicsObjectCollection_operator_58_nb_add(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PhysicsObjectCollection, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline PhysicsObjectCollection PhysicsObjectCollection::operator +(PhysicsObjectCollection const &other) const
  PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 1, "PhysicsObjectCollection.__add__", true, true);
  if (arg_this != NULL) {
    PhysicsObjectCollection *return_value = new PhysicsObjectCollection((*(const PhysicsObjectCollection*)local_this).operator +(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PhysicsObjectCollection, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PhysicsObjectCollection slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_PhysicsObjectCollection_operator_57_nb_inplace_add(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PhysicsObjectCollection, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void PhysicsObjectCollection::operator +=(PhysicsObjectCollection const &other)
    PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 1, "PhysicsObjectCollection.__iadd__", true, true);
    if (arg_this != NULL) {
      (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call PhysicsObjectCollection.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PhysicsObjectCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_PhysicsObjectCollection_operator_55_sq_item(PyObject *self, Py_ssize_t index) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PhysicsObjectCollection index out of range");
    return NULL;
  }
  // 1-PointerTo< PhysicsObject > PhysicsObjectCollection::operator [](int index) const
  PointerTo< PhysicsObject > return_value = (*(const PhysicsObjectCollection*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  PhysicsObject *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PhysicsObject, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PhysicsObjectCollection self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PhysicsObjectCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PhysicsObjectCollection_size_56_sq_length(PyObject *self) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     PhysicsObjectCollection
//////////////////
static PyObject *Dtool_Repr_PhysicsObjectCollection(PyObject *self) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     PhysicsObjectCollection
//////////////////
static PyObject *Dtool_Str_PhysicsObjectCollection(PyObject *self) {
  PhysicsObjectCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PhysicsObjectCollection = {
  &Dtool_PhysicsObjectCollection_operator_58_nb_add,
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_PhysicsObjectCollection_operator_57_nb_inplace_add,
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PhysicsObjectCollection = {
  &Dtool_PhysicsObjectCollection_size_56_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PhysicsObjectCollection_operator_55_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_PhysicsObjectCollection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.PhysicsObjectCollection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PhysicsObjectCollection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PhysicsObjectCollection,
    &Dtool_NumberMethods_PhysicsObjectCollection,
    &Dtool_SequenceMethods_PhysicsObjectCollection,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_PhysicsObjectCollection,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a set of zero or more PhysicsObjects.  It's handy for returning\n"
    " * from functions that need to return multiple PhysicsObjects.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PhysicsObjectCollection,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PhysicsObjectCollection,
    PyType_GenericAlloc,
    Dtool_new_PhysicsObjectCollection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PhysicsObjectCollection,
  Dtool_UpcastInterface_PhysicsObjectCollection,
  Dtool_DowncastInterface_PhysicsObjectCollection,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PhysicsObjectCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PhysicsObjectCollection._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PhysicsObjectCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PhysicsObjectCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PhysicsObjectCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PhysicsObjectCollection);
  }
}

/**
 * Python method tables for BaseForce (BaseForce)
 */
static PyMethodDef Dtool_Methods_BaseForce[] = {
  {"get_active", &Dtool_BaseForce_get_active_62, METH_NOARGS, (const char *)Dtool_BaseForce_get_active_62_comment},
  {"getActive", &Dtool_BaseForce_get_active_62, METH_NOARGS, (const char *)Dtool_BaseForce_get_active_62_comment},
  {"set_active", &Dtool_BaseForce_set_active_63, METH_O, (const char *)Dtool_BaseForce_set_active_63_comment},
  {"setActive", &Dtool_BaseForce_set_active_63, METH_O, (const char *)Dtool_BaseForce_set_active_63_comment},
  {"is_linear", &Dtool_BaseForce_is_linear_64, METH_NOARGS, (const char *)Dtool_BaseForce_is_linear_64_comment},
  {"isLinear", &Dtool_BaseForce_is_linear_64, METH_NOARGS, (const char *)Dtool_BaseForce_is_linear_64_comment},
  {"get_force_node", &Dtool_BaseForce_get_force_node_65, METH_NOARGS, (const char *)Dtool_BaseForce_get_force_node_65_comment},
  {"getForceNode", &Dtool_BaseForce_get_force_node_65, METH_NOARGS, (const char *)Dtool_BaseForce_get_force_node_65_comment},
  {"get_force_node_path", &Dtool_BaseForce_get_force_node_path_66, METH_NOARGS, (const char *)Dtool_BaseForce_get_force_node_path_66_comment},
  {"getForceNodePath", &Dtool_BaseForce_get_force_node_path_66, METH_NOARGS, (const char *)Dtool_BaseForce_get_force_node_path_66_comment},
  {"output", &Dtool_BaseForce_output_67, METH_O, (const char *)Dtool_BaseForce_output_67_comment},
  {"write", (PyCFunction) &Dtool_BaseForce_write_68, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseForce_write_68_comment},
  {"get_class_type", &Dtool_BaseForce_get_class_type_69, METH_NOARGS | METH_STATIC, (const char *)Dtool_BaseForce_get_class_type_69_comment},
  {"getClassType", &Dtool_BaseForce_get_class_type_69, METH_NOARGS | METH_STATIC, (const char *)Dtool_BaseForce_get_class_type_69_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     BaseForce
//////////////////
static PyObject *Dtool_Repr_BaseForce(PyObject *self) {
  BaseForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseForce, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BaseForce
//////////////////
static PyObject *Dtool_Str_BaseForce(PyObject *self) {
  BaseForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseForce, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_BaseForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BaseForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BaseForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BaseForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BaseForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.BaseForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BaseForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_BaseForce,
    &Dtool_NumberMethods_BaseForce,
    &Dtool_SequenceMethods_BaseForce,
    &Dtool_MappingMethods_BaseForce,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_BaseForce,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BaseForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * pure virtual base class for all forces that could POSSIBLY exist.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BaseForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BaseForce,
    PyType_GenericAlloc,
    Dtool_new_BaseForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BaseForce,
  Dtool_UpcastInterface_BaseForce,
  Dtool_DowncastInterface_BaseForce,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_BaseForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_BaseForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_BaseForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BaseForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BaseForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BaseForce);
  }
}

/**
 * Python method tables for LinearForce (LinearForce)
 */
static PyMethodDef Dtool_Methods_LinearForce[] = {
  {"set_amplitude", &Dtool_LinearForce_set_amplitude_71, METH_O, (const char *)Dtool_LinearForce_set_amplitude_71_comment},
  {"setAmplitude", &Dtool_LinearForce_set_amplitude_71, METH_O, (const char *)Dtool_LinearForce_set_amplitude_71_comment},
  {"set_mass_dependent", &Dtool_LinearForce_set_mass_dependent_72, METH_O, (const char *)Dtool_LinearForce_set_mass_dependent_72_comment},
  {"setMassDependent", &Dtool_LinearForce_set_mass_dependent_72, METH_O, (const char *)Dtool_LinearForce_set_mass_dependent_72_comment},
  {"get_amplitude", &Dtool_LinearForce_get_amplitude_73, METH_NOARGS, (const char *)Dtool_LinearForce_get_amplitude_73_comment},
  {"getAmplitude", &Dtool_LinearForce_get_amplitude_73, METH_NOARGS, (const char *)Dtool_LinearForce_get_amplitude_73_comment},
  {"get_mass_dependent", &Dtool_LinearForce_get_mass_dependent_74, METH_NOARGS, (const char *)Dtool_LinearForce_get_mass_dependent_74_comment},
  {"getMassDependent", &Dtool_LinearForce_get_mass_dependent_74, METH_NOARGS, (const char *)Dtool_LinearForce_get_mass_dependent_74_comment},
  {"set_vector_masks", (PyCFunction) &Dtool_LinearForce_set_vector_masks_75, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearForce_set_vector_masks_75_comment},
  {"setVectorMasks", (PyCFunction) &Dtool_LinearForce_set_vector_masks_75, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearForce_set_vector_masks_75_comment},
  {"get_vector_masks", &Dtool_LinearForce_get_vector_masks_76, METH_NOARGS, (const char *)Dtool_LinearForce_get_vector_masks_76_comment},
  {"getVectorMasks", &Dtool_LinearForce_get_vector_masks_76, METH_NOARGS, (const char *)Dtool_LinearForce_get_vector_masks_76_comment},
  {"get_vector", &Dtool_LinearForce_get_vector_77, METH_O, (const char *)Dtool_LinearForce_get_vector_77_comment},
  {"getVector", &Dtool_LinearForce_get_vector_77, METH_O, (const char *)Dtool_LinearForce_get_vector_77_comment},
  {"make_copy", &Dtool_LinearForce_make_copy_78, METH_NOARGS, (const char *)Dtool_LinearForce_make_copy_78_comment},
  {"makeCopy", &Dtool_LinearForce_make_copy_78, METH_NOARGS, (const char *)Dtool_LinearForce_make_copy_78_comment},
  {"write", (PyCFunction) &Dtool_LinearForce_write_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearForce_write_79_comment},
  {"get_class_type", &Dtool_LinearForce_get_class_type_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearForce_get_class_type_80_comment},
  {"getClassType", &Dtool_LinearForce_get_class_type_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearForce_get_class_type_80_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     LinearForce
//////////////////
static PyObject *Dtool_Str_LinearForce(PyObject *self) {
  LinearForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LinearForce, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LinearForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearForce,
    &Dtool_SequenceMethods_LinearForce,
    &Dtool_MappingMethods_LinearForce,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_LinearForce,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A force that acts on a PhysicsObject by way of an Integrator.  This is a\n"
    " * pure virtual base class.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearForce,
    PyType_GenericAlloc,
    Dtool_new_LinearForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearForce,
  Dtool_UpcastInterface_LinearForce,
  Dtool_DowncastInterface_LinearForce,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LinearForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseForce(NULL);
    Dtool_LinearForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseForce);
    PyObject *dict = PyDict_New();
    Dtool_LinearForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearForce);
  }
}

/**
 * Python method tables for AngularForce (AngularForce)
 */
static PyMethodDef Dtool_Methods_AngularForce[] = {
  {"make_copy", &Dtool_AngularForce_make_copy_82, METH_NOARGS, (const char *)Dtool_AngularForce_make_copy_82_comment},
  {"makeCopy", &Dtool_AngularForce_make_copy_82, METH_NOARGS, (const char *)Dtool_AngularForce_make_copy_82_comment},
  {"get_quat", &Dtool_AngularForce_get_quat_83, METH_O, (const char *)Dtool_AngularForce_get_quat_83_comment},
  {"getQuat", &Dtool_AngularForce_get_quat_83, METH_O, (const char *)Dtool_AngularForce_get_quat_83_comment},
  {"write", (PyCFunction) &Dtool_AngularForce_write_84, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AngularForce_write_84_comment},
  {"get_class_type", &Dtool_AngularForce_get_class_type_85, METH_NOARGS | METH_STATIC, (const char *)Dtool_AngularForce_get_class_type_85_comment},
  {"getClassType", &Dtool_AngularForce_get_class_type_85, METH_NOARGS | METH_STATIC, (const char *)Dtool_AngularForce_get_class_type_85_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     AngularForce
//////////////////
static PyObject *Dtool_Str_AngularForce(PyObject *self) {
  AngularForce *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AngularForce, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AngularForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AngularForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AngularForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AngularForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AngularForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.AngularForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AngularForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AngularForce,
    &Dtool_SequenceMethods_AngularForce,
    &Dtool_MappingMethods_AngularForce,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_AngularForce,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AngularForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * pure virtual parent of all quat-based forces.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AngularForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AngularForce,
    PyType_GenericAlloc,
    Dtool_new_AngularForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AngularForce,
  Dtool_UpcastInterface_AngularForce,
  Dtool_DowncastInterface_AngularForce,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AngularForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseForce(NULL);
    Dtool_AngularForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseForce);
    PyObject *dict = PyDict_New();
    Dtool_AngularForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AngularForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AngularForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AngularForce);
  }
}

/**
 * Python method tables for Physical (Physical)
 */
static PyMethodDef Dtool_Methods_Physical[] = {
  {"get_physics_manager", &Dtool_Physical_get_physics_manager_88, METH_NOARGS, (const char *)Dtool_Physical_get_physics_manager_88_comment},
  {"getPhysicsManager", &Dtool_Physical_get_physics_manager_88, METH_NOARGS, (const char *)Dtool_Physical_get_physics_manager_88_comment},
  {"get_physical_node", &Dtool_Physical_get_physical_node_89, METH_NOARGS, (const char *)Dtool_Physical_get_physical_node_89_comment},
  {"getPhysicalNode", &Dtool_Physical_get_physical_node_89, METH_NOARGS, (const char *)Dtool_Physical_get_physical_node_89_comment},
  {"get_physical_node_path", &Dtool_Physical_get_physical_node_path_90, METH_NOARGS, (const char *)Dtool_Physical_get_physical_node_path_90_comment},
  {"getPhysicalNodePath", &Dtool_Physical_get_physical_node_path_90, METH_NOARGS, (const char *)Dtool_Physical_get_physical_node_path_90_comment},
  {"get_phys_body", &Dtool_Physical_get_phys_body_91, METH_NOARGS, (const char *)Dtool_Physical_get_phys_body_91_comment},
  {"getPhysBody", &Dtool_Physical_get_phys_body_91, METH_NOARGS, (const char *)Dtool_Physical_get_phys_body_91_comment},
  {"clear_linear_forces", &Dtool_Physical_clear_linear_forces_92, METH_NOARGS, (const char *)Dtool_Physical_clear_linear_forces_92_comment},
  {"clearLinearForces", &Dtool_Physical_clear_linear_forces_92, METH_NOARGS, (const char *)Dtool_Physical_clear_linear_forces_92_comment},
  {"clear_angular_forces", &Dtool_Physical_clear_angular_forces_93, METH_NOARGS, (const char *)Dtool_Physical_clear_angular_forces_93_comment},
  {"clearAngularForces", &Dtool_Physical_clear_angular_forces_93, METH_NOARGS, (const char *)Dtool_Physical_clear_angular_forces_93_comment},
  {"clear_physics_objects", &Dtool_Physical_clear_physics_objects_94, METH_NOARGS, (const char *)Dtool_Physical_clear_physics_objects_94_comment},
  {"clearPhysicsObjects", &Dtool_Physical_clear_physics_objects_94, METH_NOARGS, (const char *)Dtool_Physical_clear_physics_objects_94_comment},
  {"add_linear_force", &Dtool_Physical_add_linear_force_95, METH_O, (const char *)Dtool_Physical_add_linear_force_95_comment},
  {"addLinearForce", &Dtool_Physical_add_linear_force_95, METH_O, (const char *)Dtool_Physical_add_linear_force_95_comment},
  {"add_angular_force", &Dtool_Physical_add_angular_force_96, METH_O, (const char *)Dtool_Physical_add_angular_force_96_comment},
  {"addAngularForce", &Dtool_Physical_add_angular_force_96, METH_O, (const char *)Dtool_Physical_add_angular_force_96_comment},
  {"add_physics_object", &Dtool_Physical_add_physics_object_97, METH_O, (const char *)Dtool_Physical_add_physics_object_97_comment},
  {"addPhysicsObject", &Dtool_Physical_add_physics_object_97, METH_O, (const char *)Dtool_Physical_add_physics_object_97_comment},
  {"remove_linear_force", &Dtool_Physical_remove_linear_force_98, METH_O, (const char *)Dtool_Physical_remove_linear_force_98_comment},
  {"removeLinearForce", &Dtool_Physical_remove_linear_force_98, METH_O, (const char *)Dtool_Physical_remove_linear_force_98_comment},
  {"remove_angular_force", &Dtool_Physical_remove_angular_force_99, METH_O, (const char *)Dtool_Physical_remove_angular_force_99_comment},
  {"removeAngularForce", &Dtool_Physical_remove_angular_force_99, METH_O, (const char *)Dtool_Physical_remove_angular_force_99_comment},
  {"get_num_linear_forces", &Dtool_Physical_get_num_linear_forces_100, METH_NOARGS, (const char *)Dtool_Physical_get_num_linear_forces_100_comment},
  {"getNumLinearForces", &Dtool_Physical_get_num_linear_forces_100, METH_NOARGS, (const char *)Dtool_Physical_get_num_linear_forces_100_comment},
  {"get_linear_force", &Dtool_Physical_get_linear_force_101, METH_O, (const char *)Dtool_Physical_get_linear_force_101_comment},
  {"getLinearForce", &Dtool_Physical_get_linear_force_101, METH_O, (const char *)Dtool_Physical_get_linear_force_101_comment},
  {"get_num_angular_forces", &Dtool_Physical_get_num_angular_forces_103, METH_NOARGS, (const char *)Dtool_Physical_get_num_angular_forces_103_comment},
  {"getNumAngularForces", &Dtool_Physical_get_num_angular_forces_103, METH_NOARGS, (const char *)Dtool_Physical_get_num_angular_forces_103_comment},
  {"get_angular_force", &Dtool_Physical_get_angular_force_104, METH_O, (const char *)Dtool_Physical_get_angular_force_104_comment},
  {"getAngularForce", &Dtool_Physical_get_angular_force_104, METH_O, (const char *)Dtool_Physical_get_angular_force_104_comment},
  {"set_viscosity", &Dtool_Physical_set_viscosity_106, METH_O, (const char *)Dtool_Physical_set_viscosity_106_comment},
  {"setViscosity", &Dtool_Physical_set_viscosity_106, METH_O, (const char *)Dtool_Physical_set_viscosity_106_comment},
  {"get_viscosity", &Dtool_Physical_get_viscosity_107, METH_NOARGS, (const char *)Dtool_Physical_get_viscosity_107_comment},
  {"getViscosity", &Dtool_Physical_get_viscosity_107, METH_NOARGS, (const char *)Dtool_Physical_get_viscosity_107_comment},
  {"get_objects", &Dtool_Physical_get_objects_108, METH_NOARGS, (const char *)Dtool_Physical_get_objects_108_comment},
  {"getObjects", &Dtool_Physical_get_objects_108, METH_NOARGS, (const char *)Dtool_Physical_get_objects_108_comment},
  {"output", (PyCFunction) &Dtool_Physical_output_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_output_109_comment},
  {"write_physics_objects", (PyCFunction) &Dtool_Physical_write_physics_objects_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_physics_objects_110_comment},
  {"writePhysicsObjects", (PyCFunction) &Dtool_Physical_write_physics_objects_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_physics_objects_110_comment},
  {"write_linear_forces", (PyCFunction) &Dtool_Physical_write_linear_forces_111, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_linear_forces_111_comment},
  {"writeLinearForces", (PyCFunction) &Dtool_Physical_write_linear_forces_111, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_linear_forces_111_comment},
  {"write_angular_forces", (PyCFunction) &Dtool_Physical_write_angular_forces_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_angular_forces_112_comment},
  {"writeAngularForces", (PyCFunction) &Dtool_Physical_write_angular_forces_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_angular_forces_112_comment},
  {"write", (PyCFunction) &Dtool_Physical_write_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_113_comment},
  {"get_class_type", &Dtool_Physical_get_class_type_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_Physical_get_class_type_114_comment},
  {"getClassType", &Dtool_Physical_get_class_type_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_Physical_get_class_type_114_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_linear_forces", (PyCFunction) &MakeSeq_Physical_get_linear_forces, METH_NOARGS, NULL},
  { "getLinearForces", (PyCFunction) &MakeSeq_Physical_get_linear_forces, METH_NOARGS, NULL},
  {"get_angular_forces", (PyCFunction) &MakeSeq_Physical_get_angular_forces, METH_NOARGS, NULL},
  { "getAngularForces", (PyCFunction) &MakeSeq_Physical_get_angular_forces, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     Physical
//////////////////
static PyObject *Dtool_Repr_Physical(PyObject *self) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     Physical
//////////////////
static PyObject *Dtool_Str_Physical(PyObject *self) {
  Physical *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_Physical = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Physical = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Physical = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Physical = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Physical = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.Physical",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Physical,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_Physical,
    &Dtool_NumberMethods_Physical,
    &Dtool_SequenceMethods_Physical,
    &Dtool_MappingMethods_Physical,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_Physical,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Physical,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a set of physically modeled attributes.  If you want physics\n"
    " * applied to your class, derive it from this.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Physical,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Physical,
    PyType_GenericAlloc,
    Dtool_new_Physical,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Physical,
  Dtool_UpcastInterface_Physical,
  Dtool_DowncastInterface_Physical,
  (CoerceFunction)Dtool_ConstCoerce_Physical,
  (CoerceFunction)Dtool_Coerce_Physical,
};

static void Dtool_PyModuleClassInit_Physical(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_Physical._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_Physical._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Physical) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Physical)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Physical);
  }
}

/**
 * Python method tables for PhysicalNode (PhysicalNode)
 */
static PyMethodDef Dtool_Methods_PhysicalNode[] = {
  {"clear", &Dtool_PhysicalNode_clear_118, METH_NOARGS, (const char *)Dtool_PhysicalNode_clear_118_comment},
  {"get_physical", &Dtool_PhysicalNode_get_physical_119, METH_O, (const char *)Dtool_PhysicalNode_get_physical_119_comment},
  {"getPhysical", &Dtool_PhysicalNode_get_physical_119, METH_O, (const char *)Dtool_PhysicalNode_get_physical_119_comment},
  {"get_num_physicals", &Dtool_PhysicalNode_get_num_physicals_120, METH_NOARGS, (const char *)Dtool_PhysicalNode_get_num_physicals_120_comment},
  {"getNumPhysicals", &Dtool_PhysicalNode_get_num_physicals_120, METH_NOARGS, (const char *)Dtool_PhysicalNode_get_num_physicals_120_comment},
  {"add_physical", &Dtool_PhysicalNode_add_physical_122, METH_O, (const char *)Dtool_PhysicalNode_add_physical_122_comment},
  {"addPhysical", &Dtool_PhysicalNode_add_physical_122, METH_O, (const char *)Dtool_PhysicalNode_add_physical_122_comment},
  {"add_physicals_from", &Dtool_PhysicalNode_add_physicals_from_123, METH_O, (const char *)Dtool_PhysicalNode_add_physicals_from_123_comment},
  {"addPhysicalsFrom", &Dtool_PhysicalNode_add_physicals_from_123, METH_O, (const char *)Dtool_PhysicalNode_add_physicals_from_123_comment},
  {"set_physical", (PyCFunction) &Dtool_PhysicalNode_set_physical_124, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicalNode_set_physical_124_comment},
  {"setPhysical", (PyCFunction) &Dtool_PhysicalNode_set_physical_124, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicalNode_set_physical_124_comment},
  {"remove_physical", &Dtool_PhysicalNode_remove_physical_125, METH_O, (const char *)Dtool_PhysicalNode_remove_physical_125_comment},
  {"removePhysical", &Dtool_PhysicalNode_remove_physical_125, METH_O, (const char *)Dtool_PhysicalNode_remove_physical_125_comment},
  {"write", (PyCFunction) &Dtool_PhysicalNode_write_128, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicalNode_write_128_comment},
  {"get_class_type", &Dtool_PhysicalNode_get_class_type_129, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicalNode_get_class_type_129_comment},
  {"getClassType", &Dtool_PhysicalNode_get_class_type_129, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicalNode_get_class_type_129_comment},
  {"get_physicals", (PyCFunction) &MakeSeq_PhysicalNode_get_physicals, METH_NOARGS, NULL},
  { "getPhysicals", (PyCFunction) &MakeSeq_PhysicalNode_get_physicals, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     PhysicalNode
//////////////////
static PyObject *Dtool_Str_PhysicalNode(PyObject *self) {
  PhysicalNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicalNode, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PhysicalNode[] = {
  {(char *)"physicals", &Dtool_PhysicalNode_physicals_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PhysicalNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PhysicalNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PhysicalNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PhysicalNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PhysicalNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.PhysicalNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PhysicalNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PhysicalNode,
    &Dtool_SequenceMethods_PhysicalNode,
    &Dtool_MappingMethods_PhysicalNode,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_PhysicalNode,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PhysicalNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Graph node that encapsulated a series of physical objects\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PhysicalNode,
    0, // tp_members
    Dtool_Properties_PhysicalNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PhysicalNode,
    PyType_GenericAlloc,
    Dtool_new_PhysicalNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PhysicalNode,
  Dtool_UpcastInterface_PhysicalNode,
  Dtool_DowncastInterface_PhysicalNode,
  (CoerceFunction)Dtool_ConstCoerce_PhysicalNode,
  (CoerceFunction)Dtool_Coerce_PhysicalNode,
};

static void Dtool_PyModuleClassInit_PhysicalNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_PhysicalNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_PhysicalNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PhysicalNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PhysicalNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PhysicalNode);
  }
}

/**
 * Python method tables for ActorNode (ActorNode)
 */
static PyMethodDef Dtool_Methods_ActorNode[] = {
  {"get_physics_object", &Dtool_ActorNode_get_physics_object_132, METH_NOARGS, (const char *)Dtool_ActorNode_get_physics_object_132_comment},
  {"getPhysicsObject", &Dtool_ActorNode_get_physics_object_132, METH_NOARGS, (const char *)Dtool_ActorNode_get_physics_object_132_comment},
  {"set_contact_vector", &Dtool_ActorNode_set_contact_vector_133, METH_O, (const char *)Dtool_ActorNode_set_contact_vector_133_comment},
  {"setContactVector", &Dtool_ActorNode_set_contact_vector_133, METH_O, (const char *)Dtool_ActorNode_set_contact_vector_133_comment},
  {"get_contact_vector", &Dtool_ActorNode_get_contact_vector_134, METH_NOARGS, (const char *)Dtool_ActorNode_get_contact_vector_134_comment},
  {"getContactVector", &Dtool_ActorNode_get_contact_vector_134, METH_NOARGS, (const char *)Dtool_ActorNode_get_contact_vector_134_comment},
  {"update_transform", &Dtool_ActorNode_update_transform_135, METH_NOARGS, (const char *)Dtool_ActorNode_update_transform_135_comment},
  {"updateTransform", &Dtool_ActorNode_update_transform_135, METH_NOARGS, (const char *)Dtool_ActorNode_update_transform_135_comment},
  {"set_transform_limit", &Dtool_ActorNode_set_transform_limit_136, METH_O, (const char *)Dtool_ActorNode_set_transform_limit_136_comment},
  {"setTransformLimit", &Dtool_ActorNode_set_transform_limit_136, METH_O, (const char *)Dtool_ActorNode_set_transform_limit_136_comment},
  {"get_class_type", &Dtool_ActorNode_get_class_type_137, METH_NOARGS | METH_STATIC, (const char *)Dtool_ActorNode_get_class_type_137_comment},
  {"getClassType", &Dtool_ActorNode_get_class_type_137, METH_NOARGS | METH_STATIC, (const char *)Dtool_ActorNode_get_class_type_137_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ActorNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ActorNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ActorNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ActorNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ActorNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ActorNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ActorNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ActorNode,
    &Dtool_SequenceMethods_ActorNode,
    &Dtool_MappingMethods_ActorNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ActorNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Like a physical node, but with a little more.  The actornode assumes\n"
    " * responsibility for its own transform, and changes in its own PhysicsObject\n"
    " * will be reflected as transforms.  This relation goes both ways; changes in\n"
    " * the transform will update the object's position (shoves).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ActorNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ActorNode,
    PyType_GenericAlloc,
    Dtool_new_ActorNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ActorNode,
  Dtool_UpcastInterface_ActorNode,
  Dtool_DowncastInterface_ActorNode,
  (CoerceFunction)Dtool_ConstCoerce_ActorNode,
  (CoerceFunction)Dtool_Coerce_ActorNode,
};

static void Dtool_PyModuleClassInit_ActorNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PhysicalNode(NULL);
    Dtool_ActorNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PhysicalNode);
    PyObject *dict = PyDict_New();
    Dtool_ActorNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ActorNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ActorNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ActorNode);
  }
}

/**
 * Python method tables for BaseIntegrator (BaseIntegrator)
 */
static PyMethodDef Dtool_Methods_BaseIntegrator[] = {
  {"output", &Dtool_BaseIntegrator_output_140, METH_O, (const char *)Dtool_BaseIntegrator_output_140_comment},
  {"write_precomputed_linear_matrices", (PyCFunction) &Dtool_BaseIntegrator_write_precomputed_linear_matrices_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseIntegrator_write_precomputed_linear_matrices_141_comment},
  {"writePrecomputedLinearMatrices", (PyCFunction) &Dtool_BaseIntegrator_write_precomputed_linear_matrices_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseIntegrator_write_precomputed_linear_matrices_141_comment},
  {"write_precomputed_angular_matrices", (PyCFunction) &Dtool_BaseIntegrator_write_precomputed_angular_matrices_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseIntegrator_write_precomputed_angular_matrices_142_comment},
  {"writePrecomputedAngularMatrices", (PyCFunction) &Dtool_BaseIntegrator_write_precomputed_angular_matrices_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseIntegrator_write_precomputed_angular_matrices_142_comment},
  {"write", (PyCFunction) &Dtool_BaseIntegrator_write_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseIntegrator_write_143_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     BaseIntegrator
//////////////////
static PyObject *Dtool_Repr_BaseIntegrator(PyObject *self) {
  BaseIntegrator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseIntegrator, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BaseIntegrator
//////////////////
static PyObject *Dtool_Str_BaseIntegrator(PyObject *self) {
  BaseIntegrator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseIntegrator, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_BaseIntegrator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BaseIntegrator = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BaseIntegrator = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BaseIntegrator = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BaseIntegrator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.BaseIntegrator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BaseIntegrator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_BaseIntegrator,
    &Dtool_NumberMethods_BaseIntegrator,
    &Dtool_SequenceMethods_BaseIntegrator,
    &Dtool_MappingMethods_BaseIntegrator,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_BaseIntegrator,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BaseIntegrator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * pure virtual integrator class that holds cached matrix information that\n"
    " * really should be common to any possible child implementation.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BaseIntegrator,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BaseIntegrator,
    PyType_GenericAlloc,
    Dtool_new_BaseIntegrator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BaseIntegrator,
  Dtool_UpcastInterface_BaseIntegrator,
  Dtool_DowncastInterface_BaseIntegrator,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_BaseIntegrator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_BaseIntegrator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_BaseIntegrator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BaseIntegrator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BaseIntegrator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BaseIntegrator);
  }
}

/**
 * Python method tables for AngularIntegrator (AngularIntegrator)
 */
static PyMethodDef Dtool_Methods_AngularIntegrator[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AngularIntegrator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AngularIntegrator = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AngularIntegrator = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AngularIntegrator = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AngularIntegrator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.AngularIntegrator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AngularIntegrator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AngularIntegrator,
    &Dtool_SequenceMethods_AngularIntegrator,
    &Dtool_MappingMethods_AngularIntegrator,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AngularIntegrator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Pure virtual base class for physical modeling.  Takes physically modelable\n"
    " * objects and applies forces to them.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AngularIntegrator,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AngularIntegrator,
    PyType_GenericAlloc,
    Dtool_new_AngularIntegrator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AngularIntegrator,
  Dtool_UpcastInterface_AngularIntegrator,
  Dtool_DowncastInterface_AngularIntegrator,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AngularIntegrator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseIntegrator(NULL);
    Dtool_AngularIntegrator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseIntegrator);
    PyObject *dict = PyDict_New();
    Dtool_AngularIntegrator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AngularIntegrator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AngularIntegrator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AngularIntegrator);
  }
}

/**
 * Python method tables for AngularEulerIntegrator (AngularEulerIntegrator)
 */
static PyMethodDef Dtool_Methods_AngularEulerIntegrator[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AngularEulerIntegrator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AngularEulerIntegrator = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AngularEulerIntegrator = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AngularEulerIntegrator = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AngularEulerIntegrator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.AngularEulerIntegrator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AngularEulerIntegrator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AngularEulerIntegrator,
    &Dtool_SequenceMethods_AngularEulerIntegrator,
    &Dtool_MappingMethods_AngularEulerIntegrator,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AngularEulerIntegrator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Performs Euler integration on a vector of physically modelable objects\n"
    " * given a quantum dt.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AngularEulerIntegrator,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AngularEulerIntegrator,
    PyType_GenericAlloc,
    Dtool_new_AngularEulerIntegrator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AngularEulerIntegrator,
  Dtool_UpcastInterface_AngularEulerIntegrator,
  Dtool_DowncastInterface_AngularEulerIntegrator,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AngularEulerIntegrator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AngularIntegrator(NULL);
    Dtool_AngularEulerIntegrator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AngularIntegrator);
    PyObject *dict = PyDict_New();
    Dtool_AngularEulerIntegrator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AngularEulerIntegrator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AngularEulerIntegrator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AngularEulerIntegrator);
  }
}

/**
 * Python method tables for AngularVectorForce (AngularVectorForce)
 */
static PyMethodDef Dtool_Methods_AngularVectorForce[] = {
  {"set_quat", &Dtool_AngularVectorForce_set_quat_150, METH_O, (const char *)Dtool_AngularVectorForce_set_quat_150_comment},
  {"setQuat", &Dtool_AngularVectorForce_set_quat_150, METH_O, (const char *)Dtool_AngularVectorForce_set_quat_150_comment},
  {"set_hpr", (PyCFunction) &Dtool_AngularVectorForce_set_hpr_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AngularVectorForce_set_hpr_151_comment},
  {"setHpr", (PyCFunction) &Dtool_AngularVectorForce_set_hpr_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AngularVectorForce_set_hpr_151_comment},
  {"get_local_quat", &Dtool_AngularVectorForce_get_local_quat_152, METH_NOARGS, (const char *)Dtool_AngularVectorForce_get_local_quat_152_comment},
  {"getLocalQuat", &Dtool_AngularVectorForce_get_local_quat_152, METH_NOARGS, (const char *)Dtool_AngularVectorForce_get_local_quat_152_comment},
  {"get_class_type", &Dtool_AngularVectorForce_get_class_type_153, METH_NOARGS | METH_STATIC, (const char *)Dtool_AngularVectorForce_get_class_type_153_comment},
  {"getClassType", &Dtool_AngularVectorForce_get_class_type_153, METH_NOARGS | METH_STATIC, (const char *)Dtool_AngularVectorForce_get_class_type_153_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AngularVectorForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AngularVectorForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AngularVectorForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AngularVectorForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AngularVectorForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.AngularVectorForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AngularVectorForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AngularVectorForce,
    &Dtool_SequenceMethods_AngularVectorForce,
    &Dtool_MappingMethods_AngularVectorForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AngularVectorForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * a simple directed torque force, the angular equivalent of simple vector\n"
    " * force.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AngularVectorForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AngularVectorForce,
    PyType_GenericAlloc,
    Dtool_new_AngularVectorForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AngularVectorForce,
  Dtool_UpcastInterface_AngularVectorForce,
  Dtool_DowncastInterface_AngularVectorForce,
  (CoerceFunction)Dtool_ConstCoerce_AngularVectorForce,
  (CoerceFunction)Dtool_Coerce_AngularVectorForce,
};

static void Dtool_PyModuleClassInit_AngularVectorForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AngularForce(NULL);
    Dtool_AngularVectorForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AngularForce);
    PyObject *dict = PyDict_New();
    Dtool_AngularVectorForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AngularVectorForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AngularVectorForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AngularVectorForce);
  }
}

/**
 * Python method tables for ForceNode (ForceNode)
 */
static PyMethodDef Dtool_Methods_ForceNode[] = {
  {"clear", &Dtool_ForceNode_clear_156, METH_NOARGS, (const char *)Dtool_ForceNode_clear_156_comment},
  {"get_force", &Dtool_ForceNode_get_force_157, METH_O, (const char *)Dtool_ForceNode_get_force_157_comment},
  {"getForce", &Dtool_ForceNode_get_force_157, METH_O, (const char *)Dtool_ForceNode_get_force_157_comment},
  {"get_num_forces", &Dtool_ForceNode_get_num_forces_158, METH_NOARGS, (const char *)Dtool_ForceNode_get_num_forces_158_comment},
  {"getNumForces", &Dtool_ForceNode_get_num_forces_158, METH_NOARGS, (const char *)Dtool_ForceNode_get_num_forces_158_comment},
  {"add_force", &Dtool_ForceNode_add_force_160, METH_O, (const char *)Dtool_ForceNode_add_force_160_comment},
  {"addForce", &Dtool_ForceNode_add_force_160, METH_O, (const char *)Dtool_ForceNode_add_force_160_comment},
  {"add_forces_from", &Dtool_ForceNode_add_forces_from_161, METH_O, (const char *)Dtool_ForceNode_add_forces_from_161_comment},
  {"addForcesFrom", &Dtool_ForceNode_add_forces_from_161, METH_O, (const char *)Dtool_ForceNode_add_forces_from_161_comment},
  {"set_force", (PyCFunction) &Dtool_ForceNode_set_force_162, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ForceNode_set_force_162_comment},
  {"setForce", (PyCFunction) &Dtool_ForceNode_set_force_162, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ForceNode_set_force_162_comment},
  {"remove_force", &Dtool_ForceNode_remove_force_163, METH_O, (const char *)Dtool_ForceNode_remove_force_163_comment},
  {"removeForce", &Dtool_ForceNode_remove_force_163, METH_O, (const char *)Dtool_ForceNode_remove_force_163_comment},
  {"write_forces", (PyCFunction) &Dtool_ForceNode_write_forces_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ForceNode_write_forces_166_comment},
  {"writeForces", (PyCFunction) &Dtool_ForceNode_write_forces_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ForceNode_write_forces_166_comment},
  {"write", (PyCFunction) &Dtool_ForceNode_write_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ForceNode_write_167_comment},
  {"get_class_type", &Dtool_ForceNode_get_class_type_168, METH_NOARGS | METH_STATIC, (const char *)Dtool_ForceNode_get_class_type_168_comment},
  {"getClassType", &Dtool_ForceNode_get_class_type_168, METH_NOARGS | METH_STATIC, (const char *)Dtool_ForceNode_get_class_type_168_comment},
  {"get_forces", (PyCFunction) &MakeSeq_ForceNode_get_forces, METH_NOARGS, NULL},
  { "getForces", (PyCFunction) &MakeSeq_ForceNode_get_forces, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     ForceNode
//////////////////
static PyObject *Dtool_Str_ForceNode(PyObject *self) {
  ForceNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ForceNode, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ForceNode[] = {
  {(char *)"forces", &Dtool_ForceNode_forces_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ForceNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ForceNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ForceNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ForceNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ForceNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.ForceNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ForceNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ForceNode,
    &Dtool_SequenceMethods_ForceNode,
    &Dtool_MappingMethods_ForceNode,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ForceNode,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ForceNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A force that lives in the scene graph and is therefore subject to local\n"
    " * coordinate systems.  An example of this would be simulating gravity in a\n"
    " * rotating space station.  or something.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ForceNode,
    0, // tp_members
    Dtool_Properties_ForceNode,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ForceNode,
    PyType_GenericAlloc,
    Dtool_new_ForceNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ForceNode,
  Dtool_UpcastInterface_ForceNode,
  Dtool_DowncastInterface_ForceNode,
  (CoerceFunction)Dtool_ConstCoerce_ForceNode,
  (CoerceFunction)Dtool_Coerce_ForceNode,
};

static void Dtool_PyModuleClassInit_ForceNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_ForceNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_ForceNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ForceNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ForceNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ForceNode);
  }
}

/**
 * Python method tables for LinearControlForce (LinearControlForce)
 */
static PyMethodDef Dtool_Methods_LinearControlForce[] = {
  {"clear_physics_object", &Dtool_LinearControlForce_clear_physics_object_171, METH_NOARGS, (const char *)Dtool_LinearControlForce_clear_physics_object_171_comment},
  {"clearPhysicsObject", &Dtool_LinearControlForce_clear_physics_object_171, METH_NOARGS, (const char *)Dtool_LinearControlForce_clear_physics_object_171_comment},
  {"set_physics_object", &Dtool_LinearControlForce_set_physics_object_172, METH_O, (const char *)Dtool_LinearControlForce_set_physics_object_172_comment},
  {"setPhysicsObject", &Dtool_LinearControlForce_set_physics_object_172, METH_O, (const char *)Dtool_LinearControlForce_set_physics_object_172_comment},
  {"get_physics_object", &Dtool_LinearControlForce_get_physics_object_173, METH_NOARGS, (const char *)Dtool_LinearControlForce_get_physics_object_173_comment},
  {"getPhysicsObject", &Dtool_LinearControlForce_get_physics_object_173, METH_NOARGS, (const char *)Dtool_LinearControlForce_get_physics_object_173_comment},
  {"set_vector", (PyCFunction) &Dtool_LinearControlForce_set_vector_174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearControlForce_set_vector_174_comment},
  {"setVector", (PyCFunction) &Dtool_LinearControlForce_set_vector_174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearControlForce_set_vector_174_comment},
  {"get_local_vector", &Dtool_LinearControlForce_get_local_vector_175, METH_NOARGS, (const char *)Dtool_LinearControlForce_get_local_vector_175_comment},
  {"getLocalVector", &Dtool_LinearControlForce_get_local_vector_175, METH_NOARGS, (const char *)Dtool_LinearControlForce_get_local_vector_175_comment},
  {"get_class_type", &Dtool_LinearControlForce_get_class_type_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearControlForce_get_class_type_176_comment},
  {"getClassType", &Dtool_LinearControlForce_get_class_type_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearControlForce_get_class_type_176_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearControlForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearControlForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearControlForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearControlForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearControlForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearControlForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearControlForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearControlForce,
    &Dtool_SequenceMethods_LinearControlForce,
    &Dtool_MappingMethods_LinearControlForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearControlForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Simple directed vector force.  This force is different from the others in\n"
    " * that it can be global and still only affect a single object.  That might\n"
    " * not make sense for a physics simulation, but it's very handy for a game.\n"
    " * I.e.  this is the force applied by user on the selected object.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearControlForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearControlForce,
    PyType_GenericAlloc,
    Dtool_new_LinearControlForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearControlForce,
  Dtool_UpcastInterface_LinearControlForce,
  Dtool_DowncastInterface_LinearControlForce,
  (CoerceFunction)Dtool_ConstCoerce_LinearControlForce,
  (CoerceFunction)Dtool_Coerce_LinearControlForce,
};

static void Dtool_PyModuleClassInit_LinearControlForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(NULL);
    Dtool_LinearControlForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    PyObject *dict = PyDict_New();
    Dtool_LinearControlForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearControlForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearControlForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearControlForce);
  }
}

/**
 * Python method tables for LinearCylinderVortexForce (LinearCylinderVortexForce)
 */
static PyMethodDef Dtool_Methods_LinearCylinderVortexForce[] = {
  {"set_coef", &Dtool_LinearCylinderVortexForce_set_coef_179, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_coef_179_comment},
  {"setCoef", &Dtool_LinearCylinderVortexForce_set_coef_179, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_coef_179_comment},
  {"get_coef", &Dtool_LinearCylinderVortexForce_get_coef_180, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_coef_180_comment},
  {"getCoef", &Dtool_LinearCylinderVortexForce_get_coef_180, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_coef_180_comment},
  {"set_radius", &Dtool_LinearCylinderVortexForce_set_radius_181, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_radius_181_comment},
  {"setRadius", &Dtool_LinearCylinderVortexForce_set_radius_181, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_radius_181_comment},
  {"get_radius", &Dtool_LinearCylinderVortexForce_get_radius_182, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_radius_182_comment},
  {"getRadius", &Dtool_LinearCylinderVortexForce_get_radius_182, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_radius_182_comment},
  {"set_length", &Dtool_LinearCylinderVortexForce_set_length_183, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_length_183_comment},
  {"setLength", &Dtool_LinearCylinderVortexForce_set_length_183, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_length_183_comment},
  {"get_length", &Dtool_LinearCylinderVortexForce_get_length_184, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_length_184_comment},
  {"getLength", &Dtool_LinearCylinderVortexForce_get_length_184, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_length_184_comment},
  {"get_class_type", &Dtool_LinearCylinderVortexForce_get_class_type_185, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearCylinderVortexForce_get_class_type_185_comment},
  {"getClassType", &Dtool_LinearCylinderVortexForce_get_class_type_185, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearCylinderVortexForce_get_class_type_185_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearCylinderVortexForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearCylinderVortexForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearCylinderVortexForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearCylinderVortexForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearCylinderVortexForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearCylinderVortexForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearCylinderVortexForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearCylinderVortexForce,
    &Dtool_SequenceMethods_LinearCylinderVortexForce,
    &Dtool_MappingMethods_LinearCylinderVortexForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearCylinderVortexForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a cylinder inside of which all forces are tangential to the theta\n"
    " * of the particle wrt the z-axis in local coord.  space.  This happens by\n"
    " * assigning the force a node by which the cylinder is transformed.  Be\n"
    " * warned- this will suck anything that it can reach directly into orbit and\n"
    " * will NOT let go.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearCylinderVortexForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearCylinderVortexForce,
    PyType_GenericAlloc,
    Dtool_new_LinearCylinderVortexForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearCylinderVortexForce,
  Dtool_UpcastInterface_LinearCylinderVortexForce,
  Dtool_DowncastInterface_LinearCylinderVortexForce,
  (CoerceFunction)Dtool_ConstCoerce_LinearCylinderVortexForce,
  (CoerceFunction)Dtool_Coerce_LinearCylinderVortexForce,
};

static void Dtool_PyModuleClassInit_LinearCylinderVortexForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(NULL);
    Dtool_LinearCylinderVortexForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    PyObject *dict = PyDict_New();
    Dtool_LinearCylinderVortexForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearCylinderVortexForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearCylinderVortexForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearCylinderVortexForce);
  }
}

/**
 * Python method tables for LinearDistanceForce (LinearDistanceForce)
 */
static PyMethodDef Dtool_Methods_LinearDistanceForce[] = {
  {"set_radius", &Dtool_LinearDistanceForce_set_radius_188, METH_O, (const char *)Dtool_LinearDistanceForce_set_radius_188_comment},
  {"setRadius", &Dtool_LinearDistanceForce_set_radius_188, METH_O, (const char *)Dtool_LinearDistanceForce_set_radius_188_comment},
  {"set_falloff_type", &Dtool_LinearDistanceForce_set_falloff_type_189, METH_O, (const char *)Dtool_LinearDistanceForce_set_falloff_type_189_comment},
  {"setFalloffType", &Dtool_LinearDistanceForce_set_falloff_type_189, METH_O, (const char *)Dtool_LinearDistanceForce_set_falloff_type_189_comment},
  {"set_force_center", &Dtool_LinearDistanceForce_set_force_center_190, METH_O, (const char *)Dtool_LinearDistanceForce_set_force_center_190_comment},
  {"setForceCenter", &Dtool_LinearDistanceForce_set_force_center_190, METH_O, (const char *)Dtool_LinearDistanceForce_set_force_center_190_comment},
  {"get_radius", &Dtool_LinearDistanceForce_get_radius_191, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_radius_191_comment},
  {"getRadius", &Dtool_LinearDistanceForce_get_radius_191, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_radius_191_comment},
  {"get_falloff_type", &Dtool_LinearDistanceForce_get_falloff_type_192, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_falloff_type_192_comment},
  {"getFalloffType", &Dtool_LinearDistanceForce_get_falloff_type_192, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_falloff_type_192_comment},
  {"get_force_center", &Dtool_LinearDistanceForce_get_force_center_193, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_force_center_193_comment},
  {"getForceCenter", &Dtool_LinearDistanceForce_get_force_center_193, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_force_center_193_comment},
  {"get_scalar_term", &Dtool_LinearDistanceForce_get_scalar_term_194, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_scalar_term_194_comment},
  {"getScalarTerm", &Dtool_LinearDistanceForce_get_scalar_term_194, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_scalar_term_194_comment},
  {"get_class_type", &Dtool_LinearDistanceForce_get_class_type_195, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearDistanceForce_get_class_type_195_comment},
  {"getClassType", &Dtool_LinearDistanceForce_get_class_type_195, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearDistanceForce_get_class_type_195_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearDistanceForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearDistanceForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearDistanceForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearDistanceForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearDistanceForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearDistanceForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearDistanceForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearDistanceForce,
    &Dtool_SequenceMethods_LinearDistanceForce,
    &Dtool_MappingMethods_LinearDistanceForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearDistanceForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Pure virtual class for sinks and sources\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearDistanceForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearDistanceForce,
    PyType_GenericAlloc,
    Dtool_new_LinearDistanceForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearDistanceForce,
  Dtool_UpcastInterface_LinearDistanceForce,
  Dtool_DowncastInterface_LinearDistanceForce,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LinearDistanceForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(NULL);
    Dtool_LinearDistanceForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_LinearDistanceForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LinearDistanceForce::FalloffType;
    PyDict_SetItemString(dict, "FT_ONE_OVER_R", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R));
    PyDict_SetItemString(dict, "FTONEOVERR", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R));
    PyDict_SetItemString(dict, "FT_ONE_OVER_R_SQUARED", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R_SQUARED));
    PyDict_SetItemString(dict, "FTONEOVERRSQUARED", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R_SQUARED));
    PyDict_SetItemString(dict, "FT_ONE_OVER_R_CUBED", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R_CUBED));
    PyDict_SetItemString(dict, "FTONEOVERRCUBED", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R_CUBED));
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearDistanceForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearDistanceForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearDistanceForce);
  }
}

/**
 * Python method tables for LinearIntegrator (LinearIntegrator)
 */
static PyMethodDef Dtool_Methods_LinearIntegrator[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearIntegrator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearIntegrator = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearIntegrator = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearIntegrator = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearIntegrator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearIntegrator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearIntegrator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearIntegrator,
    &Dtool_SequenceMethods_LinearIntegrator,
    &Dtool_MappingMethods_LinearIntegrator,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearIntegrator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Pure virtual base class for physical modeling.  Takes physically modelable\n"
    " * objects and applies forces to them.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearIntegrator,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearIntegrator,
    PyType_GenericAlloc,
    Dtool_new_LinearIntegrator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearIntegrator,
  Dtool_UpcastInterface_LinearIntegrator,
  Dtool_DowncastInterface_LinearIntegrator,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LinearIntegrator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseIntegrator(NULL);
    Dtool_LinearIntegrator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseIntegrator);
    PyObject *dict = PyDict_New();
    Dtool_LinearIntegrator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearIntegrator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearIntegrator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearIntegrator);
  }
}

/**
 * Python method tables for LinearEulerIntegrator (LinearEulerIntegrator)
 */
static PyMethodDef Dtool_Methods_LinearEulerIntegrator[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearEulerIntegrator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearEulerIntegrator = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearEulerIntegrator = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearEulerIntegrator = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearEulerIntegrator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearEulerIntegrator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearEulerIntegrator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearEulerIntegrator,
    &Dtool_SequenceMethods_LinearEulerIntegrator,
    &Dtool_MappingMethods_LinearEulerIntegrator,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearEulerIntegrator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Performs Euler integration on a vector of physically modelable objects\n"
    " * given a quantum dt.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearEulerIntegrator,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearEulerIntegrator,
    PyType_GenericAlloc,
    Dtool_new_LinearEulerIntegrator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearEulerIntegrator,
  Dtool_UpcastInterface_LinearEulerIntegrator,
  Dtool_DowncastInterface_LinearEulerIntegrator,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LinearEulerIntegrator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearIntegrator(NULL);
    Dtool_LinearEulerIntegrator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearIntegrator);
    PyObject *dict = PyDict_New();
    Dtool_LinearEulerIntegrator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearEulerIntegrator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearEulerIntegrator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearEulerIntegrator);
  }
}

/**
 * Python method tables for LinearFrictionForce (LinearFrictionForce)
 */
static PyMethodDef Dtool_Methods_LinearFrictionForce[] = {
  {"set_coef", &Dtool_LinearFrictionForce_set_coef_201, METH_O, (const char *)Dtool_LinearFrictionForce_set_coef_201_comment},
  {"setCoef", &Dtool_LinearFrictionForce_set_coef_201, METH_O, (const char *)Dtool_LinearFrictionForce_set_coef_201_comment},
  {"get_coef", &Dtool_LinearFrictionForce_get_coef_202, METH_NOARGS, (const char *)Dtool_LinearFrictionForce_get_coef_202_comment},
  {"getCoef", &Dtool_LinearFrictionForce_get_coef_202, METH_NOARGS, (const char *)Dtool_LinearFrictionForce_get_coef_202_comment},
  {"get_class_type", &Dtool_LinearFrictionForce_get_class_type_203, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearFrictionForce_get_class_type_203_comment},
  {"getClassType", &Dtool_LinearFrictionForce_get_class_type_203, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearFrictionForce_get_class_type_203_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearFrictionForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearFrictionForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearFrictionForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearFrictionForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearFrictionForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearFrictionForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearFrictionForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearFrictionForce,
    &Dtool_SequenceMethods_LinearFrictionForce,
    &Dtool_MappingMethods_LinearFrictionForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearFrictionForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Friction-based drag force\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearFrictionForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearFrictionForce,
    PyType_GenericAlloc,
    Dtool_new_LinearFrictionForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearFrictionForce,
  Dtool_UpcastInterface_LinearFrictionForce,
  Dtool_DowncastInterface_LinearFrictionForce,
  (CoerceFunction)Dtool_ConstCoerce_LinearFrictionForce,
  (CoerceFunction)Dtool_Coerce_LinearFrictionForce,
};

static void Dtool_PyModuleClassInit_LinearFrictionForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(NULL);
    Dtool_LinearFrictionForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    PyObject *dict = PyDict_New();
    Dtool_LinearFrictionForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearFrictionForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearFrictionForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearFrictionForce);
  }
}

/**
 * Python method tables for LinearRandomForce (LinearRandomForce)
 */
static PyMethodDef Dtool_Methods_LinearRandomForce[] = {
  {"get_class_type", &Dtool_LinearRandomForce_get_class_type_205, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearRandomForce_get_class_type_205_comment},
  {"getClassType", &Dtool_LinearRandomForce_get_class_type_205, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearRandomForce_get_class_type_205_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearRandomForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearRandomForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearRandomForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearRandomForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearRandomForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearRandomForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearRandomForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearRandomForce,
    &Dtool_SequenceMethods_LinearRandomForce,
    &Dtool_MappingMethods_LinearRandomForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearRandomForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Pure virtual, parent to noiseForce and jitterForce\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearRandomForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearRandomForce,
    PyType_GenericAlloc,
    Dtool_new_LinearRandomForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearRandomForce,
  Dtool_UpcastInterface_LinearRandomForce,
  Dtool_DowncastInterface_LinearRandomForce,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LinearRandomForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(NULL);
    Dtool_LinearRandomForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    PyObject *dict = PyDict_New();
    Dtool_LinearRandomForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearRandomForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearRandomForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearRandomForce);
  }
}

/**
 * Python method tables for LinearJitterForce (LinearJitterForce)
 */
static PyMethodDef Dtool_Methods_LinearJitterForce[] = {
  {"get_class_type", &Dtool_LinearJitterForce_get_class_type_208, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearJitterForce_get_class_type_208_comment},
  {"getClassType", &Dtool_LinearJitterForce_get_class_type_208, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearJitterForce_get_class_type_208_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearJitterForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearJitterForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearJitterForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearJitterForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearJitterForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearJitterForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearJitterForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearJitterForce,
    &Dtool_SequenceMethods_LinearJitterForce,
    &Dtool_MappingMethods_LinearJitterForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearJitterForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Completely random noise force vector.  Not repeatable, reliable, or\n"
    " * predictable.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearJitterForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearJitterForce,
    PyType_GenericAlloc,
    Dtool_new_LinearJitterForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearJitterForce,
  Dtool_UpcastInterface_LinearJitterForce,
  Dtool_DowncastInterface_LinearJitterForce,
  (CoerceFunction)Dtool_ConstCoerce_LinearJitterForce,
  (CoerceFunction)Dtool_Coerce_LinearJitterForce,
};

static void Dtool_PyModuleClassInit_LinearJitterForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearRandomForce(NULL);
    Dtool_LinearJitterForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearRandomForce);
    PyObject *dict = PyDict_New();
    Dtool_LinearJitterForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearJitterForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearJitterForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearJitterForce);
  }
}

/**
 * Python method tables for LinearNoiseForce (LinearNoiseForce)
 */
static PyMethodDef Dtool_Methods_LinearNoiseForce[] = {
  {"get_class_type", &Dtool_LinearNoiseForce_get_class_type_211, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearNoiseForce_get_class_type_211_comment},
  {"getClassType", &Dtool_LinearNoiseForce_get_class_type_211, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearNoiseForce_get_class_type_211_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearNoiseForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearNoiseForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearNoiseForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearNoiseForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearNoiseForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearNoiseForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearNoiseForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearNoiseForce,
    &Dtool_SequenceMethods_LinearNoiseForce,
    &Dtool_MappingMethods_LinearNoiseForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearNoiseForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Repeating noise force vector.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearNoiseForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearNoiseForce,
    PyType_GenericAlloc,
    Dtool_new_LinearNoiseForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearNoiseForce,
  Dtool_UpcastInterface_LinearNoiseForce,
  Dtool_DowncastInterface_LinearNoiseForce,
  (CoerceFunction)Dtool_ConstCoerce_LinearNoiseForce,
  (CoerceFunction)Dtool_Coerce_LinearNoiseForce,
};

static void Dtool_PyModuleClassInit_LinearNoiseForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearRandomForce(NULL);
    Dtool_LinearNoiseForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearRandomForce);
    PyObject *dict = PyDict_New();
    Dtool_LinearNoiseForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearNoiseForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearNoiseForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearNoiseForce);
  }
}

/**
 * Python method tables for LinearSinkForce (LinearSinkForce)
 */
static PyMethodDef Dtool_Methods_LinearSinkForce[] = {
  {"get_class_type", &Dtool_LinearSinkForce_get_class_type_214, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearSinkForce_get_class_type_214_comment},
  {"getClassType", &Dtool_LinearSinkForce_get_class_type_214, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearSinkForce_get_class_type_214_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearSinkForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearSinkForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearSinkForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearSinkForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearSinkForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearSinkForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearSinkForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearSinkForce,
    &Dtool_SequenceMethods_LinearSinkForce,
    &Dtool_MappingMethods_LinearSinkForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearSinkForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Attractor force.  Think black hole.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearSinkForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearSinkForce,
    PyType_GenericAlloc,
    Dtool_new_LinearSinkForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearSinkForce,
  Dtool_UpcastInterface_LinearSinkForce,
  Dtool_DowncastInterface_LinearSinkForce,
  (CoerceFunction)Dtool_ConstCoerce_LinearSinkForce,
  (CoerceFunction)Dtool_Coerce_LinearSinkForce,
};

static void Dtool_PyModuleClassInit_LinearSinkForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearDistanceForce(NULL);
    Dtool_LinearSinkForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearDistanceForce);
    PyObject *dict = PyDict_New();
    Dtool_LinearSinkForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearSinkForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearSinkForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearSinkForce);
  }
}

/**
 * Python method tables for LinearSourceForce (LinearSourceForce)
 */
static PyMethodDef Dtool_Methods_LinearSourceForce[] = {
  {"get_class_type", &Dtool_LinearSourceForce_get_class_type_217, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearSourceForce_get_class_type_217_comment},
  {"getClassType", &Dtool_LinearSourceForce_get_class_type_217, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearSourceForce_get_class_type_217_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearSourceForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearSourceForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearSourceForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearSourceForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearSourceForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearSourceForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearSourceForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearSourceForce,
    &Dtool_SequenceMethods_LinearSourceForce,
    &Dtool_MappingMethods_LinearSourceForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearSourceForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Repellant force.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearSourceForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearSourceForce,
    PyType_GenericAlloc,
    Dtool_new_LinearSourceForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearSourceForce,
  Dtool_UpcastInterface_LinearSourceForce,
  Dtool_DowncastInterface_LinearSourceForce,
  (CoerceFunction)Dtool_ConstCoerce_LinearSourceForce,
  (CoerceFunction)Dtool_Coerce_LinearSourceForce,
};

static void Dtool_PyModuleClassInit_LinearSourceForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearDistanceForce(NULL);
    Dtool_LinearSourceForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearDistanceForce);
    PyObject *dict = PyDict_New();
    Dtool_LinearSourceForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearSourceForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearSourceForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearSourceForce);
  }
}

/**
 * Python method tables for LinearUserDefinedForce (LinearUserDefinedForce)
 */
static PyMethodDef Dtool_Methods_LinearUserDefinedForce[] = {
  {"get_class_type", &Dtool_LinearUserDefinedForce_get_class_type_221, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearUserDefinedForce_get_class_type_221_comment},
  {"getClassType", &Dtool_LinearUserDefinedForce_get_class_type_221, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearUserDefinedForce_get_class_type_221_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearUserDefinedForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearUserDefinedForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearUserDefinedForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearUserDefinedForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearUserDefinedForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearUserDefinedForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearUserDefinedForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearUserDefinedForce,
    &Dtool_SequenceMethods_LinearUserDefinedForce,
    &Dtool_MappingMethods_LinearUserDefinedForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearUserDefinedForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * a programmable force that takes an evaluator fn.\n"
    " *\n"
    " * NOTE : AS OF Interrogate => Squeak, this class does NOT get FFI'd due to\n"
    " * the function pointer bug, and is currently NOT getting interrogated.\n"
    " * Change this in the makefile when the time is right or this class becomes\n"
    " * needed...\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearUserDefinedForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearUserDefinedForce,
    PyType_GenericAlloc,
    Dtool_new_LinearUserDefinedForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearUserDefinedForce,
  Dtool_UpcastInterface_LinearUserDefinedForce,
  Dtool_DowncastInterface_LinearUserDefinedForce,
  (CoerceFunction)Dtool_ConstCoerce_LinearUserDefinedForce,
  (CoerceFunction)Dtool_Coerce_LinearUserDefinedForce,
};

static void Dtool_PyModuleClassInit_LinearUserDefinedForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(NULL);
    Dtool_LinearUserDefinedForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    PyObject *dict = PyDict_New();
    Dtool_LinearUserDefinedForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearUserDefinedForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearUserDefinedForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearUserDefinedForce);
  }
}

/**
 * Python method tables for LinearVectorForce (LinearVectorForce)
 */
static PyMethodDef Dtool_Methods_LinearVectorForce[] = {
  {"set_vector", (PyCFunction) &Dtool_LinearVectorForce_set_vector_224, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearVectorForce_set_vector_224_comment},
  {"setVector", (PyCFunction) &Dtool_LinearVectorForce_set_vector_224, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearVectorForce_set_vector_224_comment},
  {"get_local_vector", &Dtool_LinearVectorForce_get_local_vector_225, METH_NOARGS, (const char *)Dtool_LinearVectorForce_get_local_vector_225_comment},
  {"getLocalVector", &Dtool_LinearVectorForce_get_local_vector_225, METH_NOARGS, (const char *)Dtool_LinearVectorForce_get_local_vector_225_comment},
  {"get_class_type", &Dtool_LinearVectorForce_get_class_type_226, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearVectorForce_get_class_type_226_comment},
  {"getClassType", &Dtool_LinearVectorForce_get_class_type_226, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearVectorForce_get_class_type_226_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LinearVectorForce = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearVectorForce = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LinearVectorForce = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LinearVectorForce = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LinearVectorForce = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.LinearVectorForce",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearVectorForce,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LinearVectorForce,
    &Dtool_SequenceMethods_LinearVectorForce,
    &Dtool_MappingMethods_LinearVectorForce,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LinearVectorForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Simple directed vector force.  Suitable for gravity, non-turbulent wind,\n"
    " * etc...\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LinearVectorForce,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LinearVectorForce,
    PyType_GenericAlloc,
    Dtool_new_LinearVectorForce,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearVectorForce,
  Dtool_UpcastInterface_LinearVectorForce,
  Dtool_DowncastInterface_LinearVectorForce,
  (CoerceFunction)Dtool_ConstCoerce_LinearVectorForce,
  (CoerceFunction)Dtool_Coerce_LinearVectorForce,
};

static void Dtool_PyModuleClassInit_LinearVectorForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(NULL);
    Dtool_LinearVectorForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    PyObject *dict = PyDict_New();
    Dtool_LinearVectorForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearVectorForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearVectorForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearVectorForce);
  }
}

/**
 * Python method tables for PhysicsCollisionHandler (PhysicsCollisionHandler)
 */
static PyMethodDef Dtool_Methods_PhysicsCollisionHandler[] = {
  {"set_almost_stationary_speed", &Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_230, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_230_comment},
  {"setAlmostStationarySpeed", &Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_230, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_230_comment},
  {"get_almost_stationary_speed", &Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_231, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_231_comment},
  {"getAlmostStationarySpeed", &Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_231, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_231_comment},
  {"set_static_friction_coef", &Dtool_PhysicsCollisionHandler_set_static_friction_coef_232, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_static_friction_coef_232_comment},
  {"setStaticFrictionCoef", &Dtool_PhysicsCollisionHandler_set_static_friction_coef_232, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_static_friction_coef_232_comment},
  {"get_static_friction_coef", &Dtool_PhysicsCollisionHandler_get_static_friction_coef_233, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_static_friction_coef_233_comment},
  {"getStaticFrictionCoef", &Dtool_PhysicsCollisionHandler_get_static_friction_coef_233, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_static_friction_coef_233_comment},
  {"set_dynamic_friction_coef", &Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_234, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_234_comment},
  {"setDynamicFrictionCoef", &Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_234, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_234_comment},
  {"get_dynamic_friction_coef", &Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_235, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_235_comment},
  {"getDynamicFrictionCoef", &Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_235, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_235_comment},
  {"get_class_type", &Dtool_PhysicsCollisionHandler_get_class_type_236, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicsCollisionHandler_get_class_type_236_comment},
  {"getClassType", &Dtool_PhysicsCollisionHandler_get_class_type_236, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicsCollisionHandler_get_class_type_236_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PhysicsCollisionHandler = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PhysicsCollisionHandler = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PhysicsCollisionHandler = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PhysicsCollisionHandler = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PhysicsCollisionHandler = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.PhysicsCollisionHandler",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PhysicsCollisionHandler,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PhysicsCollisionHandler,
    &Dtool_SequenceMethods_PhysicsCollisionHandler,
    &Dtool_MappingMethods_PhysicsCollisionHandler,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PhysicsCollisionHandler,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that simply pushes back on things\n"
    " * that attempt to move into solid walls.  This also puts forces onto the\n"
    " * physics objects\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PhysicsCollisionHandler,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PhysicsCollisionHandler,
    PyType_GenericAlloc,
    Dtool_new_PhysicsCollisionHandler,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PhysicsCollisionHandler,
  Dtool_UpcastInterface_PhysicsCollisionHandler,
  Dtool_DowncastInterface_PhysicsCollisionHandler,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PhysicsCollisionHandler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CollisionHandlerPusher != NULL);
    assert(Dtool_Ptr_CollisionHandlerPusher->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_CollisionHandlerPusher->_Dtool_ModuleClassInit(NULL);
    Dtool_PhysicsCollisionHandler._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CollisionHandlerPusher);
    PyObject *dict = PyDict_New();
    Dtool_PhysicsCollisionHandler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PhysicsCollisionHandler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PhysicsCollisionHandler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PhysicsCollisionHandler);
  }
}

/**
 * Python method tables for PhysicsManager (PhysicsManager)
 */
static PyMethodDef Dtool_Methods_PhysicsManager[] = {
  {"attach_linear_integrator", &Dtool_PhysicsManager_attach_linear_integrator_240, METH_O, (const char *)Dtool_PhysicsManager_attach_linear_integrator_240_comment},
  {"attachLinearIntegrator", &Dtool_PhysicsManager_attach_linear_integrator_240, METH_O, (const char *)Dtool_PhysicsManager_attach_linear_integrator_240_comment},
  {"attach_angular_integrator", &Dtool_PhysicsManager_attach_angular_integrator_241, METH_O, (const char *)Dtool_PhysicsManager_attach_angular_integrator_241_comment},
  {"attachAngularIntegrator", &Dtool_PhysicsManager_attach_angular_integrator_241, METH_O, (const char *)Dtool_PhysicsManager_attach_angular_integrator_241_comment},
  {"attach_physical", &Dtool_PhysicsManager_attach_physical_242, METH_O, (const char *)Dtool_PhysicsManager_attach_physical_242_comment},
  {"attachPhysical", &Dtool_PhysicsManager_attach_physical_242, METH_O, (const char *)Dtool_PhysicsManager_attach_physical_242_comment},
  {"attach_physicalnode", &Dtool_PhysicsManager_attach_physicalnode_243, METH_O, (const char *)Dtool_PhysicsManager_attach_physicalnode_243_comment},
  {"attachPhysicalnode", &Dtool_PhysicsManager_attach_physicalnode_243, METH_O, (const char *)Dtool_PhysicsManager_attach_physicalnode_243_comment},
  {"attach_physical_node", &Dtool_PhysicsManager_attach_physical_node_244, METH_O, (const char *)Dtool_PhysicsManager_attach_physical_node_244_comment},
  {"attachPhysicalNode", &Dtool_PhysicsManager_attach_physical_node_244, METH_O, (const char *)Dtool_PhysicsManager_attach_physical_node_244_comment},
  {"add_linear_force", &Dtool_PhysicsManager_add_linear_force_245, METH_O, (const char *)Dtool_PhysicsManager_add_linear_force_245_comment},
  {"addLinearForce", &Dtool_PhysicsManager_add_linear_force_245, METH_O, (const char *)Dtool_PhysicsManager_add_linear_force_245_comment},
  {"add_angular_force", &Dtool_PhysicsManager_add_angular_force_246, METH_O, (const char *)Dtool_PhysicsManager_add_angular_force_246_comment},
  {"addAngularForce", &Dtool_PhysicsManager_add_angular_force_246, METH_O, (const char *)Dtool_PhysicsManager_add_angular_force_246_comment},
  {"clear_linear_forces", &Dtool_PhysicsManager_clear_linear_forces_247, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_linear_forces_247_comment},
  {"clearLinearForces", &Dtool_PhysicsManager_clear_linear_forces_247, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_linear_forces_247_comment},
  {"clear_angular_forces", &Dtool_PhysicsManager_clear_angular_forces_248, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_angular_forces_248_comment},
  {"clearAngularForces", &Dtool_PhysicsManager_clear_angular_forces_248, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_angular_forces_248_comment},
  {"clear_physicals", &Dtool_PhysicsManager_clear_physicals_249, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_physicals_249_comment},
  {"clearPhysicals", &Dtool_PhysicsManager_clear_physicals_249, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_physicals_249_comment},
  {"set_viscosity", &Dtool_PhysicsManager_set_viscosity_250, METH_O, (const char *)Dtool_PhysicsManager_set_viscosity_250_comment},
  {"setViscosity", &Dtool_PhysicsManager_set_viscosity_250, METH_O, (const char *)Dtool_PhysicsManager_set_viscosity_250_comment},
  {"get_viscosity", &Dtool_PhysicsManager_get_viscosity_251, METH_NOARGS, (const char *)Dtool_PhysicsManager_get_viscosity_251_comment},
  {"getViscosity", &Dtool_PhysicsManager_get_viscosity_251, METH_NOARGS, (const char *)Dtool_PhysicsManager_get_viscosity_251_comment},
  {"remove_physical", &Dtool_PhysicsManager_remove_physical_252, METH_O, (const char *)Dtool_PhysicsManager_remove_physical_252_comment},
  {"removePhysical", &Dtool_PhysicsManager_remove_physical_252, METH_O, (const char *)Dtool_PhysicsManager_remove_physical_252_comment},
  {"remove_physical_node", &Dtool_PhysicsManager_remove_physical_node_253, METH_O, (const char *)Dtool_PhysicsManager_remove_physical_node_253_comment},
  {"removePhysicalNode", &Dtool_PhysicsManager_remove_physical_node_253, METH_O, (const char *)Dtool_PhysicsManager_remove_physical_node_253_comment},
  {"remove_linear_force", &Dtool_PhysicsManager_remove_linear_force_254, METH_O, (const char *)Dtool_PhysicsManager_remove_linear_force_254_comment},
  {"removeLinearForce", &Dtool_PhysicsManager_remove_linear_force_254, METH_O, (const char *)Dtool_PhysicsManager_remove_linear_force_254_comment},
  {"remove_angular_force", &Dtool_PhysicsManager_remove_angular_force_255, METH_O, (const char *)Dtool_PhysicsManager_remove_angular_force_255_comment},
  {"removeAngularForce", &Dtool_PhysicsManager_remove_angular_force_255, METH_O, (const char *)Dtool_PhysicsManager_remove_angular_force_255_comment},
  {"do_physics", (PyCFunction) &Dtool_PhysicsManager_do_physics_256, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_do_physics_256_comment},
  {"doPhysics", (PyCFunction) &Dtool_PhysicsManager_do_physics_256, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_do_physics_256_comment},
  {"init_random_seed", &Dtool_PhysicsManager_init_random_seed_257, METH_NOARGS, (const char *)Dtool_PhysicsManager_init_random_seed_257_comment},
  {"initRandomSeed", &Dtool_PhysicsManager_init_random_seed_257, METH_NOARGS, (const char *)Dtool_PhysicsManager_init_random_seed_257_comment},
  {"output", &Dtool_PhysicsManager_output_258, METH_O, (const char *)Dtool_PhysicsManager_output_258_comment},
  {"write_physicals", (PyCFunction) &Dtool_PhysicsManager_write_physicals_259, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_physicals_259_comment},
  {"writePhysicals", (PyCFunction) &Dtool_PhysicsManager_write_physicals_259, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_physicals_259_comment},
  {"write_linear_forces", (PyCFunction) &Dtool_PhysicsManager_write_linear_forces_260, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_linear_forces_260_comment},
  {"writeLinearForces", (PyCFunction) &Dtool_PhysicsManager_write_linear_forces_260, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_linear_forces_260_comment},
  {"write_angular_forces", (PyCFunction) &Dtool_PhysicsManager_write_angular_forces_261, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_angular_forces_261_comment},
  {"writeAngularForces", (PyCFunction) &Dtool_PhysicsManager_write_angular_forces_261, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_angular_forces_261_comment},
  {"write", (PyCFunction) &Dtool_PhysicsManager_write_262, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_262_comment},
  {"debug_output", (PyCFunction) &Dtool_PhysicsManager_debug_output_263, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_debug_output_263_comment},
  {"debugOutput", (PyCFunction) &Dtool_PhysicsManager_debug_output_263, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_debug_output_263_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PhysicsManager
//////////////////
static PyObject *Dtool_Repr_PhysicsManager(PyObject *self) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     PhysicsManager
//////////////////
static PyObject *Dtool_Str_PhysicsManager(PyObject *self) {
  PhysicsManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PhysicsManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_PhysicsManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.physics.PhysicsManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PhysicsManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PhysicsManager,
    &Dtool_NumberMethods_PhysicsManager,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_PhysicsManager,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Physics don't get much higher-level than this.  Attach as many Physicals\n"
    " * (particle systems, etc..) as you want, pick an integrator and go.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PhysicsManager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PhysicsManager,
    PyType_GenericAlloc,
    Dtool_new_PhysicsManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PhysicsManager,
  Dtool_UpcastInterface_PhysicsManager,
  Dtool_DowncastInterface_PhysicsManager,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PhysicsManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PhysicsManager._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PhysicsManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PhysicsManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PhysicsManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PhysicsManager);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3physics_RegisterTypes() {
  Dtool_PhysicsObject._type = PhysicsObject::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PhysicsObject);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PhysicsObjectCollection", Dtool_PhysicsObjectCollection);
#endif
  Dtool_BaseForce._type = BaseForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BaseForce);
  Dtool_LinearForce._type = LinearForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearForce);
  Dtool_AngularForce._type = AngularForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AngularForce);
  Dtool_Physical._type = Physical::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Physical);
  Dtool_PhysicalNode._type = PhysicalNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PhysicalNode);
  Dtool_ActorNode._type = ActorNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ActorNode);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("BaseIntegrator", Dtool_BaseIntegrator);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("AngularIntegrator", Dtool_AngularIntegrator);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("AngularEulerIntegrator", Dtool_AngularEulerIntegrator);
#endif
  Dtool_AngularVectorForce._type = AngularVectorForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AngularVectorForce);
  Dtool_ForceNode._type = ForceNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ForceNode);
  Dtool_LinearControlForce._type = LinearControlForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearControlForce);
  Dtool_LinearCylinderVortexForce._type = LinearCylinderVortexForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearCylinderVortexForce);
  Dtool_LinearDistanceForce._type = LinearDistanceForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearDistanceForce);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LinearIntegrator", Dtool_LinearIntegrator);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LinearEulerIntegrator", Dtool_LinearEulerIntegrator);
#endif
  Dtool_LinearFrictionForce._type = LinearFrictionForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearFrictionForce);
  Dtool_LinearRandomForce._type = LinearRandomForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearRandomForce);
  Dtool_LinearJitterForce._type = LinearJitterForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearJitterForce);
  Dtool_LinearNoiseForce._type = LinearNoiseForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearNoiseForce);
  Dtool_LinearSinkForce._type = LinearSinkForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearSinkForce);
  Dtool_LinearSourceForce._type = LinearSourceForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearSourceForce);
  Dtool_LinearUserDefinedForce._type = LinearUserDefinedForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearUserDefinedForce);
  Dtool_LinearVectorForce._type = LinearVectorForce::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LinearVectorForce);
  Dtool_PhysicsCollisionHandler._type = PhysicsCollisionHandler::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PhysicsCollisionHandler);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PhysicsManager", Dtool_PhysicsManager);
#endif
}

void Dtool_libp3physics_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LVector3f = LookupRuntimeTypedClass(LVector3f::get_class_type());
  Dtool_Ptr_LRotationf = LookupRuntimeTypedClass(LRotationf::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_LOrientationf = LookupRuntimeTypedClass(LOrientationf::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_CollisionHandler = LookupRuntimeTypedClass(CollisionHandler::get_class_type());
  Dtool_Ptr_CollisionHandlerEvent = LookupRuntimeTypedClass(CollisionHandlerEvent::get_class_type());
  Dtool_Ptr_CollisionHandlerPusher = LookupRuntimeTypedClass(CollisionHandlerPusher::get_class_type());
  Dtool_Ptr_CollisionHandlerPhysical = LookupRuntimeTypedClass(CollisionHandlerPhysical::get_class_type());
#endif
}

void Dtool_libp3physics_BuildInstants(PyObject *module) {
  (void) module;
  // PhysicsObject
  Dtool_PyModuleClassInit_PhysicsObject(module);
  PyModule_AddObject(module, "PhysicsObject", (PyObject *)&Dtool_PhysicsObject);
  // PhysicsObjectCollection
  Dtool_PyModuleClassInit_PhysicsObjectCollection(module);
  PyModule_AddObject(module, "PhysicsObjectCollection", (PyObject *)&Dtool_PhysicsObjectCollection);
  // BaseForce
  Dtool_PyModuleClassInit_BaseForce(module);
  PyModule_AddObject(module, "BaseForce", (PyObject *)&Dtool_BaseForce);
  // LinearForce
  Dtool_PyModuleClassInit_LinearForce(module);
  PyModule_AddObject(module, "LinearForce", (PyObject *)&Dtool_LinearForce);
  // AngularForce
  Dtool_PyModuleClassInit_AngularForce(module);
  PyModule_AddObject(module, "AngularForce", (PyObject *)&Dtool_AngularForce);
  // Physical
  Dtool_PyModuleClassInit_Physical(module);
  PyModule_AddObject(module, "Physical", (PyObject *)&Dtool_Physical);
  // PhysicalNode
  Dtool_PyModuleClassInit_PhysicalNode(module);
  PyModule_AddObject(module, "PhysicalNode", (PyObject *)&Dtool_PhysicalNode);
  // ActorNode
  Dtool_PyModuleClassInit_ActorNode(module);
  PyModule_AddObject(module, "ActorNode", (PyObject *)&Dtool_ActorNode);
  // BaseIntegrator
  Dtool_PyModuleClassInit_BaseIntegrator(module);
  PyModule_AddObject(module, "BaseIntegrator", (PyObject *)&Dtool_BaseIntegrator);
  // AngularIntegrator
  Dtool_PyModuleClassInit_AngularIntegrator(module);
  PyModule_AddObject(module, "AngularIntegrator", (PyObject *)&Dtool_AngularIntegrator);
  // AngularEulerIntegrator
  Dtool_PyModuleClassInit_AngularEulerIntegrator(module);
  PyModule_AddObject(module, "AngularEulerIntegrator", (PyObject *)&Dtool_AngularEulerIntegrator);
  // AngularVectorForce
  Dtool_PyModuleClassInit_AngularVectorForce(module);
  PyModule_AddObject(module, "AngularVectorForce", (PyObject *)&Dtool_AngularVectorForce);
  // ForceNode
  Dtool_PyModuleClassInit_ForceNode(module);
  PyModule_AddObject(module, "ForceNode", (PyObject *)&Dtool_ForceNode);
  // LinearControlForce
  Dtool_PyModuleClassInit_LinearControlForce(module);
  PyModule_AddObject(module, "LinearControlForce", (PyObject *)&Dtool_LinearControlForce);
  // LinearCylinderVortexForce
  Dtool_PyModuleClassInit_LinearCylinderVortexForce(module);
  PyModule_AddObject(module, "LinearCylinderVortexForce", (PyObject *)&Dtool_LinearCylinderVortexForce);
  // LinearDistanceForce
  Dtool_PyModuleClassInit_LinearDistanceForce(module);
  PyModule_AddObject(module, "LinearDistanceForce", (PyObject *)&Dtool_LinearDistanceForce);
  // LinearIntegrator
  Dtool_PyModuleClassInit_LinearIntegrator(module);
  PyModule_AddObject(module, "LinearIntegrator", (PyObject *)&Dtool_LinearIntegrator);
  // LinearEulerIntegrator
  Dtool_PyModuleClassInit_LinearEulerIntegrator(module);
  PyModule_AddObject(module, "LinearEulerIntegrator", (PyObject *)&Dtool_LinearEulerIntegrator);
  // LinearFrictionForce
  Dtool_PyModuleClassInit_LinearFrictionForce(module);
  PyModule_AddObject(module, "LinearFrictionForce", (PyObject *)&Dtool_LinearFrictionForce);
  // LinearRandomForce
  Dtool_PyModuleClassInit_LinearRandomForce(module);
  PyModule_AddObject(module, "LinearRandomForce", (PyObject *)&Dtool_LinearRandomForce);
  // LinearJitterForce
  Dtool_PyModuleClassInit_LinearJitterForce(module);
  PyModule_AddObject(module, "LinearJitterForce", (PyObject *)&Dtool_LinearJitterForce);
  // LinearNoiseForce
  Dtool_PyModuleClassInit_LinearNoiseForce(module);
  PyModule_AddObject(module, "LinearNoiseForce", (PyObject *)&Dtool_LinearNoiseForce);
  // LinearSinkForce
  Dtool_PyModuleClassInit_LinearSinkForce(module);
  PyModule_AddObject(module, "LinearSinkForce", (PyObject *)&Dtool_LinearSinkForce);
  // LinearSourceForce
  Dtool_PyModuleClassInit_LinearSourceForce(module);
  PyModule_AddObject(module, "LinearSourceForce", (PyObject *)&Dtool_LinearSourceForce);
  // LinearUserDefinedForce
  Dtool_PyModuleClassInit_LinearUserDefinedForce(module);
  PyModule_AddObject(module, "LinearUserDefinedForce", (PyObject *)&Dtool_LinearUserDefinedForce);
  // LinearVectorForce
  Dtool_PyModuleClassInit_LinearVectorForce(module);
  PyModule_AddObject(module, "LinearVectorForce", (PyObject *)&Dtool_LinearVectorForce);
  // PhysicsCollisionHandler
  Dtool_PyModuleClassInit_PhysicsCollisionHandler(module);
  PyModule_AddObject(module, "PhysicsCollisionHandler", (PyObject *)&Dtool_PhysicsCollisionHandler);
  // PhysicsManager
  Dtool_PyModuleClassInit_PhysicsManager(module);
  PyModule_AddObject(module, "PhysicsManager", (PyObject *)&Dtool_PhysicsManager);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3physics_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478214331,  /* file_identifier */
  "libp3physics",  /* library_name */
  "1Scs",  /* library_hash_name */
  "panda3d.physics",  /* module_name */
  "libp3physics.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  615  /* next_index */
};

Configure(_in_configure_libp3physics);
ConfigureFn(_in_configure_libp3physics) {
  interrogate_request_module(&_in_module_def);
}

