/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/egg -Ipanda/src/egg -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3egg_igate.cxx -od built/pandac/input/libp3egg.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/egg -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/zlib/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.egg -library libp3egg config_egg.h eggAnimData.h eggAnimPreload.h eggAttributes.h eggBin.h eggBinMaker.h eggComment.h eggCompositePrimitive.h eggCoordinateSystem.h eggCurve.h eggData.h eggExternalReference.h eggFilenameNode.h eggGroup.h eggGroupNode.h eggGroupNode_ext.h eggGroupUniquifier.h eggLine.h eggMaterial.h eggMaterialCollection.h eggMesher.h eggMesherEdge.h eggMesherFanMaker.h eggMesherStrip.h eggMiscFuncs.h eggMorph.h eggMorphList.h eggNameUniquifier.h eggNamedObject.h eggNode.h eggNurbsCurve.h eggNurbsSurface.h eggObject.h eggParameters.h eggPatch.h eggPoint.h eggPolygon.h eggPolysetMaker.h eggPoolUniquifier.h eggPrimitive.h eggRenderMode.h eggSAnimData.h eggSurface.h eggSwitchCondition.h eggTable.h eggTexture.h eggTextureCollection.h eggTransform.h eggTriangleFan.h eggTriangleStrip.h eggUserData.h eggUtilities.h eggVertex.h eggVertexAux.h eggVertexPool.h eggVertexUV.h eggXfmAnimData.h eggXfmSAnim.h lexerDefs.h p3egg_composite1.cxx p3egg_composite2.cxx parserDefs.h pt_EggMaterial.h pt_EggTexture.h pt_EggVertex.h vector_PT_EggMaterial.h vector_PT_EggTexture.h vector_PT_EggVertex.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3egg
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include <algorithm>
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableInt.h"
#include "configVariableSearchPath.h"
#include "config_egg.h"
#include "coordinateSystem.h"
#include "dcast.h"
#include "dtoolbase.h"
#include "eggAnimData.h"
#include "eggAnimPreload.h"
#include "eggAttributes.h"
#include "eggBin.h"
#include "eggBinMaker.h"
#include "eggComment.h"
#include "eggCompositePrimitive.h"
#include "eggCoordinateSystem.h"
#include "eggCurve.h"
#include "eggData.h"
#include "eggExternalReference.h"
#include "eggFilenameNode.h"
#include "eggGroup.h"
#include "eggGroupNode.h"
#include "eggGroupNode_ext.h"
#include "eggGroupUniquifier.h"
#include "eggLine.h"
#include "eggMaterial.h"
#include "eggMaterialCollection.h"
#include "eggMesher.h"
#include "eggMesherEdge.h"
#include "eggMesherFanMaker.h"
#include "eggMesherStrip.h"
#include "eggMiscFuncs.h"
#include "eggMorph.h"
#include "eggMorphList.h"
#include "eggNameUniquifier.h"
#include "eggNamedObject.h"
#include "eggNode.h"
#include "eggNurbsCurve.h"
#include "eggNurbsSurface.h"
#include "eggObject.h"
#include "eggParameters.h"
#include "eggPatch.h"
#include "eggPoint.h"
#include "eggPolygon.h"
#include "eggPolysetMaker.h"
#include "eggPoolUniquifier.h"
#include "eggPrimitive.h"
#include "eggRenderMode.h"
#include "eggSAnimData.h"
#include "eggSurface.h"
#include "eggSwitchCondition.h"
#include "eggTable.h"
#include "eggTexture.h"
#include "eggTextureCollection.h"
#include "eggTransform.h"
#include "eggTriangleFan.h"
#include "eggTriangleStrip.h"
#include "eggUserData.h"
#include "eggUtilities.h"
#include "eggVertex.h"
#include "eggVertexAux.h"
#include "eggVertexPool.h"
#include "eggVertexUV.h"
#include "eggXfmAnimData.h"
#include "eggXfmSAnim.h"
#include "extension.h"
#include "filename.h"
#include "lexerDefs.h"
#include "lmatrix.h"
#include "luse.h"
#include <math.h>
#include "mathNumbers.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "parserDefs.h"
#include "plist.h"
#include "pmap.h"
#include "pnotify.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pset.h"
#include "pt_EggMaterial.h"
#include "pt_EggTexture.h"
#include "pt_EggVertex.h"
#include "pta_double.h"
#include "pvector.h"
#include "py_panda.h"
#include <string>
#include "typedObject.h"
#include "typedef.h"
#include "vector_PT_EggMaterial.h"
#include "vector_PT_EggTexture.h"
#include "vector_PT_EggVertex.h"
#include "vector_double.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class EggUserData
 */
typedef EggUserData EggUserData_localtype;
Define_Module_ClassRef(panda3d.egg, EggUserData, EggUserData_localtype, EggUserData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggUserData = &Dtool_EggUserData;
static void Dtool_PyModuleClassInit_EggUserData(PyObject *module);

/**
 * Forward declarations for top-level class EggObject
 */
typedef EggObject EggObject_localtype;
Define_Module_ClassRef(panda3d.egg, EggObject, EggObject_localtype, EggObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggObject = &Dtool_EggObject;
static void Dtool_PyModuleClassInit_EggObject(PyObject *module);

/**
 * Forward declarations for top-level class EggNamedObject
 */
typedef EggNamedObject EggNamedObject_localtype;
Define_Module_ClassRef(panda3d.egg, EggNamedObject, EggNamedObject_localtype, EggNamedObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggNamedObject = &Dtool_EggNamedObject;
static void Dtool_PyModuleClassInit_EggNamedObject(PyObject *module);
bool Dtool_ConstCoerce_EggNamedObject(PyObject *args, CPT(EggNamedObject) &coerced);
bool Dtool_Coerce_EggNamedObject(PyObject *args, PT(EggNamedObject) &coerced);

/**
 * Forward declarations for top-level class EggNode
 */
typedef EggNode EggNode_localtype;
Define_Module_ClassRef(panda3d.egg, EggNode, EggNode_localtype, EggNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggNode = &Dtool_EggNode;
static void Dtool_PyModuleClassInit_EggNode(PyObject *module);
bool Dtool_ConstCoerce_EggNode(PyObject *args, CPT(EggNode) &coerced);
bool Dtool_Coerce_EggNode(PyObject *args, PT(EggNode) &coerced);

/**
 * Forward declarations for top-level class EggAnimData
 */
typedef EggAnimData EggAnimData_localtype;
Define_Module_ClassRef(panda3d.egg, EggAnimData, EggAnimData_localtype, EggAnimData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggAnimData = &Dtool_EggAnimData;
static void Dtool_PyModuleClassInit_EggAnimData(PyObject *module);
bool Dtool_ConstCoerce_EggAnimData(PyObject *args, CPT(EggAnimData) &coerced);
bool Dtool_Coerce_EggAnimData(PyObject *args, PT(EggAnimData) &coerced);

/**
 * Forward declarations for top-level class EggAnimPreload
 */
typedef EggAnimPreload EggAnimPreload_localtype;
Define_Module_ClassRef(panda3d.egg, EggAnimPreload, EggAnimPreload_localtype, EggAnimPreload);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggAnimPreload = &Dtool_EggAnimPreload;
static void Dtool_PyModuleClassInit_EggAnimPreload(PyObject *module);
bool Dtool_ConstCoerce_EggAnimPreload(PyObject *args, CPT(EggAnimPreload) &coerced);
bool Dtool_Coerce_EggAnimPreload(PyObject *args, PT(EggAnimPreload) &coerced);

/**
 * Forward declarations for top-level class EggAttributes
 */
typedef EggAttributes EggAttributes_localtype;
Define_Module_Class(panda3d.egg, EggAttributes, EggAttributes_localtype, EggAttributes);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggAttributes = &Dtool_EggAttributes;
static void Dtool_PyModuleClassInit_EggAttributes(PyObject *module);

/**
 * Forward declarations for top-level class EggVertexUV
 */
typedef EggVertexUV EggVertexUV_localtype;
Define_Module_ClassRef(panda3d.egg, EggVertexUV, EggVertexUV_localtype, EggVertexUV);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggVertexUV = &Dtool_EggVertexUV;
static void Dtool_PyModuleClassInit_EggVertexUV(PyObject *module);
bool Dtool_ConstCoerce_EggVertexUV(PyObject *args, CPT(EggVertexUV) &coerced);
bool Dtool_Coerce_EggVertexUV(PyObject *args, PT(EggVertexUV) &coerced);

/**
 * Forward declarations for top-level class EggVertexAux
 */
typedef EggVertexAux EggVertexAux_localtype;
Define_Module_ClassRef(panda3d.egg, EggVertexAux, EggVertexAux_localtype, EggVertexAux);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggVertexAux = &Dtool_EggVertexAux;
static void Dtool_PyModuleClassInit_EggVertexAux(PyObject *module);
bool Dtool_ConstCoerce_EggVertexAux(PyObject *args, CPT(EggVertexAux) &coerced);
bool Dtool_Coerce_EggVertexAux(PyObject *args, PT(EggVertexAux) &coerced);

/**
 * Forward declarations for top-level class EggVertex
 */
typedef EggVertex EggVertex_localtype;
Define_Module_ClassRef(panda3d.egg, EggVertex, EggVertex_localtype, EggVertex);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggVertex = &Dtool_EggVertex;
static void Dtool_PyModuleClassInit_EggVertex(PyObject *module);

/**
 * Forward declarations for top-level class EggVertexPool
 */
typedef EggVertexPool EggVertexPool_localtype;
Define_Module_ClassRef(panda3d.egg, EggVertexPool, EggVertexPool_localtype, EggVertexPool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggVertexPool = &Dtool_EggVertexPool;
static void Dtool_PyModuleClassInit_EggVertexPool(PyObject *module);
bool Dtool_ConstCoerce_EggVertexPool(PyObject *args, CPT(EggVertexPool) &coerced);
bool Dtool_Coerce_EggVertexPool(PyObject *args, PT(EggVertexPool) &coerced);

/**
 * Forward declarations for top-level class EggGroupNode
 */
typedef EggGroupNode EggGroupNode_localtype;
Define_Module_ClassRef(panda3d.egg, EggGroupNode, EggGroupNode_localtype, EggGroupNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggGroupNode = &Dtool_EggGroupNode;
static void Dtool_PyModuleClassInit_EggGroupNode(PyObject *module);
bool Dtool_ConstCoerce_EggGroupNode(PyObject *args, CPT(EggGroupNode) &coerced);
bool Dtool_Coerce_EggGroupNode(PyObject *args, PT(EggGroupNode) &coerced);

/**
 * Forward declarations for top-level class EggRenderMode
 */
typedef EggRenderMode EggRenderMode_localtype;
Define_Module_Class(panda3d.egg, EggRenderMode, EggRenderMode_localtype, EggRenderMode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggRenderMode = &Dtool_EggRenderMode;
static void Dtool_PyModuleClassInit_EggRenderMode(PyObject *module);

/**
 * Forward declarations for top-level class EggTransform
 */
typedef EggTransform EggTransform_localtype;
Define_Module_Class(panda3d.egg, EggTransform, EggTransform_localtype, EggTransform);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTransform = &Dtool_EggTransform;
static void Dtool_PyModuleClassInit_EggTransform(PyObject *module);

/**
 * Forward declarations for top-level class EggSwitchCondition
 */
typedef EggSwitchCondition EggSwitchCondition_localtype;
Define_Module_ClassRef(panda3d.egg, EggSwitchCondition, EggSwitchCondition_localtype, EggSwitchCondition);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggSwitchCondition = &Dtool_EggSwitchCondition;
static void Dtool_PyModuleClassInit_EggSwitchCondition(PyObject *module);

/**
 * Forward declarations for top-level class EggSwitchConditionDistance
 */
typedef EggSwitchConditionDistance EggSwitchConditionDistance_localtype;
Define_Module_ClassRef(panda3d.egg, EggSwitchConditionDistance, EggSwitchConditionDistance_localtype, EggSwitchConditionDistance);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggSwitchConditionDistance = &Dtool_EggSwitchConditionDistance;
static void Dtool_PyModuleClassInit_EggSwitchConditionDistance(PyObject *module);
bool Dtool_ConstCoerce_EggSwitchConditionDistance(PyObject *args, CPT(EggSwitchConditionDistance) &coerced);
bool Dtool_Coerce_EggSwitchConditionDistance(PyObject *args, PT(EggSwitchConditionDistance) &coerced);

/**
 * Forward declarations for top-level class EggGroup
 */
typedef EggGroup EggGroup_localtype;
Define_Module_ClassRef(panda3d.egg, EggGroup, EggGroup_localtype, EggGroup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggGroup = &Dtool_EggGroup;
static void Dtool_PyModuleClassInit_EggGroup(PyObject *module);
bool Dtool_ConstCoerce_EggGroup(PyObject *args, CPT(EggGroup) &coerced);
bool Dtool_Coerce_EggGroup(PyObject *args, PT(EggGroup) &coerced);

/**
 * Forward declarations for top-level class EggBin
 */
typedef EggBin EggBin_localtype;
Define_Module_ClassRef(panda3d.egg, EggBin, EggBin_localtype, EggBin);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggBin = &Dtool_EggBin;
static void Dtool_PyModuleClassInit_EggBin(PyObject *module);
bool Dtool_ConstCoerce_EggBin(PyObject *args, CPT(EggBin) &coerced);
bool Dtool_Coerce_EggBin(PyObject *args, PT(EggBin) &coerced);

/**
 * Forward declarations for top-level class EggBinMaker
 */
typedef EggBinMaker EggBinMaker_localtype;
Define_Module_ClassRef(panda3d.egg, EggBinMaker, EggBinMaker_localtype, EggBinMaker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggBinMaker = &Dtool_EggBinMaker;
static void Dtool_PyModuleClassInit_EggBinMaker(PyObject *module);

/**
 * Forward declarations for top-level class EggComment
 */
typedef EggComment EggComment_localtype;
Define_Module_ClassRef(panda3d.egg, EggComment, EggComment_localtype, EggComment);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggComment = &Dtool_EggComment;
static void Dtool_PyModuleClassInit_EggComment(PyObject *module);
bool Dtool_ConstCoerce_EggComment(PyObject *args, CPT(EggComment) &coerced);
bool Dtool_Coerce_EggComment(PyObject *args, PT(EggComment) &coerced);

/**
 * Forward declarations for top-level class EggFilenameNode
 */
typedef EggFilenameNode EggFilenameNode_localtype;
Define_Module_ClassRef(panda3d.egg, EggFilenameNode, EggFilenameNode_localtype, EggFilenameNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggFilenameNode = &Dtool_EggFilenameNode;
static void Dtool_PyModuleClassInit_EggFilenameNode(PyObject *module);
bool Dtool_ConstCoerce_EggFilenameNode(PyObject *args, CPT(EggFilenameNode) &coerced);
bool Dtool_Coerce_EggFilenameNode(PyObject *args, PT(EggFilenameNode) &coerced);

/**
 * Forward declarations for top-level class EggTexture
 */
typedef EggTexture EggTexture_localtype;
Define_Module_ClassRef(panda3d.egg, EggTexture, EggTexture_localtype, EggTexture);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTexture = &Dtool_EggTexture;
static void Dtool_PyModuleClassInit_EggTexture(PyObject *module);
bool Dtool_ConstCoerce_EggTexture(PyObject *args, CPT(EggTexture) &coerced);
bool Dtool_Coerce_EggTexture(PyObject *args, PT(EggTexture) &coerced);

/**
 * Forward declarations for top-level class EggMaterial
 */
typedef EggMaterial EggMaterial_localtype;
Define_Module_ClassRef(panda3d.egg, EggMaterial, EggMaterial_localtype, EggMaterial);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggMaterial = &Dtool_EggMaterial;
static void Dtool_PyModuleClassInit_EggMaterial(PyObject *module);
bool Dtool_ConstCoerce_EggMaterial(PyObject *args, CPT(EggMaterial) &coerced);
bool Dtool_Coerce_EggMaterial(PyObject *args, PT(EggMaterial) &coerced);

/**
 * Forward declarations for top-level class EggPrimitive
 */
typedef EggPrimitive EggPrimitive_localtype;
Define_Module_ClassRef(panda3d.egg, EggPrimitive, EggPrimitive_localtype, EggPrimitive);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPrimitive = &Dtool_EggPrimitive;
static void Dtool_PyModuleClassInit_EggPrimitive(PyObject *module);
bool Dtool_ConstCoerce_EggPrimitive(PyObject *args, CPT(EggPrimitive) &coerced);
bool Dtool_Coerce_EggPrimitive(PyObject *args, PT(EggPrimitive) &coerced);

/**
 * Forward declarations for top-level class EggCompositePrimitive
 */
typedef EggCompositePrimitive EggCompositePrimitive_localtype;
Define_Module_ClassRef(panda3d.egg, EggCompositePrimitive, EggCompositePrimitive_localtype, EggCompositePrimitive);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggCompositePrimitive = &Dtool_EggCompositePrimitive;
static void Dtool_PyModuleClassInit_EggCompositePrimitive(PyObject *module);
bool Dtool_ConstCoerce_EggCompositePrimitive(PyObject *args, CPT(EggCompositePrimitive) &coerced);
bool Dtool_Coerce_EggCompositePrimitive(PyObject *args, PT(EggCompositePrimitive) &coerced);

/**
 * Forward declarations for top-level class EggData
 */
typedef EggData EggData_localtype;
Define_Module_ClassRef(panda3d.egg, EggData, EggData_localtype, EggData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggData = &Dtool_EggData;
static void Dtool_PyModuleClassInit_EggData(PyObject *module);

/**
 * Forward declarations for top-level class EggCoordinateSystem
 */
typedef EggCoordinateSystem EggCoordinateSystem_localtype;
Define_Module_ClassRef(panda3d.egg, EggCoordinateSystem, EggCoordinateSystem_localtype, EggCoordinateSystem);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggCoordinateSystem = &Dtool_EggCoordinateSystem;
static void Dtool_PyModuleClassInit_EggCoordinateSystem(PyObject *module);
bool Dtool_ConstCoerce_EggCoordinateSystem(PyObject *args, CPT(EggCoordinateSystem) &coerced);
bool Dtool_Coerce_EggCoordinateSystem(PyObject *args, PT(EggCoordinateSystem) &coerced);

/**
 * Forward declarations for top-level class EggCurve
 */
typedef EggCurve EggCurve_localtype;
Define_Module_ClassRef(panda3d.egg, EggCurve, EggCurve_localtype, EggCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggCurve = &Dtool_EggCurve;
static void Dtool_PyModuleClassInit_EggCurve(PyObject *module);
bool Dtool_ConstCoerce_EggCurve(PyObject *args, CPT(EggCurve) &coerced);
bool Dtool_Coerce_EggCurve(PyObject *args, PT(EggCurve) &coerced);

/**
 * Forward declarations for top-level class EggExternalReference
 */
typedef EggExternalReference EggExternalReference_localtype;
Define_Module_ClassRef(panda3d.egg, EggExternalReference, EggExternalReference_localtype, EggExternalReference);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggExternalReference = &Dtool_EggExternalReference;
static void Dtool_PyModuleClassInit_EggExternalReference(PyObject *module);
bool Dtool_ConstCoerce_EggExternalReference(PyObject *args, CPT(EggExternalReference) &coerced);
bool Dtool_Coerce_EggExternalReference(PyObject *args, PT(EggExternalReference) &coerced);

/**
 * Forward declarations for top-level class EggNameUniquifier
 */
typedef EggNameUniquifier EggNameUniquifier_localtype;
Define_Module_ClassRef(panda3d.egg, EggNameUniquifier, EggNameUniquifier_localtype, EggNameUniquifier);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggNameUniquifier = &Dtool_EggNameUniquifier;
static void Dtool_PyModuleClassInit_EggNameUniquifier(PyObject *module);

/**
 * Forward declarations for top-level class EggGroupUniquifier
 */
typedef EggGroupUniquifier EggGroupUniquifier_localtype;
Define_Module_ClassRef(panda3d.egg, EggGroupUniquifier, EggGroupUniquifier_localtype, EggGroupUniquifier);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggGroupUniquifier = &Dtool_EggGroupUniquifier;
static void Dtool_PyModuleClassInit_EggGroupUniquifier(PyObject *module);
bool Dtool_ConstCoerce_EggGroupUniquifier(PyObject *args, CPT(EggGroupUniquifier) &coerced);
bool Dtool_Coerce_EggGroupUniquifier(PyObject *args, PT(EggGroupUniquifier) &coerced);

/**
 * Forward declarations for top-level class EggLine
 */
typedef EggLine EggLine_localtype;
Define_Module_ClassRef(panda3d.egg, EggLine, EggLine_localtype, EggLine);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggLine = &Dtool_EggLine;
static void Dtool_PyModuleClassInit_EggLine(PyObject *module);
bool Dtool_ConstCoerce_EggLine(PyObject *args, CPT(EggLine) &coerced);
bool Dtool_Coerce_EggLine(PyObject *args, PT(EggLine) &coerced);

/**
 * Forward declarations for top-level class EggMaterialCollection
 */
typedef EggMaterialCollection EggMaterialCollection_localtype;
Define_Module_Class(panda3d.egg, EggMaterialCollection, EggMaterialCollection_localtype, EggMaterialCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggMaterialCollection = &Dtool_EggMaterialCollection;
static void Dtool_PyModuleClassInit_EggMaterialCollection(PyObject *module);

/**
 * Forward declarations for top-level class EggPolygon
 */
typedef EggPolygon EggPolygon_localtype;
Define_Module_ClassRef(panda3d.egg, EggPolygon, EggPolygon_localtype, EggPolygon);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPolygon = &Dtool_EggPolygon;
static void Dtool_PyModuleClassInit_EggPolygon(PyObject *module);
bool Dtool_ConstCoerce_EggPolygon(PyObject *args, CPT(EggPolygon) &coerced);
bool Dtool_Coerce_EggPolygon(PyObject *args, PT(EggPolygon) &coerced);

/**
 * Forward declarations for top-level class EggNurbsCurve
 */
typedef EggNurbsCurve EggNurbsCurve_localtype;
Define_Module_ClassRef(panda3d.egg, EggNurbsCurve, EggNurbsCurve_localtype, EggNurbsCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggNurbsCurve = &Dtool_EggNurbsCurve;
static void Dtool_PyModuleClassInit_EggNurbsCurve(PyObject *module);
bool Dtool_ConstCoerce_EggNurbsCurve(PyObject *args, CPT(EggNurbsCurve) &coerced);
bool Dtool_Coerce_EggNurbsCurve(PyObject *args, PT(EggNurbsCurve) &coerced);

/**
 * Forward declarations for top-level class EggSurface
 */
typedef EggSurface EggSurface_localtype;
Define_Module_ClassRef(panda3d.egg, EggSurface, EggSurface_localtype, EggSurface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggSurface = &Dtool_EggSurface;
static void Dtool_PyModuleClassInit_EggSurface(PyObject *module);
bool Dtool_ConstCoerce_EggSurface(PyObject *args, CPT(EggSurface) &coerced);
bool Dtool_Coerce_EggSurface(PyObject *args, PT(EggSurface) &coerced);

/**
 * Forward declarations for top-level class EggNurbsSurface
 */
typedef EggNurbsSurface EggNurbsSurface_localtype;
Define_Module_ClassRef(panda3d.egg, EggNurbsSurface, EggNurbsSurface_localtype, EggNurbsSurface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggNurbsSurface = &Dtool_EggNurbsSurface;
static void Dtool_PyModuleClassInit_EggNurbsSurface(PyObject *module);
bool Dtool_ConstCoerce_EggNurbsSurface(PyObject *args, CPT(EggNurbsSurface) &coerced);
bool Dtool_Coerce_EggNurbsSurface(PyObject *args, PT(EggNurbsSurface) &coerced);

/**
 * Forward declarations for top-level class EggPatch
 */
typedef EggPatch EggPatch_localtype;
Define_Module_ClassRef(panda3d.egg, EggPatch, EggPatch_localtype, EggPatch);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPatch = &Dtool_EggPatch;
static void Dtool_PyModuleClassInit_EggPatch(PyObject *module);
bool Dtool_ConstCoerce_EggPatch(PyObject *args, CPT(EggPatch) &coerced);
bool Dtool_Coerce_EggPatch(PyObject *args, PT(EggPatch) &coerced);

/**
 * Forward declarations for top-level class EggPoint
 */
typedef EggPoint EggPoint_localtype;
Define_Module_ClassRef(panda3d.egg, EggPoint, EggPoint_localtype, EggPoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPoint = &Dtool_EggPoint;
static void Dtool_PyModuleClassInit_EggPoint(PyObject *module);
bool Dtool_ConstCoerce_EggPoint(PyObject *args, CPT(EggPoint) &coerced);
bool Dtool_Coerce_EggPoint(PyObject *args, PT(EggPoint) &coerced);

/**
 * Forward declarations for top-level class EggPolysetMaker
 */
typedef EggPolysetMaker EggPolysetMaker_localtype;
Define_Module_ClassRef(panda3d.egg, EggPolysetMaker, EggPolysetMaker_localtype, EggPolysetMaker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPolysetMaker = &Dtool_EggPolysetMaker;
static void Dtool_PyModuleClassInit_EggPolysetMaker(PyObject *module);

/**
 * Forward declarations for top-level class EggPoolUniquifier
 */
typedef EggPoolUniquifier EggPoolUniquifier_localtype;
Define_Module_ClassRef(panda3d.egg, EggPoolUniquifier, EggPoolUniquifier_localtype, EggPoolUniquifier);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPoolUniquifier = &Dtool_EggPoolUniquifier;
static void Dtool_PyModuleClassInit_EggPoolUniquifier(PyObject *module);

/**
 * Forward declarations for top-level class EggSAnimData
 */
typedef EggSAnimData EggSAnimData_localtype;
Define_Module_ClassRef(panda3d.egg, EggSAnimData, EggSAnimData_localtype, EggSAnimData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggSAnimData = &Dtool_EggSAnimData;
static void Dtool_PyModuleClassInit_EggSAnimData(PyObject *module);
bool Dtool_ConstCoerce_EggSAnimData(PyObject *args, CPT(EggSAnimData) &coerced);
bool Dtool_Coerce_EggSAnimData(PyObject *args, PT(EggSAnimData) &coerced);

/**
 * Forward declarations for top-level class EggTable
 */
typedef EggTable EggTable_localtype;
Define_Module_ClassRef(panda3d.egg, EggTable, EggTable_localtype, EggTable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTable = &Dtool_EggTable;
static void Dtool_PyModuleClassInit_EggTable(PyObject *module);
bool Dtool_ConstCoerce_EggTable(PyObject *args, CPT(EggTable) &coerced);
bool Dtool_Coerce_EggTable(PyObject *args, PT(EggTable) &coerced);

/**
 * Forward declarations for top-level class EggTextureCollection
 */
typedef EggTextureCollection EggTextureCollection_localtype;
Define_Module_Class(panda3d.egg, EggTextureCollection, EggTextureCollection_localtype, EggTextureCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTextureCollection = &Dtool_EggTextureCollection;
static void Dtool_PyModuleClassInit_EggTextureCollection(PyObject *module);

/**
 * Forward declarations for top-level class EggTriangleFan
 */
typedef EggTriangleFan EggTriangleFan_localtype;
Define_Module_ClassRef(panda3d.egg, EggTriangleFan, EggTriangleFan_localtype, EggTriangleFan);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTriangleFan = &Dtool_EggTriangleFan;
static void Dtool_PyModuleClassInit_EggTriangleFan(PyObject *module);
bool Dtool_ConstCoerce_EggTriangleFan(PyObject *args, CPT(EggTriangleFan) &coerced);
bool Dtool_Coerce_EggTriangleFan(PyObject *args, PT(EggTriangleFan) &coerced);

/**
 * Forward declarations for top-level class EggTriangleStrip
 */
typedef EggTriangleStrip EggTriangleStrip_localtype;
Define_Module_ClassRef(panda3d.egg, EggTriangleStrip, EggTriangleStrip_localtype, EggTriangleStrip);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTriangleStrip = &Dtool_EggTriangleStrip;
static void Dtool_PyModuleClassInit_EggTriangleStrip(PyObject *module);
bool Dtool_ConstCoerce_EggTriangleStrip(PyObject *args, CPT(EggTriangleStrip) &coerced);
bool Dtool_Coerce_EggTriangleStrip(PyObject *args, PT(EggTriangleStrip) &coerced);

/**
 * Forward declarations for top-level class EggXfmSAnim
 */
typedef EggXfmSAnim EggXfmSAnim_localtype;
Define_Module_ClassRef(panda3d.egg, EggXfmSAnim, EggXfmSAnim_localtype, EggXfmSAnim);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggXfmSAnim = &Dtool_EggXfmSAnim;
static void Dtool_PyModuleClassInit_EggXfmSAnim(PyObject *module);
bool Dtool_ConstCoerce_EggXfmSAnim(PyObject *args, CPT(EggXfmSAnim) &coerced);
bool Dtool_Coerce_EggXfmSAnim(PyObject *args, PT(EggXfmSAnim) &coerced);

/**
 * Forward declarations for top-level class EggXfmAnimData
 */
typedef EggXfmAnimData EggXfmAnimData_localtype;
Define_Module_ClassRef(panda3d.egg, EggXfmAnimData, EggXfmAnimData_localtype, EggXfmAnimData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggXfmAnimData = &Dtool_EggXfmAnimData;
static void Dtool_PyModuleClassInit_EggXfmAnimData(PyObject *module);
bool Dtool_ConstCoerce_EggXfmAnimData(PyObject *args, CPT(EggXfmAnimData) &coerced);
bool Dtool_Coerce_EggXfmAnimData(PyObject *args, PT(EggXfmAnimData) &coerced);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// istream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_istream;
#else
extern struct Dtool_PyTypedObject Dtool_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_istream = &Dtool_istream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// GlobPattern
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GlobPattern;
inline static bool Dtool_ConstCoerce_GlobPattern(PyObject *args, GlobPattern const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_GlobPattern != NULL, false);
  nassertr(Dtool_Ptr_GlobPattern->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, GlobPattern const *&, bool&))Dtool_Ptr_GlobPattern->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_GlobPattern != NULL, false);
  nassertr(Dtool_Ptr_GlobPattern->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, GlobPattern *&, bool&))Dtool_Ptr_GlobPattern->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_GlobPattern;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GlobPattern = &Dtool_GlobPattern;
extern bool Dtool_ConstCoerce_GlobPattern(PyObject *args, GlobPattern const *&coerced, bool &manage);
extern bool Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern *&coerced, bool &manage);
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// DSearchPath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DSearchPath;
inline static bool Dtool_ConstCoerce_DSearchPath(PyObject *args, DSearchPath const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_DSearchPath != NULL, false);
  nassertr(Dtool_Ptr_DSearchPath->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, DSearchPath const *&, bool&))Dtool_Ptr_DSearchPath->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_DSearchPath != NULL, false);
  nassertr(Dtool_Ptr_DSearchPath->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, DSearchPath *&, bool&))Dtool_Ptr_DSearchPath->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_DSearchPath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DSearchPath = &Dtool_DSearchPath;
extern bool Dtool_ConstCoerce_DSearchPath(PyObject *args, DSearchPath const *&coerced, bool &manage);
extern bool Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath *&coerced, bool &manage);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVecBase4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4d;
inline static LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced) {
  nassertr(Dtool_Ptr_LVecBase4d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4d *(*)(PyObject *, LVecBase4d &))Dtool_Ptr_LVecBase4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4d = &Dtool_LVecBase4d;
extern LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced);
#endif
// LPoint3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3d;
inline static LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced) {
  nassertr(Dtool_Ptr_LPoint3d != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3d->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3d *(*)(PyObject *, LPoint3d &))Dtool_Ptr_LPoint3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3d = &Dtool_LPoint3d;
extern LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced);
#endif
// LMatrix3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix3d;
inline static LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced) {
  nassertr(Dtool_Ptr_LMatrix3d != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix3d->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix3d *(*)(PyObject *, LMatrix3d &))Dtool_Ptr_LMatrix3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3d = &Dtool_LMatrix3d;
extern LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced);
#endif
// LMatrix4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4d;
inline static LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced) {
  nassertr(Dtool_Ptr_LMatrix4d != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4d->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4d *(*)(PyObject *, LMatrix4d &))Dtool_Ptr_LMatrix4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d = &Dtool_LMatrix4d;
extern LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced);
#endif
// LVecBase2d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2d;
inline static LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced) {
  nassertr(Dtool_Ptr_LVecBase2d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2d *(*)(PyObject *, LVecBase2d &))Dtool_Ptr_LVecBase2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2d = &Dtool_LVecBase2d;
extern LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced);
#endif
// LVecBase3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3d;
inline static LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced) {
  nassertr(Dtool_Ptr_LVecBase3d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3d *(*)(PyObject *, LVecBase3d &))Dtool_Ptr_LVecBase3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3d = &Dtool_LVecBase3d;
extern LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced);
#endif
// LVector2d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector2d;
inline static LVector2d *Dtool_Coerce_LVector2d(PyObject *args, LVector2d &coerced) {
  nassertr(Dtool_Ptr_LVector2d != NULL, NULL);
  nassertr(Dtool_Ptr_LVector2d->_Dtool_Coerce != NULL, NULL);
  return ((LVector2d *(*)(PyObject *, LVector2d &))Dtool_Ptr_LVector2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2d = &Dtool_LVector2d;
extern LVector2d *Dtool_Coerce_LVector2d(PyObject *args, LVector2d &coerced);
#endif
// LVector3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3d;
inline static LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced) {
  nassertr(Dtool_Ptr_LVector3d != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3d->_Dtool_Coerce != NULL, NULL);
  return ((LVector3d *(*)(PyObject *, LVector3d &))Dtool_Ptr_LVector3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3d = &Dtool_LVector3d;
extern LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced);
#endif
// LPoint2d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint2d;
inline static LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced) {
  nassertr(Dtool_Ptr_LPoint2d != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint2d->_Dtool_Coerce != NULL, NULL);
  return ((LPoint2d *(*)(PyObject *, LPoint2d &))Dtool_Ptr_LPoint2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2d = &Dtool_LPoint2d;
extern LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced);
#endif
// LQuaterniond
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LQuaterniond;
inline static LQuaterniond *Dtool_Coerce_LQuaterniond(PyObject *args, LQuaterniond &coerced) {
  nassertr(Dtool_Ptr_LQuaterniond != NULL, NULL);
  nassertr(Dtool_Ptr_LQuaterniond->_Dtool_Coerce != NULL, NULL);
  return ((LQuaterniond *(*)(PyObject *, LQuaterniond &))Dtool_Ptr_LQuaterniond->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaterniond;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaterniond = &Dtool_LQuaterniond;
extern LQuaterniond *Dtool_Coerce_LQuaterniond(PyObject *args, LQuaterniond &coerced);
#endif
// LPoint4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint4d;
inline static LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced) {
  nassertr(Dtool_Ptr_LPoint4d != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint4d->_Dtool_Coerce != NULL, NULL);
  return ((LPoint4d *(*)(PyObject *, LPoint4d &))Dtool_Ptr_LPoint4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint4d = &Dtool_LPoint4d;
extern LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced);
#endif
// BamCacheRecord
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_BamCacheRecord;
#else
extern struct Dtool_PyTypedObject Dtool_BamCacheRecord;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamCacheRecord = &Dtool_BamCacheRecord;
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_BitMask_uint32_t_32;
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != NULL, NULL);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != NULL, NULL);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class EggUserData
 */
/**
 * Python function wrapper for:
 * inline EggUserData &EggUserData::operator =(EggUserData const &copy)
 */
static PyObject *Dtool_EggUserData_operator_4(PyObject *self, PyObject *arg) {
  EggUserData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggUserData, (void **)&local_this, "EggUserData.assign")) {
    return NULL;
  }
  // 1-inline EggUserData &EggUserData::operator =(EggUserData const &copy)
  EggUserData const *arg_this = (EggUserData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggUserData, 1, "EggUserData.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    EggUserData *return_value = local_this;
    if (return_value != (EggUserData *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggUserData *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggUserData, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggUserData self, const EggUserData copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggUserData_operator_4_comment =
  "C++ Interface:\n"
  "assign(const EggUserData self, const EggUserData copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggUserData_operator_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggUserData::get_class_type(void)
 */
static PyObject *Dtool_EggUserData_get_class_type_5(PyObject *, PyObject *) {
  // 1-static TypeHandle EggUserData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggUserData::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggUserData_get_class_type_5_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggUserData_get_class_type_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggUserData::EggUserData(void)
 * inline EggUserData::EggUserData(EggUserData const &copy)
 */
static int Dtool_Init_EggUserData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggUserData::EggUserData(void)
      EggUserData *return_value = new EggUserData();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggUserData, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline EggUserData::EggUserData(EggUserData const &copy)
      EggUserData const *arg_this = (EggUserData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggUserData, 0, "EggUserData.EggUserData", true, true);
      if (arg_this != NULL) {
        EggUserData *return_value = new EggUserData(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggUserData, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggUserData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggUserData()\n"
      "EggUserData(const EggUserData copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggUserData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggUserData) {
    printf("EggUserData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggUserData *local_this = (EggUserData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggUserData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggUserData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggUserData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggUserData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggUserData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggUserData*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggObject
 */
/**
 * Python function wrapper for:
 * EggObject &EggObject::operator =(EggObject const &copy)
 */
static PyObject *Dtool_EggObject_operator_8(PyObject *self, PyObject *arg) {
  EggObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggObject, (void **)&local_this, "EggObject.assign")) {
    return NULL;
  }
  // 1-EggObject &EggObject::operator =(EggObject const &copy)
  EggObject const *arg_this = (EggObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggObject, 1, "EggObject.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    EggObject *return_value = local_this;
    if (return_value != (EggObject *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggObject *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggObject, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggObject self, const EggObject copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggObject_operator_8_comment =
  "C++ Interface:\n"
  "assign(const EggObject self, const EggObject copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggObject_operator_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggObject::set_user_data(EggUserData *user_data)
 */
static PyObject *Dtool_EggObject_set_user_data_9(PyObject *self, PyObject *arg) {
  EggObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggObject, (void **)&local_this, "EggObject.set_user_data")) {
    return NULL;
  }
  // 1-void EggObject::set_user_data(EggUserData *user_data)
  EggUserData *arg_this = (EggUserData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggUserData, 1, "EggObject.set_user_data", false, true);
  if (arg_this != NULL) {
    (*local_this).set_user_data(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_user_data(const EggObject self, EggUserData user_data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggObject_set_user_data_9_comment =
  "C++ Interface:\n"
  "set_user_data(const EggObject self, EggUserData user_data)\n"
  "\n"
  "/**\n"
  " * Sets the user data associated with this object.  This may be any\n"
  " * EggUserData-derived object.  The egg library will do nothing with this\n"
  " * pointer, except to hold its reference count and return the pointer on\n"
  " * request.\n"
  " *\n"
  " * The EggObject maintains multiple different EggUserData pointers, one for\n"
  " * each unique type (as reported by get_type()).  If you know that only one\n"
  " * type of EggUserData object will be added in your application, you may use\n"
  " * the query functions that accept no parameters, but it is recommended that\n"
  " * in general you pass in the type of your particular user data, to allow\n"
  " * multiple applications to coexist in the same egg data.\n"
  " *\n"
  " * This pointer is also copied by the copy assignment operator and copy\n"
  " * constructor.\n"
  " */";
#else
static const char *Dtool_EggObject_set_user_data_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggUserData *EggObject::get_user_data(void) const
 * EggUserData *EggObject::get_user_data(TypeHandle type) const
 */
static PyObject *Dtool_EggObject_get_user_data_10(PyObject *self, PyObject *args) {
  EggObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggObject, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-EggUserData *EggObject::get_user_data(void) const
      EggUserData *return_value = (*(const EggObject*)local_this).get_user_data();
      if (return_value != (EggUserData *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (EggUserData *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggUserData, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-EggUserData *EggObject::get_user_data(TypeHandle type) const
      TypeHandle arg_local;
      TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "EggObject.get_user_data", "TypeHandle");
      }
      EggUserData *return_value = (*(const EggObject*)local_this).get_user_data(*arg_this);
      if (return_value != (EggUserData *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (EggUserData *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggUserData, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_user_data() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_user_data(EggObject self)\n"
      "get_user_data(EggObject self, TypeHandle type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggObject_get_user_data_10_comment =
  "C++ Interface:\n"
  "get_user_data(EggObject self)\n"
  "get_user_data(EggObject self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Returns the user data pointer most recently stored on this object, or NULL\n"
  " * if nothing was previously stored.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the user data pointer of the indicated type, if it exists, or NULL\n"
  " * if it does not.\n"
  " */";
#else
static const char *Dtool_EggObject_get_user_data_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggObject::has_user_data(void) const
 * bool EggObject::has_user_data(TypeHandle type) const
 */
static PyObject *Dtool_EggObject_has_user_data_11(PyObject *self, PyObject *args) {
  EggObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggObject, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-bool EggObject::has_user_data(void) const
      bool return_value = (*(const EggObject*)local_this).has_user_data();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool EggObject::has_user_data(TypeHandle type) const
      TypeHandle arg_local;
      TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "EggObject.has_user_data", "TypeHandle");
      }
      bool return_value = (*(const EggObject*)local_this).has_user_data(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_user_data() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_user_data(EggObject self)\n"
      "has_user_data(EggObject self, TypeHandle type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggObject_has_user_data_11_comment =
  "C++ Interface:\n"
  "has_user_data(EggObject self)\n"
  "has_user_data(EggObject self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Returns true if a generic user data pointer has recently been set and not\n"
  " * yet cleared, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the user data pointer of the indicated type has been set,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EggObject_has_user_data_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggObject::clear_user_data(void)
 * void EggObject::clear_user_data(TypeHandle type)
 */
static PyObject *Dtool_EggObject_clear_user_data_12(PyObject *self, PyObject *args) {
  EggObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggObject, (void **)&local_this, "EggObject.clear_user_data")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void EggObject::clear_user_data(void)
      (*local_this).clear_user_data();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void EggObject::clear_user_data(TypeHandle type)
      TypeHandle arg_local;
      TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "EggObject.clear_user_data", "TypeHandle");
      }
      (*local_this).clear_user_data(*arg_this);
      return Dtool_Return_None();
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_user_data() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_user_data(const EggObject self)\n"
      "clear_user_data(const EggObject self, TypeHandle type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggObject_clear_user_data_12_comment =
  "C++ Interface:\n"
  "clear_user_data(const EggObject self)\n"
  "clear_user_data(const EggObject self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Removes *all* user data pointers from the node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the user data pointer of the indicated type.\n"
  " */";
#else
static const char *Dtool_EggObject_clear_user_data_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggObject::get_class_type(void)
 */
static PyObject *Dtool_EggObject_get_class_type_13(PyObject *, PyObject *) {
  // 1-static TypeHandle EggObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggObject::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggObject_get_class_type_13_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggObject_get_class_type_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggNamedObject *EggObject::downcast_to_EggNamedObject(void)
 */
static PyObject *Dtool_EggObject_downcast_to_EggNamedObject_16(PyObject *self, PyObject *) {
  EggObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggObject, (void **)&local_this, "EggObject.downcast_to_EggNamedObject")) {
    return NULL;
  }
  // 1-EggNamedObject *EggObject::downcast_to_EggNamedObject(void)
  EggNamedObject *return_value = (EggNamedObject *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNamedObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggObject_downcast_to_EggNamedObject_16_comment =
  "C++ Interface:\n"
  "downcast_to_EggNamedObject(const EggObject self)\n"
  "\n"
  "downcast from EggObject to EggNamedObject";
#else
static const char *Dtool_EggObject_downcast_to_EggNamedObject_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggObject::downcast_to_EggVertex(void)
 */
static PyObject *Dtool_EggObject_downcast_to_EggVertex_162(PyObject *self, PyObject *) {
  EggObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggObject, (void **)&local_this, "EggObject.downcast_to_EggVertex")) {
    return NULL;
  }
  // 1-EggVertex *EggObject::downcast_to_EggVertex(void)
  EggVertex *return_value = (EggVertex *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggObject_downcast_to_EggVertex_162_comment =
  "C++ Interface:\n"
  "downcast_to_EggVertex(const EggObject self)\n"
  "\n"
  "downcast from EggObject to EggVertex";
#else
static const char *Dtool_EggObject_downcast_to_EggVertex_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggObject::EggObject(void)
 * EggObject::EggObject(EggObject const &copy)
 */
static int Dtool_Init_EggObject(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggObject::EggObject(void)
      EggObject *return_value = new EggObject();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggObject, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-EggObject::EggObject(EggObject const &copy)
      EggObject const *arg_this = (EggObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggObject, 0, "EggObject.EggObject", true, true);
      if (arg_this != NULL) {
        EggObject *return_value = new EggObject(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggObject, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggObject() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggObject()\n"
      "EggObject(const EggObject copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggObject) {
    printf("EggObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggObject *local_this = (EggObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggObject*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggNamedObject
 */
/**
 * Python function wrapper for:
 * inline EggNamedObject &EggNamedObject::operator =(EggNamedObject const &copy)
 */
static PyObject *Dtool_EggNamedObject_operator_21(PyObject *self, PyObject *arg) {
  EggNamedObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNamedObject, (void **)&local_this, "EggNamedObject.assign")) {
    return NULL;
  }
  // 1-inline EggNamedObject &EggNamedObject::operator =(EggNamedObject const &copy)
  CPT(EggNamedObject) arg_this;
  if (!Dtool_ConstCoerce_EggNamedObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggNamedObject.assign", "EggNamedObject");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggNamedObject *return_value = local_this;
  if (return_value != (EggNamedObject *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggNamedObject *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNamedObject, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggNamedObject self, const EggNamedObject copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNamedObject_operator_21_comment =
  "C++ Interface:\n"
  "assign(const EggNamedObject self, const EggNamedObject copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNamedObject_operator_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggNamedObject::output(ostream &out) const
 */
static PyObject *Dtool_EggNamedObject_output_22(PyObject *self, PyObject *arg) {
  EggNamedObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNamedObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggNamedObject::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "EggNamedObject.output", false, true);
  if (arg_this != NULL) {
    (*(const EggNamedObject*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(EggNamedObject self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNamedObject_output_22_comment =
  "C++ Interface:\n"
  "output(EggNamedObject self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNamedObject_output_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggNamedObject::get_class_type(void)
 */
static PyObject *Dtool_EggNamedObject_get_class_type_23(PyObject *, PyObject *) {
  // 1-static TypeHandle EggNamedObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggNamedObject::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNamedObject_get_class_type_23_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggNamedObject_get_class_type_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggObject *EggNamedObject::upcast_to_EggObject(void)
 */
static PyObject *Dtool_EggNamedObject_upcast_to_EggObject_15(PyObject *self, PyObject *) {
  EggNamedObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNamedObject, (void **)&local_this, "EggNamedObject.upcast_to_EggObject")) {
    return NULL;
  }
  // 1-EggObject *EggNamedObject::upcast_to_EggObject(void)
  EggObject *return_value = (EggObject *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggNamedObject_upcast_to_EggObject_15_comment =
  "C++ Interface:\n"
  "upcast_to_EggObject(const EggNamedObject self)\n"
  "\n"
  "upcast from EggNamedObject to EggObject";
#else
static const char *Dtool_EggNamedObject_upcast_to_EggObject_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Namable *EggNamedObject::upcast_to_Namable(void)
 */
static PyObject *Dtool_EggNamedObject_upcast_to_Namable_18(PyObject *self, PyObject *) {
  EggNamedObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNamedObject, (void **)&local_this, "EggNamedObject.upcast_to_Namable")) {
    return NULL;
  }
  // 1-Namable *EggNamedObject::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNamedObject_upcast_to_Namable_18_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const EggNamedObject self)\n"
  "\n"
  "upcast from EggNamedObject to Namable";
#else
static const char *Dtool_EggNamedObject_upcast_to_Namable_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggNamedObject::EggNamedObject(EggNamedObject const &copy)
 * inline EggNamedObject::EggNamedObject(std::string const &name = "")
 */
static int Dtool_Init_EggNamedObject(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggNamedObject::EggNamedObject(std::string const &name)
      EggNamedObject *return_value = new EggNamedObject();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNamedObject, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggNamedObject::EggNamedObject(EggNamedObject const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggNamedObject", (char **)keyword_list, &param0)) {
          EggNamedObject const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggNamedObject, (void **)&param0_this);
          if (param0_this != NULL) {
            EggNamedObject *return_value = new EggNamedObject(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNamedObject, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggNamedObject::EggNamedObject(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggNamedObject", (char **)keyword_list, &param0_str, &param0_len)) {
          EggNamedObject *return_value = new EggNamedObject(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNamedObject, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggNamedObject::EggNamedObject(EggNamedObject const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggNamedObject", (char **)keyword_list, &param0)) {
          CPT(EggNamedObject) param0_this;
          if (Dtool_ConstCoerce_EggNamedObject(param0, param0_this)) {
            EggNamedObject *return_value = new EggNamedObject(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNamedObject, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggNamedObject::EggNamedObject(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggNamedObject() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggNamedObject()\n"
      "EggNamedObject(const EggNamedObject copy)\n"
      "EggNamedObject(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggNamedObject(PyObject *args, CPT(EggNamedObject) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggNamedObject, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggNamedObject::EggNamedObject(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggNamedObject *return_value = new EggNamedObject(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_EggNamedObject(PyObject *args, PT(EggNamedObject) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggNamedObject, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggNamedObject::EggNamedObject(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggNamedObject *return_value = new EggNamedObject(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_EggNamedObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggNamedObject) {
    printf("EggNamedObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggNamedObject *local_this = (EggNamedObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggNamedObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggNamedObject*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggNamedObject*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggNamedObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggNamedObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggNamedObject*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggNode
 */
/**
 * Python function wrapper for:
 * inline EggNode &EggNode::operator =(EggNode const &copy)
 */
static PyObject *Dtool_EggNode_operator_26(PyObject *self, PyObject *arg) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.assign")) {
    return NULL;
  }
  // 1-inline EggNode &EggNode::operator =(EggNode const &copy)
  CPT(EggNode) arg_this;
  if (!Dtool_ConstCoerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggNode.assign", "EggNode");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggNode *return_value = local_this;
  if (return_value != (EggNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggNode self, const EggNode copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNode_operator_26_comment =
  "C++ Interface:\n"
  "assign(const EggNode self, const EggNode copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNode_operator_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggGroupNode *EggNode::get_parent(void) const
 */
static PyObject *Dtool_EggNode_get_parent_27(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggGroupNode *EggNode::get_parent(void) const
  EggGroupNode *return_value = (*(const EggNode*)local_this).get_parent();
  if (return_value != (EggGroupNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggGroupNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroupNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_parent_27_comment =
  "C++ Interface:\n"
  "get_parent(EggNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNode_get_parent_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNode::get_depth(void) const
 */
static PyObject *Dtool_EggNode_get_depth_28(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNode::get_depth(void) const
  int return_value = (*(const EggNode*)local_this).get_depth();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_depth_28_comment =
  "C++ Interface:\n"
  "get_depth(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of nodes above this node in the egg hierarchy.\n"
  " */";
#else
static const char *Dtool_EggNode_get_depth_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggNode::is_under_instance(void) const
 */
static PyObject *Dtool_EggNode_is_under_instance_29(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggNode::is_under_instance(void) const
  bool return_value = (*(const EggNode*)local_this).is_under_instance();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_is_under_instance_29_comment =
  "C++ Interface:\n"
  "is_under_instance(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is an <Instance> node somewhere in the egg tree at or\n"
  " * above this node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_is_under_instance_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggNode::is_under_transform(void) const
 */
static PyObject *Dtool_EggNode_is_under_transform_30(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggNode::is_under_transform(void) const
  bool return_value = (*(const EggNode*)local_this).is_under_transform();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_is_under_transform_30_comment =
  "C++ Interface:\n"
  "is_under_transform(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a <Transform> entry somewhere in the egg tree at\n"
  " * or above this node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_is_under_transform_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggNode::is_local_coord(void) const
 */
static PyObject *Dtool_EggNode_is_local_coord_31(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggNode::is_local_coord(void) const
  bool return_value = (*(const EggNode*)local_this).is_local_coord();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_is_local_coord_31_comment =
  "C++ Interface:\n"
  "is_local_coord(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if this node's vertices are not in the global coordinate\n"
  " * space.  This will be the case if there was an <Instance> node under a\n"
  " * transform at or above this node.\n"
  " */";
#else
static const char *Dtool_EggNode_is_local_coord_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_vertex_frame(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_frame_32(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const &EggNode::get_vertex_frame(void) const
  LMatrix4d const *return_value = &((*(const EggNode*)local_this).get_vertex_frame());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_frame_32_comment =
  "C++ Interface:\n"
  "get_vertex_frame(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate frame of the vertices referenced by primitives at or\n"
  " * under this node.  This is not the same as get_node_frame().\n"
  " *\n"
  " * Generally, vertices in an egg file are stored in the global coordinate\n"
  " * space, regardless of the transforms defined at each node.  Thus,\n"
  " * get_vertex_frame() will usually return the identity transform (global\n"
  " * coordinate space).  However, primitives under an <Instance> entry reference\n"
  " * their vertices in the coordinate system under effect at the time of the\n"
  " * <Instance>.  Thus, nodes under an <Instance> entry may return this non-\n"
  " * identity matrix.\n"
  " *\n"
  " * Specifically, this may return a non-identity matrix only if\n"
  " * is_local_coord() is true.\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_frame_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_node_frame(void) const
 */
static PyObject *Dtool_EggNode_get_node_frame_33(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const &EggNode::get_node_frame(void) const
  LMatrix4d const *return_value = &((*(const EggNode*)local_this).get_node_frame());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_frame_33_comment =
  "C++ Interface:\n"
  "get_node_frame(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate frame of the node itself.  This is simply the net\n"
  " * product of all transformations up to the root.\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_frame_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_vertex_frame_inv(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_frame_inv_34(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const &EggNode::get_vertex_frame_inv(void) const
  LMatrix4d const *return_value = &((*(const EggNode*)local_this).get_vertex_frame_inv());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_frame_inv_34_comment =
  "C++ Interface:\n"
  "get_vertex_frame_inv(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the inverse of the matrix returned by get_vertex_frame().  See\n"
  " * get_vertex_frame().\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_frame_inv_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_node_frame_inv(void) const
 */
static PyObject *Dtool_EggNode_get_node_frame_inv_35(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const &EggNode::get_node_frame_inv(void) const
  LMatrix4d const *return_value = &((*(const EggNode*)local_this).get_node_frame_inv());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_frame_inv_35_comment =
  "C++ Interface:\n"
  "get_node_frame_inv(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the inverse of the matrix returned by get_node_frame().  See\n"
  " * get_node_frame().\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_frame_inv_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_vertex_to_node(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_to_node_36(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const &EggNode::get_vertex_to_node(void) const
  LMatrix4d const *return_value = &((*(const EggNode*)local_this).get_vertex_to_node());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_to_node_36_comment =
  "C++ Interface:\n"
  "get_vertex_to_node(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the transformation matrix suitable for converting the vertices as\n"
  " * read from the egg file into the coordinate space of the node.  This is the\n"
  " * same thing as:\n"
  " *\n"
  " * get_vertex_frame() * get_node_frame_inv()\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_to_node_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_node_to_vertex(void) const
 */
static PyObject *Dtool_EggNode_get_node_to_vertex_37(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const &EggNode::get_node_to_vertex(void) const
  LMatrix4d const *return_value = &((*(const EggNode*)local_this).get_node_to_vertex());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_to_vertex_37_comment =
  "C++ Interface:\n"
  "get_node_to_vertex(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the transformation matrix suitable for converting vertices in the\n"
  " * coordinate space of the node to the appropriate coordinate space for\n"
  " * storing in the egg file.  This is the same thing as:\n"
  " *\n"
  " * get_node_frame() * get_vertex_frame_inv()\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_to_vertex_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_vertex_frame_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_frame_ptr_38(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const *EggNode::get_vertex_frame_ptr(void) const
  LMatrix4d const *return_value = (*(const EggNode*)local_this).get_vertex_frame_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_frame_ptr_38_comment =
  "C++ Interface:\n"
  "get_vertex_frame_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_vertex_frame() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_frame_ptr_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_node_frame_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_node_frame_ptr_39(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const *EggNode::get_node_frame_ptr(void) const
  LMatrix4d const *return_value = (*(const EggNode*)local_this).get_node_frame_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_frame_ptr_39_comment =
  "C++ Interface:\n"
  "get_node_frame_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_node_frame() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_frame_ptr_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_vertex_frame_inv_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_frame_inv_ptr_40(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const *EggNode::get_vertex_frame_inv_ptr(void) const
  LMatrix4d const *return_value = (*(const EggNode*)local_this).get_vertex_frame_inv_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_frame_inv_ptr_40_comment =
  "C++ Interface:\n"
  "get_vertex_frame_inv_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_vertex_frame_inv() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_frame_inv_ptr_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_node_frame_inv_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_node_frame_inv_ptr_41(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const *EggNode::get_node_frame_inv_ptr(void) const
  LMatrix4d const *return_value = (*(const EggNode*)local_this).get_node_frame_inv_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_frame_inv_ptr_41_comment =
  "C++ Interface:\n"
  "get_node_frame_inv_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_node_frame_inv() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_frame_inv_ptr_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_vertex_to_node_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_to_node_ptr_42(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const *EggNode::get_vertex_to_node_ptr(void) const
  LMatrix4d const *return_value = (*(const EggNode*)local_this).get_vertex_to_node_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_to_node_ptr_42_comment =
  "C++ Interface:\n"
  "get_vertex_to_node_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_vertex_to_node() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_to_node_ptr_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_node_to_vertex_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_node_to_vertex_ptr_43(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const *EggNode::get_node_to_vertex_ptr(void) const
  LMatrix4d const *return_value = (*(const EggNode*)local_this).get_node_to_vertex_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_to_vertex_ptr_43_comment =
  "C++ Interface:\n"
  "get_node_to_vertex_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_node_to_vertex() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_to_vertex_ptr_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggNode::transform(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggNode_transform_44(PyObject *self, PyObject *arg) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.transform")) {
    return NULL;
  }
  // 1-inline void EggNode::transform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggNode.transform", "LMatrix4d");
  }
  (*local_this).transform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggNode self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNode_transform_44_comment =
  "C++ Interface:\n"
  "transform(const EggNode self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation to the node and all of its\n"
  " * descendants.\n"
  " */";
#else
static const char *Dtool_EggNode_transform_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggNode::transform_vertices_only(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggNode_transform_vertices_only_45(PyObject *self, PyObject *arg) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.transform_vertices_only")) {
    return NULL;
  }
  // 1-inline void EggNode::transform_vertices_only(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggNode.transform_vertices_only", "LMatrix4d");
  }
  (*local_this).transform_vertices_only(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform_vertices_only(const EggNode self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNode_transform_vertices_only_45_comment =
  "C++ Interface:\n"
  "transform_vertices_only(const EggNode self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation only to vertices that appear in global\n"
  " * space within vertex pools at this node and below.  Joints and other\n"
  " * transforms are not affected, nor are local vertices.\n"
  " */";
#else
static const char *Dtool_EggNode_transform_vertices_only_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggNode::flatten_transforms(void)
 */
static PyObject *Dtool_EggNode_flatten_transforms_46(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.flatten_transforms")) {
    return NULL;
  }
  // 1-inline void EggNode::flatten_transforms(void)
  (*local_this).flatten_transforms();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggNode_flatten_transforms_46_comment =
  "C++ Interface:\n"
  "flatten_transforms(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Removes any transform and instance records from this node in the scene\n"
  " * graph and below.  If an instance node is encountered, removes the instance\n"
  " * and applies the transform to its vertices, duplicating vertices if\n"
  " * necessary.\n"
  " *\n"
  " * Since this function may result in duplicated vertices, it may be a good\n"
  " * idea to call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggNode_flatten_transforms_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggNode::apply_texmats(void)
 */
static PyObject *Dtool_EggNode_apply_texmats_47(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.apply_texmats")) {
    return NULL;
  }
  // 1-void EggNode::apply_texmats(void)
  (*local_this).apply_texmats();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggNode_apply_texmats_47_comment =
  "C++ Interface:\n"
  "apply_texmats(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Applies the texture matrices to the UV's of the vertices that reference\n"
  " * them, and then removes the texture matrices from the textures themselves.\n"
  " */";
#else
static const char *Dtool_EggNode_apply_texmats_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggNode::is_joint(void) const
 */
static PyObject *Dtool_EggNode_is_joint_49(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool EggNode::is_joint(void) const
  bool return_value = (*(const EggNode*)local_this).is_joint();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_is_joint_49_comment =
  "C++ Interface:\n"
  "is_joint(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular node represents a <Joint> entry or not.\n"
  " * This is a handy thing to know since Joints are sorted to the end of their\n"
  " * sibling list when writing an egg file.  See EggGroupNode::write().\n"
  " */";
#else
static const char *Dtool_EggNode_is_joint_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggNode::is_anim_matrix(void) const
 */
static PyObject *Dtool_EggNode_is_anim_matrix_50(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool EggNode::is_anim_matrix(void) const
  bool return_value = (*(const EggNode*)local_this).is_anim_matrix();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_is_anim_matrix_50_comment =
  "C++ Interface:\n"
  "is_anim_matrix(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if this node represents a table of animation transformation\n"
  " * data, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_is_anim_matrix_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_alpha_mode(void)
 */
static PyObject *Dtool_EggNode_determine_alpha_mode_51(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_alpha_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggNode::determine_alpha_mode(void)
  EggRenderMode *return_value = (*local_this).determine_alpha_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_alpha_mode_51_comment =
  "C++ Interface:\n"
  "determine_alpha_mode(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has an alpha_mode\n"
  " * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is\n"
  " * found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_alpha_mode_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_depth_write_mode(void)
 */
static PyObject *Dtool_EggNode_determine_depth_write_mode_52(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_depth_write_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggNode::determine_depth_write_mode(void)
  EggRenderMode *return_value = (*local_this).determine_depth_write_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_depth_write_mode_52_comment =
  "C++ Interface:\n"
  "determine_depth_write_mode(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_depth_write_mode_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_depth_test_mode(void)
 */
static PyObject *Dtool_EggNode_determine_depth_test_mode_53(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_depth_test_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggNode::determine_depth_test_mode(void)
  EggRenderMode *return_value = (*local_this).determine_depth_test_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_depth_test_mode_53_comment =
  "C++ Interface:\n"
  "determine_depth_test_mode(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_depth_test_mode_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_visibility_mode(void)
 */
static PyObject *Dtool_EggNode_determine_visibility_mode_54(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_visibility_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggNode::determine_visibility_mode(void)
  EggRenderMode *return_value = (*local_this).determine_visibility_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_visibility_mode_54_comment =
  "C++ Interface:\n"
  "determine_visibility_mode(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_visibility_mode_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_depth_offset(void)
 */
static PyObject *Dtool_EggNode_determine_depth_offset_55(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_depth_offset")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggNode::determine_depth_offset(void)
  EggRenderMode *return_value = (*local_this).determine_depth_offset();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_depth_offset_55_comment =
  "C++ Interface:\n"
  "determine_depth_offset(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a depth_offset\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_depth_offset_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_draw_order(void)
 */
static PyObject *Dtool_EggNode_determine_draw_order_56(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_draw_order")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggNode::determine_draw_order(void)
  EggRenderMode *return_value = (*local_this).determine_draw_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_draw_order_56_comment =
  "C++ Interface:\n"
  "determine_draw_order(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a draw_order\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_draw_order_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_bin(void)
 */
static PyObject *Dtool_EggNode_determine_bin_57(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_bin")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggNode::determine_bin(void)
  EggRenderMode *return_value = (*local_this).determine_bin();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_bin_57_comment =
  "C++ Interface:\n"
  "determine_bin(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a bin specified.\n"
  " * Returns a valid EggRenderMode pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_bin_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggNode::determine_indexed(void)
 */
static PyObject *Dtool_EggNode_determine_indexed_58(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_indexed")) {
    return NULL;
  }
  // 1-virtual bool EggNode::determine_indexed(void)
  bool return_value = (*local_this).determine_indexed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_indexed_58_comment =
  "C++ Interface:\n"
  "determine_indexed(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup at this level or above\n"
  " * that has the \"indexed\" scalar set.  Returns the value of the indexed scalar\n"
  " * if it is found, or false if it is not.\n"
  " *\n"
  " * In other words, returns true if the \"indexed\" flag is in effect for the\n"
  " * indicated node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_indexed_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggNode::determine_decal(void)
 */
static PyObject *Dtool_EggNode_determine_decal_59(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_decal")) {
    return NULL;
  }
  // 1-virtual bool EggNode::determine_decal(void)
  bool return_value = (*local_this).determine_decal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_decal_59_comment =
  "C++ Interface:\n"
  "determine_decal(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup at this level or above\n"
  " * that has the \"decal\" flag set.  Returns the value of the decal flag if it\n"
  " * is found, or false if it is not.\n"
  " *\n"
  " * In other words, returns true if the \"decal\" flag is in effect for the\n"
  " * indicated node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_decal_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggNode::write(ostream &out, int indent_level) const = 0
 */
static PyObject *Dtool_EggNode_write_60(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void EggNode::write(ostream &out, int indent_level) const = 0
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggNode.write", false, true);
    if (param1_this != NULL) {
      (*(const EggNode*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggNode self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNode_write_60_comment =
  "C++ Interface:\n"
  "write(EggNode self, ostream out, int indent_level)\n";
#else
static const char *Dtool_EggNode_write_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggNode::parse_egg(std::string const &egg_syntax)
 */
static PyObject *Dtool_EggNode_parse_egg_61(PyObject *self, PyObject *arg) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.parse_egg")) {
    return NULL;
  }
  // 1-bool EggNode::parse_egg(std::string const &egg_syntax)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).parse_egg(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "parse_egg(const EggNode self, str egg_syntax)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNode_parse_egg_61_comment =
  "C++ Interface:\n"
  "parse_egg(const EggNode self, str egg_syntax)\n"
  "\n"
  "/**\n"
  " * Parses the egg syntax given in the indicate string as if it had been read\n"
  " * from the egg file within this object's definition.  Updates the object\n"
  " * accordingly.  Returns true if successful, false if there was some parse\n"
  " * error or if the object does not support this functionality.\n"
  " */";
#else
static const char *Dtool_EggNode_parse_egg_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggNode::test_under_integrity(void) const
 */
static PyObject *Dtool_EggNode_test_under_integrity_62(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggNode::test_under_integrity(void) const
  (*(const EggNode*)local_this).test_under_integrity();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggNode_test_under_integrity_62_comment =
  "C++ Interface:\n"
  "test_under_integrity(EggNode self)\n";
#else
static const char *Dtool_EggNode_test_under_integrity_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggNode::get_class_type(void)
 */
static PyObject *Dtool_EggNode_get_class_type_63(PyObject *, PyObject *) {
  // 1-static TypeHandle EggNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_class_type_63_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggNode_get_class_type_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggPrimitive *EggNode::downcast_to_EggPrimitive(void)
 */
static PyObject *Dtool_EggNode_downcast_to_EggPrimitive_842(PyObject *self, PyObject *) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.downcast_to_EggPrimitive")) {
    return NULL;
  }
  // 1-EggPrimitive *EggNode::downcast_to_EggPrimitive(void)
  EggPrimitive *return_value = (EggPrimitive *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPrimitive, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggNode_downcast_to_EggPrimitive_842_comment =
  "C++ Interface:\n"
  "downcast_to_EggPrimitive(const EggNode self)\n"
  "\n"
  "downcast from EggNode to EggPrimitive";
#else
static const char *Dtool_EggNode_downcast_to_EggPrimitive_842_comment = NULL;
#endif

static int Dtool_Init_EggNode(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggNode(PyObject *args, CPT(EggNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggNode(PyObject *args, PT(EggNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggNode) {
    printf("EggNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggNode *local_this = (EggNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggNode*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggAnimData
 */
/**
 * Python function wrapper for:
 * inline EggAnimData &EggAnimData::operator =(EggAnimData const &copy)
 */
static PyObject *Dtool_EggAnimData_operator_66(PyObject *self, PyObject *arg) {
  EggAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.assign")) {
    return NULL;
  }
  // 1-inline EggAnimData &EggAnimData::operator =(EggAnimData const &copy)
  CPT(EggAnimData) arg_this;
  if (!Dtool_ConstCoerce_EggAnimData(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggAnimData.assign", "EggAnimData");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggAnimData *return_value = local_this;
  if (return_value != (EggAnimData *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggAnimData *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggAnimData, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggAnimData self, const EggAnimData copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_operator_66_comment =
  "C++ Interface:\n"
  "assign(const EggAnimData self, const EggAnimData copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimData_operator_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimData::set_fps(double type)
 */
static PyObject *Dtool_EggAnimData_set_fps_67(PyObject *self, PyObject *arg) {
  EggAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.set_fps")) {
    return NULL;
  }
  // 1-inline void EggAnimData::set_fps(double type)
  if (PyNumber_Check(arg)) {
    (*local_this).set_fps(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fps(const EggAnimData self, double type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_set_fps_67_comment =
  "C++ Interface:\n"
  "set_fps(const EggAnimData self, double type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimData_set_fps_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimData::clear_fps(void)
 */
static PyObject *Dtool_EggAnimData_clear_fps_68(PyObject *self, PyObject *) {
  EggAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.clear_fps")) {
    return NULL;
  }
  // 1-inline void EggAnimData::clear_fps(void)
  (*local_this).clear_fps();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_clear_fps_68_comment =
  "C++ Interface:\n"
  "clear_fps(const EggAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimData_clear_fps_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAnimData::has_fps(void) const
 */
static PyObject *Dtool_EggAnimData_has_fps_69(PyObject *self, PyObject *) {
  EggAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggAnimData::has_fps(void) const
  bool return_value = (*(const EggAnimData*)local_this).has_fps();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_has_fps_69_comment =
  "C++ Interface:\n"
  "has_fps(EggAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimData_has_fps_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggAnimData::get_fps(void) const
 */
static PyObject *Dtool_EggAnimData_get_fps_70(PyObject *self, PyObject *) {
  EggAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggAnimData::get_fps(void) const
  double return_value = (*(const EggAnimData*)local_this).get_fps();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_get_fps_70_comment =
  "C++ Interface:\n"
  "get_fps(EggAnimData self)\n"
  "\n"
  "/**\n"
  " * This is only valid if has_fps() returns true.\n"
  " */";
#else
static const char *Dtool_EggAnimData_get_fps_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimData::clear_data(void)
 */
static PyObject *Dtool_EggAnimData_clear_data_71(PyObject *self, PyObject *) {
  EggAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.clear_data")) {
    return NULL;
  }
  // 1-inline void EggAnimData::clear_data(void)
  (*local_this).clear_data();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_clear_data_71_comment =
  "C++ Interface:\n"
  "clear_data(const EggAnimData self)\n"
  "\n"
  "/**\n"
  " * Removes all data and empties the table.\n"
  " */";
#else
static const char *Dtool_EggAnimData_clear_data_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimData::add_data(double value)
 */
static PyObject *Dtool_EggAnimData_add_data_72(PyObject *self, PyObject *arg) {
  EggAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.add_data")) {
    return NULL;
  }
  // 1-inline void EggAnimData::add_data(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_data(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data(const EggAnimData self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_add_data_72_comment =
  "C++ Interface:\n"
  "add_data(const EggAnimData self, double value)\n"
  "\n"
  "/**\n"
  " * Adds a single element to the table.\n"
  " */";
#else
static const char *Dtool_EggAnimData_add_data_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggAnimData::get_size(void) const
 */
static PyObject *Dtool_EggAnimData_get_size_73(PyObject *self, PyObject *) {
  EggAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggAnimData::get_size(void) const
  int return_value = (*(const EggAnimData*)local_this).get_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_get_size_73_comment =
  "C++ Interface:\n"
  "get_size(EggAnimData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the table.\n"
  " */";
#else
static const char *Dtool_EggAnimData_get_size_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggAnimData::quantize(double quantum)
 */
static PyObject *Dtool_EggAnimData_quantize_74(PyObject *self, PyObject *arg) {
  EggAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.quantize")) {
    return NULL;
  }
  // 1-void EggAnimData::quantize(double quantum)
  if (PyNumber_Check(arg)) {
    (*local_this).quantize(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quantize(const EggAnimData self, double quantum)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_quantize_74_comment =
  "C++ Interface:\n"
  "quantize(const EggAnimData self, double quantum)\n"
  "\n"
  "/**\n"
  " * Rounds each element of the table to the nearest multiple of quantum.\n"
  " */";
#else
static const char *Dtool_EggAnimData_quantize_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggAnimData::get_class_type(void)
 */
static PyObject *Dtool_EggAnimData_get_class_type_75(PyObject *, PyObject *) {
  // 1-static TypeHandle EggAnimData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggAnimData::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_get_class_type_75_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggAnimData_get_class_type_75_comment = NULL;
#endif

static int Dtool_Init_EggAnimData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggAnimData(PyObject *args, CPT(EggAnimData) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggAnimData, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggAnimData(PyObject *args, PT(EggAnimData) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggAnimData, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggAnimData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggAnimData) {
    printf("EggAnimData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggAnimData *local_this = (EggAnimData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggAnimData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggAnimData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggAnimData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggAnimData*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggAnimPreload
 */
/**
 * Python function wrapper for:
 * inline EggAnimPreload &EggAnimPreload::operator =(EggAnimPreload const &copy)
 */
static PyObject *Dtool_EggAnimPreload_operator_79(PyObject *self, PyObject *arg) {
  EggAnimPreload *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimPreload, (void **)&local_this, "EggAnimPreload.assign")) {
    return NULL;
  }
  // 1-inline EggAnimPreload &EggAnimPreload::operator =(EggAnimPreload const &copy)
  CPT(EggAnimPreload) arg_this;
  if (!Dtool_ConstCoerce_EggAnimPreload(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggAnimPreload.assign", "EggAnimPreload");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggAnimPreload *return_value = local_this;
  if (return_value != (EggAnimPreload *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggAnimPreload *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggAnimPreload, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggAnimPreload self, const EggAnimPreload copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_operator_79_comment =
  "C++ Interface:\n"
  "assign(const EggAnimPreload self, const EggAnimPreload copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_operator_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimPreload::set_fps(double fps)
 */
static PyObject *Dtool_EggAnimPreload_set_fps_80(PyObject *self, PyObject *arg) {
  EggAnimPreload *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimPreload, (void **)&local_this, "EggAnimPreload.set_fps")) {
    return NULL;
  }
  // 1-inline void EggAnimPreload::set_fps(double fps)
  if (PyNumber_Check(arg)) {
    (*local_this).set_fps(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fps(const EggAnimPreload self, double fps)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_set_fps_80_comment =
  "C++ Interface:\n"
  "set_fps(const EggAnimPreload self, double fps)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_set_fps_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimPreload::clear_fps(void)
 */
static PyObject *Dtool_EggAnimPreload_clear_fps_81(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimPreload, (void **)&local_this, "EggAnimPreload.clear_fps")) {
    return NULL;
  }
  // 1-inline void EggAnimPreload::clear_fps(void)
  (*local_this).clear_fps();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_clear_fps_81_comment =
  "C++ Interface:\n"
  "clear_fps(const EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_clear_fps_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAnimPreload::has_fps(void) const
 */
static PyObject *Dtool_EggAnimPreload_has_fps_82(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAnimPreload, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggAnimPreload::has_fps(void) const
  bool return_value = (*(const EggAnimPreload*)local_this).has_fps();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_has_fps_82_comment =
  "C++ Interface:\n"
  "has_fps(EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_has_fps_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggAnimPreload::get_fps(void) const
 */
static PyObject *Dtool_EggAnimPreload_get_fps_83(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAnimPreload, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggAnimPreload::get_fps(void) const
  double return_value = (*(const EggAnimPreload*)local_this).get_fps();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_get_fps_83_comment =
  "C++ Interface:\n"
  "get_fps(EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " * This is only valid if has_fps() returns true.\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_get_fps_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimPreload::set_num_frames(int num_frames)
 */
static PyObject *Dtool_EggAnimPreload_set_num_frames_84(PyObject *self, PyObject *arg) {
  EggAnimPreload *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimPreload, (void **)&local_this, "EggAnimPreload.set_num_frames")) {
    return NULL;
  }
  // 1-inline void EggAnimPreload::set_num_frames(int num_frames)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_frames((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_frames(const EggAnimPreload self, int num_frames)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_set_num_frames_84_comment =
  "C++ Interface:\n"
  "set_num_frames(const EggAnimPreload self, int num_frames)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_set_num_frames_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimPreload::clear_num_frames(void)
 */
static PyObject *Dtool_EggAnimPreload_clear_num_frames_85(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimPreload, (void **)&local_this, "EggAnimPreload.clear_num_frames")) {
    return NULL;
  }
  // 1-inline void EggAnimPreload::clear_num_frames(void)
  (*local_this).clear_num_frames();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_clear_num_frames_85_comment =
  "C++ Interface:\n"
  "clear_num_frames(const EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_clear_num_frames_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAnimPreload::has_num_frames(void) const
 */
static PyObject *Dtool_EggAnimPreload_has_num_frames_86(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAnimPreload, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggAnimPreload::has_num_frames(void) const
  bool return_value = (*(const EggAnimPreload*)local_this).has_num_frames();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_has_num_frames_86_comment =
  "C++ Interface:\n"
  "has_num_frames(EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_has_num_frames_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggAnimPreload::get_num_frames(void) const
 */
static PyObject *Dtool_EggAnimPreload_get_num_frames_87(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAnimPreload, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggAnimPreload::get_num_frames(void) const
  int return_value = (*(const EggAnimPreload*)local_this).get_num_frames();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_get_num_frames_87_comment =
  "C++ Interface:\n"
  "get_num_frames(EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " * This is only valid if has_num_frames() returns true.\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_get_num_frames_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggAnimPreload::get_class_type(void)
 */
static PyObject *Dtool_EggAnimPreload_get_class_type_88(PyObject *, PyObject *) {
  // 1-static TypeHandle EggAnimPreload::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggAnimPreload::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_get_class_type_88_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggAnimPreload_get_class_type_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggAnimPreload::EggAnimPreload(EggAnimPreload const &copy)
 * inline EggAnimPreload::EggAnimPreload(std::string const &name = "")
 */
static int Dtool_Init_EggAnimPreload(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggAnimPreload::EggAnimPreload(std::string const &name)
      EggAnimPreload *return_value = new EggAnimPreload();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggAnimPreload, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggAnimPreload::EggAnimPreload(EggAnimPreload const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggAnimPreload", (char **)keyword_list, &param0)) {
          EggAnimPreload const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggAnimPreload, (void **)&param0_this);
          if (param0_this != NULL) {
            EggAnimPreload *return_value = new EggAnimPreload(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggAnimPreload, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggAnimPreload::EggAnimPreload(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggAnimPreload", (char **)keyword_list, &param0_str, &param0_len)) {
          EggAnimPreload *return_value = new EggAnimPreload(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggAnimPreload, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggAnimPreload::EggAnimPreload(EggAnimPreload const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggAnimPreload", (char **)keyword_list, &param0)) {
          CPT(EggAnimPreload) param0_this;
          if (Dtool_ConstCoerce_EggAnimPreload(param0, param0_this)) {
            EggAnimPreload *return_value = new EggAnimPreload(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggAnimPreload, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggAnimPreload::EggAnimPreload(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggAnimPreload() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggAnimPreload()\n"
      "EggAnimPreload(const EggAnimPreload copy)\n"
      "EggAnimPreload(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggAnimPreload(PyObject *args, CPT(EggAnimPreload) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggAnimPreload, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggAnimPreload::EggAnimPreload(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggAnimPreload *return_value = new EggAnimPreload(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_EggAnimPreload(PyObject *args, PT(EggAnimPreload) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggAnimPreload, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggAnimPreload::EggAnimPreload(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggAnimPreload *return_value = new EggAnimPreload(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_EggAnimPreload(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggAnimPreload) {
    printf("EggAnimPreload ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggAnimPreload *local_this = (EggAnimPreload *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggAnimPreload) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggAnimPreload(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggAnimPreload) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggAnimPreload*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggAttributes
 */
/**
 * Python function wrapper for:
 * EggAttributes &EggAttributes::operator =(EggAttributes const &copy)
 */
static PyObject *Dtool_EggAttributes_operator_95(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.assign")) {
    return NULL;
  }
  // 1-EggAttributes &EggAttributes::operator =(EggAttributes const &copy)
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    EggAttributes *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggAttributes self, const EggAttributes copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_operator_95_comment =
  "C++ Interface:\n"
  "assign(const EggAttributes self, const EggAttributes copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_operator_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAttributes::has_normal(void) const
 */
static PyObject *Dtool_EggAttributes_has_normal_97(PyObject *self, PyObject *) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggAttributes::has_normal(void) const
  bool return_value = (*(const EggAttributes*)local_this).has_normal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_has_normal_97_comment =
  "C++ Interface:\n"
  "has_normal(EggAttributes self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_has_normal_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LNormald const &EggAttributes::get_normal(void) const
 */
static PyObject *Dtool_EggAttributes_get_normal_98(PyObject *self, PyObject *) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LNormald const &EggAttributes::get_normal(void) const
  LNormald const *return_value = &((*(const EggAttributes*)local_this).get_normal());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_get_normal_98_comment =
  "C++ Interface:\n"
  "get_normal(EggAttributes self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_get_normal_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::set_normal(LNormald const &normal)
 */
static PyObject *Dtool_EggAttributes_set_normal_99(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.set_normal")) {
    return NULL;
  }
  // 1-inline void EggAttributes::set_normal(LNormald const &normal)
  LVector3d arg_local;
  LNormald const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggAttributes.set_normal", "LVector3d");
  }
  (*local_this).set_normal(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_normal(const EggAttributes self, const LVector3d normal)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_set_normal_99_comment =
  "C++ Interface:\n"
  "set_normal(const EggAttributes self, const LVector3d normal)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_set_normal_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::clear_normal(void)
 */
static PyObject *Dtool_EggAttributes_clear_normal_100(PyObject *self, PyObject *) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.clear_normal")) {
    return NULL;
  }
  // 1-inline void EggAttributes::clear_normal(void)
  (*local_this).clear_normal();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_clear_normal_100_comment =
  "C++ Interface:\n"
  "clear_normal(const EggAttributes self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_clear_normal_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAttributes::matches_normal(EggAttributes const &other) const
 */
static PyObject *Dtool_EggAttributes_matches_normal_101(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggAttributes::matches_normal(EggAttributes const &other) const
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.matches_normal", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const EggAttributes*)local_this).matches_normal(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches_normal(EggAttributes self, const EggAttributes other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_matches_normal_101_comment =
  "C++ Interface:\n"
  "matches_normal(EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * Returns true if this normal matches that of the other EggAttributes object,\n"
  " * include the morph list.\n"
  " */";
#else
static const char *Dtool_EggAttributes_matches_normal_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::copy_normal(EggAttributes const &other)
 */
static PyObject *Dtool_EggAttributes_copy_normal_102(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.copy_normal")) {
    return NULL;
  }
  // 1-inline void EggAttributes::copy_normal(EggAttributes const &other)
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.copy_normal", true, true);
  if (arg_this != NULL) {
    (*local_this).copy_normal(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_normal(const EggAttributes self, const EggAttributes other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_copy_normal_102_comment =
  "C++ Interface:\n"
  "copy_normal(const EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * Sets this normal to be the same as the other's, include morphs.  If the\n"
  " * other has no normal, this clears the normal.\n"
  " */";
#else
static const char *Dtool_EggAttributes_copy_normal_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAttributes::has_color(void) const
 */
static PyObject *Dtool_EggAttributes_has_color_103(PyObject *self, PyObject *) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggAttributes::has_color(void) const
  bool return_value = (*(const EggAttributes*)local_this).has_color();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_has_color_103_comment =
  "C++ Interface:\n"
  "has_color(EggAttributes self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_has_color_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggAttributes::get_color(void) const
 */
static PyObject *Dtool_EggAttributes_get_color_104(PyObject *self, PyObject *) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor EggAttributes::get_color(void) const
  LColor *return_value = new LColor((*(const EggAttributes*)local_this).get_color());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_get_color_104_comment =
  "C++ Interface:\n"
  "get_color(EggAttributes self)\n"
  "\n"
  "/**\n"
  " * Returns the color set on this particular attribute.  If there is no color\n"
  " * set, returns white.\n"
  " */";
#else
static const char *Dtool_EggAttributes_get_color_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::set_color(LColor const &Color)
 */
static PyObject *Dtool_EggAttributes_set_color_105(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.set_color")) {
    return NULL;
  }
  // 1-inline void EggAttributes::set_color(LColor const &Color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggAttributes.set_color", "LVecBase4f");
  }
  (*local_this).set_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const EggAttributes self, const LVecBase4f Color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_set_color_105_comment =
  "C++ Interface:\n"
  "set_color(const EggAttributes self, const LVecBase4f Color)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_set_color_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::clear_color(void)
 */
static PyObject *Dtool_EggAttributes_clear_color_106(PyObject *self, PyObject *) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.clear_color")) {
    return NULL;
  }
  // 1-inline void EggAttributes::clear_color(void)
  (*local_this).clear_color();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_clear_color_106_comment =
  "C++ Interface:\n"
  "clear_color(const EggAttributes self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_clear_color_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAttributes::matches_color(EggAttributes const &other) const
 */
static PyObject *Dtool_EggAttributes_matches_color_107(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggAttributes::matches_color(EggAttributes const &other) const
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.matches_color", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const EggAttributes*)local_this).matches_color(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches_color(EggAttributes self, const EggAttributes other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_matches_color_107_comment =
  "C++ Interface:\n"
  "matches_color(EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * Returns true if this color matches that of the other EggAttributes object,\n"
  " * include the morph list.\n"
  " */";
#else
static const char *Dtool_EggAttributes_matches_color_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::copy_color(EggAttributes const &other)
 */
static PyObject *Dtool_EggAttributes_copy_color_108(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.copy_color")) {
    return NULL;
  }
  // 1-inline void EggAttributes::copy_color(EggAttributes const &other)
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.copy_color", true, true);
  if (arg_this != NULL) {
    (*local_this).copy_color(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_color(const EggAttributes self, const EggAttributes other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_copy_color_108_comment =
  "C++ Interface:\n"
  "copy_color(const EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * Sets this color to be the same as the other's, include morphs.  If the\n"
  " * other has no color, this clears the color.\n"
  " */";
#else
static const char *Dtool_EggAttributes_copy_color_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggAttributes::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggAttributes_write_109(PyObject *self, PyObject *args, PyObject *kwds) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggAttributes::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggAttributes.write", false, true);
    if (param1_this != NULL) {
      (*(const EggAttributes*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggAttributes self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_write_109_comment =
  "C++ Interface:\n"
  "write(EggAttributes self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the attributes to the indicated output stream in Egg format.\n"
  " */";
#else
static const char *Dtool_EggAttributes_write_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAttributes::sorts_less_than(EggAttributes const &other) const
 */
static PyObject *Dtool_EggAttributes_sorts_less_than_110(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggAttributes::sorts_less_than(EggAttributes const &other) const
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.sorts_less_than", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const EggAttributes*)local_this).sorts_less_than(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sorts_less_than(EggAttributes self, const EggAttributes other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_sorts_less_than_110_comment =
  "C++ Interface:\n"
  "sorts_less_than(EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " */";
#else
static const char *Dtool_EggAttributes_sorts_less_than_110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggAttributes::compare_to(EggAttributes const &other) const
 */
static PyObject *Dtool_EggAttributes_compare_to_111(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggAttributes::compare_to(EggAttributes const &other) const
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const EggAttributes*)local_this).compare_to(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(EggAttributes self, const EggAttributes other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_compare_to_111_comment =
  "C++ Interface:\n"
  "compare_to(EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " */";
#else
static const char *Dtool_EggAttributes_compare_to_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggAttributes::transform(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggAttributes_transform_112(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.transform")) {
    return NULL;
  }
  // 1-void EggAttributes::transform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggAttributes.transform", "LMatrix4d");
  }
  (*local_this).transform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggAttributes self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_transform_112_comment =
  "C++ Interface:\n"
  "transform(const EggAttributes self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation matrix to the attributes.\n"
  " */";
#else
static const char *Dtool_EggAttributes_transform_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggAttributes::get_class_type(void)
 */
static PyObject *Dtool_EggAttributes_get_class_type_121(PyObject *, PyObject *) {
  // 1-static TypeHandle EggAttributes::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggAttributes::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_get_class_type_121_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggAttributes_get_class_type_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggAttributes::downcast_to_EggVertex(void)
 */
static PyObject *Dtool_EggAttributes_downcast_to_EggVertex_164(PyObject *self, PyObject *) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.downcast_to_EggVertex")) {
    return NULL;
  }
  // 1-EggVertex *EggAttributes::downcast_to_EggVertex(void)
  EggVertex *return_value = (EggVertex *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_downcast_to_EggVertex_164_comment =
  "C++ Interface:\n"
  "downcast_to_EggVertex(const EggAttributes self)\n"
  "\n"
  "downcast from EggAttributes to EggVertex";
#else
static const char *Dtool_EggAttributes_downcast_to_EggVertex_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggPrimitive *EggAttributes::downcast_to_EggPrimitive(void)
 */
static PyObject *Dtool_EggAttributes_downcast_to_EggPrimitive_844(PyObject *self, PyObject *) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.downcast_to_EggPrimitive")) {
    return NULL;
  }
  // 1-EggPrimitive *EggAttributes::downcast_to_EggPrimitive(void)
  EggPrimitive *return_value = (EggPrimitive *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPrimitive, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_downcast_to_EggPrimitive_844_comment =
  "C++ Interface:\n"
  "downcast_to_EggPrimitive(const EggAttributes self)\n"
  "\n"
  "downcast from EggAttributes to EggPrimitive";
#else
static const char *Dtool_EggAttributes_downcast_to_EggPrimitive_844_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggAttributes::EggAttributes(void)
 * EggAttributes::EggAttributes(EggAttributes const &copy)
 */
static int Dtool_Init_EggAttributes(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggAttributes::EggAttributes(void)
      EggAttributes *return_value = new EggAttributes();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggAttributes, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-EggAttributes::EggAttributes(EggAttributes const &copy)
      EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 0, "EggAttributes.EggAttributes", true, true);
      if (arg_this != NULL) {
        EggAttributes *return_value = new EggAttributes(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggAttributes, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggAttributes() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggAttributes()\n"
      "EggAttributes(const EggAttributes copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggAttributes(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggAttributes) {
    printf("EggAttributes ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggAttributes *local_this = (EggAttributes *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggAttributes(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggVertexUV
 */
/**
 * Python function wrapper for:
 * EggVertexUV &EggVertexUV::operator =(EggVertexUV const &copy)
 */
static PyObject *Dtool_EggVertexUV_operator_124(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.assign")) {
    return NULL;
  }
  // 1-EggVertexUV &EggVertexUV::operator =(EggVertexUV const &copy)
  CPT(EggVertexUV) arg_this;
  if (!Dtool_ConstCoerce_EggVertexUV(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.assign", "EggVertexUV");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggVertexUV *return_value = local_this;
  if (return_value != (EggVertexUV *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggVertexUV *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexUV, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggVertexUV self, const EggVertexUV copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_operator_124_comment =
  "C++ Interface:\n"
  "assign(const EggVertexUV self, const EggVertexUV copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_operator_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string EggVertexUV::filter_name(std::string const &name)
 */
static PyObject *Dtool_EggVertexUV_filter_name_125(PyObject *, PyObject *arg) {
  // 1-static inline std::string EggVertexUV::filter_name(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    std::string return_value = EggVertexUV::filter_name(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "filter_name(str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_filter_name_125_comment =
  "C++ Interface:\n"
  "filter_name(str name)\n"
  "\n"
  "/**\n"
  " * Returns the actual name that should be set for a given name string.\n"
  " * Usually this is the same string that is input, but for historical reasons\n"
  " * the texture coordinate name \"default\" is mapped to the empty string.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_filter_name_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::set_name(std::string const &name)
 */
static PyObject *Dtool_EggVertexUV_set_name_126(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.set_name")) {
    return NULL;
  }
  // 1-inline void EggVertexUV::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const EggVertexUV self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_set_name_126_comment =
  "C++ Interface:\n"
  "set_name(const EggVertexUV self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_set_name_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggVertexUV::get_num_dimensions(void) const
 */
static PyObject *Dtool_EggVertexUV_get_num_dimensions_127(PyObject *self, PyObject *) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggVertexUV::get_num_dimensions(void) const
  int return_value = (*(const EggVertexUV*)local_this).get_num_dimensions();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_num_dimensions_127_comment =
  "C++ Interface:\n"
  "get_num_dimensions(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " * Returns the number of components of the texture coordinate set.  This is\n"
  " * either 2 (the normal case) or 3 (for a 3-d texture coordinate).\n"
  " */";
#else
static const char *Dtool_EggVertexUV_get_num_dimensions_127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertexUV::has_w(void) const
 */
static PyObject *Dtool_EggVertexUV_has_w_128(PyObject *self, PyObject *) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggVertexUV::has_w(void) const
  bool return_value = (*(const EggVertexUV*)local_this).has_w();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_has_w_128_comment =
  "C++ Interface:\n"
  "has_w(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture coordinate has a third, w component, false if\n"
  " * it is just a normal 2-d texture coordinate.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_has_w_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LTexCoordd EggVertexUV::get_uv(void) const
 */
static PyObject *Dtool_EggVertexUV_get_uv_129(PyObject *self, PyObject *) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LTexCoordd EggVertexUV::get_uv(void) const
  LTexCoordd *return_value = new LTexCoordd((*(const EggVertexUV*)local_this).get_uv());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_uv_129_comment =
  "C++ Interface:\n"
  "get_uv(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " * Returns the texture coordinate pair, if get_num_dimensions() is 2.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_get_uv_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LTexCoord3d const &EggVertexUV::get_uvw(void) const
 */
static PyObject *Dtool_EggVertexUV_get_uvw_130(PyObject *self, PyObject *) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LTexCoord3d const &EggVertexUV::get_uvw(void) const
  LTexCoord3d const *return_value = &((*(const EggVertexUV*)local_this).get_uvw());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_uvw_130_comment =
  "C++ Interface:\n"
  "get_uvw(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " * Returns the texture coordinate triple, if get_num_dimensions() is 3.  This\n"
  " * is also legal to call if get_num_dimensions() is 2 (but the last dimension\n"
  " * will be zero).\n"
  " */";
#else
static const char *Dtool_EggVertexUV_get_uvw_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::set_uv(LTexCoordd const &texCoord)
 */
static PyObject *Dtool_EggVertexUV_set_uv_131(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.set_uv")) {
    return NULL;
  }
  // 1-inline void EggVertexUV::set_uv(LTexCoordd const &texCoord)
  LPoint2d arg_local;
  LTexCoordd const *arg_this = Dtool_Coerce_LPoint2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.set_uv", "LPoint2d");
  }
  (*local_this).set_uv(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv(const EggVertexUV self, const LPoint2d texCoord)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_set_uv_131_comment =
  "C++ Interface:\n"
  "set_uv(const EggVertexUV self, const LPoint2d texCoord)\n"
  "\n"
  "/**\n"
  " * Sets the texture coordinate pair.  This makes the texture coordinate a 2-d\n"
  " * texture coordinate, which is the usual case.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_set_uv_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::set_uvw(LTexCoord3d const &texCoord)
 */
static PyObject *Dtool_EggVertexUV_set_uvw_132(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.set_uvw")) {
    return NULL;
  }
  // 1-inline void EggVertexUV::set_uvw(LTexCoord3d const &texCoord)
  LPoint3d arg_local;
  LTexCoord3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.set_uvw", "LPoint3d");
  }
  (*local_this).set_uvw(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uvw(const EggVertexUV self, const LPoint3d texCoord)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_set_uvw_132_comment =
  "C++ Interface:\n"
  "set_uvw(const EggVertexUV self, const LPoint3d texCoord)\n"
  "\n"
  "/**\n"
  " * Sets the texture coordinate triple.  This makes the texture coordinate a\n"
  " * 3-d texture coordinate.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_set_uvw_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertexUV::has_tangent(void) const
 */
static PyObject *Dtool_EggVertexUV_has_tangent_133(PyObject *self, PyObject *) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggVertexUV::has_tangent(void) const
  bool return_value = (*(const EggVertexUV*)local_this).has_tangent();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_has_tangent_133_comment =
  "C++ Interface:\n"
  "has_tangent(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_has_tangent_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LNormald const &EggVertexUV::get_tangent(void) const
 */
static PyObject *Dtool_EggVertexUV_get_tangent_134(PyObject *self, PyObject *) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LNormald const &EggVertexUV::get_tangent(void) const
  LNormald const *return_value = &((*(const EggVertexUV*)local_this).get_tangent());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_tangent_134_comment =
  "C++ Interface:\n"
  "get_tangent(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_get_tangent_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::set_tangent(LNormald const &tangent)
 */
static PyObject *Dtool_EggVertexUV_set_tangent_135(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.set_tangent")) {
    return NULL;
  }
  // 1-inline void EggVertexUV::set_tangent(LNormald const &tangent)
  LVector3d arg_local;
  LNormald const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.set_tangent", "LVector3d");
  }
  (*local_this).set_tangent(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tangent(const EggVertexUV self, const LVector3d tangent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_set_tangent_135_comment =
  "C++ Interface:\n"
  "set_tangent(const EggVertexUV self, const LVector3d tangent)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_set_tangent_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::clear_tangent(void)
 */
static PyObject *Dtool_EggVertexUV_clear_tangent_136(PyObject *self, PyObject *) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.clear_tangent")) {
    return NULL;
  }
  // 1-inline void EggVertexUV::clear_tangent(void)
  (*local_this).clear_tangent();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_clear_tangent_136_comment =
  "C++ Interface:\n"
  "clear_tangent(const EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_clear_tangent_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertexUV::has_binormal(void) const
 */
static PyObject *Dtool_EggVertexUV_has_binormal_137(PyObject *self, PyObject *) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggVertexUV::has_binormal(void) const
  bool return_value = (*(const EggVertexUV*)local_this).has_binormal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_has_binormal_137_comment =
  "C++ Interface:\n"
  "has_binormal(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_has_binormal_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LNormald const &EggVertexUV::get_binormal(void) const
 */
static PyObject *Dtool_EggVertexUV_get_binormal_138(PyObject *self, PyObject *) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LNormald const &EggVertexUV::get_binormal(void) const
  LNormald const *return_value = &((*(const EggVertexUV*)local_this).get_binormal());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_binormal_138_comment =
  "C++ Interface:\n"
  "get_binormal(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_get_binormal_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::set_binormal(LNormald const &binormal)
 */
static PyObject *Dtool_EggVertexUV_set_binormal_139(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.set_binormal")) {
    return NULL;
  }
  // 1-inline void EggVertexUV::set_binormal(LNormald const &binormal)
  LVector3d arg_local;
  LNormald const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.set_binormal", "LVector3d");
  }
  (*local_this).set_binormal(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_binormal(const EggVertexUV self, const LVector3d binormal)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_set_binormal_139_comment =
  "C++ Interface:\n"
  "set_binormal(const EggVertexUV self, const LVector3d binormal)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_set_binormal_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::clear_binormal(void)
 */
static PyObject *Dtool_EggVertexUV_clear_binormal_140(PyObject *self, PyObject *) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.clear_binormal")) {
    return NULL;
  }
  // 1-inline void EggVertexUV::clear_binormal(void)
  (*local_this).clear_binormal();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_clear_binormal_140_comment =
  "C++ Interface:\n"
  "clear_binormal(const EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_clear_binormal_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< EggVertexUV > EggVertexUV::make_average(EggVertexUV const *first, EggVertexUV const *second)
 */
static PyObject *Dtool_EggVertexUV_make_average_141(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< EggVertexUV > EggVertexUV::make_average(EggVertexUV const *first, EggVertexUV const *second)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"first", "second", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_average", (char **)keyword_list, &param0, &param1)) {
    CPT(EggVertexUV) param0_this;
    if (!Dtool_ConstCoerce_EggVertexUV(param0, param0_this)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "EggVertexUV.make_average", "EggVertexUV");
    }
    CPT(EggVertexUV) param1_this;
    if (!Dtool_ConstCoerce_EggVertexUV(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggVertexUV.make_average", "EggVertexUV");
    }
    PointerTo< EggVertexUV > return_value = EggVertexUV::make_average(MOVE(param0_this), MOVE(param1_this));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    EggVertexUV *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggVertexUV, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_average(const EggVertexUV first, const EggVertexUV second)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_make_average_141_comment =
  "C++ Interface:\n"
  "make_average(const EggVertexUV first, const EggVertexUV second)\n"
  "\n"
  "/**\n"
  " * Creates a new EggVertexUV that contains the averaged values of the two\n"
  " * given objects.  It is an error if they don't have the same name.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_make_average_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertexUV::transform(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggVertexUV_transform_142(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.transform")) {
    return NULL;
  }
  // 1-void EggVertexUV::transform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.transform", "LMatrix4d");
  }
  (*local_this).transform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggVertexUV self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_transform_142_comment =
  "C++ Interface:\n"
  "transform(const EggVertexUV self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation matrix to the UV's tangent and/or\n"
  " * binormal.  This does nothing if there is no tangent or binormal.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_transform_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertexUV::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggVertexUV_write_143(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggVertexUV::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggVertexUV.write", false, true);
    if (param1_this != NULL) {
      (*(const EggVertexUV*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggVertexUV self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_write_143_comment =
  "C++ Interface:\n"
  "write(EggVertexUV self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_write_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggVertexUV::compare_to(EggVertexUV const &other) const
 */
static PyObject *Dtool_EggVertexUV_compare_to_144(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggVertexUV::compare_to(EggVertexUV const &other) const
  CPT(EggVertexUV) arg_this;
  if (!Dtool_ConstCoerce_EggVertexUV(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.compare_to", "EggVertexUV");
  }
  int return_value = (*(const EggVertexUV*)local_this).compare_to(*MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertexUV self, const EggVertexUV other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_compare_to_144_comment =
  "C++ Interface:\n"
  "compare_to(EggVertexUV self, const EggVertexUV other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_compare_to_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggVertexUV::get_class_type(void)
 */
static PyObject *Dtool_EggVertexUV_get_class_type_149(PyObject *, PyObject *) {
  // 1-static TypeHandle EggVertexUV::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggVertexUV::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_class_type_149_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggVertexUV_get_class_type_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertexUV::EggVertexUV(EggVertexUV const &copy)
 * EggVertexUV::EggVertexUV(std::string const &name, LTexCoord3d const &uvw)
 * EggVertexUV::EggVertexUV(std::string const &name, LTexCoordd const &uv)
 */
static int Dtool_Init_EggVertexUV(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-EggVertexUV::EggVertexUV(EggVertexUV const &copy)
      CPT(EggVertexUV) arg_this;
      if (!Dtool_ConstCoerce_EggVertexUV(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "EggVertexUV.EggVertexUV", "EggVertexUV");
        return -1;
      }
      EggVertexUV *return_value = new EggVertexUV(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexUV, true, false);
    }
    break;
  case 2:
    {
      {
        // -2 EggVertexUV::EggVertexUV(std::string const &name, LTexCoordd const &uv)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        static const char *keyword_list[] = {"name", "uv", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggVertexUV", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          LTexCoordd const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint2d, (void **)&param1_this);
          if (param1_this != NULL) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexUV, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 EggVertexUV::EggVertexUV(std::string const &name, LTexCoord3d const &uvw)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        static const char *keyword_list[] = {"name", "uvw", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggVertexUV", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          LTexCoord3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3d, (void **)&param1_this);
          if (param1_this != NULL) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexUV, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 EggVertexUV::EggVertexUV(std::string const &name, LTexCoordd const &uv)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        static const char *keyword_list[] = {"name", "uv", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggVertexUV", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          LPoint2d param1_local;
          LTexCoordd const *param1_this = Dtool_Coerce_LPoint2d(param1, param1_local);
          if ((param1_this != NULL)) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexUV, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 EggVertexUV::EggVertexUV(std::string const &name, LTexCoord3d const &uvw)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        static const char *keyword_list[] = {"name", "uvw", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggVertexUV", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          LPoint3d param1_local;
          LTexCoord3d const *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
          if ((param1_this != NULL)) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexUV, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggVertexUV() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggVertexUV(const EggVertexUV copy)\n"
      "EggVertexUV(str name, const LPoint2d uv)\n"
      "EggVertexUV(str name, const LPoint3d uvw)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggVertexUV(PyObject *args, CPT(EggVertexUV) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggVertexUV, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      {
        // -2 EggVertexUV::EggVertexUV(std::string const &name, LTexCoordd const &uv)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:EggVertexUV", &param0_str, &param0_len, &param1)) {
          LTexCoordd const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint2d, (void **)&param1_this);
          if (param1_this != NULL) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 EggVertexUV::EggVertexUV(std::string const &name, LTexCoord3d const &uvw)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:EggVertexUV", &param0_str, &param0_len, &param1)) {
          LTexCoord3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3d, (void **)&param1_this);
          if (param1_this != NULL) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_EggVertexUV(PyObject *args, PT(EggVertexUV) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggVertexUV, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      {
        // -2 EggVertexUV::EggVertexUV(std::string const &name, LTexCoordd const &uv)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:EggVertexUV", &param0_str, &param0_len, &param1)) {
          LTexCoordd const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint2d, (void **)&param1_this);
          if (param1_this != NULL) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 EggVertexUV::EggVertexUV(std::string const &name, LTexCoord3d const &uvw)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:EggVertexUV", &param0_str, &param0_len, &param1)) {
          LTexCoord3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3d, (void **)&param1_this);
          if (param1_this != NULL) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggVertexUV(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggVertexUV) {
    printf("EggVertexUV ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggVertexUV *local_this = (EggVertexUV *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggVertexUV) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggVertexUV(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggVertexUV) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggVertexUV*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggVertexUV*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggVertexUV*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggVertexUV*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggVertexUV*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggVertexUV*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggVertexAux
 */
/**
 * Python function wrapper for:
 * EggVertexAux &EggVertexAux::operator =(EggVertexAux const &copy)
 */
static PyObject *Dtool_EggVertexAux_operator_152(PyObject *self, PyObject *arg) {
  EggVertexAux *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexAux, (void **)&local_this, "EggVertexAux.assign")) {
    return NULL;
  }
  // 1-EggVertexAux &EggVertexAux::operator =(EggVertexAux const &copy)
  CPT(EggVertexAux) arg_this;
  if (!Dtool_ConstCoerce_EggVertexAux(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexAux.assign", "EggVertexAux");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggVertexAux *return_value = local_this;
  if (return_value != (EggVertexAux *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggVertexAux *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexAux, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggVertexAux self, const EggVertexAux copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_operator_152_comment =
  "C++ Interface:\n"
  "assign(const EggVertexAux self, const EggVertexAux copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexAux_operator_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexAux::set_name(std::string const &name)
 */
static PyObject *Dtool_EggVertexAux_set_name_153(PyObject *self, PyObject *arg) {
  EggVertexAux *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexAux, (void **)&local_this, "EggVertexAux.set_name")) {
    return NULL;
  }
  // 1-inline void EggVertexAux::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const EggVertexAux self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_set_name_153_comment =
  "C++ Interface:\n"
  "set_name(const EggVertexAux self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexAux_set_name_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d const &EggVertexAux::get_aux(void) const
 */
static PyObject *Dtool_EggVertexAux_get_aux_154(PyObject *self, PyObject *) {
  EggVertexAux *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexAux, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4d const &EggVertexAux::get_aux(void) const
  LVecBase4d const *return_value = &((*(const EggVertexAux*)local_this).get_aux());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_get_aux_154_comment =
  "C++ Interface:\n"
  "get_aux(EggVertexAux self)\n"
  "\n"
  "/**\n"
  " * Returns the auxiliary data quadruple.\n"
  " */";
#else
static const char *Dtool_EggVertexAux_get_aux_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexAux::set_aux(LVecBase4d const &aux)
 */
static PyObject *Dtool_EggVertexAux_set_aux_155(PyObject *self, PyObject *arg) {
  EggVertexAux *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexAux, (void **)&local_this, "EggVertexAux.set_aux")) {
    return NULL;
  }
  // 1-inline void EggVertexAux::set_aux(LVecBase4d const &aux)
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexAux.set_aux", "LVecBase4d");
  }
  (*local_this).set_aux(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux(const EggVertexAux self, const LVecBase4d aux)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_set_aux_155_comment =
  "C++ Interface:\n"
  "set_aux(const EggVertexAux self, const LVecBase4d aux)\n"
  "\n"
  "/**\n"
  " * Sets the auxiliary data quadruple.\n"
  " */";
#else
static const char *Dtool_EggVertexAux_set_aux_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< EggVertexAux > EggVertexAux::make_average(EggVertexAux const *first, EggVertexAux const *second)
 */
static PyObject *Dtool_EggVertexAux_make_average_156(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< EggVertexAux > EggVertexAux::make_average(EggVertexAux const *first, EggVertexAux const *second)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"first", "second", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_average", (char **)keyword_list, &param0, &param1)) {
    CPT(EggVertexAux) param0_this;
    if (!Dtool_ConstCoerce_EggVertexAux(param0, param0_this)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "EggVertexAux.make_average", "EggVertexAux");
    }
    CPT(EggVertexAux) param1_this;
    if (!Dtool_ConstCoerce_EggVertexAux(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggVertexAux.make_average", "EggVertexAux");
    }
    PointerTo< EggVertexAux > return_value = EggVertexAux::make_average(MOVE(param0_this), MOVE(param1_this));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    EggVertexAux *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggVertexAux, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_average(const EggVertexAux first, const EggVertexAux second)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_make_average_156_comment =
  "C++ Interface:\n"
  "make_average(const EggVertexAux first, const EggVertexAux second)\n"
  "\n"
  "/**\n"
  " * Creates a new EggVertexAux that contains the averaged values of the two\n"
  " * given objects.  It is an error if they don't have the same name.\n"
  " */";
#else
static const char *Dtool_EggVertexAux_make_average_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertexAux::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggVertexAux_write_157(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertexAux *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexAux, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggVertexAux::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggVertexAux.write", false, true);
    if (param1_this != NULL) {
      (*(const EggVertexAux*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggVertexAux self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_write_157_comment =
  "C++ Interface:\n"
  "write(EggVertexAux self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexAux_write_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggVertexAux::compare_to(EggVertexAux const &other) const
 */
static PyObject *Dtool_EggVertexAux_compare_to_158(PyObject *self, PyObject *arg) {
  EggVertexAux *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexAux, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggVertexAux::compare_to(EggVertexAux const &other) const
  CPT(EggVertexAux) arg_this;
  if (!Dtool_ConstCoerce_EggVertexAux(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexAux.compare_to", "EggVertexAux");
  }
  int return_value = (*(const EggVertexAux*)local_this).compare_to(*MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertexAux self, const EggVertexAux other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_compare_to_158_comment =
  "C++ Interface:\n"
  "compare_to(EggVertexAux self, const EggVertexAux other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " */";
#else
static const char *Dtool_EggVertexAux_compare_to_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggVertexAux::get_class_type(void)
 */
static PyObject *Dtool_EggVertexAux_get_class_type_159(PyObject *, PyObject *) {
  // 1-static TypeHandle EggVertexAux::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggVertexAux::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_get_class_type_159_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggVertexAux_get_class_type_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertexAux::EggVertexAux(EggVertexAux const &copy)
 * EggVertexAux::EggVertexAux(std::string const &name, LVecBase4d const &aux)
 */
static int Dtool_Init_EggVertexAux(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-EggVertexAux::EggVertexAux(EggVertexAux const &copy)
      CPT(EggVertexAux) arg_this;
      if (!Dtool_ConstCoerce_EggVertexAux(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "EggVertexAux.EggVertexAux", "EggVertexAux");
        return -1;
      }
      EggVertexAux *return_value = new EggVertexAux(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexAux, true, false);
    }
    break;
  case 2:
    {
      // 1-EggVertexAux::EggVertexAux(std::string const &name, LVecBase4d const &aux)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"name", "aux", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggVertexAux", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        LVecBase4d param1_local;
        LVecBase4d const *param1_this = Dtool_Coerce_LVecBase4d(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "EggVertexAux.EggVertexAux", "LVecBase4d");
          return -1;
        }
        EggVertexAux *return_value = new EggVertexAux(std::string(param0_str, param0_len), *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexAux, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggVertexAux() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggVertexAux(const EggVertexAux copy)\n"
      "EggVertexAux(str name, const LVecBase4d aux)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggVertexAux(PyObject *args, CPT(EggVertexAux) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggVertexAux, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-EggVertexAux::EggVertexAux(std::string const &name, LVecBase4d const &aux)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:EggVertexAux", &param0_str, &param0_len, &param1)) {
        LVecBase4d const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4d, (void **)&param1_this);
        if (param1_this != NULL) {
          EggVertexAux *return_value = new EggVertexAux(std::string(param0_str, param0_len), *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_EggVertexAux(PyObject *args, PT(EggVertexAux) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggVertexAux, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-EggVertexAux::EggVertexAux(std::string const &name, LVecBase4d const &aux)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:EggVertexAux", &param0_str, &param0_len, &param1)) {
        LVecBase4d const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4d, (void **)&param1_this);
        if (param1_this != NULL) {
          EggVertexAux *return_value = new EggVertexAux(std::string(param0_str, param0_len), *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggVertexAux(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggVertexAux) {
    printf("EggVertexAux ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggVertexAux *local_this = (EggVertexAux *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggVertexAux) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggVertexAux(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggVertexAux) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggVertexAux*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggVertexAux*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggVertexAux*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggVertexAux*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggVertexAux*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggVertexAux*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggVertex
 */
/**
 * Python function wrapper for:
 * EggVertex &EggVertex::operator =(EggVertex const &copy)
 */
static PyObject *Dtool_EggVertex_operator_166(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.assign")) {
    return NULL;
  }
  // 1-EggVertex &EggVertex::operator =(EggVertex const &copy)
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertex.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    EggVertex *return_value = local_this;
    if (return_value != (EggVertex *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertex *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggVertex self, const EggVertex copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_operator_166_comment =
  "C++ Interface:\n"
  "assign(const EggVertex self, const EggVertex copy)\n"
  "\n"
  "/**\n"
  " * Copies all properties of the vertex except its vertex pool, index number,\n"
  " * and group membership.\n"
  " */";
#else
static const char *Dtool_EggVertex_operator_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggVertexPool *EggVertex::get_pool(void) const
 */
static PyObject *Dtool_EggVertex_get_pool_168(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggVertexPool *EggVertex::get_pool(void) const
  EggVertexPool *return_value = (*(const EggVertex*)local_this).get_pool();
  if (return_value != (EggVertexPool *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggVertexPool *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexPool, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_pool_168_comment =
  "C++ Interface:\n"
  "get_pool(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex pool this vertex belongs in.  This may be NULL if the\n"
  " * vertex has not been added to a pool.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_pool_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertex::is_forward_reference(void) const
 */
static PyObject *Dtool_EggVertex_is_forward_reference_169(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggVertex::is_forward_reference(void) const
  bool return_value = (*(const EggVertex*)local_this).is_forward_reference();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_is_forward_reference_169_comment =
  "C++ Interface:\n"
  "is_forward_reference(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex is a forward reference to some vertex that\n"
  " * hasn't been defined yet.  In this case, the vertex may not have any\n"
  " * properties filled in yet.\n"
  " *\n"
  " * This can only happen if you implicitly create a vertex via\n"
  " * EggVertexPool::get_forward_vertex(). Presumably, when the vertex pool is\n"
  " * later filled in, this vertex will be replaced with real data.\n"
  " */";
#else
static const char *Dtool_EggVertex_is_forward_reference_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::set_pos(LPoint2d const &pos)
 * inline void EggVertex::set_pos(LPoint3d const &pos)
 * inline void EggVertex::set_pos(LPoint4d const &pos)
 * inline void EggVertex::set_pos(double pos)
 */
static PyObject *Dtool_EggVertex_set_pos_170(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_pos")) {
    return NULL;
  }
  {
    // -2 inline void EggVertex::set_pos(LPoint3d const &pos)
    LPoint3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint3d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_pos(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(LPoint2d const &pos)
    LPoint2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint2d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_pos(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(LPoint4d const &pos)
    LPoint4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint4d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_pos(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(double pos)
    if (PyNumber_Check(arg)) {
      (*local_this).set_pos(PyFloat_AsDouble(arg));
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(LPoint3d const &pos)
    LPoint3d arg_local;
    LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_pos(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(LPoint2d const &pos)
    LPoint2d arg_local;
    LPoint2d const *arg_this = Dtool_Coerce_LPoint2d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_pos(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(LPoint4d const &pos)
    LPoint4d arg_local;
    LPoint4d const *arg_this = Dtool_Coerce_LPoint4d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_pos(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void EggVertex::set_pos(double pos)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const EggVertex self, const LPoint3d pos)\n"
      "set_pos(const EggVertex self, const LPoint2d pos)\n"
      "set_pos(const EggVertex self, const LPoint4d pos)\n"
      "set_pos(const EggVertex self, double pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_pos_170_comment =
  "C++ Interface:\n"
  "set_pos(const EggVertex self, const LPoint3d pos)\n"
  "set_pos(const EggVertex self, const LPoint2d pos)\n"
  "set_pos(const EggVertex self, const LPoint4d pos)\n"
  "set_pos(const EggVertex self, double pos)\n"
  "\n"
  "// The pos might have 1, 2, 3, or 4 dimensions.  That complicates things a\n"
  "// bit.\n"
  "\n"
  "/**\n"
  " * Sets the vertex position.  This variant sets the vertex to a one-\n"
  " * dimensional value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the vertex position.  This variant sets the vertex to a two-\n"
  " * dimensional value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the vertex position.  This variant sets the vertex to a three-\n"
  " * dimensional value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the vertex position.  This variant sets the vertex to a four-\n"
  " * dimensional value.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_pos_170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::set_pos4(LPoint4d const &pos)
 */
static PyObject *Dtool_EggVertex_set_pos4_171(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_pos4")) {
    return NULL;
  }
  // 1-inline void EggVertex::set_pos4(LPoint4d const &pos)
  LPoint4d arg_local;
  LPoint4d const *arg_this = Dtool_Coerce_LPoint4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertex.set_pos4", "LPoint4d");
  }
  (*local_this).set_pos4(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos4(const EggVertex self, const LPoint4d pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_pos4_171_comment =
  "C++ Interface:\n"
  "set_pos4(const EggVertex self, const LPoint4d pos)\n"
  "\n"
  "/**\n"
  " * This special flavor of set_pos() sets the vertex as a four-component value,\n"
  " * but does not change the set number of dimensions.  It's handy for\n"
  " * retrieving the vertex position via get_pos4, manipulating it, then storing\n"
  " * it back again, without worrying about the number of dimensions it actually\n"
  " * had.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_pos4_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggVertex::get_num_dimensions(void) const
 */
static PyObject *Dtool_EggVertex_get_num_dimensions_172(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggVertex::get_num_dimensions(void) const
  int return_value = (*(const EggVertex*)local_this).get_num_dimensions();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_num_dimensions_172_comment =
  "C++ Interface:\n"
  "get_num_dimensions(EggVertex self)\n"
  "\n"
  "// get_pos[123] return the pos as the corresponding type.  It is an error to\n"
  "// call any of these without first verifying that get_num_dimensions()\n"
  "// matches the desired type.  However, get_pos4() may always be called; it\n"
  "// returns the pos as a four-component point in homogeneous space (with a\n"
  "// 1.0 in the last position if the pos has fewer than four components).\n"
  "\n"
  "/**\n"
  " * Returns the number of dimensions the vertex uses.  Usually this will be 3,\n"
  " * but it may be 1, 2, 3, or 4.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_num_dimensions_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggVertex::get_pos1(void) const
 */
static PyObject *Dtool_EggVertex_get_pos1_173(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggVertex::get_pos1(void) const
  double return_value = (*(const EggVertex*)local_this).get_pos1();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_pos1_173_comment =
  "C++ Interface:\n"
  "get_pos1(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Only valid if get_num_dimensions() returns 1. Returns the position as a\n"
  " * one-dimensional value.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_pos1_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2d EggVertex::get_pos2(void) const
 */
static PyObject *Dtool_EggVertex_get_pos2_174(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2d EggVertex::get_pos2(void) const
  LPoint2d *return_value = new LPoint2d((*(const EggVertex*)local_this).get_pos2());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_pos2_174_comment =
  "C++ Interface:\n"
  "get_pos2(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Only valid if get_num_dimensions() returns 2. Returns the position as a\n"
  " * two-dimensional value.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_pos2_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVertexd EggVertex::get_pos3(void) const
 */
static PyObject *Dtool_EggVertex_get_pos3_175(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVertexd EggVertex::get_pos3(void) const
  LVertexd *return_value = new LVertexd((*(const EggVertex*)local_this).get_pos3());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_pos3_175_comment =
  "C++ Interface:\n"
  "get_pos3(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Valid if get_num_dimensions() returns 3 or 4. Returns the position as a\n"
  " * three-dimensional value.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_pos3_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4d EggVertex::get_pos4(void) const
 */
static PyObject *Dtool_EggVertex_get_pos4_176(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint4d EggVertex::get_pos4(void) const
  LPoint4d *return_value = new LPoint4d((*(const EggVertex*)local_this).get_pos4());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_pos4_176_comment =
  "C++ Interface:\n"
  "get_pos4(EggVertex self)\n"
  "\n"
  "/**\n"
  " * This is always valid, regardless of the value of get_num_dimensions.  It\n"
  " * returns the position as a four-dimensional value.  If the pos has fewer\n"
  " * than four dimensions, this value represents the pos extended into four-\n"
  " * dimensional homogenous space, e.g.  by adding 1 as the fourth component.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_pos4_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertex::has_uv(void) const
 * bool EggVertex::has_uv(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_has_uv_177(PyObject *self, PyObject *args) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool EggVertex::has_uv(void) const
      bool return_value = (*(const EggVertex*)local_this).has_uv();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool EggVertex::has_uv(std::string const &name) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        bool return_value = (*(const EggVertex*)local_this).has_uv(std::string(param1_str, param1_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_uv() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_uv(EggVertex self)\n"
      "has_uv(EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_has_uv_177_comment =
  "C++ Interface:\n"
  "has_uv(EggVertex self)\n"
  "has_uv(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex has an unnamed UV coordinate pair, false\n"
  " * otherwise.\n"
  " *\n"
  " * This is the more restrictive interface, and is generally useful only in the\n"
  " * absence of multitexturing; see has_uv(name) for the interface that supports\n"
  " * multitexturing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex has the named UV coordinate pair, and the named\n"
  " * UV coordinate pair is 2-d, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggVertex_has_uv_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LTexCoordd EggVertex::get_uv(void) const
 * LTexCoordd EggVertex::get_uv(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_get_uv_178(PyObject *self, PyObject *args) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LTexCoordd EggVertex::get_uv(void) const
      LTexCoordd *return_value = new LTexCoordd((*(const EggVertex*)local_this).get_uv());
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-LTexCoordd EggVertex::get_uv(std::string const &name) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        LTexCoordd *return_value = new LTexCoordd((*(const EggVertex*)local_this).get_uv(std::string(param1_str, param1_len)));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_uv() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_uv(EggVertex self)\n"
      "get_uv(EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_uv_178_comment =
  "C++ Interface:\n"
  "get_uv(EggVertex self)\n"
  "get_uv(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the unnamed UV coordinate pair on the vertex.  It is an error to\n"
  " * call this if has_uv() has returned false.\n"
  " *\n"
  " * This is the more restrictive interface, and is generally useful only in the\n"
  " * absence of multitexturing; see get_uv(name) for the interface that supports\n"
  " * multitexturing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the named UV coordinate pair on the vertex.  It is an error to call\n"
  " * this if has_uv(name) returned false.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_uv_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::set_uv(LTexCoordd const &texCoord)
 * void EggVertex::set_uv(std::string const &name, LTexCoordd const &texCoord)
 */
static PyObject *Dtool_EggVertex_set_uv_179(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_uv")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "texCoord");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'texCoord' (pos 1) not found");
      }
      // 1-inline void EggVertex::set_uv(LTexCoordd const &texCoord)
      LPoint2d arg_local;
      LTexCoordd const *arg_this = Dtool_Coerce_LPoint2d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "EggVertex.set_uv", "LPoint2d");
      }
      (*local_this).set_uv(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-void EggVertex::set_uv(std::string const &name, LTexCoordd const &texCoord)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      static const char *keyword_list[] = {"name", "texCoord", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_uv", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
        LPoint2d param2_local;
        LTexCoordd const *param2_this = Dtool_Coerce_LPoint2d(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "EggVertex.set_uv", "LPoint2d");
        }
        (*local_this).set_uv(std::string(param1_str, param1_len), *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_uv() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv(const EggVertex self, const LPoint2d texCoord)\n"
      "set_uv(const EggVertex self, str name, const LPoint2d texCoord)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_uv_179_comment =
  "C++ Interface:\n"
  "set_uv(const EggVertex self, const LPoint2d texCoord)\n"
  "set_uv(const EggVertex self, str name, const LPoint2d texCoord)\n"
  "\n"
  "/**\n"
  " * Replaces the unnamed UV coordinate pair on the vertex with the indicated\n"
  " * value.\n"
  " *\n"
  " * This is the more restrictive interface, and is generally useful only in the\n"
  " * absence of multitexturing; see set_uv(name, uv) for the interface that\n"
  " * supports multitexturing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the indicated UV coordinate pair on the vertex.  This replaces any UV\n"
  " * coordinate pair with the same name already on the vertex, but preserves UV\n"
  " * morphs.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_uv_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::clear_uv(void)
 * void EggVertex::clear_uv(std::string const &name)
 */
static PyObject *Dtool_EggVertex_clear_uv_180(PyObject *self, PyObject *args) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.clear_uv")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void EggVertex::clear_uv(void)
      (*local_this).clear_uv();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void EggVertex::clear_uv(std::string const &name)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        (*local_this).clear_uv(std::string(param1_str, param1_len));
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_uv() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_uv(const EggVertex self)\n"
      "clear_uv(const EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_clear_uv_180_comment =
  "C++ Interface:\n"
  "clear_uv(const EggVertex self)\n"
  "clear_uv(const EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Removes all UV coordinate pairs from the vertex.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the named UV coordinate pair from the vertex, along with any UV\n"
  " * morphs.\n"
  " */";
#else
static const char *Dtool_EggVertex_clear_uv_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggVertex::has_uvw(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_has_uvw_181(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggVertex::has_uvw(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const EggVertex*)local_this).has_uvw(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_uvw(EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_has_uvw_181_comment =
  "C++ Interface:\n"
  "has_uvw(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex has the named UV coordinate triple, and the\n"
  " * named UV coordinate triple is 3-d, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggVertex_has_uvw_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LTexCoord3d const &EggVertex::get_uvw(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_get_uvw_182(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-LTexCoord3d const &EggVertex::get_uvw(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    LTexCoord3d const *return_value = &((*(const EggVertex*)local_this).get_uvw(std::string(param1_str, param1_len)));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_uvw(EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_uvw_182_comment =
  "C++ Interface:\n"
  "get_uvw(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the named UV coordinate triple on the vertex.  It is an error to\n"
  " * call this if has_uvw(name) returned false.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_uvw_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::set_uvw(std::string const &name, LTexCoord3d const &texCoord)
 */
static PyObject *Dtool_EggVertex_set_uvw_183(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_uvw")) {
    return NULL;
  }
  // 1-void EggVertex::set_uvw(std::string const &name, LTexCoord3d const &texCoord)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "texCoord", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_uvw", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    LPoint3d param2_local;
    LTexCoord3d const *param2_this = Dtool_Coerce_LPoint3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggVertex.set_uvw", "LPoint3d");
    }
    (*local_this).set_uvw(std::string(param1_str, param1_len), *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uvw(const EggVertex self, str name, const LPoint3d texCoord)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_uvw_183_comment =
  "C++ Interface:\n"
  "set_uvw(const EggVertex self, str name, const LPoint3d texCoord)\n"
  "\n"
  "/**\n"
  " * Sets the indicated UV coordinate triple on the vertex.  This replaces any\n"
  " * UV coordinate pair or triple with the same name already on the vertex, but\n"
  " * preserves UV morphs.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_uvw_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertexUV const *EggVertex::get_uv_obj(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_get_uv_obj_184(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-EggVertexUV const *EggVertex::get_uv_obj(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    EggVertexUV const *return_value = (*(const EggVertex*)local_this).get_uv_obj(std::string(param1_str, param1_len));
    if (return_value != (EggVertexUV const *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertexUV const *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexUV, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_uv_obj(EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_uv_obj_184_comment =
  "C++ Interface:\n"
  "get_uv_obj(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the named EggVertexUV object, which defines both the UV coordinate\n"
  " * pair for this name and the UV morphs.  This object might be shared between\n"
  " * multiple vertices.  You should not attempt to modify this object; instead,\n"
  " * call modify_uv_object to return a modifiable pointer.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_uv_obj_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertexUV *EggVertex::modify_uv_obj(std::string const &name)
 */
static PyObject *Dtool_EggVertex_modify_uv_obj_185(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.modify_uv_obj")) {
    return NULL;
  }
  // 1-EggVertexUV *EggVertex::modify_uv_obj(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    EggVertexUV *return_value = (*local_this).modify_uv_obj(std::string(param1_str, param1_len));
    if (return_value != (EggVertexUV *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertexUV *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexUV, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_uv_obj(const EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_modify_uv_obj_185_comment =
  "C++ Interface:\n"
  "modify_uv_obj(const EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the named EggVertexUV object, which defines\n"
  " * both the UV coordinate pair for this name and the UV morphs.  Returns NULL\n"
  " * if there is no such named UV object.\n"
  " */";
#else
static const char *Dtool_EggVertex_modify_uv_obj_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::set_uv_obj(EggVertexUV *vertex_uv)
 */
static PyObject *Dtool_EggVertex_set_uv_obj_186(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_uv_obj")) {
    return NULL;
  }
  // 1-void EggVertex::set_uv_obj(EggVertexUV *vertex_uv)
  PT(EggVertexUV) arg_this;
  if (!Dtool_Coerce_EggVertexUV(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertex.set_uv_obj", "EggVertexUV");
  }
  (*local_this).set_uv_obj(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_obj(const EggVertex self, EggVertexUV vertex_uv)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_uv_obj_186_comment =
  "C++ Interface:\n"
  "set_uv_obj(const EggVertex self, EggVertexUV vertex_uv)\n"
  "\n"
  "/**\n"
  " * Sets the indicated EggVertexUV on the vertex.  This replaces any UV\n"
  " * coordinate pair with the same name already on the vertex, including UV\n"
  " * morphs.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_uv_obj_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertex::has_aux(void) const
 * bool EggVertex::has_aux(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_has_aux_187(PyObject *self, PyObject *args) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool EggVertex::has_aux(void) const
      bool return_value = (*(const EggVertex*)local_this).has_aux();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool EggVertex::has_aux(std::string const &name) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        bool return_value = (*(const EggVertex*)local_this).has_aux(std::string(param1_str, param1_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_aux() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_aux(EggVertex self)\n"
      "has_aux(EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_has_aux_187_comment =
  "C++ Interface:\n"
  "has_aux(EggVertex self)\n"
  "has_aux(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex has any auxiliary data, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex has the named auxiliary data quadruple.\n"
  " */";
#else
static const char *Dtool_EggVertex_has_aux_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::clear_aux(void)
 * void EggVertex::clear_aux(std::string const &name)
 */
static PyObject *Dtool_EggVertex_clear_aux_188(PyObject *self, PyObject *args) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.clear_aux")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void EggVertex::clear_aux(void)
      (*local_this).clear_aux();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void EggVertex::clear_aux(std::string const &name)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        (*local_this).clear_aux(std::string(param1_str, param1_len));
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_aux() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_aux(const EggVertex self)\n"
      "clear_aux(const EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_clear_aux_188_comment =
  "C++ Interface:\n"
  "clear_aux(const EggVertex self)\n"
  "clear_aux(const EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Removes all auxiliary data from the vertex.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the named auxiliary data from the vertex.\n"
  " */";
#else
static const char *Dtool_EggVertex_clear_aux_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase4d const &EggVertex::get_aux(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_get_aux_189(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVecBase4d const &EggVertex::get_aux(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    LVecBase4d const *return_value = &((*(const EggVertex*)local_this).get_aux(std::string(param1_str, param1_len)));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_aux(EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_aux_189_comment =
  "C++ Interface:\n"
  "get_aux(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the named auxiliary data quadruple on the vertex.  It is an error\n"
  " * to call this if has_aux(name) returned false.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_aux_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::set_aux(std::string const &name, LVecBase4d const &aux)
 */
static PyObject *Dtool_EggVertex_set_aux_190(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_aux")) {
    return NULL;
  }
  // 1-void EggVertex::set_aux(std::string const &name, LVecBase4d const &aux)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "aux", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_aux", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    LVecBase4d param2_local;
    LVecBase4d const *param2_this = Dtool_Coerce_LVecBase4d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggVertex.set_aux", "LVecBase4d");
    }
    (*local_this).set_aux(std::string(param1_str, param1_len), *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux(const EggVertex self, str name, const LVecBase4d aux)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_aux_190_comment =
  "C++ Interface:\n"
  "set_aux(const EggVertex self, str name, const LVecBase4d aux)\n"
  "\n"
  "/**\n"
  " * Sets the indicated auxiliary data quadruple on the vertex.  This replaces\n"
  " * any auxiliary data with the same name already on the vertex.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_aux_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertexAux const *EggVertex::get_aux_obj(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_get_aux_obj_191(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-EggVertexAux const *EggVertex::get_aux_obj(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    EggVertexAux const *return_value = (*(const EggVertex*)local_this).get_aux_obj(std::string(param1_str, param1_len));
    if (return_value != (EggVertexAux const *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertexAux const *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexAux, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_aux_obj(EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_aux_obj_191_comment =
  "C++ Interface:\n"
  "get_aux_obj(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the named EggVertexAux object, which defines the auxiliary data for\n"
  " * this name.  This object might be shared between multiple vertices.  You\n"
  " * should not attempt to modify this object; instead, call modify_aux_object\n"
  " * to return a modifiable pointer.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_aux_obj_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertexAux *EggVertex::modify_aux_obj(std::string const &name)
 */
static PyObject *Dtool_EggVertex_modify_aux_obj_192(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.modify_aux_obj")) {
    return NULL;
  }
  // 1-EggVertexAux *EggVertex::modify_aux_obj(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    EggVertexAux *return_value = (*local_this).modify_aux_obj(std::string(param1_str, param1_len));
    if (return_value != (EggVertexAux *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertexAux *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexAux, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_aux_obj(const EggVertex self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_modify_aux_obj_192_comment =
  "C++ Interface:\n"
  "modify_aux_obj(const EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the named EggVertexAux object, which\n"
  " * defines the auxiliary data for this name.  Returns NULL if there is no such\n"
  " * named UV object.\n"
  " */";
#else
static const char *Dtool_EggVertex_modify_aux_obj_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::set_aux_obj(EggVertexAux *vertex_aux)
 */
static PyObject *Dtool_EggVertex_set_aux_obj_193(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_aux_obj")) {
    return NULL;
  }
  // 1-void EggVertex::set_aux_obj(EggVertexAux *vertex_aux)
  PT(EggVertexAux) arg_this;
  if (!Dtool_Coerce_EggVertexAux(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertex.set_aux_obj", "EggVertexAux");
  }
  (*local_this).set_aux_obj(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux_obj(const EggVertex self, EggVertexAux vertex_aux)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_aux_obj_193_comment =
  "C++ Interface:\n"
  "set_aux_obj(const EggVertex self, EggVertexAux vertex_aux)\n"
  "\n"
  "/**\n"
  " * Sets the indicated EggVertexAux on the vertex.  This replaces any auxiliary\n"
  " * data with the same name already on the vertex.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_aux_obj_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< EggVertex > EggVertex::make_average(EggVertex const *first, EggVertex const *second)
 */
static PyObject *Dtool_EggVertex_make_average_194(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< EggVertex > EggVertex::make_average(EggVertex const *first, EggVertex const *second)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"first", "second", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_average", (char **)keyword_list, &param0, &param1)) {
    EggVertex const *param0_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_EggVertex, 0, "EggVertex.make_average", true, true);
    EggVertex const *param1_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggVertex, 1, "EggVertex.make_average", true, true);
    if (param0_this != NULL && param1_this != NULL) {
      PointerTo< EggVertex > return_value = EggVertex::make_average(param0_this, param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      EggVertex *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      if (return_ptr == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggVertex, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_average(const EggVertex first, const EggVertex second)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_make_average_194_comment =
  "C++ Interface:\n"
  "make_average(const EggVertex first, const EggVertex second)\n"
  "\n"
  "/**\n"
  " * Creates a new vertex that lies in between the two given vertices.  The\n"
  " * attributes for the UV sets they have in common are averaged.\n"
  " *\n"
  " * Both vertices need to be either in no pool, or in the same pool.  In the\n"
  " * latter case, the new vertex will be placed in that pool.\n"
  " */";
#else
static const char *Dtool_EggVertex_make_average_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggVertex::get_index(void) const
 */
static PyObject *Dtool_EggVertex_get_index_195(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggVertex::get_index(void) const
  int return_value = (*(const EggVertex*)local_this).get_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_index_195_comment =
  "C++ Interface:\n"
  "get_index(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the vertex within its pool.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_index_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::set_external_index(int external_index)
 */
static PyObject *Dtool_EggVertex_set_external_index_196(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_external_index")) {
    return NULL;
  }
  // 1-inline void EggVertex::set_external_index(int external_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_external_index((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_external_index(const EggVertex self, int external_index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_external_index_196_comment =
  "C++ Interface:\n"
  "set_external_index(const EggVertex self, int external_index)\n"
  "\n"
  "/**\n"
  " * Sets a special index number that is associated with the EggVertex (but is\n"
  " * not written to the egg file). This number is not interpreted by any egg\n"
  " * code; it is simply maintained along with the vertex.  It *is* used to\n"
  " * differentiate otherwise identical vertices in\n"
  " * EggVertexPool::create_unique_vertex(), however.\n"
  " *\n"
  " * The intention of this number is as an aid for file converters, to associate\n"
  " * an EggVertex back to the index number of the original source vertex.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_external_index_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggVertex::get_external_index(void) const
 */
static PyObject *Dtool_EggVertex_get_external_index_197(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggVertex::get_external_index(void) const
  int return_value = (*(const EggVertex*)local_this).get_external_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_external_index_197_comment =
  "C++ Interface:\n"
  "get_external_index(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the number set by set_external_index().  See set_external_index().\n"
  " */";
#else
static const char *Dtool_EggVertex_get_external_index_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::set_external_index2(int external_index2)
 */
static PyObject *Dtool_EggVertex_set_external_index2_198(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_external_index2")) {
    return NULL;
  }
  // 1-inline void EggVertex::set_external_index2(int external_index2)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_external_index2((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_external_index2(const EggVertex self, int external_index2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_external_index2_198_comment =
  "C++ Interface:\n"
  "set_external_index2(const EggVertex self, int external_index2)\n"
  "\n"
  "/**\n"
  " * Similar to set_external_index(), but this is a different number which may\n"
  " * be used for a different purpose by the calling code.  The egg library does\n"
  " * not assign any meaning to this number or use it in any way.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_external_index2_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggVertex::get_external_index2(void) const
 */
static PyObject *Dtool_EggVertex_get_external_index2_199(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggVertex::get_external_index2(void) const
  int return_value = (*(const EggVertex*)local_this).get_external_index2();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_external_index2_199_comment =
  "C++ Interface:\n"
  "get_external_index2(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the number set by set_external_index2().  See\n"
  " * set_external_index2().\n"
  " */";
#else
static const char *Dtool_EggVertex_get_external_index2_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggVertex_write_200(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggVertex::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggVertex.write", false, true);
    if (param1_this != NULL) {
      (*(const EggVertex*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggVertex self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_write_200_comment =
  "C++ Interface:\n"
  "write(EggVertex self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the vertex to the indicated output stream in Egg format.\n"
  " */";
#else
static const char *Dtool_EggVertex_write_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertex::sorts_less_than(EggVertex const &other) const
 */
static PyObject *Dtool_EggVertex_sorts_less_than_201(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggVertex::sorts_less_than(EggVertex const &other) const
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertex.sorts_less_than", true, true);
  if (arg_this != NULL) {
    bool return_value = (*(const EggVertex*)local_this).sorts_less_than(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sorts_less_than(EggVertex self, const EggVertex other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_sorts_less_than_201_comment =
  "C++ Interface:\n"
  "sorts_less_than(EggVertex self, const EggVertex other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " */";
#else
static const char *Dtool_EggVertex_sorts_less_than_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggVertex::compare_to(EggVertex const &other) const
 */
static PyObject *Dtool_EggVertex_compare_to_202(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggVertex::compare_to(EggVertex const &other) const
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertex.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const EggVertex*)local_this).compare_to(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertex self, const EggVertex other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_compare_to_202_comment =
  "C++ Interface:\n"
  "compare_to(EggVertex self, const EggVertex other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " *\n"
  " * Group membership is not considered in this comparison.  This is somewhat\n"
  " * problematic, but cannot easily be helped, because considering group\n"
  " * membership would make it difficult to add and remove groups from vertices.\n"
  " * It also makes it impossible to meaningfully compare with a concrete\n"
  " * EggVertex object (which cannot have group memberships).\n"
  " *\n"
  " * However, this is not altogether bad, because two vertices that are\n"
  " * identical in all other properties should generally also be identical in\n"
  " * group memberships, else the vertices will tend to fly apart when the joints\n"
  " * animate.\n"
  " */";
#else
static const char *Dtool_EggVertex_compare_to_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggVertex::get_num_local_coord(void) const
 */
static PyObject *Dtool_EggVertex_get_num_local_coord_203(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggVertex::get_num_local_coord(void) const
  int return_value = (*(const EggVertex*)local_this).get_num_local_coord();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_num_local_coord_203_comment =
  "C++ Interface:\n"
  "get_num_local_coord(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the number of primitives that own this vertex whose vertices are\n"
  " * interpreted to be in a local coordinate system.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_num_local_coord_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggVertex::get_num_global_coord(void) const
 */
static PyObject *Dtool_EggVertex_get_num_global_coord_204(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggVertex::get_num_global_coord(void) const
  int return_value = (*(const EggVertex*)local_this).get_num_global_coord();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_num_global_coord_204_comment =
  "C++ Interface:\n"
  "get_num_global_coord(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the number of primitives that own this vertex whose vertices are\n"
  " * interpreted in the global coordinate system.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_num_global_coord_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::transform(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggVertex_transform_205(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.transform")) {
    return NULL;
  }
  // 1-void EggVertex::transform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertex.transform", "LMatrix4d");
  }
  (*local_this).transform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggVertex self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_transform_205_comment =
  "C++ Interface:\n"
  "transform(const EggVertex self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation matrix to the vertex.\n"
  " */";
#else
static const char *Dtool_EggVertex_transform_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggVertex::has_gref(EggGroup const *group) const
 */
static PyObject *Dtool_EggVertex_has_gref_206(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggVertex::has_gref(EggGroup const *group) const
  CPT(EggGroup) arg_this;
  if (!Dtool_ConstCoerce_EggGroup(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertex.has_gref", "EggGroup");
  }
  bool return_value = (*(const EggVertex*)local_this).has_gref(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_gref(EggVertex self, const EggGroup group)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_has_gref_206_comment =
  "C++ Interface:\n"
  "has_gref(EggVertex self, const EggGroup group)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated group references this vertex, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggVertex_has_gref_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::copy_grefs_from(EggVertex const &other)
 */
static PyObject *Dtool_EggVertex_copy_grefs_from_207(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.copy_grefs_from")) {
    return NULL;
  }
  // 1-void EggVertex::copy_grefs_from(EggVertex const &other)
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertex.copy_grefs_from", true, true);
  if (arg_this != NULL) {
    (*local_this).copy_grefs_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_grefs_from(const EggVertex self, const EggVertex other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_copy_grefs_from_207_comment =
  "C++ Interface:\n"
  "copy_grefs_from(const EggVertex self, const EggVertex other)\n"
  "\n"
  "/**\n"
  " * Copies all the group references from the other vertex onto this one.  This\n"
  " * assigns the current vertex to exactly the same groups, with exactly the\n"
  " * same memberships, as the given one.\n"
  " *\n"
  " * Warning: only an EggVertex allocated from the free store may have groups\n"
  " * assigned to it.  Do not attempt to call this on a temporary concrete\n"
  " * EggVertex object; a core dump will certainly result.\n"
  " */";
#else
static const char *Dtool_EggVertex_copy_grefs_from_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::clear_grefs(void)
 */
static PyObject *Dtool_EggVertex_clear_grefs_208(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.clear_grefs")) {
    return NULL;
  }
  // 1-void EggVertex::clear_grefs(void)
  (*local_this).clear_grefs();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_clear_grefs_208_comment =
  "C++ Interface:\n"
  "clear_grefs(const EggVertex self)\n"
  "\n"
  "/**\n"
  " * Removes all group references from the vertex, so that it is not assigned to\n"
  " * any group.\n"
  " */";
#else
static const char *Dtool_EggVertex_clear_grefs_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggVertex::has_pref(EggPrimitive const *prim) const
 */
static PyObject *Dtool_EggVertex_has_pref_209(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggVertex::has_pref(EggPrimitive const *prim) const
  CPT(EggPrimitive) arg_this;
  if (!Dtool_ConstCoerce_EggPrimitive(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertex.has_pref", "EggPrimitive");
  }
  int return_value = (*(const EggVertex*)local_this).has_pref(MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_pref(EggVertex self, const EggPrimitive prim)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_has_pref_209_comment =
  "C++ Interface:\n"
  "has_pref(EggVertex self, const EggPrimitive prim)\n"
  "\n"
  "/**\n"
  " * Returns the number of times the vertex appears in the indicated primitive,\n"
  " * or 0 if it does not appear.\n"
  " */";
#else
static const char *Dtool_EggVertex_has_pref_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::test_gref_integrity(void) const
 */
static PyObject *Dtool_EggVertex_test_gref_integrity_210(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggVertex::test_gref_integrity(void) const
  (*(const EggVertex*)local_this).test_gref_integrity();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_test_gref_integrity_210_comment =
  "C++ Interface:\n"
  "test_gref_integrity(EggVertex self)\n";
#else
static const char *Dtool_EggVertex_test_gref_integrity_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::test_pref_integrity(void) const
 */
static PyObject *Dtool_EggVertex_test_pref_integrity_211(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggVertex::test_pref_integrity(void) const
  (*(const EggVertex*)local_this).test_pref_integrity();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_test_pref_integrity_211_comment =
  "C++ Interface:\n"
  "test_pref_integrity(EggVertex self)\n";
#else
static const char *Dtool_EggVertex_test_pref_integrity_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::output(ostream &out) const
 */
static PyObject *Dtool_EggVertex_output_212(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggVertex::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "EggVertex.output", false, true);
  if (arg_this != NULL) {
    (*(const EggVertex*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(EggVertex self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_output_212_comment =
  "C++ Interface:\n"
  "output(EggVertex self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertex_output_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggVertex::get_class_type(void)
 */
static PyObject *Dtool_EggVertex_get_class_type_217(PyObject *, PyObject *) {
  // 1-static TypeHandle EggVertex::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggVertex::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_class_type_217_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggVertex_get_class_type_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggObject *EggVertex::upcast_to_EggObject(void)
 */
static PyObject *Dtool_EggVertex_upcast_to_EggObject_161(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.upcast_to_EggObject")) {
    return NULL;
  }
  // 1-EggObject *EggVertex::upcast_to_EggObject(void)
  EggObject *return_value = (EggObject *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_upcast_to_EggObject_161_comment =
  "C++ Interface:\n"
  "upcast_to_EggObject(const EggVertex self)\n"
  "\n"
  "upcast from EggVertex to EggObject";
#else
static const char *Dtool_EggVertex_upcast_to_EggObject_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggAttributes *EggVertex::upcast_to_EggAttributes(void)
 */
static PyObject *Dtool_EggVertex_upcast_to_EggAttributes_163(PyObject *self, PyObject *) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.upcast_to_EggAttributes")) {
    return NULL;
  }
  // 1-EggAttributes *EggVertex::upcast_to_EggAttributes(void)
  EggAttributes *return_value = (EggAttributes *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_upcast_to_EggAttributes_163_comment =
  "C++ Interface:\n"
  "upcast_to_EggAttributes(const EggVertex self)\n"
  "\n"
  "upcast from EggVertex to EggAttributes";
#else
static const char *Dtool_EggVertex_upcast_to_EggAttributes_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertex::EggVertex(void)
 * EggVertex::EggVertex(EggVertex const &copy)
 */
static int Dtool_Init_EggVertex(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggVertex::EggVertex(void)
      EggVertex *return_value = new EggVertex();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertex, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-EggVertex::EggVertex(EggVertex const &copy)
      EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 0, "EggVertex.EggVertex", true, true);
      if (arg_this != NULL) {
        EggVertex *return_value = new EggVertex(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertex, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggVertex() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggVertex()\n"
      "EggVertex(const EggVertex copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggVertex(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggVertex) {
    printf("EggVertex ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggVertex *local_this = (EggVertex *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggVertex) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggVertex(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggVertex) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggVertex*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggVertex*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggVertex*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggVertex*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggVertex*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggVertexPool
 */
/**
 * Python function wrapper for:
 * inline bool EggVertexPool::has_vertex(int index) const
 */
static PyObject *Dtool_EggVertexPool_has_vertex_220(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggVertexPool::has_vertex(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const EggVertexPool*)local_this).has_vertex((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_vertex(EggVertexPool self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_vertex_220_comment =
  "C++ Interface:\n"
  "has_vertex(EggVertexPool self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated vertex has been defined in the vertex pool,\n"
  " * false otherwise.  This does not include forward references.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_vertex_220_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_forward_vertices(void) const
 */
static PyObject *Dtool_EggVertexPool_has_forward_vertices_221(PyObject *self, PyObject *) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggVertexPool::has_forward_vertices(void) const
  bool return_value = (*(const EggVertexPool*)local_this).has_forward_vertices();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_forward_vertices_221_comment =
  "C++ Interface:\n"
  "has_forward_vertices(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertices in the pool are undefined forward-reference\n"
  " * vertices, false if all vertices are defined.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_forward_vertices_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_defined_vertices(void) const
 */
static PyObject *Dtool_EggVertexPool_has_defined_vertices_222(PyObject *self, PyObject *) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggVertexPool::has_defined_vertices(void) const
  bool return_value = (*(const EggVertexPool*)local_this).has_defined_vertices();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_defined_vertices_222_comment =
  "C++ Interface:\n"
  "has_defined_vertices(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertices in the pool are fully defined vertices, false\n"
  " * if all vertices are forward references.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_defined_vertices_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggVertexPool::get_vertex(int index) const
 */
static PyObject *Dtool_EggVertexPool_get_vertex_223(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }
  // 1-EggVertex *EggVertexPool::get_vertex(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggVertex *return_value = (*(const EggVertexPool*)local_this).get_vertex((int)arg_val);
    if (return_value != (EggVertex *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertex *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(EggVertexPool self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_get_vertex_223_comment =
  "C++ Interface:\n"
  "get_vertex(EggVertexPool self, int index)\n"
  "\n"
  "// Returns NULL if there is no such vertex.\n"
  "\n"
  "/**\n"
  " * Returns the vertex in the pool with the indicated index number, or NULL if\n"
  " * no vertices have that index number.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_get_vertex_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggVertexPool::get_forward_vertex(int index)
 */
static PyObject *Dtool_EggVertexPool_get_forward_vertex_225(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.get_forward_vertex")) {
    return NULL;
  }
  // 1-EggVertex *EggVertexPool::get_forward_vertex(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggVertex *return_value = (*local_this).get_forward_vertex((int)arg_val);
    if (return_value != (EggVertex *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertex *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_forward_vertex(const EggVertexPool self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_get_forward_vertex_225_comment =
  "C++ Interface:\n"
  "get_forward_vertex(const EggVertexPool self, int index)\n"
  "\n"
  "// Returns a forward reference if there is no such vertex.\n"
  "\n"
  "/**\n"
  " * Returns the vertex in the pool with the indicated index number.  If there\n"
  " * is not a vertex in the pool with the indicated index number, creates a\n"
  " * special forward-reference EggVertex that has no data, on the assumption\n"
  " * that the vertex pool has not yet been fully read and more data will be\n"
  " * available later.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_get_forward_vertex_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggVertexPool::get_highest_index(void) const
 */
static PyObject *Dtool_EggVertexPool_get_highest_index_226(PyObject *self, PyObject *) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggVertexPool::get_highest_index(void) const
  int return_value = (*(const EggVertexPool*)local_this).get_highest_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_get_highest_index_226_comment =
  "C++ Interface:\n"
  "get_highest_index(EggVertexPool self)\n"
  "\n"
  "// Returns 0 if the pool is empty.\n"
  "\n"
  "/**\n"
  " * Returns the highest index number used by any vertex in the pool (except\n"
  " * forward references).  Returns -1 if the pool is empty.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_get_highest_index_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertexPool::set_highest_index(int highest_index)
 */
static PyObject *Dtool_EggVertexPool_set_highest_index_227(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.set_highest_index")) {
    return NULL;
  }
  // 1-void EggVertexPool::set_highest_index(int highest_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_highest_index((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_highest_index(const EggVertexPool self, int highest_index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_set_highest_index_227_comment =
  "C++ Interface:\n"
  "set_highest_index(const EggVertexPool self, int highest_index)\n"
  "\n"
  "/**\n"
  " * Artificially changes the \"highest index number\", so that a newly created\n"
  " * vertex will begin at this number plus 1.  This can be used to default a\n"
  " * vertex pool to start counting at 1 (or any other index number), instead of\n"
  " * the default of 0.  Use with caution.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_set_highest_index_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggVertexPool::get_num_dimensions(void) const
 */
static PyObject *Dtool_EggVertexPool_get_num_dimensions_228(PyObject *self, PyObject *) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggVertexPool::get_num_dimensions(void) const
  int return_value = (*(const EggVertexPool*)local_this).get_num_dimensions();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_get_num_dimensions_228_comment =
  "C++ Interface:\n"
  "get_num_dimensions(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of dimensions used by any vertex in the pool.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_get_num_dimensions_228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggVertexPool::has_normals(void) const
 */
static PyObject *Dtool_EggVertexPool_has_normals_229(PyObject *self, PyObject *) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool EggVertexPool::has_normals(void) const
  bool return_value = (*(const EggVertexPool*)local_this).has_normals();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_normals_229_comment =
  "C++ Interface:\n"
  "has_normals(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex in the pool has a normal defined, false if none\n"
  " * of them do.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_normals_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_colors(void) const
 */
static PyObject *Dtool_EggVertexPool_has_colors_230(PyObject *self, PyObject *) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggVertexPool::has_colors(void) const
  bool return_value = (*(const EggVertexPool*)local_this).has_colors();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_colors_230_comment =
  "C++ Interface:\n"
  "has_colors(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex in the pool has a color defined, false if none\n"
  " * of them do.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_colors_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_nonwhite_colors(void) const
 */
static PyObject *Dtool_EggVertexPool_has_nonwhite_colors_231(PyObject *self, PyObject *) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggVertexPool::has_nonwhite_colors(void) const
  bool return_value = (*(const EggVertexPool*)local_this).has_nonwhite_colors();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_nonwhite_colors_231_comment =
  "C++ Interface:\n"
  "has_nonwhite_colors(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex in the pool has a color defined other than\n"
  " * white, false if no vertices have colors, or if all colors are white.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_nonwhite_colors_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_uvs(void) const
 */
static PyObject *Dtool_EggVertexPool_has_uvs_233(PyObject *self, PyObject *) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggVertexPool::has_uvs(void) const
  bool return_value = (*(const EggVertexPool*)local_this).has_uvs();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_uvs_233_comment =
  "C++ Interface:\n"
  "has_uvs(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex in the pool has a uv defined, false if none of\n"
  " * them do.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_uvs_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_aux(void) const
 */
static PyObject *Dtool_EggVertexPool_has_aux_234(PyObject *self, PyObject *) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggVertexPool::has_aux(void) const
  bool return_value = (*(const EggVertexPool*)local_this).has_aux();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_aux_234_comment =
  "C++ Interface:\n"
  "has_aux(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex in the pool has auxiliary data defined, false if\n"
  " * none of them do.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_aux_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggVertexPool::add_vertex(EggVertex *vertex, int index = -1)
 */
static PyObject *Dtool_EggVertexPool_add_vertex_238(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.add_vertex")) {
    return NULL;
  }
  // 1-EggVertex *EggVertexPool::add_vertex(EggVertex *vertex, int index = -1)
  PyObject *param1;
  int param2 = -1;
  static const char *keyword_list[] = {"vertex", "index", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:add_vertex", (char **)keyword_list, &param1, &param2)) {
    EggVertex *param1_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggVertex, 1, "EggVertexPool.add_vertex", false, true);
    if (param1_this != NULL) {
      EggVertex *return_value = (*local_this).add_vertex(param1_this, (int)param2);
      if (return_value != (EggVertex *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (EggVertex *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const EggVertexPool self, EggVertex vertex, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_add_vertex_238_comment =
  "C++ Interface:\n"
  "add_vertex(const EggVertexPool self, EggVertex vertex, int index)\n"
  "\n"
  "// add_vertex() adds a freshly-allocated vertex.  It is up to the user to\n"
  "// allocate the vertex.\n"
  "\n"
  "/**\n"
  " * Adds the indicated vertex to the pool.  It is an error if the vertex is\n"
  " * already a member of this or any other pool.  The vertex must have been\n"
  " * allocated from the free store; its pointer will now be owned by the vertex\n"
  " * pool.  If the index number is supplied, tries to assign that index number;\n"
  " * it is an error if the index number is already in use.\n"
  " *\n"
  " * It is possible that a forward reference to this vertex was requested in the\n"
  " * past; if so, the data from the supplied vertex is copied onto the forward\n"
  " * reference, which becomes the actual vertex.  In this case, a different\n"
  " * pointer is saved (and returned) than the one actually passed in.  In the\n"
  " * usual case, however, the vertex pointer passed in is the one that is saved\n"
  " * in the vertex pool and returned from this method.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_add_vertex_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggVertex *EggVertexPool::make_new_vertex(void)
 * inline EggVertex *EggVertexPool::make_new_vertex(LPoint2d const &pos)
 * inline EggVertex *EggVertexPool::make_new_vertex(LPoint3d const &pos)
 * inline EggVertex *EggVertexPool::make_new_vertex(LPoint4d const &pos)
 * inline EggVertex *EggVertexPool::make_new_vertex(double pos)
 */
static PyObject *Dtool_EggVertexPool_make_new_vertex_239(PyObject *self, PyObject *args) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.make_new_vertex")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggVertex *EggVertexPool::make_new_vertex(void)
      EggVertex *return_value = (*local_this).make_new_vertex();
      if (return_value != (EggVertex *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (EggVertex *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint2d const &pos)
        LPoint2d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint2d, (void **)&arg_this);
        if (arg_this != NULL) {
          EggVertex *return_value = (*local_this).make_new_vertex(*arg_this);
          if (return_value != (EggVertex *)NULL) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != (EggVertex *)NULL) {
              unref_delete(return_value);
            }
            return NULL;
          }
          if (return_value == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint3d const &pos)
        LPoint3d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint3d, (void **)&arg_this);
        if (arg_this != NULL) {
          EggVertex *return_value = (*local_this).make_new_vertex(*arg_this);
          if (return_value != (EggVertex *)NULL) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != (EggVertex *)NULL) {
              unref_delete(return_value);
            }
            return NULL;
          }
          if (return_value == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint4d const &pos)
        LPoint4d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint4d, (void **)&arg_this);
        if (arg_this != NULL) {
          EggVertex *return_value = (*local_this).make_new_vertex(*arg_this);
          if (return_value != (EggVertex *)NULL) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != (EggVertex *)NULL) {
              unref_delete(return_value);
            }
            return NULL;
          }
          if (return_value == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(double pos)
        if (PyNumber_Check(arg)) {
          EggVertex *return_value = (*local_this).make_new_vertex(PyFloat_AsDouble(arg));
          if (return_value != (EggVertex *)NULL) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != (EggVertex *)NULL) {
              unref_delete(return_value);
            }
            return NULL;
          }
          if (return_value == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint2d const &pos)
        LPoint2d arg_local;
        LPoint2d const *arg_this = Dtool_Coerce_LPoint2d(arg, arg_local);
        if ((arg_this != NULL)) {
          EggVertex *return_value = (*local_this).make_new_vertex(*arg_this);
          if (return_value != (EggVertex *)NULL) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != (EggVertex *)NULL) {
              unref_delete(return_value);
            }
            return NULL;
          }
          if (return_value == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint3d const &pos)
        LPoint3d arg_local;
        LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
        if ((arg_this != NULL)) {
          EggVertex *return_value = (*local_this).make_new_vertex(*arg_this);
          if (return_value != (EggVertex *)NULL) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != (EggVertex *)NULL) {
              unref_delete(return_value);
            }
            return NULL;
          }
          if (return_value == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint4d const &pos)
        LPoint4d arg_local;
        LPoint4d const *arg_this = Dtool_Coerce_LPoint4d(arg, arg_local);
        if ((arg_this != NULL)) {
          EggVertex *return_value = (*local_this).make_new_vertex(*arg_this);
          if (return_value != (EggVertex *)NULL) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != (EggVertex *)NULL) {
              unref_delete(return_value);
            }
            return NULL;
          }
          if (return_value == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      // No coercion possible: inline EggVertex *EggVertexPool::make_new_vertex(double pos)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_new_vertex() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_new_vertex(const EggVertexPool self)\n"
      "make_new_vertex(const EggVertexPool self, const LPoint2d pos)\n"
      "make_new_vertex(const EggVertexPool self, const LPoint3d pos)\n"
      "make_new_vertex(const EggVertexPool self, const LPoint4d pos)\n"
      "make_new_vertex(const EggVertexPool self, double pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_make_new_vertex_239_comment =
  "C++ Interface:\n"
  "make_new_vertex(const EggVertexPool self)\n"
  "make_new_vertex(const EggVertexPool self, const LPoint2d pos)\n"
  "make_new_vertex(const EggVertexPool self, const LPoint3d pos)\n"
  "make_new_vertex(const EggVertexPool self, const LPoint4d pos)\n"
  "make_new_vertex(const EggVertexPool self, double pos)\n"
  "\n"
  "// make_new_vertex() allocates and returns a new vertex from the pool.\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new vertex from the pool.  This is one of three\n"
  " * ways to add new vertices to a vertex pool.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new vertex from the pool.  This is one of three\n"
  " * ways to add new vertices to a vertex pool.\n"
  " *\n"
  " * This flavor of make_new_vertex() explicitly sets the vertex position as it\n"
  " * is allocated.  It does not attempt to share vertices.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new vertex from the pool.  This is one of three\n"
  " * ways to add new vertices to a vertex pool.\n"
  " *\n"
  " * This flavor of make_new_vertex() explicitly sets the vertex position as it\n"
  " * is allocated.  It does not attempt to share vertices.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new vertex from the pool.  This is one of three\n"
  " * ways to add new vertices to a vertex pool.\n"
  " *\n"
  " * This flavor of make_new_vertex() explicitly sets the vertex position as it\n"
  " * is allocated.  It does not attempt to share vertices.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new vertex from the pool.  This is one of three\n"
  " * ways to add new vertices to a vertex pool.\n"
  " *\n"
  " * This flavor of make_new_vertex() explicitly sets the vertex position as it\n"
  " * is allocated.  It does not attempt to share vertices.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_make_new_vertex_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggVertexPool::create_unique_vertex(EggVertex const &copy)
 */
static PyObject *Dtool_EggVertexPool_create_unique_vertex_240(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.create_unique_vertex")) {
    return NULL;
  }
  // 1-EggVertex *EggVertexPool::create_unique_vertex(EggVertex const &copy)
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertexPool.create_unique_vertex", true, true);
  if (arg_this != NULL) {
    EggVertex *return_value = (*local_this).create_unique_vertex(*arg_this);
    if (return_value != (EggVertex *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertex *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "create_unique_vertex(const EggVertexPool self, const EggVertex copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_create_unique_vertex_240_comment =
  "C++ Interface:\n"
  "create_unique_vertex(const EggVertexPool self, const EggVertex copy)\n"
  "\n"
  "// create_unique_vertex() creates a new vertex if there is not already one\n"
  "// identical to the indicated vertex, or returns the existing one if there\n"
  "// is.\n"
  "\n"
  "/**\n"
  " * Creates a new vertex in the pool that is a copy of the indicated one and\n"
  " * returns it.  If there is already a vertex in the pool like the indicated\n"
  " * one, simply returns that one.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_create_unique_vertex_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggVertexPool::find_matching_vertex(EggVertex const &copy)
 */
static PyObject *Dtool_EggVertexPool_find_matching_vertex_241(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.find_matching_vertex")) {
    return NULL;
  }
  // 1-EggVertex *EggVertexPool::find_matching_vertex(EggVertex const &copy)
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertexPool.find_matching_vertex", true, true);
  if (arg_this != NULL) {
    EggVertex *return_value = (*local_this).find_matching_vertex(*arg_this);
    if (return_value != (EggVertex *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertex *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_matching_vertex(const EggVertexPool self, const EggVertex copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_find_matching_vertex_241_comment =
  "C++ Interface:\n"
  "find_matching_vertex(const EggVertexPool self, const EggVertex copy)\n"
  "\n"
  "/**\n"
  " * If the EggVertexPool already has a vertex matching the indicated vertex,\n"
  " * returns it; otherwise, returns NULL.  This is similar to\n"
  " * create_unique_vertex() except that a new vertex is never created.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_find_matching_vertex_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertexPool::remove_vertex(EggVertex *vertex)
 */
static PyObject *Dtool_EggVertexPool_remove_vertex_242(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.remove_vertex")) {
    return NULL;
  }
  // 1-void EggVertexPool::remove_vertex(EggVertex *vertex)
  EggVertex *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertexPool.remove_vertex", false, true);
  if (arg_this != NULL) {
    (*local_this).remove_vertex(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_vertex(const EggVertexPool self, EggVertex vertex)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_remove_vertex_242_comment =
  "C++ Interface:\n"
  "remove_vertex(const EggVertexPool self, EggVertex vertex)\n"
  "\n"
  "/**\n"
  " * Removes the vertex from the pool.  It is an error if the vertex is not\n"
  " * already a member of the pool.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_remove_vertex_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggVertexPool::remove_unused_vertices(void)
 */
static PyObject *Dtool_EggVertexPool_remove_unused_vertices_243(PyObject *self, PyObject *) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.remove_unused_vertices")) {
    return NULL;
  }
  // 1-int EggVertexPool::remove_unused_vertices(void)
  int return_value = (*local_this).remove_unused_vertices();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_remove_unused_vertices_243_comment =
  "C++ Interface:\n"
  "remove_unused_vertices(const EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Removes all vertices from the pool that are not referenced by at least one\n"
  " * primitive.  Also collapses together equivalent vertices, and renumbers all\n"
  " * vertices after the operation so their indices are consecutive, beginning at\n"
  " * zero.  Returns the number of vertices removed.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_remove_unused_vertices_243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertexPool::add_unused_vertices_to_prim(EggPrimitive *prim)
 */
static PyObject *Dtool_EggVertexPool_add_unused_vertices_to_prim_244(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.add_unused_vertices_to_prim")) {
    return NULL;
  }
  // 1-void EggVertexPool::add_unused_vertices_to_prim(EggPrimitive *prim)
  PT(EggPrimitive) arg_this;
  if (!Dtool_Coerce_EggPrimitive(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexPool.add_unused_vertices_to_prim", "EggPrimitive");
  }
  (*local_this).add_unused_vertices_to_prim(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_unused_vertices_to_prim(const EggVertexPool self, EggPrimitive prim)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_add_unused_vertices_to_prim_244_comment =
  "C++ Interface:\n"
  "add_unused_vertices_to_prim(const EggVertexPool self, EggPrimitive prim)\n"
  "\n"
  "/**\n"
  " * Adds all of the unused vertices in this vertex pool to the indicated\n"
  " * primitive, in ascending order.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_add_unused_vertices_to_prim_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertexPool::transform(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggVertexPool_transform_245(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.transform")) {
    return NULL;
  }
  // 1-void EggVertexPool::transform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexPool.transform", "LMatrix4d");
  }
  (*local_this).transform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggVertexPool self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_transform_245_comment =
  "C++ Interface:\n"
  "transform(const EggVertexPool self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation matrix to all the vertices.  However,\n"
  " * vertices that are attached to primitives that believe their vertices are in\n"
  " * a local coordinate system are transformed only by the scale and rotation\n"
  " * component.  If a vertex happens to be attached both to a local and a global\n"
  " * primitive, and the transformation includes a translation component, the\n"
  " * vertex will be split.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_transform_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggVertexPool::sort_by_external_index(void)
 */
static PyObject *Dtool_EggVertexPool_sort_by_external_index_246(PyObject *self, PyObject *) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.sort_by_external_index")) {
    return NULL;
  }
  // 1-void EggVertexPool::sort_by_external_index(void)
  (*local_this).sort_by_external_index();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_sort_by_external_index_246_comment =
  "C++ Interface:\n"
  "sort_by_external_index(const EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Re-orders (and re-numbers) the vertices in this vertex pool so that they\n"
  " * appear in increasing order by the optional external_index that has been\n"
  " * assigned to each vertex.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_sort_by_external_index_246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggVertexPool::get_class_type(void)
 */
static PyObject *Dtool_EggVertexPool_get_class_type_247(PyObject *, PyObject *) {
  // 1-static TypeHandle EggVertexPool::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggVertexPool::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_get_class_type_247_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggVertexPool_get_class_type_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertexPool::EggVertexPool(EggVertexPool const &copy)
 * EggVertexPool::EggVertexPool(std::string const &name)
 */
static int Dtool_Init_EggVertexPool(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EggVertexPool() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 EggVertexPool::EggVertexPool(EggVertexPool const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggVertexPool", (char **)keyword_list, &param0)) {
      EggVertexPool const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggVertexPool, (void **)&param0_this);
      if (param0_this != NULL) {
        EggVertexPool *return_value = new EggVertexPool(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexPool, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 EggVertexPool::EggVertexPool(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggVertexPool", (char **)keyword_list, &param0_str, &param0_len)) {
      EggVertexPool *return_value = new EggVertexPool(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexPool, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 EggVertexPool::EggVertexPool(EggVertexPool const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggVertexPool", (char **)keyword_list, &param0)) {
      CPT(EggVertexPool) param0_this;
      if (Dtool_ConstCoerce_EggVertexPool(param0, param0_this)) {
        EggVertexPool *return_value = new EggVertexPool(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexPool, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: EggVertexPool::EggVertexPool(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggVertexPool(const EggVertexPool copy)\n"
      "EggVertexPool(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggVertexPool(PyObject *args, CPT(EggVertexPool) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggVertexPool, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggVertexPool::EggVertexPool(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggVertexPool *return_value = new EggVertexPool(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_EggVertexPool(PyObject *args, PT(EggVertexPool) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggVertexPool, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggVertexPool::EggVertexPool(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggVertexPool *return_value = new EggVertexPool(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_EggVertexPool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggVertexPool) {
    printf("EggVertexPool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggVertexPool *local_this = (EggVertexPool *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggVertexPool) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggVertexPool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggVertexPool) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggVertexPool*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggGroupNode
 */
/**
 * Python function wrapper for:
 * EggGroupNode &EggGroupNode::operator =(EggGroupNode const &copy)
 */
static PyObject *Dtool_EggGroupNode_operator_250(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.assign")) {
    return NULL;
  }
  // 1-EggGroupNode &EggGroupNode::operator =(EggGroupNode const &copy)
  CPT(EggGroupNode) arg_this;
  if (!Dtool_ConstCoerce_EggGroupNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroupNode.assign", "EggGroupNode");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggGroupNode *return_value = local_this;
  if (return_value != (EggGroupNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggGroupNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroupNode, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggGroupNode self, const EggGroupNode copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_operator_250_comment =
  "C++ Interface:\n"
  "assign(const EggGroupNode self, const EggGroupNode copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroupNode_operator_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggGroupNode::empty(void) const
 */
static PyObject *Dtool_EggGroupNode_empty_251(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroupNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggGroupNode::empty(void) const
  bool return_value = (*(const EggGroupNode*)local_this).empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_empty_251_comment =
  "C++ Interface:\n"
  "empty(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroupNode_empty_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggGroupNode::size_type EggGroupNode::size(void) const
 */
static PyObject *Dtool_EggGroupNode_size_252(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroupNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-EggGroupNode::size_type EggGroupNode::size(void) const
  EggGroupNode::size_type return_value = (*(const EggGroupNode*)local_this).size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_size_252_comment =
  "C++ Interface:\n"
  "size(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroupNode_size_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::clear(void)
 */
static PyObject *Dtool_EggGroupNode_clear_253(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.clear")) {
    return NULL;
  }
  // 1-void EggGroupNode::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_clear_253_comment =
  "C++ Interface:\n"
  "clear(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroupNode_clear_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggGroupNode::get_first_child(void)
 */
static PyObject *Dtool_EggGroupNode_get_first_child_254(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.get_first_child")) {
    return NULL;
  }
  // 1-EggNode *EggGroupNode::get_first_child(void)
  EggNode *return_value = (*local_this).get_first_child();
  if (return_value != (EggNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_get_first_child_254_comment =
  "C++ Interface:\n"
  "get_first_child(const EggGroupNode self)\n"
  "\n"
  "// This is an alternate way to traverse the list of children.  It is mainly\n"
  "// provided for scripting code, which can't use the iterators defined above\n"
  "// (they don't export through interrogate very well). These are, of course,\n"
  "// non-thread-safe.\n"
  "\n"
  "/**\n"
  " * Returns the first child in the group's list of children, or NULL if the\n"
  " * list of children is empty.  Can be used with get_next_child() to return the\n"
  " * complete list of children without using the iterator class; however, this\n"
  " * is non-thread-safe, and so is not recommended except for languages other\n"
  " * than C++ which cannot use the iterators.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_get_first_child_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggGroupNode::get_next_child(void)
 */
static PyObject *Dtool_EggGroupNode_get_next_child_255(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.get_next_child")) {
    return NULL;
  }
  // 1-EggNode *EggGroupNode::get_next_child(void)
  EggNode *return_value = (*local_this).get_next_child();
  if (return_value != (EggNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_get_next_child_255_comment =
  "C++ Interface:\n"
  "get_next_child(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Returns the next child in the group's list of children since the last call\n"
  " * to get_first_child() or get_next_child(), or NULL if the last child has\n"
  " * been returned.  Can be used with get_first_child() to return the complete\n"
  " * list of children without using the iterator class; however, this is non-\n"
  " * thread-safe, and so is not recommended except for languages other than C++\n"
  " * which cannot use the iterators.\n"
  " *\n"
  " * It is an error to call this without previously calling get_first_child().\n"
  " */";
#else
static const char *Dtool_EggGroupNode_get_next_child_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *EggGroupNode::get_children(void) const
 */
static PyObject *Dtool_EggGroupNode_get_children_256(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroupNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *EggGroupNode::get_children(void) const
  PyObject *return_value = invoke_extension((const EggGroupNode*)local_this).get_children();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_get_children_256_comment =
  "C++ Interface:\n"
  "get_children(EggGroupNode self)\n";
#else
static const char *Dtool_EggGroupNode_get_children_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggGroupNode::add_child(EggNode *node)
 */
static PyObject *Dtool_EggGroupNode_add_child_257(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.add_child")) {
    return NULL;
  }
  // 1-EggNode *EggGroupNode::add_child(EggNode *node)
  PT(EggNode) arg_this;
  if (!Dtool_Coerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroupNode.add_child", "EggNode");
  }
  EggNode *return_value = (*local_this).add_child(MOVE(arg_this));
  if (return_value != (EggNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_child(const EggGroupNode self, EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_add_child_257_comment =
  "C++ Interface:\n"
  "add_child(const EggGroupNode self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Adds the indicated child to the group and returns it.  If the child node is\n"
  " * already a child of some other node, removes it first.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_add_child_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< EggNode > EggGroupNode::remove_child(EggNode *node)
 */
static PyObject *Dtool_EggGroupNode_remove_child_258(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.remove_child")) {
    return NULL;
  }
  // 1-PointerTo< EggNode > EggGroupNode::remove_child(EggNode *node)
  PT(EggNode) arg_this;
  if (!Dtool_Coerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroupNode.remove_child", "EggNode");
  }
  PointerTo< EggNode > return_value = (*local_this).remove_child(MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  EggNode *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_child(const EggGroupNode self, EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_remove_child_258_comment =
  "C++ Interface:\n"
  "remove_child(const EggGroupNode self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Removes the indicated child node from the group and returns it.  If the\n"
  " * child was not already in the group, does nothing and returns NULL.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_remove_child_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::steal_children(EggGroupNode &other)
 */
static PyObject *Dtool_EggGroupNode_steal_children_259(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.steal_children")) {
    return NULL;
  }
  // 1-void EggGroupNode::steal_children(EggGroupNode &other)
  PT(EggGroupNode) arg_this;
  if (!Dtool_Coerce_EggGroupNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroupNode.steal_children", "EggGroupNode");
  }
  (*local_this).steal_children(*MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "steal_children(const EggGroupNode self, EggGroupNode other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_steal_children_259_comment =
  "C++ Interface:\n"
  "steal_children(const EggGroupNode self, EggGroupNode other)\n"
  "\n"
  "/**\n"
  " * Moves all the children from the other node to this one.  This is especially\n"
  " * useful because the group node copy assignment operator does not copy\n"
  " * children.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_steal_children_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggGroupNode::find_child(std::string const &name) const
 */
static PyObject *Dtool_EggGroupNode_find_child_260(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroupNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-EggNode *EggGroupNode::find_child(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    EggNode *return_value = (*(const EggGroupNode*)local_this).find_child(std::string(param1_str, param1_len));
    if (return_value != (EggNode *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggNode *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_child(EggGroupNode self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_find_child_260_comment =
  "C++ Interface:\n"
  "find_child(EggGroupNode self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the child of this node whose name is the indicated string, or NULL\n"
  " * if there is no child of this node by that name.  Does not search\n"
  " * recursively.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_find_child_260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggGroupNode::has_absolute_pathnames(void) const
 */
static PyObject *Dtool_EggGroupNode_has_absolute_pathnames_261(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroupNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggGroupNode::has_absolute_pathnames(void) const
  bool return_value = (*(const EggGroupNode*)local_this).has_absolute_pathnames();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_has_absolute_pathnames_261_comment =
  "C++ Interface:\n"
  "has_absolute_pathnames(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if any nodes at this level and below include a reference to a\n"
  " * file via an absolute pathname, or false if all references are relative.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_has_absolute_pathnames_261_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::resolve_filenames(DSearchPath const &searchpath)
 */
static PyObject *Dtool_EggGroupNode_resolve_filenames_262(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.resolve_filenames")) {
    return NULL;
  }
  // 1-void EggGroupNode::resolve_filenames(DSearchPath const &searchpath)
  DSearchPath const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DSearchPath(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroupNode.resolve_filenames", "DSearchPath");
  }
  (*local_this).resolve_filenames(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resolve_filenames(const EggGroupNode self, const DSearchPath searchpath)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_resolve_filenames_262_comment =
  "C++ Interface:\n"
  "resolve_filenames(const EggGroupNode self, const DSearchPath searchpath)\n"
  "\n"
  "/**\n"
  " * Walks the tree and attempts to resolve any filenames encountered.  This\n"
  " * looks up filenames along the specified search path; it does not\n"
  " * automatically search the model_path for missing files.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_resolve_filenames_262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::force_filenames(Filename const &directory)
 */
static PyObject *Dtool_EggGroupNode_force_filenames_263(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.force_filenames")) {
    return NULL;
  }
  // 1-void EggGroupNode::force_filenames(Filename const &directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroupNode.force_filenames", "Filename");
  }
  (*local_this).force_filenames(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "force_filenames(const EggGroupNode self, const Filename directory)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_force_filenames_263_comment =
  "C++ Interface:\n"
  "force_filenames(const EggGroupNode self, const Filename directory)\n"
  "\n"
  "/**\n"
  " * Similar to resolve_filenames, but each non-absolute filename encountered is\n"
  " * arbitrarily taken to be in the indicated directory, whether or not the so-\n"
  " * named filename exists.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_force_filenames_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::reverse_vertex_ordering(void)
 */
static PyObject *Dtool_EggGroupNode_reverse_vertex_ordering_264(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.reverse_vertex_ordering")) {
    return NULL;
  }
  // 1-void EggGroupNode::reverse_vertex_ordering(void)
  (*local_this).reverse_vertex_ordering();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_reverse_vertex_ordering_264_comment =
  "C++ Interface:\n"
  "reverse_vertex_ordering(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Reverses the vertex ordering of all polygons defined at this node and\n"
  " * below.  Does not change the surface normals, if any.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_reverse_vertex_ordering_264_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::recompute_vertex_normals(double threshold, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_EggGroupNode_recompute_vertex_normals_265(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.recompute_vertex_normals")) {
    return NULL;
  }
  // 1-void EggGroupNode::recompute_vertex_normals(double threshold, CoordinateSystem cs = ::CS_default)
  double param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"threshold", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "d|i:recompute_vertex_normals", (char **)keyword_list, &param1, &param2)) {
    (*local_this).recompute_vertex_normals((double)param1, (CoordinateSystem)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "recompute_vertex_normals(const EggGroupNode self, double threshold, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_recompute_vertex_normals_265_comment =
  "C++ Interface:\n"
  "recompute_vertex_normals(const EggGroupNode self, double threshold, int cs)\n"
  "\n"
  "/**\n"
  " * Recomputes all the vertex normals for polygon geometry at this group node\n"
  " * and below so that they accurately reflect the vertex positions.  A shared\n"
  " * edge between two polygons (even in different groups) is considered smooth\n"
  " * if the angle between the two edges is less than threshold degrees.\n"
  " *\n"
  " * This function also removes degenerate polygons that do not have enough\n"
  " * vertices to define a normal.  It does not affect normals for other kinds of\n"
  " * primitives like Nurbs or Points.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the correct normals.  Thus, it is a good idea\n"
  " * to call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_recompute_vertex_normals_265_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::recompute_polygon_normals(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_EggGroupNode_recompute_polygon_normals_266(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.recompute_polygon_normals")) {
    return NULL;
  }
  // 1-void EggGroupNode::recompute_polygon_normals(CoordinateSystem cs = ::CS_default)
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:recompute_polygon_normals", (char **)keyword_list, &param1)) {
    (*local_this).recompute_polygon_normals((CoordinateSystem)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "recompute_polygon_normals(const EggGroupNode self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_recompute_polygon_normals_266_comment =
  "C++ Interface:\n"
  "recompute_polygon_normals(const EggGroupNode self, int cs)\n"
  "\n"
  "/**\n"
  " * Recomputes all the polygon normals for polygon geometry at this group node\n"
  " * and below so that they accurately reflect the vertex positions.  Normals\n"
  " * are removed from the vertices and defined only on polygons, giving the\n"
  " * geometry a faceted appearance.\n"
  " *\n"
  " * This function also removes degenerate polygons that do not have enough\n"
  " * vertices to define a normal.  It does not affect normals for other kinds of\n"
  " * primitives like Nurbs or Points.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the normals removed.  Thus, it is a good idea\n"
  " * to call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_recompute_polygon_normals_266_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::strip_normals(void)
 */
static PyObject *Dtool_EggGroupNode_strip_normals_267(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.strip_normals")) {
    return NULL;
  }
  // 1-void EggGroupNode::strip_normals(void)
  (*local_this).strip_normals();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_strip_normals_267_comment =
  "C++ Interface:\n"
  "strip_normals(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Removes all normals from primitives, and the vertices they reference, at\n"
  " * this node and below.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the normal removed.  Thus, it is a good idea to\n"
  " * call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_strip_normals_267_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggGroupNode::recompute_tangent_binormal(GlobPattern const &uv_name)
 * Rejected Remap [bool EggGroupNode::recompute_tangent_binormal(vector_string const &names)]
 */
static PyObject *Dtool_EggGroupNode_recompute_tangent_binormal_268(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.recompute_tangent_binormal")) {
    return NULL;
  }
  // 1-bool EggGroupNode::recompute_tangent_binormal(GlobPattern const &uv_name)
  GlobPattern const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_GlobPattern(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroupNode.recompute_tangent_binormal", "GlobPattern");
  }
  bool return_value = (*local_this).recompute_tangent_binormal(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "recompute_tangent_binormal(const EggGroupNode self, const GlobPattern uv_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_recompute_tangent_binormal_268_comment =
  "C++ Interface:\n"
  "recompute_tangent_binormal(const EggGroupNode self, const GlobPattern uv_name)\n"
  "\n"
  "/**\n"
  " * This function recomputes the tangent and binormal for the named texture\n"
  " * coordinate set for all vertices at this level and below.  Use the empty\n"
  " * string for the default texture coordinate set.\n"
  " *\n"
  " * It is necessary for each vertex to already have a normal (or at least a\n"
  " * polygon normal), as well as a texture coordinate in the named texture\n"
  " * coordinate set, before calling this function.  You might precede this with\n"
  " * recompute_vertex_normals() to ensure that the normals exist.\n"
  " *\n"
  " * Like recompute_vertex_normals(), this function does not remove or adjust\n"
  " * vertices in the vertex pool; it only adds new vertices with the new\n"
  " * tangents and binormals computed.  Thus, it is a good idea to call\n"
  " * remove_unused_vertices() after calling this.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This function recomputes the tangent and binormal for the named texture\n"
  " * coordinate sets.  Returns true if anything was done.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_recompute_tangent_binormal_268_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggGroupNode::recompute_tangent_binormal_auto(void)
 */
static PyObject *Dtool_EggGroupNode_recompute_tangent_binormal_auto_269(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.recompute_tangent_binormal_auto")) {
    return NULL;
  }
  // 1-bool EggGroupNode::recompute_tangent_binormal_auto(void)
  bool return_value = (*local_this).recompute_tangent_binormal_auto();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_recompute_tangent_binormal_auto_269_comment =
  "C++ Interface:\n"
  "recompute_tangent_binormal_auto(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * This function recomputes the tangent and binormal for any texture\n"
  " * coordinate set that affects a normal map.  Returns true if anything was\n"
  " * done.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_recompute_tangent_binormal_auto_269_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggGroupNode::triangulate_polygons(int flags)
 */
static PyObject *Dtool_EggGroupNode_triangulate_polygons_271(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.triangulate_polygons")) {
    return NULL;
  }
  // 1-int EggGroupNode::triangulate_polygons(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*local_this).triangulate_polygons((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "triangulate_polygons(const EggGroupNode self, int flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_triangulate_polygons_271_comment =
  "C++ Interface:\n"
  "triangulate_polygons(const EggGroupNode self, int flags)\n"
  "\n"
  "/**\n"
  " * Replace all higher-order polygons at this point in the scene graph and\n"
  " * below with triangles.  Returns the total number of new triangles produced,\n"
  " * less degenerate polygons removed.\n"
  " *\n"
  " * If flags contains T_polygon and T_convex, both concave and convex polygons\n"
  " * will be subdivided into triangles; with only T_polygon, only concave\n"
  " * polygons will be subdivided, and convex polygons will be largely unchanged.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_triangulate_polygons_271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::mesh_triangles(int flags)
 */
static PyObject *Dtool_EggGroupNode_mesh_triangles_272(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.mesh_triangles")) {
    return NULL;
  }
  // 1-void EggGroupNode::mesh_triangles(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).mesh_triangles((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mesh_triangles(const EggGroupNode self, int flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_mesh_triangles_272_comment =
  "C++ Interface:\n"
  "mesh_triangles(const EggGroupNode self, int flags)\n"
  "\n"
  "/**\n"
  " * Combine triangles together into triangle strips, at this group and below.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_mesh_triangles_272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::make_point_primitives(void)
 */
static PyObject *Dtool_EggGroupNode_make_point_primitives_273(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.make_point_primitives")) {
    return NULL;
  }
  // 1-void EggGroupNode::make_point_primitives(void)
  (*local_this).make_point_primitives();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_make_point_primitives_273_comment =
  "C++ Interface:\n"
  "make_point_primitives(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Creates PointLight primitives to reference any otherwise unreferences\n"
  " * vertices discovered in this group or below.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_make_point_primitives_273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggGroupNode::remove_unused_vertices(bool recurse)
 */
static PyObject *Dtool_EggGroupNode_remove_unused_vertices_275(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.remove_unused_vertices")) {
    return NULL;
  }
  // 1-int EggGroupNode::remove_unused_vertices(bool recurse)
  int return_value = (*local_this).remove_unused_vertices((PyObject_IsTrue(arg) != 0));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_unused_vertices(const EggGroupNode self, bool recurse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_remove_unused_vertices_275_comment =
  "C++ Interface:\n"
  "remove_unused_vertices(const EggGroupNode self, bool recurse)\n"
  "\n"
  "/**\n"
  " * Removes all vertices from VertexPools within this group or below that are\n"
  " * not referenced by at least one primitive.  Also collapses together\n"
  " * equivalent vertices, and renumbers all vertices after the operation so\n"
  " * their indices are consecutive, beginning at zero.  Returns the total number\n"
  " * of vertices removed.\n"
  " *\n"
  " * Note that this operates on the VertexPools within this group level, without\n"
  " * respect to primitives that reference these vertices (unlike other functions\n"
  " * like strip_normals()).  It is therefore most useful to call this on the\n"
  " * EggData root, rather than on a subgroup within the hierarchy, since a\n"
  " * VertexPool may appear anywhere in the hierarchy.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_remove_unused_vertices_275_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggGroupNode::remove_invalid_primitives(bool recurse)
 */
static PyObject *Dtool_EggGroupNode_remove_invalid_primitives_276(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.remove_invalid_primitives")) {
    return NULL;
  }
  // 1-int EggGroupNode::remove_invalid_primitives(bool recurse)
  int return_value = (*local_this).remove_invalid_primitives((PyObject_IsTrue(arg) != 0));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_invalid_primitives(const EggGroupNode self, bool recurse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_remove_invalid_primitives_276_comment =
  "C++ Interface:\n"
  "remove_invalid_primitives(const EggGroupNode self, bool recurse)\n"
  "\n"
  "/**\n"
  " * Removes primitives at this level and below which appear to be degenerate;\n"
  " * e.g.  polygons with fewer than 3 vertices, etc.  Returns the number of\n"
  " * primitives removed.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_remove_invalid_primitives_276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::clear_connected_shading(void)
 */
static PyObject *Dtool_EggGroupNode_clear_connected_shading_277(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.clear_connected_shading")) {
    return NULL;
  }
  // 1-void EggGroupNode::clear_connected_shading(void)
  (*local_this).clear_connected_shading();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_clear_connected_shading_277_comment =
  "C++ Interface:\n"
  "clear_connected_shading(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Resets the connected_shading information on all primitives at this node and\n"
  " * below, so that it may be accurately rederived by the next call to\n"
  " * get_connected_shading().\n"
  " *\n"
  " * It may be a good idea to call remove_unused_vertices() as well, to\n"
  " * establish the correct connectivity between common vertices.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_clear_connected_shading_277_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::get_connected_shading(void)
 */
static PyObject *Dtool_EggGroupNode_get_connected_shading_278(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.get_connected_shading")) {
    return NULL;
  }
  // 1-void EggGroupNode::get_connected_shading(void)
  (*local_this).get_connected_shading();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_get_connected_shading_278_comment =
  "C++ Interface:\n"
  "get_connected_shading(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Queries the connected_shading information on all primitives at this node\n"
  " * and below, to ensure that it has been completely filled in before we start\n"
  " * mucking around with vertices.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_get_connected_shading_278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::unify_attributes(bool use_connected_shading, bool allow_per_primitive, bool recurse)
 */
static PyObject *Dtool_EggGroupNode_unify_attributes_279(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.unify_attributes")) {
    return NULL;
  }
  // 1-void EggGroupNode::unify_attributes(bool use_connected_shading, bool allow_per_primitive, bool recurse)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"use_connected_shading", "allow_per_primitive", "recurse", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:unify_attributes", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).unify_attributes((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unify_attributes(const EggGroupNode self, bool use_connected_shading, bool allow_per_primitive, bool recurse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_unify_attributes_279_comment =
  "C++ Interface:\n"
  "unify_attributes(const EggGroupNode self, bool use_connected_shading, bool allow_per_primitive, bool recurse)\n"
  "\n"
  "/**\n"
  " * Applies per-vertex normal and color to all vertices, if they are in fact\n"
  " * per-vertex (and different for each vertex), or moves them to the primitive\n"
  " * if they are all the same.\n"
  " *\n"
  " * After this call, either the primitive will have normals or its vertices\n"
  " * will, but not both.  Ditto for colors.\n"
  " *\n"
  " * If use_connected_shading is true, each polygon is considered in conjunction\n"
  " * with all connected polygons; otherwise, each polygon is considered\n"
  " * individually.\n"
  " *\n"
  " * If allow_per_primitive is false, S_per_face or S_overall will treated like\n"
  " * S_per_vertex: normals and colors will always be assigned to the vertices.\n"
  " * In this case, there will never be per-primitive colors or normals after\n"
  " * this call returns.  On the other hand, if allow_per_primitive is true, then\n"
  " * S_per_face means that normals and colors should be assigned to the\n"
  " * primitives, and removed from the vertices, as described above.\n"
  " *\n"
  " * This may create redundant vertices in the vertex pool, so it may be a good\n"
  " * idea to follow this up with remove_unused_vertices().\n"
  " */";
#else
static const char *Dtool_EggGroupNode_unify_attributes_279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::apply_last_attribute(bool recurse)
 */
static PyObject *Dtool_EggGroupNode_apply_last_attribute_280(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.apply_last_attribute")) {
    return NULL;
  }
  // 1-void EggGroupNode::apply_last_attribute(bool recurse)
  (*local_this).apply_last_attribute((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_last_attribute(const EggGroupNode self, bool recurse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_apply_last_attribute_280_comment =
  "C++ Interface:\n"
  "apply_last_attribute(const EggGroupNode self, bool recurse)\n"
  "\n"
  "/**\n"
  " * Sets the last vertex of the triangle (or each component) to the primitive\n"
  " * normal and/or color, if the primitive is flat-shaded.  This reflects the\n"
  " * OpenGL convention of storing flat-shaded properties on the last vertex,\n"
  " * although it is not usually a convention in Egg.\n"
  " *\n"
  " * This may create redundant vertices in the vertex pool, so it may be a good\n"
  " * idea to follow this up with remove_unused_vertices().\n"
  " */";
#else
static const char *Dtool_EggGroupNode_apply_last_attribute_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::apply_first_attribute(bool recurse)
 */
static PyObject *Dtool_EggGroupNode_apply_first_attribute_281(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.apply_first_attribute")) {
    return NULL;
  }
  // 1-void EggGroupNode::apply_first_attribute(bool recurse)
  (*local_this).apply_first_attribute((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_first_attribute(const EggGroupNode self, bool recurse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_apply_first_attribute_281_comment =
  "C++ Interface:\n"
  "apply_first_attribute(const EggGroupNode self, bool recurse)\n"
  "\n"
  "/**\n"
  " * Sets the first vertex of the triangle (or each component) to the primitive\n"
  " * normal and/or color, if the primitive is flat-shaded.  This reflects the\n"
  " * DirectX convention of storing flat-shaded properties on the first vertex,\n"
  " * although it is not usually a convention in Egg.\n"
  " *\n"
  " * This may create redundant vertices in the vertex pool, so it may be a good\n"
  " * idea to follow this up with remove_unused_vertices().\n"
  " */";
#else
static const char *Dtool_EggGroupNode_apply_first_attribute_281_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::post_apply_flat_attribute(bool recurse)
 */
static PyObject *Dtool_EggGroupNode_post_apply_flat_attribute_282(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.post_apply_flat_attribute")) {
    return NULL;
  }
  // 1-void EggGroupNode::post_apply_flat_attribute(bool recurse)
  (*local_this).post_apply_flat_attribute((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "post_apply_flat_attribute(const EggGroupNode self, bool recurse)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_post_apply_flat_attribute_282_comment =
  "C++ Interface:\n"
  "post_apply_flat_attribute(const EggGroupNode self, bool recurse)\n"
  "\n"
  "/**\n"
  " * Intended as a followup to apply_last_attribute(), this also sets an\n"
  " * attribute on the first vertices of the primitive, if they don't already\n"
  " * have an attribute set, just so they end up with *something*.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_post_apply_flat_attribute_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroupNode::has_primitives(void) const
 */
static PyObject *Dtool_EggGroupNode_has_primitives_283(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroupNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool EggGroupNode::has_primitives(void) const
  bool return_value = (*(const EggGroupNode*)local_this).has_primitives();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_has_primitives_283_comment =
  "C++ Interface:\n"
  "has_primitives(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are any primitives (e.g.  polygons) defined within\n"
  " * this group or below, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_has_primitives_283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroupNode::joint_has_primitives(void) const
 */
static PyObject *Dtool_EggGroupNode_joint_has_primitives_284(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroupNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool EggGroupNode::joint_has_primitives(void) const
  bool return_value = (*(const EggGroupNode*)local_this).joint_has_primitives();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_joint_has_primitives_284_comment =
  "C++ Interface:\n"
  "joint_has_primitives(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are any primitives (e.g.  polygons) defined within\n"
  " * this group or below, but the search does not include nested joints.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_joint_has_primitives_284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroupNode::has_normals(void) const
 */
static PyObject *Dtool_EggGroupNode_has_normals_285(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroupNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool EggGroupNode::has_normals(void) const
  bool return_value = (*(const EggGroupNode*)local_this).has_normals();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_has_normals_285_comment =
  "C++ Interface:\n"
  "has_normals(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if any of the primitives (e.g.  polygons) defined within this\n"
  " * group or below have either face or vertex normals defined, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_has_normals_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool EggGroupNode::is_right(LVector2d const &v1, LVector2d const &v2)
 */
static PyObject *Dtool_EggGroupNode_is_right_286(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline bool EggGroupNode::is_right(LVector2d const &v1, LVector2d const &v2)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"v1", "v2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:is_right", (char **)keyword_list, &param0, &param1)) {
    LVector2d param0_local;
    LVector2d const *param0_this = Dtool_Coerce_LVector2d(param0, param0_local);
    if (!(param0_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "EggGroupNode.is_right", "LVector2d");
    }
    LVector2d param1_local;
    LVector2d const *param1_this = Dtool_Coerce_LVector2d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggGroupNode.is_right", "LVector2d");
    }
    bool return_value = EggGroupNode::is_right(*param0_this, *param1_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_right(const LVector2d v1, const LVector2d v2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_is_right_286_comment =
  "C++ Interface:\n"
  "is_right(const LVector2d v1, const LVector2d v2)\n"
  "\n"
  "/**\n"
  " * Returns true if the 2-d v1 is to the right of v2.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_is_right_286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggGroupNode::get_class_type(void)
 */
static PyObject *Dtool_EggGroupNode_get_class_type_287(PyObject *, PyObject *) {
  // 1-static TypeHandle EggGroupNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggGroupNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_get_class_type_287_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggGroupNode_get_class_type_287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggGroup *EggGroupNode::downcast_to_EggGroup(void)
 */
static PyObject *Dtool_EggGroupNode_downcast_to_EggGroup_371(PyObject *self, PyObject *) {
  EggGroupNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.downcast_to_EggGroup")) {
    return NULL;
  }
  // 1-EggGroup *EggGroupNode::downcast_to_EggGroup(void)
  EggGroup *return_value = (EggGroup *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_downcast_to_EggGroup_371_comment =
  "C++ Interface:\n"
  "downcast_to_EggGroup(const EggGroupNode self)\n"
  "\n"
  "downcast from EggGroupNode to EggGroup";
#else
static const char *Dtool_EggGroupNode_downcast_to_EggGroup_371_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggGroupNode::EggGroupNode(EggGroupNode const &copy)
 * EggGroupNode::EggGroupNode(std::string const &name = "")
 */
static int Dtool_Init_EggGroupNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggGroupNode::EggGroupNode(std::string const &name)
      EggGroupNode *return_value = new EggGroupNode();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroupNode, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 EggGroupNode::EggGroupNode(EggGroupNode const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggGroupNode", (char **)keyword_list, &param0)) {
          EggGroupNode const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggGroupNode, (void **)&param0_this);
          if (param0_this != NULL) {
            EggGroupNode *return_value = new EggGroupNode(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroupNode, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 EggGroupNode::EggGroupNode(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggGroupNode", (char **)keyword_list, &param0_str, &param0_len)) {
          EggGroupNode *return_value = new EggGroupNode(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroupNode, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 EggGroupNode::EggGroupNode(EggGroupNode const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggGroupNode", (char **)keyword_list, &param0)) {
          CPT(EggGroupNode) param0_this;
          if (Dtool_ConstCoerce_EggGroupNode(param0, param0_this)) {
            EggGroupNode *return_value = new EggGroupNode(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroupNode, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: EggGroupNode::EggGroupNode(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggGroupNode() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggGroupNode()\n"
      "EggGroupNode(const EggGroupNode copy)\n"
      "EggGroupNode(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggGroupNode(PyObject *args, CPT(EggGroupNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggGroupNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggGroupNode::EggGroupNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggGroupNode *return_value = new EggGroupNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_EggGroupNode(PyObject *args, PT(EggGroupNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggGroupNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggGroupNode::EggGroupNode(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggGroupNode *return_value = new EggGroupNode(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_EggGroupNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggGroupNode) {
    printf("EggGroupNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggGroupNode *local_this = (EggGroupNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggGroupNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggGroupNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggGroupNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggRenderMode
 */
/**
 * Python function wrapper for:
 * EggRenderMode &EggRenderMode::operator =(EggRenderMode const &copy)
 */
static PyObject *Dtool_EggRenderMode_operator_290(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.assign")) {
    return NULL;
  }
  // 1-EggRenderMode &EggRenderMode::operator =(EggRenderMode const &copy)
  EggRenderMode const *arg_this = (EggRenderMode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggRenderMode, 1, "EggRenderMode.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    EggRenderMode *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggRenderMode self, const EggRenderMode copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_operator_290_comment =
  "C++ Interface:\n"
  "assign(const EggRenderMode self, const EggRenderMode copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggRenderMode_operator_290_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggRenderMode::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggRenderMode_write_291(PyObject *self, PyObject *args, PyObject *kwds) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggRenderMode::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggRenderMode.write", false, true);
    if (param1_this != NULL) {
      (*(const EggRenderMode*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggRenderMode self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_write_291_comment =
  "C++ Interface:\n"
  "write(EggRenderMode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the attributes to the indicated output stream in Egg format.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_write_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_alpha_mode(EggRenderMode::AlphaMode mode)
 */
static PyObject *Dtool_EggRenderMode_set_alpha_mode_296(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_alpha_mode")) {
    return NULL;
  }
  // 1-inline void EggRenderMode::set_alpha_mode(EggRenderMode::AlphaMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_alpha_mode((EggRenderMode::AlphaMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_mode(const EggRenderMode self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_alpha_mode_296_comment =
  "C++ Interface:\n"
  "set_alpha_mode(const EggRenderMode self, int mode)\n"
  "\n"
  "/**\n"
  " * Specifies precisely how the transparency for this geometry should be\n"
  " * achieved, or if it should be used.  The default, AM_unspecified, is to use\n"
  " * transparency if the geometry has a color whose alpha value is non-1, or if\n"
  " * it has a four-channel texture applied; otherwise, AM_on forces transparency\n"
  " * on, and AM_off forces it off.  The other flavors of transparency are\n"
  " * specific ways to turn on transparency, which may or may not be supported by\n"
  " * a particular rendering backend.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_alpha_mode_296_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggRenderMode::AlphaMode EggRenderMode::get_alpha_mode(void) const
 */
static PyObject *Dtool_EggRenderMode_get_alpha_mode_297(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggRenderMode::AlphaMode EggRenderMode::get_alpha_mode(void) const
  EggRenderMode::AlphaMode return_value = (*(const EggRenderMode*)local_this).get_alpha_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_alpha_mode_297_comment =
  "C++ Interface:\n"
  "get_alpha_mode(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the alpha mode that was set, or AM_unspecified if nothing was set.\n"
  " * See set_alpha_mode().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_alpha_mode_297_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_depth_write_mode(EggRenderMode::DepthWriteMode mode)
 */
static PyObject *Dtool_EggRenderMode_set_depth_write_mode_298(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_depth_write_mode")) {
    return NULL;
  }
  // 1-inline void EggRenderMode::set_depth_write_mode(EggRenderMode::DepthWriteMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_depth_write_mode((EggRenderMode::DepthWriteMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth_write_mode(const EggRenderMode self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_depth_write_mode_298_comment =
  "C++ Interface:\n"
  "set_depth_write_mode(const EggRenderMode self, int mode)\n"
  "\n"
  "/**\n"
  " * Specifies whether writes should be made to the depth buffer (assuming the\n"
  " * rendering backend provides a depth buffer) when rendering this geometry.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_depth_write_mode_298_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggRenderMode::DepthWriteMode EggRenderMode::get_depth_write_mode(void) const
 */
static PyObject *Dtool_EggRenderMode_get_depth_write_mode_299(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggRenderMode::DepthWriteMode EggRenderMode::get_depth_write_mode(void) const
  EggRenderMode::DepthWriteMode return_value = (*(const EggRenderMode*)local_this).get_depth_write_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_depth_write_mode_299_comment =
  "C++ Interface:\n"
  "get_depth_write_mode(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the depth_write mode that was set, or DWM_unspecified if nothing\n"
  " * was set.  See set_depth_write_mode().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_depth_write_mode_299_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_depth_test_mode(EggRenderMode::DepthTestMode mode)
 */
static PyObject *Dtool_EggRenderMode_set_depth_test_mode_300(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_depth_test_mode")) {
    return NULL;
  }
  // 1-inline void EggRenderMode::set_depth_test_mode(EggRenderMode::DepthTestMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_depth_test_mode((EggRenderMode::DepthTestMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth_test_mode(const EggRenderMode self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_depth_test_mode_300_comment =
  "C++ Interface:\n"
  "set_depth_test_mode(const EggRenderMode self, int mode)\n"
  "\n"
  "/**\n"
  " * Specifies whether this geometry should be tested against the depth buffer\n"
  " * when it is drawn (assuming the rendering backend provides a depth buffer).\n"
  " * Note that this is different, and independent from, the depth_write mode.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_depth_test_mode_300_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggRenderMode::DepthTestMode EggRenderMode::get_depth_test_mode(void) const
 */
static PyObject *Dtool_EggRenderMode_get_depth_test_mode_301(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggRenderMode::DepthTestMode EggRenderMode::get_depth_test_mode(void) const
  EggRenderMode::DepthTestMode return_value = (*(const EggRenderMode*)local_this).get_depth_test_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_depth_test_mode_301_comment =
  "C++ Interface:\n"
  "get_depth_test_mode(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the depth_test mode that was set, or DTM_unspecified if nothing was\n"
  " * set.  See set_depth_test_mode().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_depth_test_mode_301_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_visibility_mode(EggRenderMode::VisibilityMode mode)
 */
static PyObject *Dtool_EggRenderMode_set_visibility_mode_302(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_visibility_mode")) {
    return NULL;
  }
  // 1-inline void EggRenderMode::set_visibility_mode(EggRenderMode::VisibilityMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_visibility_mode((EggRenderMode::VisibilityMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_visibility_mode(const EggRenderMode self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_visibility_mode_302_comment =
  "C++ Interface:\n"
  "set_visibility_mode(const EggRenderMode self, int mode)\n"
  "\n"
  "/**\n"
  " * Specifies whether this geometry is to be considered normally visible, or\n"
  " * hidden.  If it is hidden, it is either not loaded into the scene graph at\n"
  " * all, or loaded as a \"stashed\" node, according to the setting of egg-\n"
  " * suppress-hidden.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_visibility_mode_302_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggRenderMode::VisibilityMode EggRenderMode::get_visibility_mode(void) const
 */
static PyObject *Dtool_EggRenderMode_get_visibility_mode_303(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggRenderMode::VisibilityMode EggRenderMode::get_visibility_mode(void) const
  EggRenderMode::VisibilityMode return_value = (*(const EggRenderMode*)local_this).get_visibility_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_visibility_mode_303_comment =
  "C++ Interface:\n"
  "get_visibility_mode(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the visibility mode that was set, or VM_unspecified if nothing was\n"
  " * set.  See set_visibility_mode().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_visibility_mode_303_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_depth_offset(int bias)
 */
static PyObject *Dtool_EggRenderMode_set_depth_offset_304(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_depth_offset")) {
    return NULL;
  }
  // 1-inline void EggRenderMode::set_depth_offset(int bias)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_depth_offset((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth_offset(const EggRenderMode self, int bias)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_depth_offset_304_comment =
  "C++ Interface:\n"
  "set_depth_offset(const EggRenderMode self, int bias)\n"
  "\n"
  "/**\n"
  " * Sets the \"depth-offset\" flag associated with this object.  This adds or\n"
  " * subtracts an offset bias into the depth buffer.  See also DepthOffsetAttrib\n"
  " * and NodePath::set_depth_offset().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_depth_offset_304_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggRenderMode::get_depth_offset(void) const
 */
static PyObject *Dtool_EggRenderMode_get_depth_offset_305(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggRenderMode::get_depth_offset(void) const
  int return_value = (*(const EggRenderMode*)local_this).get_depth_offset();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_depth_offset_305_comment =
  "C++ Interface:\n"
  "get_depth_offset(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"depth-offset\" flag as set for this particular object.  See\n"
  " * set_depth_offset().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_depth_offset_305_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggRenderMode::has_depth_offset(void) const
 */
static PyObject *Dtool_EggRenderMode_has_depth_offset_306(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggRenderMode::has_depth_offset(void) const
  bool return_value = (*(const EggRenderMode*)local_this).has_depth_offset();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_has_depth_offset_306_comment =
  "C++ Interface:\n"
  "has_depth_offset(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the depth-offset flag has been set for this particular\n"
  " * object.  See set_depth_offset().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_has_depth_offset_306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::clear_depth_offset(void)
 */
static PyObject *Dtool_EggRenderMode_clear_depth_offset_307(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.clear_depth_offset")) {
    return NULL;
  }
  // 1-inline void EggRenderMode::clear_depth_offset(void)
  (*local_this).clear_depth_offset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_clear_depth_offset_307_comment =
  "C++ Interface:\n"
  "clear_depth_offset(const EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Removes the depth-offset flag from this particular object.  See\n"
  " * set_depth_offset().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_clear_depth_offset_307_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_draw_order(int order)
 */
static PyObject *Dtool_EggRenderMode_set_draw_order_308(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_draw_order")) {
    return NULL;
  }
  // 1-inline void EggRenderMode::set_draw_order(int order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_draw_order((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_draw_order(const EggRenderMode self, int order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_draw_order_308_comment =
  "C++ Interface:\n"
  "set_draw_order(const EggRenderMode self, int order)\n"
  "\n"
  "/**\n"
  " * Sets the \"draw-order\" flag associated with this object.  This specifies a\n"
  " * particular order in which objects of this type should be drawn, within the\n"
  " * specified bin.  If a bin is not explicitly specified, \"fixed\" is used.  See\n"
  " * also set_bin().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_draw_order_308_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggRenderMode::get_draw_order(void) const
 */
static PyObject *Dtool_EggRenderMode_get_draw_order_309(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggRenderMode::get_draw_order(void) const
  int return_value = (*(const EggRenderMode*)local_this).get_draw_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_draw_order_309_comment =
  "C++ Interface:\n"
  "get_draw_order(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"draw-order\" flag as set for this particular object.  See\n"
  " * set_draw_order().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_draw_order_309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggRenderMode::has_draw_order(void) const
 */
static PyObject *Dtool_EggRenderMode_has_draw_order_310(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggRenderMode::has_draw_order(void) const
  bool return_value = (*(const EggRenderMode*)local_this).has_draw_order();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_has_draw_order_310_comment =
  "C++ Interface:\n"
  "has_draw_order(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the draw-order flag has been set for this particular\n"
  " * object.  See set_draw_order().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_has_draw_order_310_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::clear_draw_order(void)
 */
static PyObject *Dtool_EggRenderMode_clear_draw_order_311(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.clear_draw_order")) {
    return NULL;
  }
  // 1-inline void EggRenderMode::clear_draw_order(void)
  (*local_this).clear_draw_order();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_clear_draw_order_311_comment =
  "C++ Interface:\n"
  "clear_draw_order(const EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Removes the draw-order flag from this particular object.  See\n"
  " * set_draw_order().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_clear_draw_order_311_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_bin(std::string const &bin)
 */
static PyObject *Dtool_EggRenderMode_set_bin_312(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_bin")) {
    return NULL;
  }
  // 1-inline void EggRenderMode::set_bin(std::string const &bin)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_bin(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin(const EggRenderMode self, str bin)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_bin_312_comment =
  "C++ Interface:\n"
  "set_bin(const EggRenderMode self, str bin)\n"
  "\n"
  "/**\n"
  " * Sets the \"bin\" string for this particular object.  This names a particular\n"
  " * bin in which the object should be rendered.  The exact meaning of a bin is\n"
  " * implementation defined, but generally a GeomBin matching each bin name must\n"
  " * also be specifically added to the rendering engine (e.g.  the\n"
  " * CullTraverser) in use for this to work.  See also set_draw_order().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_bin_312_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string EggRenderMode::get_bin(void) const
 */
static PyObject *Dtool_EggRenderMode_get_bin_313(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string EggRenderMode::get_bin(void) const
  std::string return_value = (*(const EggRenderMode*)local_this).get_bin();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_bin_313_comment =
  "C++ Interface:\n"
  "get_bin(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the bin name that has been set for this particular object, if any.\n"
  " * See set_bin().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_bin_313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggRenderMode::has_bin(void) const
 */
static PyObject *Dtool_EggRenderMode_has_bin_314(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggRenderMode::has_bin(void) const
  bool return_value = (*(const EggRenderMode*)local_this).has_bin();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_has_bin_314_comment =
  "C++ Interface:\n"
  "has_bin(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns true if a bin name has been set for this particular object.  See\n"
  " * set_bin().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_has_bin_314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::clear_bin(void)
 */
static PyObject *Dtool_EggRenderMode_clear_bin_315(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.clear_bin")) {
    return NULL;
  }
  // 1-inline void EggRenderMode::clear_bin(void)
  (*local_this).clear_bin();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_clear_bin_315_comment =
  "C++ Interface:\n"
  "clear_bin(const EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Removes the bin name that was set for this particular object.  See\n"
  " * set_bin().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_clear_bin_315_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggRenderMode::AlphaMode EggRenderMode::string_alpha_mode(std::string const &string)
 */
static PyObject *Dtool_EggRenderMode_string_alpha_mode_319(PyObject *, PyObject *arg) {
  // 1-static EggRenderMode::AlphaMode EggRenderMode::string_alpha_mode(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggRenderMode::AlphaMode return_value = EggRenderMode::string_alpha_mode(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_alpha_mode(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_string_alpha_mode_319_comment =
  "C++ Interface:\n"
  "string_alpha_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the AlphaMode value associated with the given string\n"
  " * representation, or AM_unspecified if the string does not match any known\n"
  " * AlphaMode value.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_string_alpha_mode_319_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggRenderMode::DepthWriteMode EggRenderMode::string_depth_write_mode(std::string const &string)
 */
static PyObject *Dtool_EggRenderMode_string_depth_write_mode_320(PyObject *, PyObject *arg) {
  // 1-static EggRenderMode::DepthWriteMode EggRenderMode::string_depth_write_mode(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggRenderMode::DepthWriteMode return_value = EggRenderMode::string_depth_write_mode(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_depth_write_mode(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_string_depth_write_mode_320_comment =
  "C++ Interface:\n"
  "string_depth_write_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the DepthWriteMode value associated with the given string\n"
  " * representation, or DWM_unspecified if the string does not match any known\n"
  " * DepthWriteMode value.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_string_depth_write_mode_320_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggRenderMode::DepthTestMode EggRenderMode::string_depth_test_mode(std::string const &string)
 */
static PyObject *Dtool_EggRenderMode_string_depth_test_mode_321(PyObject *, PyObject *arg) {
  // 1-static EggRenderMode::DepthTestMode EggRenderMode::string_depth_test_mode(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggRenderMode::DepthTestMode return_value = EggRenderMode::string_depth_test_mode(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_depth_test_mode(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_string_depth_test_mode_321_comment =
  "C++ Interface:\n"
  "string_depth_test_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the DepthTestMode value associated with the given string\n"
  " * representation, or DTM_unspecified if the string does not match any known\n"
  " * DepthTestMode value.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_string_depth_test_mode_321_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggRenderMode::VisibilityMode EggRenderMode::string_visibility_mode(std::string const &string)
 */
static PyObject *Dtool_EggRenderMode_string_visibility_mode_322(PyObject *, PyObject *arg) {
  // 1-static EggRenderMode::VisibilityMode EggRenderMode::string_visibility_mode(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggRenderMode::VisibilityMode return_value = EggRenderMode::string_visibility_mode(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_visibility_mode(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_string_visibility_mode_322_comment =
  "C++ Interface:\n"
  "string_visibility_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the HiddenMode value associated with the given string\n"
  " * representation, or VM_unspecified if the string does not match any known\n"
  " * HiddenMode value.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_string_visibility_mode_322_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggRenderMode::get_class_type(void)
 */
static PyObject *Dtool_EggRenderMode_get_class_type_323(PyObject *, PyObject *) {
  // 1-static TypeHandle EggRenderMode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggRenderMode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_class_type_323_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggRenderMode_get_class_type_323_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggGroup *EggRenderMode::downcast_to_EggGroup(void)
 */
static PyObject *Dtool_EggRenderMode_downcast_to_EggGroup_373(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.downcast_to_EggGroup")) {
    return NULL;
  }
  // 1-EggGroup *EggRenderMode::downcast_to_EggGroup(void)
  EggGroup *return_value = (EggGroup *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_downcast_to_EggGroup_373_comment =
  "C++ Interface:\n"
  "downcast_to_EggGroup(const EggRenderMode self)\n"
  "\n"
  "downcast from EggRenderMode to EggGroup";
#else
static const char *Dtool_EggRenderMode_downcast_to_EggGroup_373_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggTexture *EggRenderMode::downcast_to_EggTexture(void)
 */
static PyObject *Dtool_EggRenderMode_downcast_to_EggTexture_612(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.downcast_to_EggTexture")) {
    return NULL;
  }
  // 1-EggTexture *EggRenderMode::downcast_to_EggTexture(void)
  EggTexture *return_value = (EggTexture *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_downcast_to_EggTexture_612_comment =
  "C++ Interface:\n"
  "downcast_to_EggTexture(const EggRenderMode self)\n"
  "\n"
  "downcast from EggRenderMode to EggTexture";
#else
static const char *Dtool_EggRenderMode_downcast_to_EggTexture_612_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggPrimitive *EggRenderMode::downcast_to_EggPrimitive(void)
 */
static PyObject *Dtool_EggRenderMode_downcast_to_EggPrimitive_846(PyObject *self, PyObject *) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.downcast_to_EggPrimitive")) {
    return NULL;
  }
  // 1-EggPrimitive *EggRenderMode::downcast_to_EggPrimitive(void)
  EggPrimitive *return_value = (EggPrimitive *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPrimitive, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_downcast_to_EggPrimitive_846_comment =
  "C++ Interface:\n"
  "downcast_to_EggPrimitive(const EggRenderMode self)\n"
  "\n"
  "downcast from EggRenderMode to EggPrimitive";
#else
static const char *Dtool_EggRenderMode_downcast_to_EggPrimitive_846_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggRenderMode::EggRenderMode(void)
 * inline EggRenderMode::EggRenderMode(EggRenderMode const &copy)
 */
static int Dtool_Init_EggRenderMode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggRenderMode::EggRenderMode(void)
      EggRenderMode *return_value = new EggRenderMode();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggRenderMode, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline EggRenderMode::EggRenderMode(EggRenderMode const &copy)
      EggRenderMode const *arg_this = (EggRenderMode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggRenderMode, 0, "EggRenderMode.EggRenderMode", true, true);
      if (arg_this != NULL) {
        EggRenderMode *return_value = new EggRenderMode(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggRenderMode, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggRenderMode() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggRenderMode()\n"
      "EggRenderMode(const EggRenderMode copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggRenderMode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggRenderMode) {
    printf("EggRenderMode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggRenderMode *local_this = (EggRenderMode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggRenderMode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggTransform
 */
/**
 * Python function wrapper for:
 * EggTransform &EggTransform::operator =(EggTransform const &copy)
 */
static PyObject *Dtool_EggTransform_operator_327(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.assign")) {
    return NULL;
  }
  // 1-EggTransform &EggTransform::operator =(EggTransform const &copy)
  EggTransform const *arg_this = (EggTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTransform, 1, "EggTransform.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    EggTransform *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTransform self, const EggTransform copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_operator_327_comment =
  "C++ Interface:\n"
  "assign(const EggTransform self, const EggTransform copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTransform_operator_327_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTransform::clear_transform(void)
 */
static PyObject *Dtool_EggTransform_clear_transform_329(PyObject *self, PyObject *) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.clear_transform")) {
    return NULL;
  }
  // 1-inline void EggTransform::clear_transform(void)
  (*local_this).clear_transform();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_clear_transform_329_comment =
  "C++ Interface:\n"
  "clear_transform(const EggTransform self)\n"
  "\n"
  "/**\n"
  " * Resets the transform to empty, identity.\n"
  " */";
#else
static const char *Dtool_EggTransform_clear_transform_329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_translate2d(LVector2d const &translate)
 */
static PyObject *Dtool_EggTransform_add_translate2d_330(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_translate2d")) {
    return NULL;
  }
  // 1-void EggTransform::add_translate2d(LVector2d const &translate)
  LVector2d arg_local;
  LVector2d const *arg_this = Dtool_Coerce_LVector2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_translate2d", "LVector2d");
  }
  (*local_this).add_translate2d(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_translate2d(const EggTransform self, const LVector2d translate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_translate2d_330_comment =
  "C++ Interface:\n"
  "add_translate2d(const EggTransform self, const LVector2d translate)\n"
  "\n"
  "/**\n"
  " * Appends a 2-d translation operation to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_translate2d_330_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_translate3d(LVector3d const &translate)
 */
static PyObject *Dtool_EggTransform_add_translate3d_331(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_translate3d")) {
    return NULL;
  }
  // 1-void EggTransform::add_translate3d(LVector3d const &translate)
  LVector3d arg_local;
  LVector3d const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_translate3d", "LVector3d");
  }
  (*local_this).add_translate3d(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_translate3d(const EggTransform self, const LVector3d translate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_translate3d_331_comment =
  "C++ Interface:\n"
  "add_translate3d(const EggTransform self, const LVector3d translate)\n"
  "\n"
  "/**\n"
  " * Appends a 3-d translation operation to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_translate3d_331_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_rotate2d(double angle)
 */
static PyObject *Dtool_EggTransform_add_rotate2d_332(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_rotate2d")) {
    return NULL;
  }
  // 1-void EggTransform::add_rotate2d(double angle)
  if (PyNumber_Check(arg)) {
    (*local_this).add_rotate2d(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rotate2d(const EggTransform self, double angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_rotate2d_332_comment =
  "C++ Interface:\n"
  "add_rotate2d(const EggTransform self, double angle)\n"
  "\n"
  "/**\n"
  " * Appends a 2-d rotation to the current transform.  The rotation angle is\n"
  " * specified in degrees counterclockwise about the origin.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_rotate2d_332_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_rotx(double angle)
 */
static PyObject *Dtool_EggTransform_add_rotx_333(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_rotx")) {
    return NULL;
  }
  // 1-void EggTransform::add_rotx(double angle)
  if (PyNumber_Check(arg)) {
    (*local_this).add_rotx(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rotx(const EggTransform self, double angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_rotx_333_comment =
  "C++ Interface:\n"
  "add_rotx(const EggTransform self, double angle)\n"
  "\n"
  "/**\n"
  " * Appends a rotation about the X axis to the current transform.  The rotation\n"
  " * angle is specified in degrees counterclockwise about the axis.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_rotx_333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_roty(double angle)
 */
static PyObject *Dtool_EggTransform_add_roty_334(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_roty")) {
    return NULL;
  }
  // 1-void EggTransform::add_roty(double angle)
  if (PyNumber_Check(arg)) {
    (*local_this).add_roty(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_roty(const EggTransform self, double angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_roty_334_comment =
  "C++ Interface:\n"
  "add_roty(const EggTransform self, double angle)\n"
  "\n"
  "/**\n"
  " * Appends a rotation about the Y axis to the current transform.  The rotation\n"
  " * angle is specified in degrees counterclockwise about the axis.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_roty_334_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_rotz(double angle)
 */
static PyObject *Dtool_EggTransform_add_rotz_335(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_rotz")) {
    return NULL;
  }
  // 1-void EggTransform::add_rotz(double angle)
  if (PyNumber_Check(arg)) {
    (*local_this).add_rotz(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rotz(const EggTransform self, double angle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_rotz_335_comment =
  "C++ Interface:\n"
  "add_rotz(const EggTransform self, double angle)\n"
  "\n"
  "/**\n"
  " * Appends a rotation about the Z axis to the current transform.  The rotation\n"
  " * angle is specified in degrees counterclockwise about the axis.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_rotz_335_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_rotate3d(LQuaterniond const &quat)
 * void EggTransform::add_rotate3d(double angle, LVector3d const &axis)
 */
static PyObject *Dtool_EggTransform_add_rotate3d_336(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_rotate3d")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "quat");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'quat' (pos 1) not found");
      }
      // 1-void EggTransform::add_rotate3d(LQuaterniond const &quat)
      LQuaterniond arg_local;
      LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_rotate3d", "LQuaterniond");
      }
      (*local_this).add_rotate3d(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-void EggTransform::add_rotate3d(double angle, LVector3d const &axis)
      double param1;
      PyObject *param2;
      static const char *keyword_list[] = {"angle", "axis", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dO:add_rotate3d", (char **)keyword_list, &param1, &param2)) {
        LVector3d param2_local;
        LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "EggTransform.add_rotate3d", "LVector3d");
        }
        (*local_this).add_rotate3d((double)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_rotate3d() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rotate3d(const EggTransform self, const LQuaterniond quat)\n"
      "add_rotate3d(const EggTransform self, double angle, const LVector3d axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_rotate3d_336_comment =
  "C++ Interface:\n"
  "add_rotate3d(const EggTransform self, const LQuaterniond quat)\n"
  "add_rotate3d(const EggTransform self, double angle, const LVector3d axis)\n"
  "\n"
  "/**\n"
  " * Appends a 3-d rotation about an arbitrary axis to the current transform.\n"
  " * The rotation angle is specified in degrees counterclockwise about the axis.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Appends an arbitrary 3-d rotation to the current transform, expressed as a\n"
  " * quaternion.  This is converted to axis-angle notation for the egg file.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_rotate3d_336_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_scale2d(LVecBase2d const &scale)
 */
static PyObject *Dtool_EggTransform_add_scale2d_337(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_scale2d")) {
    return NULL;
  }
  // 1-void EggTransform::add_scale2d(LVecBase2d const &scale)
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_scale2d", "LVecBase2d");
  }
  (*local_this).add_scale2d(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_scale2d(const EggTransform self, const LVecBase2d scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_scale2d_337_comment =
  "C++ Interface:\n"
  "add_scale2d(const EggTransform self, const LVecBase2d scale)\n"
  "\n"
  "/**\n"
  " * Appends a possibly non-uniform scale to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_scale2d_337_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_scale3d(LVecBase3d const &scale)
 */
static PyObject *Dtool_EggTransform_add_scale3d_338(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_scale3d")) {
    return NULL;
  }
  // 1-void EggTransform::add_scale3d(LVecBase3d const &scale)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_scale3d", "LVecBase3d");
  }
  (*local_this).add_scale3d(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_scale3d(const EggTransform self, const LVecBase3d scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_scale3d_338_comment =
  "C++ Interface:\n"
  "add_scale3d(const EggTransform self, const LVecBase3d scale)\n"
  "\n"
  "/**\n"
  " * Appends a possibly non-uniform scale to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_scale3d_338_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_uniform_scale(double scale)
 */
static PyObject *Dtool_EggTransform_add_uniform_scale_339(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_uniform_scale")) {
    return NULL;
  }
  // 1-void EggTransform::add_uniform_scale(double scale)
  if (PyNumber_Check(arg)) {
    (*local_this).add_uniform_scale(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uniform_scale(const EggTransform self, double scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_uniform_scale_339_comment =
  "C++ Interface:\n"
  "add_uniform_scale(const EggTransform self, double scale)\n"
  "\n"
  "/**\n"
  " * Appends a uniform scale to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_uniform_scale_339_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTransform::add_matrix3(LMatrix3d const &mat)
 */
static PyObject *Dtool_EggTransform_add_matrix3_340(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_matrix3")) {
    return NULL;
  }
  // 1-inline void EggTransform::add_matrix3(LMatrix3d const &mat)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_matrix3", "LMatrix3d");
  }
  (*local_this).add_matrix3(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_matrix3(const EggTransform self, const LMatrix3d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_matrix3_340_comment =
  "C++ Interface:\n"
  "add_matrix3(const EggTransform self, const LMatrix3d mat)\n"
  "\n"
  "/**\n"
  " * Appends an arbitrary 3x3 matrix to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_matrix3_340_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTransform::add_matrix4(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggTransform_add_matrix4_341(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_matrix4")) {
    return NULL;
  }
  // 1-inline void EggTransform::add_matrix4(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_matrix4", "LMatrix4d");
  }
  (*local_this).add_matrix4(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_matrix4(const EggTransform self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_matrix4_341_comment =
  "C++ Interface:\n"
  "add_matrix4(const EggTransform self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Appends an arbitrary 4x4 matrix to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_matrix4_341_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTransform::has_transform(void) const
 */
static PyObject *Dtool_EggTransform_has_transform_342(PyObject *self, PyObject *) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTransform::has_transform(void) const
  bool return_value = (*(const EggTransform*)local_this).has_transform();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_has_transform_342_comment =
  "C++ Interface:\n"
  "has_transform(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform is nonempty, false if it is empty (no\n"
  " * transform components have been added).  This is true for either a 2-d or a\n"
  " * 3-d transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_has_transform_342_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTransform::has_transform2d(void) const
 */
static PyObject *Dtool_EggTransform_has_transform2d_343(PyObject *self, PyObject *) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTransform::has_transform2d(void) const
  bool return_value = (*(const EggTransform*)local_this).has_transform2d();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_has_transform2d_343_comment =
  "C++ Interface:\n"
  "has_transform2d(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform is specified as a 2-d transform, e.g.  with a\n"
  " * 3x3 matrix, or false if it is specified as a 3-d transform (with a 4x4\n"
  " * matrix), or not specified at all.\n"
  " *\n"
  " * Normally, EggTextures have a 2-d matrix (but occasionally they use a 3-d\n"
  " * matrix), and EggGroups always have a 3-d matrix.\n"
  " */";
#else
static const char *Dtool_EggTransform_has_transform2d_343_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTransform::set_transform2d(LMatrix3d const &mat)
 */
static PyObject *Dtool_EggTransform_set_transform2d_344(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.set_transform2d")) {
    return NULL;
  }
  // 1-inline void EggTransform::set_transform2d(LMatrix3d const &mat)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.set_transform2d", "LMatrix3d");
  }
  (*local_this).set_transform2d(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform2d(const EggTransform self, const LMatrix3d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_set_transform2d_344_comment =
  "C++ Interface:\n"
  "set_transform2d(const EggTransform self, const LMatrix3d mat)\n"
  "\n"
  "/**\n"
  " * Sets the overall transform as a 3x3 matrix.  This completely replaces\n"
  " * whatever componentwise transform may have been defined.\n"
  " */";
#else
static const char *Dtool_EggTransform_set_transform2d_344_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTransform::has_transform3d(void) const
 */
static PyObject *Dtool_EggTransform_has_transform3d_345(PyObject *self, PyObject *) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTransform::has_transform3d(void) const
  bool return_value = (*(const EggTransform*)local_this).has_transform3d();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_has_transform3d_345_comment =
  "C++ Interface:\n"
  "has_transform3d(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform is specified as a 3-d transform, e.g.  with a\n"
  " * 4x4 matrix, or false if it is specified as a 2-d transform (with a 2x2\n"
  " * matrix), or not specified at all.\n"
  " *\n"
  " * Normally, EggTextures have a 3-d matrix (but occasionally they use a 3-d\n"
  " * matrix), and EggGroups always have a 3-d matrix.\n"
  " */";
#else
static const char *Dtool_EggTransform_has_transform3d_345_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTransform::set_transform3d(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggTransform_set_transform3d_346(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.set_transform3d")) {
    return NULL;
  }
  // 1-inline void EggTransform::set_transform3d(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.set_transform3d", "LMatrix4d");
  }
  (*local_this).set_transform3d(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform3d(const EggTransform self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_set_transform3d_346_comment =
  "C++ Interface:\n"
  "set_transform3d(const EggTransform self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Sets the overall transform as a 4x4 matrix.  This completely replaces\n"
  " * whatever componentwise transform may have been defined.\n"
  " */";
#else
static const char *Dtool_EggTransform_set_transform3d_346_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d EggTransform::get_transform2d(void) const
 */
static PyObject *Dtool_EggTransform_get_transform2d_347(PyObject *self, PyObject *) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3d EggTransform::get_transform2d(void) const
  LMatrix3d *return_value = new LMatrix3d((*(const EggTransform*)local_this).get_transform2d());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_transform2d_347_comment =
  "C++ Interface:\n"
  "get_transform2d(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns the overall transform as a 3x3 matrix.  It is an error to call this\n"
  " * if has_transform3d() is true.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_transform2d_347_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggTransform::get_transform3d(void) const
 */
static PyObject *Dtool_EggTransform_get_transform3d_348(PyObject *self, PyObject *) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const &EggTransform::get_transform3d(void) const
  LMatrix4d const *return_value = &((*(const EggTransform*)local_this).get_transform3d());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_transform3d_348_comment =
  "C++ Interface:\n"
  "get_transform3d(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns the overall transform as a 4x4 matrix.  It is valid to call this\n"
  " * even if has_transform2d() is true; in this case, the 3x3 transform will be\n"
  " * expanded to a 4x4 matrix.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_transform3d_348_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTransform::transform_is_identity(void) const
 */
static PyObject *Dtool_EggTransform_transform_is_identity_349(PyObject *self, PyObject *) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTransform::transform_is_identity(void) const
  bool return_value = (*(const EggTransform*)local_this).transform_is_identity();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_transform_is_identity_349_comment =
  "C++ Interface:\n"
  "transform_is_identity(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns true if the described transform is identity, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTransform_transform_is_identity_349_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggTransform::get_num_components(void) const
 */
static PyObject *Dtool_EggTransform_get_num_components_351(PyObject *self, PyObject *) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggTransform::get_num_components(void) const
  int return_value = (*(const EggTransform*)local_this).get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_num_components_351_comment =
  "C++ Interface:\n"
  "get_num_components(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns the number of components that make up the transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_num_components_351_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTransform::ComponentType EggTransform::get_component_type(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_type_352(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTransform::ComponentType EggTransform::get_component_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggTransform::ComponentType return_value = (*(const EggTransform*)local_this).get_component_type((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_type(EggTransform self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_type_352_comment =
  "C++ Interface:\n"
  "get_component_type(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the type of the nth component.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_type_352_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggTransform::get_component_number(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_number_353(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggTransform::get_component_number(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const EggTransform*)local_this).get_component_number((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_number(EggTransform self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_number_353_comment =
  "C++ Interface:\n"
  "get_component_number(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the solitary number associated with the nth component.  In the case\n"
  " * of a rotation, this is the angle in degrees to rotate; in the case of\n"
  " * uniform scale, this is the amount of the scale.  Other types do not use\n"
  " * this property.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_number_353_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d const &EggTransform::get_component_vec2(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_vec2_354(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d const &EggTransform::get_component_vec2(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase2d const *return_value = &((*(const EggTransform*)local_this).get_component_vec2((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_vec2(EggTransform self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_vec2_354_comment =
  "C++ Interface:\n"
  "get_component_vec2(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the 2-component vector associated with the nth component.  This may\n"
  " * be the translate vector, rotate axis, or non-uniform scale.  It is an error\n"
  " * to call this if the component type does not use a 2-d vector property.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_vec2_354_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &EggTransform::get_component_vec3(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_vec3_355(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d const &EggTransform::get_component_vec3(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3d const *return_value = &((*(const EggTransform*)local_this).get_component_vec3((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_vec3(EggTransform self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_vec3_355_comment =
  "C++ Interface:\n"
  "get_component_vec3(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the 3-component vector associated with the nth component.  This may\n"
  " * be the translate vector, rotate axis, or non-uniform scale.  It is an error\n"
  " * to call this if the component type does not use a 3-d vector property.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_vec3_355_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d const &EggTransform::get_component_mat3(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_mat3_356(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3d const &EggTransform::get_component_mat3(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LMatrix3d const *return_value = &((*(const EggTransform*)local_this).get_component_mat3((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_mat3(EggTransform self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_mat3_356_comment =
  "C++ Interface:\n"
  "get_component_mat3(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the 3x3 matrix associated with the nth component.  It is an error\n"
  " * to call this if the component type is not CT_matrix3.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_mat3_356_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggTransform::get_component_mat4(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_mat4_357(PyObject *self, PyObject *arg) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix4d const &EggTransform::get_component_mat4(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LMatrix4d const *return_value = &((*(const EggTransform*)local_this).get_component_mat4((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_mat4(EggTransform self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_mat4_357_comment =
  "C++ Interface:\n"
  "get_component_mat4(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the 4x4 matrix associated with the nth component.  It is an error\n"
  " * to call this if the component type is not CT_matrix4.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_mat4_357_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::write(ostream &out, int indent_level, std::string const &label) const
 */
static PyObject *Dtool_EggTransform_write_358(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggTransform::write(ostream &out, int indent_level, std::string const &label) const
  PyObject *param1;
  int param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"out", "indent_level", "label", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Ois#:write", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggTransform.write", false, true);
    if (param1_this != NULL) {
      (*(const EggTransform*)local_this).write(*param1_this, (int)param2, std::string(param3_str, param3_len));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggTransform self, ostream out, int indent_level, str label)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_write_358_comment =
  "C++ Interface:\n"
  "write(EggTransform self, ostream out, int indent_level, str label)\n"
  "\n"
  "/**\n"
  " * Writes the transform to the indicated stream in Egg format.\n"
  " */";
#else
static const char *Dtool_EggTransform_write_358_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggGroup *EggTransform::downcast_to_EggGroup(void)
 */
static PyObject *Dtool_EggTransform_downcast_to_EggGroup_375(PyObject *self, PyObject *) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.downcast_to_EggGroup")) {
    return NULL;
  }
  // 1-EggGroup *EggTransform::downcast_to_EggGroup(void)
  EggGroup *return_value = (EggGroup *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_downcast_to_EggGroup_375_comment =
  "C++ Interface:\n"
  "downcast_to_EggGroup(const EggTransform self)\n"
  "\n"
  "downcast from EggTransform to EggGroup";
#else
static const char *Dtool_EggTransform_downcast_to_EggGroup_375_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggTexture *EggTransform::downcast_to_EggTexture(void)
 */
static PyObject *Dtool_EggTransform_downcast_to_EggTexture_614(PyObject *self, PyObject *) {
  EggTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.downcast_to_EggTexture")) {
    return NULL;
  }
  // 1-EggTexture *EggTransform::downcast_to_EggTexture(void)
  EggTexture *return_value = (EggTexture *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_downcast_to_EggTexture_614_comment =
  "C++ Interface:\n"
  "downcast_to_EggTexture(const EggTransform self)\n"
  "\n"
  "downcast from EggTransform to EggTexture";
#else
static const char *Dtool_EggTransform_downcast_to_EggTexture_614_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggTransform::EggTransform(void)
 * EggTransform::EggTransform(EggTransform const &copy)
 */
static int Dtool_Init_EggTransform(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggTransform::EggTransform(void)
      EggTransform *return_value = new EggTransform();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTransform, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-EggTransform::EggTransform(EggTransform const &copy)
      EggTransform const *arg_this = (EggTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTransform, 0, "EggTransform.EggTransform", true, true);
      if (arg_this != NULL) {
        EggTransform *return_value = new EggTransform(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTransform, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggTransform() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggTransform()\n"
      "EggTransform(const EggTransform copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggTransform(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggTransform) {
    printf("EggTransform ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggTransform *local_this = (EggTransform *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggTransform) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggTransform(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggTransform) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggSwitchCondition
 */
/**
 * Python function wrapper for:
 * virtual EggSwitchCondition *EggSwitchCondition::make_copy(void) const = 0
 */
static PyObject *Dtool_EggSwitchCondition_make_copy_360(PyObject *self, PyObject *) {
  EggSwitchCondition *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggSwitchCondition, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual EggSwitchCondition *EggSwitchCondition::make_copy(void) const = 0
  EggSwitchCondition *return_value = (*(const EggSwitchCondition*)local_this).make_copy();
  if (return_value != (EggSwitchCondition *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggSwitchCondition *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggSwitchCondition, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggSwitchCondition_make_copy_360_comment =
  "C++ Interface:\n"
  "make_copy(EggSwitchCondition self)\n";
#else
static const char *Dtool_EggSwitchCondition_make_copy_360_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggSwitchCondition::write(ostream &out, int indent_level) const = 0
 */
static PyObject *Dtool_EggSwitchCondition_write_361(PyObject *self, PyObject *args, PyObject *kwds) {
  EggSwitchCondition *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggSwitchCondition, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void EggSwitchCondition::write(ostream &out, int indent_level) const = 0
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggSwitchCondition.write", false, true);
    if (param1_this != NULL) {
      (*(const EggSwitchCondition*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggSwitchCondition self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggSwitchCondition_write_361_comment =
  "C++ Interface:\n"
  "write(EggSwitchCondition self, ostream out, int indent_level)\n";
#else
static const char *Dtool_EggSwitchCondition_write_361_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggSwitchCondition::transform(LMatrix4d const &mat) = 0
 */
static PyObject *Dtool_EggSwitchCondition_transform_362(PyObject *self, PyObject *arg) {
  EggSwitchCondition *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSwitchCondition, (void **)&local_this, "EggSwitchCondition.transform")) {
    return NULL;
  }
  // 1-virtual void EggSwitchCondition::transform(LMatrix4d const &mat) = 0
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggSwitchCondition.transform", "LMatrix4d");
  }
  (*local_this).transform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggSwitchCondition self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggSwitchCondition_transform_362_comment =
  "C++ Interface:\n"
  "transform(const EggSwitchCondition self, const LMatrix4d mat)\n";
#else
static const char *Dtool_EggSwitchCondition_transform_362_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggSwitchCondition::get_class_type(void)
 */
static PyObject *Dtool_EggSwitchCondition_get_class_type_363(PyObject *, PyObject *) {
  // 1-static TypeHandle EggSwitchCondition::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggSwitchCondition::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggSwitchCondition_get_class_type_363_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggSwitchCondition_get_class_type_363_comment = NULL;
#endif

static int Dtool_Init_EggSwitchCondition(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_EggSwitchCondition(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggSwitchCondition) {
    printf("EggSwitchCondition ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggSwitchCondition *local_this = (EggSwitchCondition *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggSwitchCondition) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggSwitchCondition(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggSwitchCondition) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggSwitchCondition*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggSwitchCondition*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggSwitchCondition*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggSwitchCondition*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggSwitchConditionDistance
 */
/**
 * Python function wrapper for:
 * static TypeHandle EggSwitchConditionDistance::get_class_type(void)
 */
static PyObject *Dtool_EggSwitchConditionDistance_get_class_type_367(PyObject *, PyObject *) {
  // 1-static TypeHandle EggSwitchConditionDistance::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggSwitchConditionDistance::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggSwitchConditionDistance_get_class_type_367_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggSwitchConditionDistance_get_class_type_367_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggSwitchConditionDistance::EggSwitchConditionDistance(double switch_in, double switch_out, LPoint3d const &center, double fade = 0.0)
 */
static int Dtool_Init_EggSwitchConditionDistance(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-EggSwitchConditionDistance::EggSwitchConditionDistance(double switch_in, double switch_out, LPoint3d const &center, double fade = 0.0)
  double param0;
  double param1;
  PyObject *param2;
  double param3 = 0.0;
  static const char *keyword_list[] = {"switch_in", "switch_out", "center", "fade", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ddO|d:EggSwitchConditionDistance", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LPoint3d param2_local;
    LPoint3d const *param2_this = Dtool_Coerce_LPoint3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      Dtool_Raise_ArgTypeError(param2, 2, "EggSwitchConditionDistance.EggSwitchConditionDistance", "LPoint3d");
      return -1;
    }
    EggSwitchConditionDistance *return_value = new EggSwitchConditionDistance((double)param0, (double)param1, *param2_this, (double)param3);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggSwitchConditionDistance, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggSwitchConditionDistance(double switch_in, double switch_out, const LPoint3d center, double fade)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggSwitchConditionDistance(PyObject *args, CPT(EggSwitchConditionDistance) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggSwitchConditionDistance, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 4) {
      // 1-EggSwitchConditionDistance::EggSwitchConditionDistance(double switch_in, double switch_out, LPoint3d const &center, double fade = 0.0)
      double param0;
      double param1;
      PyObject *param2;
      double param3 = 0.0;
      if (PyArg_ParseTuple(args, "ddO|d:EggSwitchConditionDistance", &param0, &param1, &param2, &param3)) {
        LPoint3d const *param2_this;
        DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LPoint3d, (void **)&param2_this);
        if (param2_this != NULL) {
          EggSwitchConditionDistance *return_value = new EggSwitchConditionDistance((double)param0, (double)param1, *param2_this, (double)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_EggSwitchConditionDistance(PyObject *args, PT(EggSwitchConditionDistance) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggSwitchConditionDistance, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 4) {
      // 1-EggSwitchConditionDistance::EggSwitchConditionDistance(double switch_in, double switch_out, LPoint3d const &center, double fade = 0.0)
      double param0;
      double param1;
      PyObject *param2;
      double param3 = 0.0;
      if (PyArg_ParseTuple(args, "ddO|d:EggSwitchConditionDistance", &param0, &param1, &param2, &param3)) {
        LPoint3d const *param2_this;
        DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LPoint3d, (void **)&param2_this);
        if (param2_this != NULL) {
          EggSwitchConditionDistance *return_value = new EggSwitchConditionDistance((double)param0, (double)param1, *param2_this, (double)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggSwitchConditionDistance(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggSwitchConditionDistance) {
    printf("EggSwitchConditionDistance ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggSwitchConditionDistance *local_this = (EggSwitchConditionDistance *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggSwitchConditionDistance) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggSwitchCondition *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggSwitchCondition) {
    return (EggSwitchCondition *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggSwitchCondition *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggSwitchCondition *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggSwitchCondition *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggSwitchConditionDistance(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggSwitchConditionDistance) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggSwitchConditionDistance*)other_this;
  }
  if (from_type == Dtool_Ptr_EggSwitchCondition) {
    EggSwitchCondition* other_this = (EggSwitchCondition*)from_this;
    return (EggSwitchConditionDistance*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggSwitchConditionDistance*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggSwitchConditionDistance*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggSwitchConditionDistance*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggGroup
 */
/**
 * Python function wrapper for:
 * EggGroup &EggGroup::operator =(EggGroup const &copy)
 */
static PyObject *Dtool_EggGroup_operator_389(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.assign")) {
    return NULL;
  }
  // 1-EggGroup &EggGroup::operator =(EggGroup const &copy)
  CPT(EggGroup) arg_this;
  if (!Dtool_ConstCoerce_EggGroup(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.assign", "EggGroup");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggGroup *return_value = local_this;
  if (return_value != (EggGroup *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggGroup *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggGroup self, const EggGroup copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_operator_389_comment =
  "C++ Interface:\n"
  "assign(const EggGroup self, const EggGroup copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_operator_389_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggGroup::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_391(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void EggGroup::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggGroup.write", false, true);
    if (param1_this != NULL) {
      (*(const EggGroup*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_391_comment =
  "C++ Interface:\n"
  "write(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the group and all of its children to the indicated output stream in\n"
  " * Egg format.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_391_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_billboard_flags(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_billboard_flags_392(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggGroup::write_billboard_flags(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_billboard_flags", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggGroup.write_billboard_flags", false, true);
    if (param1_this != NULL) {
      (*(const EggGroup*)local_this).write_billboard_flags(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_billboard_flags(EggGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_billboard_flags_392_comment =
  "C++ Interface:\n"
  "write_billboard_flags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes just the <Billboard> entry and related fields to the indicated\n"
  " * ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_billboard_flags_392_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_collide_flags(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_collide_flags_393(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggGroup::write_collide_flags(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_collide_flags", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggGroup.write_collide_flags", false, true);
    if (param1_this != NULL) {
      (*(const EggGroup*)local_this).write_collide_flags(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_collide_flags(EggGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_collide_flags_393_comment =
  "C++ Interface:\n"
  "write_collide_flags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes just the <Collide> entry and related fields to the indicated\n"
  " * ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_collide_flags_393_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_model_flags(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_model_flags_394(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggGroup::write_model_flags(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_model_flags", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggGroup.write_model_flags", false, true);
    if (param1_this != NULL) {
      (*(const EggGroup*)local_this).write_model_flags(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_model_flags(EggGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_model_flags_394_comment =
  "C++ Interface:\n"
  "write_model_flags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the <Model> flag and related flags to the indicated ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_model_flags_394_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_switch_flags(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_switch_flags_395(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggGroup::write_switch_flags(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_switch_flags", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggGroup.write_switch_flags", false, true);
    if (param1_this != NULL) {
      (*(const EggGroup*)local_this).write_switch_flags(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_switch_flags(EggGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_switch_flags_395_comment =
  "C++ Interface:\n"
  "write_switch_flags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the <Switch> flag and related flags to the indicated ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_switch_flags_395_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_object_types(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_object_types_396(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggGroup::write_object_types(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_object_types", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggGroup.write_object_types", false, true);
    if (param1_this != NULL) {
      (*(const EggGroup*)local_this).write_object_types(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_object_types(EggGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_object_types_396_comment =
  "C++ Interface:\n"
  "write_object_types(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes just the <ObjectTypes> entries, if any, to the indicated ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_object_types_396_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_decal_flags(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_decal_flags_397(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggGroup::write_decal_flags(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_decal_flags", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggGroup.write_decal_flags", false, true);
    if (param1_this != NULL) {
      (*(const EggGroup*)local_this).write_decal_flags(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_decal_flags(EggGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_decal_flags_397_comment =
  "C++ Interface:\n"
  "write_decal_flags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the flags related to decaling, if any.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_decal_flags_397_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_tags(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_tags_398(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggGroup::write_tags(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_tags", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggGroup.write_tags", false, true);
    if (param1_this != NULL) {
      (*(const EggGroup*)local_this).write_tags(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_tags(EggGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_tags_398_comment =
  "C++ Interface:\n"
  "write_tags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes just the <Tag> entries, if any, to the indicated ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_tags_398_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_render_mode(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_render_mode_399(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggGroup::write_render_mode(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_render_mode", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggGroup.write_render_mode", false, true);
    if (param1_this != NULL) {
      (*(const EggGroup*)local_this).write_render_mode(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_render_mode(EggGroup self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_render_mode_399_comment =
  "C++ Interface:\n"
  "write_render_mode(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the flags inherited from EggRenderMode and similar flags that\n"
  " * control obscure render effects.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_render_mode_399_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroup::is_joint(void) const
 */
static PyObject *Dtool_EggGroup_is_joint_400(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool EggGroup::is_joint(void) const
  bool return_value = (*(const EggGroup*)local_this).is_joint();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_is_joint_400_comment =
  "C++ Interface:\n"
  "is_joint(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular node represents a <Joint> entry or not.\n"
  " * This is a handy thing to know since Joints are sorted to the end of their\n"
  " * sibling list when writing an egg file.  See EggGroupNode::write().\n"
  " */";
#else
static const char *Dtool_EggGroup_is_joint_400_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_alpha_mode(void)
 */
static PyObject *Dtool_EggGroup_determine_alpha_mode_401(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_alpha_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_alpha_mode(void)
  EggRenderMode *return_value = (*local_this).determine_alpha_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_alpha_mode_401_comment =
  "C++ Interface:\n"
  "determine_alpha_mode(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has an alpha_mode\n"
  " * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is\n"
  " * found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_alpha_mode_401_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_depth_write_mode(void)
 */
static PyObject *Dtool_EggGroup_determine_depth_write_mode_402(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_depth_write_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_depth_write_mode(void)
  EggRenderMode *return_value = (*local_this).determine_depth_write_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_depth_write_mode_402_comment =
  "C++ Interface:\n"
  "determine_depth_write_mode(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a\n"
  " * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_depth_write_mode_402_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_depth_test_mode(void)
 */
static PyObject *Dtool_EggGroup_determine_depth_test_mode_403(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_depth_test_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_depth_test_mode(void)
  EggRenderMode *return_value = (*local_this).determine_depth_test_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_depth_test_mode_403_comment =
  "C++ Interface:\n"
  "determine_depth_test_mode(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a\n"
  " * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_depth_test_mode_403_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_visibility_mode(void)
 */
static PyObject *Dtool_EggGroup_determine_visibility_mode_404(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_visibility_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_visibility_mode(void)
  EggRenderMode *return_value = (*local_this).determine_visibility_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_visibility_mode_404_comment =
  "C++ Interface:\n"
  "determine_visibility_mode(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a\n"
  " * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_visibility_mode_404_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_depth_offset(void)
 */
static PyObject *Dtool_EggGroup_determine_depth_offset_405(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_depth_offset")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_depth_offset(void)
  EggRenderMode *return_value = (*local_this).determine_depth_offset();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_depth_offset_405_comment =
  "C++ Interface:\n"
  "determine_depth_offset(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a depth_offset\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_depth_offset_405_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_draw_order(void)
 */
static PyObject *Dtool_EggGroup_determine_draw_order_406(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_draw_order")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_draw_order(void)
  EggRenderMode *return_value = (*local_this).determine_draw_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_draw_order_406_comment =
  "C++ Interface:\n"
  "determine_draw_order(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a draw_order\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_draw_order_406_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_bin(void)
 */
static PyObject *Dtool_EggGroup_determine_bin_407(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_bin")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_bin(void)
  EggRenderMode *return_value = (*local_this).determine_bin();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_bin_407_comment =
  "C++ Interface:\n"
  "determine_bin(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a bin\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_bin_407_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroup::determine_indexed(void)
 */
static PyObject *Dtool_EggGroup_determine_indexed_408(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_indexed")) {
    return NULL;
  }
  // 1-virtual bool EggGroup::determine_indexed(void)
  bool return_value = (*local_this).determine_indexed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_indexed_408_comment =
  "C++ Interface:\n"
  "determine_indexed(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup at this level or above\n"
  " * that has the \"indexed\" scalar set.  Returns the value of the indexed scalar\n"
  " * if it is found, or false if it is not.\n"
  " *\n"
  " * In other words, returns true if the \"indexed\" flag is in effect for the\n"
  " * indicated node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_indexed_408_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroup::determine_decal(void)
 */
static PyObject *Dtool_EggGroup_determine_decal_409(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_decal")) {
    return NULL;
  }
  // 1-virtual bool EggGroup::determine_decal(void)
  bool return_value = (*local_this).determine_decal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_decal_409_comment =
  "C++ Interface:\n"
  "determine_decal(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup at this level or above\n"
  " * that has the \"decal\" flag set.  Returns the value of the decal flag if it\n"
  " * is found, or false if it is not.\n"
  " *\n"
  " * In other words, returns true if the \"decal\" flag is in effect for the\n"
  " * indicated node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_decal_409_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::set_group_type(EggGroup::GroupType type)
 */
static PyObject *Dtool_EggGroup_set_group_type_410(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_group_type")) {
    return NULL;
  }
  // 1-void EggGroup::set_group_type(EggGroup::GroupType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_group_type((EggGroup::GroupType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_group_type(const EggGroup self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_group_type_410_comment =
  "C++ Interface:\n"
  "set_group_type(const EggGroup self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_group_type_410_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::GroupType EggGroup::get_group_type(void) const
 */
static PyObject *Dtool_EggGroup_get_group_type_411(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggGroup::GroupType EggGroup::get_group_type(void) const
  EggGroup::GroupType return_value = (*(const EggGroup*)local_this).get_group_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_group_type_411_comment =
  "C++ Interface:\n"
  "get_group_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_group_type_411_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::is_instance_type(void) const
 */
static PyObject *Dtool_EggGroup_is_instance_type_412(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::is_instance_type(void) const
  bool return_value = (*(const EggGroup*)local_this).is_instance_type();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_is_instance_type_412_comment =
  "C++ Interface:\n"
  "is_instance_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns true if this group is an instance type node; i.e.  it begins the\n"
  " * root of a local coordinate space.  This is not related to instancing\n"
  " * (multiple copies of a node in a scene graph).\n"
  " *\n"
  " * This also includes the case of the node including a billboard flag without\n"
  " * an explicit center, which implicitly makes the node behave like an\n"
  " * instance.\n"
  " */";
#else
static const char *Dtool_EggGroup_is_instance_type_412_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_billboard_type(EggGroup::BillboardType type)
 */
static PyObject *Dtool_EggGroup_set_billboard_type_413(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_billboard_type")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_billboard_type(EggGroup::BillboardType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_billboard_type((EggGroup::BillboardType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_billboard_type(const EggGroup self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_billboard_type_413_comment =
  "C++ Interface:\n"
  "set_billboard_type(const EggGroup self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_billboard_type_413_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::BillboardType EggGroup::get_billboard_type(void) const
 */
static PyObject *Dtool_EggGroup_get_billboard_type_414(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggGroup::BillboardType EggGroup::get_billboard_type(void) const
  EggGroup::BillboardType return_value = (*(const EggGroup*)local_this).get_billboard_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_billboard_type_414_comment =
  "C++ Interface:\n"
  "get_billboard_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_billboard_type_414_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_billboard_center(LPoint3d const &billboard_center)
 */
static PyObject *Dtool_EggGroup_set_billboard_center_415(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_billboard_center")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_billboard_center(LPoint3d const &billboard_center)
  LPoint3d arg_local;
  LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_billboard_center", "LPoint3d");
  }
  (*local_this).set_billboard_center(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_billboard_center(const EggGroup self, const LPoint3d billboard_center)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_billboard_center_415_comment =
  "C++ Interface:\n"
  "set_billboard_center(const EggGroup self, const LPoint3d billboard_center)\n"
  "\n"
  "/**\n"
  " * Sets the point around which the billboard will rotate, if this node\n"
  " * contains a billboard specification.\n"
  " *\n"
  " * If a billboard type is given but no billboard_center is specified, then the\n"
  " * group node is treated as an <Instance>, and the billboard rotates around\n"
  " * the origin.  If, however, a billboard_center is specified, then the group\n"
  " * node is *not* treated as an <Instance>, and the billboard rotates around\n"
  " * the specified point.\n"
  " *\n"
  " * The point is in the same coordinate system as the vertices of this node:\n"
  " * usually global, but possibly local if there is an <Instance> somewhere\n"
  " * above.  Specifically, this is the coordinate system defined by\n"
  " * get_vertex_frame().\n"
  " */";
#else
static const char *Dtool_EggGroup_set_billboard_center_415_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_billboard_center(void)
 */
static PyObject *Dtool_EggGroup_clear_billboard_center_416(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_billboard_center")) {
    return NULL;
  }
  // 1-inline void EggGroup::clear_billboard_center(void)
  (*local_this).clear_billboard_center();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_billboard_center_416_comment =
  "C++ Interface:\n"
  "clear_billboard_center(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_billboard_center_416_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_billboard_center(void) const
 */
static PyObject *Dtool_EggGroup_has_billboard_center_417(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::has_billboard_center(void) const
  bool return_value = (*(const EggGroup*)local_this).has_billboard_center();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_billboard_center_417_comment =
  "C++ Interface:\n"
  "has_billboard_center(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_billboard_center_417_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d const &EggGroup::get_billboard_center(void) const
 */
static PyObject *Dtool_EggGroup_get_billboard_center_418(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3d const &EggGroup::get_billboard_center(void) const
  LPoint3d const *return_value = &((*(const EggGroup*)local_this).get_billboard_center());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_billboard_center_418_comment =
  "C++ Interface:\n"
  "get_billboard_center(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_billboard_center_418_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_cs_type(EggGroup::CollisionSolidType type)
 */
static PyObject *Dtool_EggGroup_set_cs_type_419(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_cs_type")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_cs_type(EggGroup::CollisionSolidType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_cs_type((EggGroup::CollisionSolidType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cs_type(const EggGroup self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_cs_type_419_comment =
  "C++ Interface:\n"
  "set_cs_type(const EggGroup self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_cs_type_419_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::CollisionSolidType EggGroup::get_cs_type(void) const
 */
static PyObject *Dtool_EggGroup_get_cs_type_420(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggGroup::CollisionSolidType EggGroup::get_cs_type(void) const
  EggGroup::CollisionSolidType return_value = (*(const EggGroup*)local_this).get_cs_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_cs_type_420_comment =
  "C++ Interface:\n"
  "get_cs_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_cs_type_420_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_collide_flags(int flags)
 */
static PyObject *Dtool_EggGroup_set_collide_flags_421(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_collide_flags")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_collide_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_collide_flags((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_flags(const EggGroup self, int flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_collide_flags_421_comment =
  "C++ Interface:\n"
  "set_collide_flags(const EggGroup self, int flags)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_collide_flags_421_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::CollideFlags EggGroup::get_collide_flags(void) const
 */
static PyObject *Dtool_EggGroup_get_collide_flags_422(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggGroup::CollideFlags EggGroup::get_collide_flags(void) const
  EggGroup::CollideFlags return_value = (*(const EggGroup*)local_this).get_collide_flags();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_collide_flags_422_comment =
  "C++ Interface:\n"
  "get_collide_flags(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_collide_flags_422_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_collision_name(std::string const &collision_name)
 */
static PyObject *Dtool_EggGroup_set_collision_name_423(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_collision_name")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_collision_name(std::string const &collision_name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_collision_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collision_name(const EggGroup self, str collision_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_collision_name_423_comment =
  "C++ Interface:\n"
  "set_collision_name(const EggGroup self, str collision_name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_collision_name_423_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_collision_name(void)
 */
static PyObject *Dtool_EggGroup_clear_collision_name_424(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_collision_name")) {
    return NULL;
  }
  // 1-inline void EggGroup::clear_collision_name(void)
  (*local_this).clear_collision_name();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_collision_name_424_comment =
  "C++ Interface:\n"
  "clear_collision_name(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_collision_name_424_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_collision_name(void) const
 */
static PyObject *Dtool_EggGroup_has_collision_name_425(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::has_collision_name(void) const
  bool return_value = (*(const EggGroup*)local_this).has_collision_name();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_collision_name_425_comment =
  "C++ Interface:\n"
  "has_collision_name(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_collision_name_425_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggGroup::get_collision_name(void) const
 */
static PyObject *Dtool_EggGroup_get_collision_name_426(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &EggGroup::get_collision_name(void) const
  std::string const &return_value = (*(const EggGroup*)local_this).get_collision_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_collision_name_426_comment =
  "C++ Interface:\n"
  "get_collision_name(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_collision_name_426_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_dcs_type(EggGroup::DCSType type)
 */
static PyObject *Dtool_EggGroup_set_dcs_type_427(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_dcs_type")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_dcs_type(EggGroup::DCSType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_dcs_type((EggGroup::DCSType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dcs_type(const EggGroup self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_dcs_type_427_comment =
  "C++ Interface:\n"
  "set_dcs_type(const EggGroup self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_dcs_type_427_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::DCSType EggGroup::get_dcs_type(void) const
 */
static PyObject *Dtool_EggGroup_get_dcs_type_428(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggGroup::DCSType EggGroup::get_dcs_type(void) const
  EggGroup::DCSType return_value = (*(const EggGroup*)local_this).get_dcs_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_dcs_type_428_comment =
  "C++ Interface:\n"
  "get_dcs_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_dcs_type_428_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_dcs_type(void) const
 */
static PyObject *Dtool_EggGroup_has_dcs_type_429(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::has_dcs_type(void) const
  bool return_value = (*(const EggGroup*)local_this).has_dcs_type();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_dcs_type_429_comment =
  "C++ Interface:\n"
  "has_dcs_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns true if the specified DCS type is not DC_none and not\n"
  " * DC_unspecified.\n"
  " */";
#else
static const char *Dtool_EggGroup_has_dcs_type_429_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_dart_type(EggGroup::DartType type)
 */
static PyObject *Dtool_EggGroup_set_dart_type_430(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_dart_type")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_dart_type(EggGroup::DartType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_dart_type((EggGroup::DartType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dart_type(const EggGroup self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_dart_type_430_comment =
  "C++ Interface:\n"
  "set_dart_type(const EggGroup self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_dart_type_430_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::DartType EggGroup::get_dart_type(void) const
 */
static PyObject *Dtool_EggGroup_get_dart_type_431(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggGroup::DartType EggGroup::get_dart_type(void) const
  EggGroup::DartType return_value = (*(const EggGroup*)local_this).get_dart_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_dart_type_431_comment =
  "C++ Interface:\n"
  "get_dart_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_dart_type_431_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_switch_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_switch_flag_432(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_switch_flag")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_switch_flag(bool flag)
  (*local_this).set_switch_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_switch_flag(const EggGroup self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_switch_flag_432_comment =
  "C++ Interface:\n"
  "set_switch_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_switch_flag_432_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_switch_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_switch_flag_433(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::get_switch_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_switch_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_switch_flag_433_comment =
  "C++ Interface:\n"
  "get_switch_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_switch_flag_433_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_switch_fps(double fps)
 */
static PyObject *Dtool_EggGroup_set_switch_fps_434(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_switch_fps")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_switch_fps(double fps)
  if (PyNumber_Check(arg)) {
    (*local_this).set_switch_fps(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_switch_fps(const EggGroup self, double fps)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_switch_fps_434_comment =
  "C++ Interface:\n"
  "set_switch_fps(const EggGroup self, double fps)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_switch_fps_434_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggGroup::get_switch_fps(void) const
 */
static PyObject *Dtool_EggGroup_get_switch_fps_435(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggGroup::get_switch_fps(void) const
  double return_value = (*(const EggGroup*)local_this).get_switch_fps();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_switch_fps_435_comment =
  "C++ Interface:\n"
  "get_switch_fps(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_switch_fps_435_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::add_object_type(std::string const &object_type)
 */
static PyObject *Dtool_EggGroup_add_object_type_436(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.add_object_type")) {
    return NULL;
  }
  // 1-inline void EggGroup::add_object_type(std::string const &object_type)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).add_object_type(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_object_type(const EggGroup self, str object_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_add_object_type_436_comment =
  "C++ Interface:\n"
  "add_object_type(const EggGroup self, str object_type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_add_object_type_436_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_object_types(void)
 */
static PyObject *Dtool_EggGroup_clear_object_types_437(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_object_types")) {
    return NULL;
  }
  // 1-inline void EggGroup::clear_object_types(void)
  (*local_this).clear_object_types();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_object_types_437_comment =
  "C++ Interface:\n"
  "clear_object_types(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_object_types_437_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggGroup::get_num_object_types(void) const
 */
static PyObject *Dtool_EggGroup_get_num_object_types_438(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggGroup::get_num_object_types(void) const
  int return_value = (*(const EggGroup*)local_this).get_num_object_types();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_num_object_types_438_comment =
  "C++ Interface:\n"
  "get_num_object_types(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_num_object_types_438_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string EggGroup::get_object_type(int index) const
 */
static PyObject *Dtool_EggGroup_get_object_type_439(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string EggGroup::get_object_type(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const EggGroup*)local_this).get_object_type((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_object_type(EggGroup self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_object_type_439_comment =
  "C++ Interface:\n"
  "get_object_type(EggGroup self, int index)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_object_type_439_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggGroup::has_object_type(std::string const &object_type) const
 */
static PyObject *Dtool_EggGroup_has_object_type_441(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggGroup::has_object_type(std::string const &object_type) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const EggGroup*)local_this).has_object_type(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_object_type(EggGroup self, str object_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_object_type_441_comment =
  "C++ Interface:\n"
  "has_object_type(EggGroup self, str object_type)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated object type has been added to the group, or\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_has_object_type_441_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggGroup::remove_object_type(std::string const &object_type)
 */
static PyObject *Dtool_EggGroup_remove_object_type_442(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.remove_object_type")) {
    return NULL;
  }
  // 1-bool EggGroup::remove_object_type(std::string const &object_type)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).remove_object_type(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_object_type(const EggGroup self, str object_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_remove_object_type_442_comment =
  "C++ Interface:\n"
  "remove_object_type(const EggGroup self, str object_type)\n"
  "\n"
  "/**\n"
  " * Removes the first instance of the indicated object type from the group if\n"
  " * it is present.  Returns true if the object type was found and removed,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_remove_object_type_442_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_model_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_model_flag_443(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_model_flag")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_model_flag(bool flag)
  (*local_this).set_model_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_model_flag(const EggGroup self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_model_flag_443_comment =
  "C++ Interface:\n"
  "set_model_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_model_flag_443_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_model_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_model_flag_444(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::get_model_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_model_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_model_flag_444_comment =
  "C++ Interface:\n"
  "get_model_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_model_flag_444_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_texlist_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_texlist_flag_445(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_texlist_flag")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_texlist_flag(bool flag)
  (*local_this).set_texlist_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texlist_flag(const EggGroup self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_texlist_flag_445_comment =
  "C++ Interface:\n"
  "set_texlist_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_texlist_flag_445_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_texlist_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_texlist_flag_446(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::get_texlist_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_texlist_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_texlist_flag_446_comment =
  "C++ Interface:\n"
  "get_texlist_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_texlist_flag_446_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_nofog_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_nofog_flag_447(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_nofog_flag")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_nofog_flag(bool flag)
  (*local_this).set_nofog_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_nofog_flag(const EggGroup self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_nofog_flag_447_comment =
  "C++ Interface:\n"
  "set_nofog_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_nofog_flag_447_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_nofog_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_nofog_flag_448(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::get_nofog_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_nofog_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_nofog_flag_448_comment =
  "C++ Interface:\n"
  "get_nofog_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_nofog_flag_448_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_decal_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_decal_flag_449(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_decal_flag")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_decal_flag(bool flag)
  (*local_this).set_decal_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_decal_flag(const EggGroup self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_decal_flag_449_comment =
  "C++ Interface:\n"
  "set_decal_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_decal_flag_449_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_decal_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_decal_flag_450(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::get_decal_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_decal_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_decal_flag_450_comment =
  "C++ Interface:\n"
  "get_decal_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_decal_flag_450_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_direct_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_direct_flag_451(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_direct_flag")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_direct_flag(bool flag)
  (*local_this).set_direct_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_direct_flag(const EggGroup self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_direct_flag_451_comment =
  "C++ Interface:\n"
  "set_direct_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_direct_flag_451_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_direct_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_direct_flag_452(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::get_direct_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_direct_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_direct_flag_452_comment =
  "C++ Interface:\n"
  "get_direct_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_direct_flag_452_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_portal_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_portal_flag_453(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_portal_flag")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_portal_flag(bool flag)
  (*local_this).set_portal_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_portal_flag(const EggGroup self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_portal_flag_453_comment =
  "C++ Interface:\n"
  "set_portal_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_portal_flag_453_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_portal_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_portal_flag_454(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::get_portal_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_portal_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_portal_flag_454_comment =
  "C++ Interface:\n"
  "get_portal_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_portal_flag_454_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_occluder_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_occluder_flag_455(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_occluder_flag")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_occluder_flag(bool flag)
  (*local_this).set_occluder_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_occluder_flag(const EggGroup self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_occluder_flag_455_comment =
  "C++ Interface:\n"
  "set_occluder_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_occluder_flag_455_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_occluder_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_occluder_flag_456(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::get_occluder_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_occluder_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_occluder_flag_456_comment =
  "C++ Interface:\n"
  "get_occluder_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_occluder_flag_456_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_polylight_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_polylight_flag_457(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_polylight_flag")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_polylight_flag(bool flag)
  (*local_this).set_polylight_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_polylight_flag(const EggGroup self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_polylight_flag_457_comment =
  "C++ Interface:\n"
  "set_polylight_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_polylight_flag_457_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_polylight_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_polylight_flag_458(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::get_polylight_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_polylight_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_polylight_flag_458_comment =
  "C++ Interface:\n"
  "get_polylight_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_polylight_flag_458_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_indexed_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_indexed_flag_459(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_indexed_flag")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_indexed_flag(bool flag)
  (*local_this).set_indexed_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_indexed_flag(const EggGroup self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_indexed_flag_459_comment =
  "C++ Interface:\n"
  "set_indexed_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " * If this flag is true, geometry at this node and below will be generated as\n"
  " * indexed geometry.\n"
  " */";
#else
static const char *Dtool_EggGroup_set_indexed_flag_459_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_indexed_flag(void)
 */
static PyObject *Dtool_EggGroup_clear_indexed_flag_460(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_indexed_flag")) {
    return NULL;
  }
  // 1-inline void EggGroup::clear_indexed_flag(void)
  (*local_this).clear_indexed_flag();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_indexed_flag_460_comment =
  "C++ Interface:\n"
  "clear_indexed_flag(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_indexed_flag_460_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_indexed_flag(void) const
 */
static PyObject *Dtool_EggGroup_has_indexed_flag_461(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::has_indexed_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).has_indexed_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_indexed_flag_461_comment =
  "C++ Interface:\n"
  "has_indexed_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_indexed_flag_461_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_indexed_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_indexed_flag_462(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::get_indexed_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_indexed_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_indexed_flag_462_comment =
  "C++ Interface:\n"
  "get_indexed_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_indexed_flag_462_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_EggGroup_set_collide_mask_463(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_collide_mask")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_collide_mask", "BitMask");
  }
  (*local_this).set_collide_mask(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_collide_mask_463_comment =
  "C++ Interface:\n"
  "set_collide_mask(const EggGroup self, BitMask mask)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_collide_mask_463_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_collide_mask(void)
 */
static PyObject *Dtool_EggGroup_clear_collide_mask_464(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_collide_mask")) {
    return NULL;
  }
  // 1-inline void EggGroup::clear_collide_mask(void)
  (*local_this).clear_collide_mask();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_collide_mask_464_comment =
  "C++ Interface:\n"
  "clear_collide_mask(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_collide_mask_464_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_has_collide_mask_465(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::has_collide_mask(void) const
  bool return_value = (*(const EggGroup*)local_this).has_collide_mask();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_collide_mask_465_comment =
  "C++ Interface:\n"
  "has_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_collide_mask_465_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask EggGroup::get_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_get_collide_mask_466(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CollideMask EggGroup::get_collide_mask(void) const
  CollideMask *return_value = new CollideMask((*(const EggGroup*)local_this).get_collide_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_collide_mask_466_comment =
  "C++ Interface:\n"
  "get_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_collide_mask_466_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_from_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_EggGroup_set_from_collide_mask_467(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_from_collide_mask")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_from_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_from_collide_mask", "BitMask");
  }
  (*local_this).set_from_collide_mask(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_from_collide_mask_467_comment =
  "C++ Interface:\n"
  "set_from_collide_mask(const EggGroup self, BitMask mask)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_from_collide_mask_467_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_from_collide_mask(void)
 */
static PyObject *Dtool_EggGroup_clear_from_collide_mask_468(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_from_collide_mask")) {
    return NULL;
  }
  // 1-inline void EggGroup::clear_from_collide_mask(void)
  (*local_this).clear_from_collide_mask();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_from_collide_mask_468_comment =
  "C++ Interface:\n"
  "clear_from_collide_mask(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_from_collide_mask_468_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_from_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_has_from_collide_mask_469(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::has_from_collide_mask(void) const
  bool return_value = (*(const EggGroup*)local_this).has_from_collide_mask();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_from_collide_mask_469_comment =
  "C++ Interface:\n"
  "has_from_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_from_collide_mask_469_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask EggGroup::get_from_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_get_from_collide_mask_470(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CollideMask EggGroup::get_from_collide_mask(void) const
  CollideMask *return_value = new CollideMask((*(const EggGroup*)local_this).get_from_collide_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_from_collide_mask_470_comment =
  "C++ Interface:\n"
  "get_from_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_from_collide_mask_470_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_into_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_EggGroup_set_into_collide_mask_471(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_into_collide_mask")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_into_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_into_collide_mask", "BitMask");
  }
  (*local_this).set_into_collide_mask(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_into_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_into_collide_mask_471_comment =
  "C++ Interface:\n"
  "set_into_collide_mask(const EggGroup self, BitMask mask)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_into_collide_mask_471_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_into_collide_mask(void)
 */
static PyObject *Dtool_EggGroup_clear_into_collide_mask_472(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_into_collide_mask")) {
    return NULL;
  }
  // 1-inline void EggGroup::clear_into_collide_mask(void)
  (*local_this).clear_into_collide_mask();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_into_collide_mask_472_comment =
  "C++ Interface:\n"
  "clear_into_collide_mask(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_into_collide_mask_472_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_into_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_has_into_collide_mask_473(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::has_into_collide_mask(void) const
  bool return_value = (*(const EggGroup*)local_this).has_into_collide_mask();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_into_collide_mask_473_comment =
  "C++ Interface:\n"
  "has_into_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_into_collide_mask_473_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask EggGroup::get_into_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_get_into_collide_mask_474(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CollideMask EggGroup::get_into_collide_mask(void) const
  CollideMask *return_value = new CollideMask((*(const EggGroup*)local_this).get_into_collide_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_into_collide_mask_474_comment =
  "C++ Interface:\n"
  "get_into_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_into_collide_mask_474_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_blend_mode(EggGroup::BlendMode blend_mode)
 */
static PyObject *Dtool_EggGroup_set_blend_mode_475(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_blend_mode")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_blend_mode(EggGroup::BlendMode blend_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_blend_mode((EggGroup::BlendMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_mode(const EggGroup self, int blend_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_blend_mode_475_comment =
  "C++ Interface:\n"
  "set_blend_mode(const EggGroup self, int blend_mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_blend_mode_475_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::BlendMode EggGroup::get_blend_mode(void) const
 */
static PyObject *Dtool_EggGroup_get_blend_mode_476(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggGroup::BlendMode EggGroup::get_blend_mode(void) const
  EggGroup::BlendMode return_value = (*(const EggGroup*)local_this).get_blend_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_blend_mode_476_comment =
  "C++ Interface:\n"
  "get_blend_mode(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_blend_mode_476_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_blend_operand_a(EggGroup::BlendOperand blend_operand_a)
 */
static PyObject *Dtool_EggGroup_set_blend_operand_a_477(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_blend_operand_a")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_blend_operand_a(EggGroup::BlendOperand blend_operand_a)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_blend_operand_a((EggGroup::BlendOperand)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_operand_a(const EggGroup self, int blend_operand_a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_blend_operand_a_477_comment =
  "C++ Interface:\n"
  "set_blend_operand_a(const EggGroup self, int blend_operand_a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_blend_operand_a_477_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::BlendOperand EggGroup::get_blend_operand_a(void) const
 */
static PyObject *Dtool_EggGroup_get_blend_operand_a_478(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggGroup::BlendOperand EggGroup::get_blend_operand_a(void) const
  EggGroup::BlendOperand return_value = (*(const EggGroup*)local_this).get_blend_operand_a();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_blend_operand_a_478_comment =
  "C++ Interface:\n"
  "get_blend_operand_a(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_blend_operand_a_478_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_blend_operand_b(EggGroup::BlendOperand blend_operand_b)
 */
static PyObject *Dtool_EggGroup_set_blend_operand_b_479(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_blend_operand_b")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_blend_operand_b(EggGroup::BlendOperand blend_operand_b)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_blend_operand_b((EggGroup::BlendOperand)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_operand_b(const EggGroup self, int blend_operand_b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_blend_operand_b_479_comment =
  "C++ Interface:\n"
  "set_blend_operand_b(const EggGroup self, int blend_operand_b)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_blend_operand_b_479_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::BlendOperand EggGroup::get_blend_operand_b(void) const
 */
static PyObject *Dtool_EggGroup_get_blend_operand_b_480(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggGroup::BlendOperand EggGroup::get_blend_operand_b(void) const
  EggGroup::BlendOperand return_value = (*(const EggGroup*)local_this).get_blend_operand_b();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_blend_operand_b_480_comment =
  "C++ Interface:\n"
  "get_blend_operand_b(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_blend_operand_b_480_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_blend_color(LColor const &blend_color)
 */
static PyObject *Dtool_EggGroup_set_blend_color_481(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_blend_color")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_blend_color(LColor const &blend_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_blend_color", "LVecBase4f");
  }
  (*local_this).set_blend_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_color(const EggGroup self, const LVecBase4f blend_color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_blend_color_481_comment =
  "C++ Interface:\n"
  "set_blend_color(const EggGroup self, const LVecBase4f blend_color)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_blend_color_481_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_blend_color(void)
 */
static PyObject *Dtool_EggGroup_clear_blend_color_482(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_blend_color")) {
    return NULL;
  }
  // 1-inline void EggGroup::clear_blend_color(void)
  (*local_this).clear_blend_color();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_blend_color_482_comment =
  "C++ Interface:\n"
  "clear_blend_color(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Removes the blend color specification.\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_blend_color_482_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_blend_color(void) const
 */
static PyObject *Dtool_EggGroup_has_blend_color_483(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::has_blend_color(void) const
  bool return_value = (*(const EggGroup*)local_this).has_blend_color();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_blend_color_483_comment =
  "C++ Interface:\n"
  "has_blend_color(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns true if the blend color has been specified, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_has_blend_color_483_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &EggGroup::get_blend_color(void) const
 */
static PyObject *Dtool_EggGroup_get_blend_color_484(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &EggGroup::get_blend_color(void) const
  LColor const *return_value = &((*(const EggGroup*)local_this).get_blend_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_blend_color_484_comment =
  "C++ Interface:\n"
  "get_blend_color(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns the blend color if one has been specified, or (0, 0, 0, 0) if one\n"
  " * has not.\n"
  " */";
#else
static const char *Dtool_EggGroup_get_blend_color_484_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_lod(EggSwitchCondition const &lod)
 */
static PyObject *Dtool_EggGroup_set_lod_485(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_lod")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_lod(EggSwitchCondition const &lod)
  EggSwitchCondition const *arg_this = (EggSwitchCondition *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggSwitchCondition, 1, "EggGroup.set_lod", true, true);
  if (arg_this != NULL) {
    (*local_this).set_lod(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod(const EggGroup self, const EggSwitchCondition lod)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_lod_485_comment =
  "C++ Interface:\n"
  "set_lod(const EggGroup self, const EggSwitchCondition lod)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_lod_485_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_lod(void)
 */
static PyObject *Dtool_EggGroup_clear_lod_486(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_lod")) {
    return NULL;
  }
  // 1-inline void EggGroup::clear_lod(void)
  (*local_this).clear_lod();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_lod_486_comment =
  "C++ Interface:\n"
  "clear_lod(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_lod_486_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_lod(void) const
 */
static PyObject *Dtool_EggGroup_has_lod_487(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::has_lod(void) const
  bool return_value = (*(const EggGroup*)local_this).has_lod();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_lod_487_comment =
  "C++ Interface:\n"
  "has_lod(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_lod_487_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggSwitchCondition const &EggGroup::get_lod(void) const
 */
static PyObject *Dtool_EggGroup_get_lod_488(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggSwitchCondition const &EggGroup::get_lod(void) const
  EggSwitchCondition const *return_value = &((*(const EggGroup*)local_this).get_lod());
  if (return_value != (EggSwitchCondition const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggSwitchCondition const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggSwitchCondition, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_lod_488_comment =
  "C++ Interface:\n"
  "get_lod(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_lod_488_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_tag(std::string const &key, std::string const &value)
 */
static PyObject *Dtool_EggGroup_set_tag_489(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_tag")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_tag(std::string const &key, std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"key", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:set_tag", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    (*local_this).set_tag(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tag(const EggGroup self, str key, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_tag_489_comment =
  "C++ Interface:\n"
  "set_tag(const EggGroup self, str key, str value)\n"
  "\n"
  "/**\n"
  " * Associates a user-defined value with a user-defined key which is stored on\n"
  " * the node.  This value has no meaning to Panda; but it is stored\n"
  " * indefinitely on the node until it is requested again.  This value will be\n"
  " * copied to the PandaNode that is created for this particular EggGroup if the\n"
  " * egg file is loaded as a scene.\n"
  " *\n"
  " * Each unique key stores a different string value.  There is no effective\n"
  " * limit on the number of different keys that may be stored or on the length\n"
  " * of any one key's value.\n"
  " */";
#else
static const char *Dtool_EggGroup_set_tag_489_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string EggGroup::get_tag(std::string const &key) const
 */
static PyObject *Dtool_EggGroup_get_tag_490(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string EggGroup::get_tag(std::string const &key) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    std::string return_value = (*(const EggGroup*)local_this).get_tag(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tag(EggGroup self, str key)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_tag_490_comment =
  "C++ Interface:\n"
  "get_tag(EggGroup self, str key)\n"
  "\n"
  "/**\n"
  " * Retrieves the user-defined value that was previously set on this node for\n"
  " * the particular key, if any.  If no value has been previously set, returns\n"
  " * the empty string.\n"
  " */";
#else
static const char *Dtool_EggGroup_get_tag_490_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_tag(std::string const &key) const
 */
static PyObject *Dtool_EggGroup_has_tag_491(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggGroup::has_tag(std::string const &key) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const EggGroup*)local_this).has_tag(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_tag(EggGroup self, str key)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_tag_491_comment =
  "C++ Interface:\n"
  "has_tag(EggGroup self, str key)\n"
  "\n"
  "/**\n"
  " * Returns true if a value has been defined on this node for the particular\n"
  " * key (even if that value is the empty string), or false if no value has been\n"
  " * set.\n"
  " */";
#else
static const char *Dtool_EggGroup_has_tag_491_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_tag(std::string const &key)
 */
static PyObject *Dtool_EggGroup_clear_tag_492(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_tag")) {
    return NULL;
  }
  // 1-inline void EggGroup::clear_tag(std::string const &key)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).clear_tag(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_tag(const EggGroup self, str key)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_tag_492_comment =
  "C++ Interface:\n"
  "clear_tag(const EggGroup self, str key)\n"
  "\n"
  "/**\n"
  " * Removes the value defined for this key on this particular node.  After a\n"
  " * call to clear_tag(), has_tag() will return false for the indicated key.\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_tag_492_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTransform const &EggGroup::get_default_pose(void) const
 */
static PyObject *Dtool_EggGroup_get_default_pose_493(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTransform const &EggGroup::get_default_pose(void) const
  EggTransform const *return_value = &((*(const EggGroup*)local_this).get_default_pose());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_default_pose_493_comment =
  "C++ Interface:\n"
  "get_default_pose(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns a read-only accessor to the initial pose transform.  This is the\n"
  " * <DefaultPose> entry for a Joint, and defines only the initial transform\n"
  " * pose for the unanimated joint; it has nothing to do with the group's\n"
  " * <Transform> entry, which defines the (eventual) space of the group's\n"
  " * vertices.\n"
  " */";
#else
static const char *Dtool_EggGroup_get_default_pose_493_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTransform &EggGroup::modify_default_pose(void)
 */
static PyObject *Dtool_EggGroup_modify_default_pose_494(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.modify_default_pose")) {
    return NULL;
  }
  // 1-inline EggTransform &EggGroup::modify_default_pose(void)
  EggTransform *return_value = &((*local_this).modify_default_pose());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_modify_default_pose_494_comment =
  "C++ Interface:\n"
  "modify_default_pose(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns a writable accessor to the initial pose transform.  This is the\n"
  " * <DefaultPose> entry for a Joint, and defines only the initial transform\n"
  " * pose for the unanimated joint; it has nothing to do with the group's\n"
  " * <Transform> entry, which defines the (eventual) space of the group's\n"
  " * vertices.\n"
  " */";
#else
static const char *Dtool_EggGroup_modify_default_pose_494_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_default_pose(EggTransform const &transform)
 */
static PyObject *Dtool_EggGroup_set_default_pose_495(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_default_pose")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_default_pose(EggTransform const &transform)
  EggTransform const *arg_this = (EggTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTransform, 1, "EggGroup.set_default_pose", true, true);
  if (arg_this != NULL) {
    (*local_this).set_default_pose(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_pose(const EggGroup self, const EggTransform transform)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_default_pose_495_comment =
  "C++ Interface:\n"
  "set_default_pose(const EggGroup self, const EggTransform transform)\n"
  "\n"
  "/**\n"
  " * Replaces the initial pose transform.  This is the <DefaultPose> entry for a\n"
  " * Joint, and defines only the initial transform pose for the unanimated\n"
  " * joint; it has nothing to do with the group's <Transform> entry, which\n"
  " * defines the (eventual) space of the group's vertices.\n"
  " */";
#else
static const char *Dtool_EggGroup_set_default_pose_495_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_default_pose(void)
 */
static PyObject *Dtool_EggGroup_clear_default_pose_496(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_default_pose")) {
    return NULL;
  }
  // 1-inline void EggGroup::clear_default_pose(void)
  (*local_this).clear_default_pose();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_default_pose_496_comment =
  "C++ Interface:\n"
  "clear_default_pose(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Removes the initial pose transform.  See set_default_pose().\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_default_pose_496_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_scroll_u(double const u_speed)
 */
static PyObject *Dtool_EggGroup_set_scroll_u_497(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_scroll_u")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_scroll_u(double const u_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_scroll_u(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scroll_u(const EggGroup self, double u_speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_scroll_u_497_comment =
  "C++ Interface:\n"
  "set_scroll_u(const EggGroup self, double u_speed)\n";
#else
static const char *Dtool_EggGroup_set_scroll_u_497_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_scroll_v(double const v_speed)
 */
static PyObject *Dtool_EggGroup_set_scroll_v_498(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_scroll_v")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_scroll_v(double const v_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_scroll_v(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scroll_v(const EggGroup self, double v_speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_scroll_v_498_comment =
  "C++ Interface:\n"
  "set_scroll_v(const EggGroup self, double v_speed)\n";
#else
static const char *Dtool_EggGroup_set_scroll_v_498_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_scroll_w(double const w_speed)
 */
static PyObject *Dtool_EggGroup_set_scroll_w_499(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_scroll_w")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_scroll_w(double const w_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_scroll_w(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scroll_w(const EggGroup self, double w_speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_scroll_w_499_comment =
  "C++ Interface:\n"
  "set_scroll_w(const EggGroup self, double w_speed)\n";
#else
static const char *Dtool_EggGroup_set_scroll_w_499_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_scroll_r(double const r_speed)
 */
static PyObject *Dtool_EggGroup_set_scroll_r_500(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_scroll_r")) {
    return NULL;
  }
  // 1-inline void EggGroup::set_scroll_r(double const r_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_scroll_r(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scroll_r(const EggGroup self, double r_speed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_scroll_r_500_comment =
  "C++ Interface:\n"
  "set_scroll_r(const EggGroup self, double r_speed)\n";
#else
static const char *Dtool_EggGroup_set_scroll_r_500_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggGroup::get_scroll_u(void) const
 */
static PyObject *Dtool_EggGroup_get_scroll_u_501(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggGroup::get_scroll_u(void) const
  double return_value = (*(const EggGroup*)local_this).get_scroll_u();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_scroll_u_501_comment =
  "C++ Interface:\n"
  "get_scroll_u(EggGroup self)\n";
#else
static const char *Dtool_EggGroup_get_scroll_u_501_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggGroup::get_scroll_v(void) const
 */
static PyObject *Dtool_EggGroup_get_scroll_v_502(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggGroup::get_scroll_v(void) const
  double return_value = (*(const EggGroup*)local_this).get_scroll_v();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_scroll_v_502_comment =
  "C++ Interface:\n"
  "get_scroll_v(EggGroup self)\n";
#else
static const char *Dtool_EggGroup_get_scroll_v_502_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggGroup::get_scroll_w(void) const
 */
static PyObject *Dtool_EggGroup_get_scroll_w_503(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggGroup::get_scroll_w(void) const
  double return_value = (*(const EggGroup*)local_this).get_scroll_w();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_scroll_w_503_comment =
  "C++ Interface:\n"
  "get_scroll_w(EggGroup self)\n";
#else
static const char *Dtool_EggGroup_get_scroll_w_503_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggGroup::get_scroll_r(void) const
 */
static PyObject *Dtool_EggGroup_get_scroll_r_504(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggGroup::get_scroll_r(void) const
  double return_value = (*(const EggGroup*)local_this).get_scroll_r();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_scroll_r_504_comment =
  "C++ Interface:\n"
  "get_scroll_r(EggGroup self)\n";
#else
static const char *Dtool_EggGroup_get_scroll_r_504_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_scrolling_uvs(void)
 */
static PyObject *Dtool_EggGroup_has_scrolling_uvs_505(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.has_scrolling_uvs")) {
    return NULL;
  }
  // 1-inline bool EggGroup::has_scrolling_uvs(void)
  bool return_value = (*local_this).has_scrolling_uvs();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_scrolling_uvs_505_comment =
  "C++ Interface:\n"
  "has_scrolling_uvs(const EggGroup self)\n";
#else
static const char *Dtool_EggGroup_has_scrolling_uvs_505_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::ref_vertex(EggVertex *vert, double membership = 1.0)
 */
static PyObject *Dtool_EggGroup_ref_vertex_554(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.ref_vertex")) {
    return NULL;
  }
  // 1-void EggGroup::ref_vertex(EggVertex *vert, double membership = 1.0)
  PyObject *param1;
  double param2 = 1.0;
  static const char *keyword_list[] = {"vert", "membership", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:ref_vertex", (char **)keyword_list, &param1, &param2)) {
    EggVertex *param1_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggVertex, 1, "EggGroup.ref_vertex", false, true);
    if (param1_this != NULL) {
      (*local_this).ref_vertex(param1_this, (double)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ref_vertex(const EggGroup self, EggVertex vert, double membership)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_ref_vertex_554_comment =
  "C++ Interface:\n"
  "ref_vertex(const EggGroup self, EggVertex vert, double membership)\n"
  "\n"
  "/**\n"
  " * Adds the vertex to the set of those referenced by the group, at the\n"
  " * indicated membership level.  If the vertex is already being referenced,\n"
  " * increases the membership amount by the indicated amount.\n"
  " */";
#else
static const char *Dtool_EggGroup_ref_vertex_554_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::unref_vertex(EggVertex *vert)
 */
static PyObject *Dtool_EggGroup_unref_vertex_555(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.unref_vertex")) {
    return NULL;
  }
  // 1-void EggGroup::unref_vertex(EggVertex *vert)
  EggVertex *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggGroup.unref_vertex", false, true);
  if (arg_this != NULL) {
    (*local_this).unref_vertex(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unref_vertex(const EggGroup self, EggVertex vert)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_unref_vertex_555_comment =
  "C++ Interface:\n"
  "unref_vertex(const EggGroup self, EggVertex vert)\n"
  "\n"
  "/**\n"
  " * Removes the vertex from the set of those referenced by the group.  Does\n"
  " * nothing if the vertex is not already reffed.\n"
  " */";
#else
static const char *Dtool_EggGroup_unref_vertex_555_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::unref_all_vertices(void)
 */
static PyObject *Dtool_EggGroup_unref_all_vertices_556(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.unref_all_vertices")) {
    return NULL;
  }
  // 1-void EggGroup::unref_all_vertices(void)
  (*local_this).unref_all_vertices();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_unref_all_vertices_556_comment =
  "C++ Interface:\n"
  "unref_all_vertices(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Removes all vertices from the reference list.\n"
  " */";
#else
static const char *Dtool_EggGroup_unref_all_vertices_556_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double EggGroup::get_vertex_membership(EggVertex const *vert) const
 */
static PyObject *Dtool_EggGroup_get_vertex_membership_557(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-double EggGroup::get_vertex_membership(EggVertex const *vert) const
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggGroup.get_vertex_membership", true, true);
  if (arg_this != NULL) {
    double return_value = (*(const EggGroup*)local_this).get_vertex_membership(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex_membership(EggGroup self, const EggVertex vert)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_vertex_membership_557_comment =
  "C++ Interface:\n"
  "get_vertex_membership(EggGroup self, const EggVertex vert)\n"
  "\n"
  "/**\n"
  " * Returns the amount of membership of the indicated vertex in this group.  If\n"
  " * the vertex is not reffed by the group, returns 0.\n"
  " */";
#else
static const char *Dtool_EggGroup_get_vertex_membership_557_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::set_vertex_membership(EggVertex *vert, double membership)
 */
static PyObject *Dtool_EggGroup_set_vertex_membership_558(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_vertex_membership")) {
    return NULL;
  }
  // 1-void EggGroup::set_vertex_membership(EggVertex *vert, double membership)
  PyObject *param1;
  double param2;
  static const char *keyword_list[] = {"vert", "membership", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:set_vertex_membership", (char **)keyword_list, &param1, &param2)) {
    EggVertex *param1_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggVertex, 1, "EggGroup.set_vertex_membership", false, true);
    if (param1_this != NULL) {
      (*local_this).set_vertex_membership(param1_this, (double)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex_membership(const EggGroup self, EggVertex vert, double membership)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_vertex_membership_558_comment =
  "C++ Interface:\n"
  "set_vertex_membership(const EggGroup self, EggVertex vert, double membership)\n"
  "\n"
  "/**\n"
  " * Explicitly sets the net membership of the indicated vertex in this group to\n"
  " * the given value.\n"
  " */";
#else
static const char *Dtool_EggGroup_set_vertex_membership_558_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::steal_vrefs(EggGroup *other)
 */
static PyObject *Dtool_EggGroup_steal_vrefs_559(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.steal_vrefs")) {
    return NULL;
  }
  // 1-void EggGroup::steal_vrefs(EggGroup *other)
  PT(EggGroup) arg_this;
  if (!Dtool_Coerce_EggGroup(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.steal_vrefs", "EggGroup");
  }
  (*local_this).steal_vrefs(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "steal_vrefs(const EggGroup self, EggGroup other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_steal_vrefs_559_comment =
  "C++ Interface:\n"
  "steal_vrefs(const EggGroup self, EggGroup other)\n"
  "\n"
  "/**\n"
  " * Moves all of the vertex references from the indicated other group into this\n"
  " * one.  If a given vertex was previously shared by both groups, the relative\n"
  " * memberships will be summed.\n"
  " */";
#else
static const char *Dtool_EggGroup_steal_vrefs_559_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::test_vref_integrity(void) const
 */
static PyObject *Dtool_EggGroup_test_vref_integrity_560(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggGroup::test_vref_integrity(void) const
  (*(const EggGroup*)local_this).test_vref_integrity();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_test_vref_integrity_560_comment =
  "C++ Interface:\n"
  "test_vref_integrity(EggGroup self)\n";
#else
static const char *Dtool_EggGroup_test_vref_integrity_560_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::add_group_ref(EggGroup *group)
 */
static PyObject *Dtool_EggGroup_add_group_ref_561(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.add_group_ref")) {
    return NULL;
  }
  // 1-void EggGroup::add_group_ref(EggGroup *group)
  PT(EggGroup) arg_this;
  if (!Dtool_Coerce_EggGroup(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.add_group_ref", "EggGroup");
  }
  (*local_this).add_group_ref(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_group_ref(const EggGroup self, EggGroup group)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_add_group_ref_561_comment =
  "C++ Interface:\n"
  "add_group_ref(const EggGroup self, EggGroup group)\n"
  "\n"
  "/**\n"
  " * Adds a new <Ref> entry to the group.  This declares an internal reference\n"
  " * to another node, and is used to implement scene-graph instancing; it is\n"
  " * only valid if the group_type is GT_instance.\n"
  " */";
#else
static const char *Dtool_EggGroup_add_group_ref_561_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggGroup::get_num_group_refs(void) const
 */
static PyObject *Dtool_EggGroup_get_num_group_refs_562(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggGroup::get_num_group_refs(void) const
  int return_value = (*(const EggGroup*)local_this).get_num_group_refs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_num_group_refs_562_comment =
  "C++ Interface:\n"
  "get_num_group_refs(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns the number of <Ref> entries within this group.  See\n"
  " * add_group_ref().\n"
  " */";
#else
static const char *Dtool_EggGroup_get_num_group_refs_562_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggGroup *EggGroup::get_group_ref(int n) const
 */
static PyObject *Dtool_EggGroup_get_group_ref_563(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  // 1-EggGroup *EggGroup::get_group_ref(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggGroup *return_value = (*(const EggGroup*)local_this).get_group_ref((int)arg_val);
    if (return_value != (EggGroup *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggGroup *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_group_ref(EggGroup self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_group_ref_563_comment =
  "C++ Interface:\n"
  "get_group_ref(EggGroup self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth <Ref> entry within this group.  See add_group_ref().\n"
  " */";
#else
static const char *Dtool_EggGroup_get_group_ref_563_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::remove_group_ref(int n)
 */
static PyObject *Dtool_EggGroup_remove_group_ref_565(PyObject *self, PyObject *arg) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.remove_group_ref")) {
    return NULL;
  }
  // 1-void EggGroup::remove_group_ref(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).remove_group_ref((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_group_ref(const EggGroup self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_remove_group_ref_565_comment =
  "C++ Interface:\n"
  "remove_group_ref(const EggGroup self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the nth <Ref> entry within this group.  See add_group_ref().\n"
  " */";
#else
static const char *Dtool_EggGroup_remove_group_ref_565_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::clear_group_refs(void)
 */
static PyObject *Dtool_EggGroup_clear_group_refs_566(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_group_refs")) {
    return NULL;
  }
  // 1-void EggGroup::clear_group_refs(void)
  (*local_this).clear_group_refs();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_group_refs_566_comment =
  "C++ Interface:\n"
  "clear_group_refs(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Removes all of the <Ref> entries within this group.  See add_group_ref().\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_group_refs_566_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::GroupType EggGroup::string_group_type(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_group_type_567(PyObject *, PyObject *arg) {
  // 1-static EggGroup::GroupType EggGroup::string_group_type(std::string const &strval)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggGroup::GroupType return_value = EggGroup::string_group_type(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_group_type(str strval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_group_type_567_comment =
  "C++ Interface:\n"
  "string_group_type(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the GroupType value associated with the given string\n"
  " * representation, or GT_invalid if the string does not match any known\n"
  " * GroupType value.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_group_type_567_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::DartType EggGroup::string_dart_type(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_dart_type_568(PyObject *, PyObject *arg) {
  // 1-static EggGroup::DartType EggGroup::string_dart_type(std::string const &strval)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggGroup::DartType return_value = EggGroup::string_dart_type(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_dart_type(str strval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_dart_type_568_comment =
  "C++ Interface:\n"
  "string_dart_type(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the DartType value associated with the given string representation,\n"
  " * or DT_none if the string does not match any known DartType value.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_dart_type_568_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::DCSType EggGroup::string_dcs_type(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_dcs_type_569(PyObject *, PyObject *arg) {
  // 1-static EggGroup::DCSType EggGroup::string_dcs_type(std::string const &strval)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggGroup::DCSType return_value = EggGroup::string_dcs_type(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_dcs_type(str strval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_dcs_type_569_comment =
  "C++ Interface:\n"
  "string_dcs_type(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the DCSType value associated with the given string representation,\n"
  " * or DC_unspecified if the string does not match any known DCSType value.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_dcs_type_569_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::BillboardType EggGroup::string_billboard_type(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_billboard_type_570(PyObject *, PyObject *arg) {
  // 1-static EggGroup::BillboardType EggGroup::string_billboard_type(std::string const &strval)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggGroup::BillboardType return_value = EggGroup::string_billboard_type(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_billboard_type(str strval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_billboard_type_570_comment =
  "C++ Interface:\n"
  "string_billboard_type(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the BillboardType value associated with the given string\n"
  " * representation, or BT_none if the string does not match any known\n"
  " * BillboardType value.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_billboard_type_570_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::CollisionSolidType EggGroup::string_cs_type(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_cs_type_571(PyObject *, PyObject *arg) {
  // 1-static EggGroup::CollisionSolidType EggGroup::string_cs_type(std::string const &strval)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggGroup::CollisionSolidType return_value = EggGroup::string_cs_type(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_cs_type(str strval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_cs_type_571_comment =
  "C++ Interface:\n"
  "string_cs_type(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the CollisionSolidType value associated with the given string\n"
  " * representation, or CST_none if the string does not match any known\n"
  " * CollisionSolidType value.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_cs_type_571_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::CollideFlags EggGroup::string_collide_flags(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_collide_flags_572(PyObject *, PyObject *arg) {
  // 1-static EggGroup::CollideFlags EggGroup::string_collide_flags(std::string const &strval)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggGroup::CollideFlags return_value = EggGroup::string_collide_flags(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_collide_flags(str strval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_collide_flags_572_comment =
  "C++ Interface:\n"
  "string_collide_flags(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the CollideFlags value associated with the given string\n"
  " * representation, or CF_none if the string does not match any known\n"
  " * CollideFlags value.  This only recognizes a single keyword; it does not\n"
  " * attempt to parse a string of keywords.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_collide_flags_572_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::BlendMode EggGroup::string_blend_mode(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_blend_mode_573(PyObject *, PyObject *arg) {
  // 1-static EggGroup::BlendMode EggGroup::string_blend_mode(std::string const &strval)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggGroup::BlendMode return_value = EggGroup::string_blend_mode(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_blend_mode(str strval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_blend_mode_573_comment =
  "C++ Interface:\n"
  "string_blend_mode(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the BlendMode value associated with the given string\n"
  " * representation, or BM_none if the string does not match any known\n"
  " * BlendMode.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_blend_mode_573_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::BlendOperand EggGroup::string_blend_operand(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_blend_operand_574(PyObject *, PyObject *arg) {
  // 1-static EggGroup::BlendOperand EggGroup::string_blend_operand(std::string const &strval)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggGroup::BlendOperand return_value = EggGroup::string_blend_operand(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_blend_operand(str strval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_blend_operand_574_comment =
  "C++ Interface:\n"
  "string_blend_operand(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the BlendOperand value associated with the given string\n"
  " * representation, or BO_none if the string does not match any known\n"
  " * BlendOperand.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_blend_operand_574_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggGroup::get_class_type(void)
 */
static PyObject *Dtool_EggGroup_get_class_type_575(PyObject *, PyObject *) {
  // 1-static TypeHandle EggGroup::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggGroup::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_class_type_575_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggGroup_get_class_type_575_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggGroupNode *EggGroup::upcast_to_EggGroupNode(void)
 */
static PyObject *Dtool_EggGroup_upcast_to_EggGroupNode_370(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.upcast_to_EggGroupNode")) {
    return NULL;
  }
  // 1-EggGroupNode *EggGroup::upcast_to_EggGroupNode(void)
  EggGroupNode *return_value = (EggGroupNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroupNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_upcast_to_EggGroupNode_370_comment =
  "C++ Interface:\n"
  "upcast_to_EggGroupNode(const EggGroup self)\n"
  "\n"
  "upcast from EggGroup to EggGroupNode";
#else
static const char *Dtool_EggGroup_upcast_to_EggGroupNode_370_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggRenderMode *EggGroup::upcast_to_EggRenderMode(void)
 */
static PyObject *Dtool_EggGroup_upcast_to_EggRenderMode_372(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.upcast_to_EggRenderMode")) {
    return NULL;
  }
  // 1-EggRenderMode *EggGroup::upcast_to_EggRenderMode(void)
  EggRenderMode *return_value = (EggRenderMode *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_upcast_to_EggRenderMode_372_comment =
  "C++ Interface:\n"
  "upcast_to_EggRenderMode(const EggGroup self)\n"
  "\n"
  "upcast from EggGroup to EggRenderMode";
#else
static const char *Dtool_EggGroup_upcast_to_EggRenderMode_372_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggTransform *EggGroup::upcast_to_EggTransform(void)
 */
static PyObject *Dtool_EggGroup_upcast_to_EggTransform_374(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.upcast_to_EggTransform")) {
    return NULL;
  }
  // 1-EggTransform *EggGroup::upcast_to_EggTransform(void)
  EggTransform *return_value = (EggTransform *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_upcast_to_EggTransform_374_comment =
  "C++ Interface:\n"
  "upcast_to_EggTransform(const EggGroup self)\n"
  "\n"
  "upcast from EggGroup to EggTransform";
#else
static const char *Dtool_EggGroup_upcast_to_EggTransform_374_comment = NULL;
#endif

static PyObject *Dtool_EggGroup_group_type_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggGroup::GroupType EggGroup::get_group_type(void) const
  EggGroup::GroupType return_value = (*(const EggGroup*)local_this).get_group_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_group_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.group_type")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete group_type attribute");
    return -1;
  }
  // 1-void EggGroup::set_group_type(EggGroup::GroupType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_group_type((EggGroup::GroupType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_group_type(const EggGroup self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_billboard_type_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggGroup::BillboardType EggGroup::get_billboard_type(void) const
  EggGroup::BillboardType return_value = (*(const EggGroup*)local_this).get_billboard_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_billboard_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.billboard_type")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete billboard_type attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_billboard_type(EggGroup::BillboardType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_billboard_type((EggGroup::BillboardType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_billboard_type(const EggGroup self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_billboard_center_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_billboard_center()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LPoint3d const &EggGroup::get_billboard_center(void) const
  LPoint3d const *return_value = &((*(const EggGroup*)local_this).get_billboard_center());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
}

static int Dtool_EggGroup_billboard_center_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.billboard_center")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete billboard_center attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_billboard_center();
    return 0;
  }
  // 1-inline void EggGroup::set_billboard_center(LPoint3d const &billboard_center)
  LPoint3d arg_local;
  LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_billboard_center", "LPoint3d");
    return -1;
  }
  (*local_this).set_billboard_center(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_billboard_center(const EggGroup self, const LPoint3d billboard_center)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_cs_type_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggGroup::CollisionSolidType EggGroup::get_cs_type(void) const
  EggGroup::CollisionSolidType return_value = (*(const EggGroup*)local_this).get_cs_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_cs_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.cs_type")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete cs_type attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_cs_type(EggGroup::CollisionSolidType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_cs_type((EggGroup::CollisionSolidType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cs_type(const EggGroup self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_collide_flags_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggGroup::CollideFlags EggGroup::get_collide_flags(void) const
  EggGroup::CollideFlags return_value = (*(const EggGroup*)local_this).get_collide_flags();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_collide_flags_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.collide_flags")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete collide_flags attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_collide_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_collide_flags((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_collide_flags(const EggGroup self, int flags)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_collision_name_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &EggGroup::get_collision_name(void) const
  std::string const &return_value = (*(const EggGroup*)local_this).get_collision_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_collision_name_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.collision_name")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete collision_name attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_collision_name(std::string const &collision_name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_collision_name(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_collision_name(const EggGroup self, str collision_name)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_dcs_type_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggGroup::DCSType EggGroup::get_dcs_type(void) const
  EggGroup::DCSType return_value = (*(const EggGroup*)local_this).get_dcs_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_dcs_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.dcs_type")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete dcs_type attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_dcs_type(EggGroup::DCSType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_dcs_type((EggGroup::DCSType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dcs_type(const EggGroup self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_dart_type_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggGroup::DartType EggGroup::get_dart_type(void) const
  EggGroup::DartType return_value = (*(const EggGroup*)local_this).get_dart_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_dart_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.dart_type")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete dart_type attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_dart_type(EggGroup::DartType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_dart_type((EggGroup::DartType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dart_type(const EggGroup self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_switch_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggGroup::get_switch_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_switch_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_switch_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.switch_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete switch_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_switch_flag(bool flag)
  (*local_this).set_switch_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_switch_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_switch_fps_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double EggGroup::get_switch_fps(void) const
  double return_value = (*(const EggGroup*)local_this).get_switch_fps();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_switch_fps_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.switch_fps")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete switch_fps attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_switch_fps(double fps)
  if (PyNumber_Check(arg)) {
    (*local_this).set_switch_fps(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_switch_fps(const EggGroup self, double fps)\n");
  }
  return -1;
}

/**
 * sequence length function for property EggGroup::object_types
 */
static Py_ssize_t Dtool_EggGroup_object_types_Len(PyObject *self) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_object_types();
}

/**
 * sequence getter for property EggGroup::object_types
 */
static PyObject *Dtool_EggGroup_object_types_Getitem(PyObject *self, Py_ssize_t index) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_object_types()) {
    PyErr_SetString(PyExc_IndexError, "EggGroup.object_types[] index out of range");
    return NULL;
  }
  // 1-inline std::string EggGroup::get_object_type(int index) const
  std::string return_value = (*(const EggGroup*)local_this).get_object_type(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_object_type(EggGroup self, index)\n");
  }
}

static PyObject *Dtool_EggGroup_object_types_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_EggGroup_object_types_Len;
  wrap->_getitem_func = &Dtool_EggGroup_object_types_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static PyObject *Dtool_EggGroup_model_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggGroup::get_model_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_model_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_model_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.model_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete model_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_model_flag(bool flag)
  (*local_this).set_model_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_model_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_texlist_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggGroup::get_texlist_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_texlist_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_texlist_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.texlist_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete texlist_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_texlist_flag(bool flag)
  (*local_this).set_texlist_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texlist_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_nofog_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggGroup::get_nofog_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_nofog_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_nofog_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.nofog_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete nofog_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_nofog_flag(bool flag)
  (*local_this).set_nofog_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_nofog_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_decal_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggGroup::get_decal_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_decal_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_decal_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.decal_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete decal_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_decal_flag(bool flag)
  (*local_this).set_decal_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_decal_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_direct_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggGroup::get_direct_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_direct_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_direct_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.direct_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete direct_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_direct_flag(bool flag)
  (*local_this).set_direct_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_direct_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_portal_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggGroup::get_portal_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_portal_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_portal_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.portal_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete portal_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_portal_flag(bool flag)
  (*local_this).set_portal_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_portal_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_occluder_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggGroup::get_occluder_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_occluder_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_occluder_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.occluder_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete occluder_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_occluder_flag(bool flag)
  (*local_this).set_occluder_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_occluder_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_indexed_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_indexed_flag()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool EggGroup::get_indexed_flag(void) const
  bool return_value = (*(const EggGroup*)local_this).get_indexed_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_indexed_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.indexed_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete indexed_flag attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_indexed_flag();
    return 0;
  }
  // 1-inline void EggGroup::set_indexed_flag(bool flag)
  (*local_this).set_indexed_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_indexed_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_collide_mask_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_collide_mask()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline CollideMask EggGroup::get_collide_mask(void) const
  CollideMask *return_value = new CollideMask((*(const EggGroup*)local_this).get_collide_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_EggGroup_collide_mask_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.collide_mask")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete collide_mask attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_collide_mask();
    return 0;
  }
  // 1-inline void EggGroup::set_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_collide_mask", "BitMask");
    return -1;
  }
  (*local_this).set_collide_mask(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_from_collide_mask_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_from_collide_mask()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline CollideMask EggGroup::get_from_collide_mask(void) const
  CollideMask *return_value = new CollideMask((*(const EggGroup*)local_this).get_from_collide_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_EggGroup_from_collide_mask_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.from_collide_mask")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete from_collide_mask attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_from_collide_mask();
    return 0;
  }
  // 1-inline void EggGroup::set_from_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_from_collide_mask", "BitMask");
    return -1;
  }
  (*local_this).set_from_collide_mask(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_from_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_into_collide_mask_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_into_collide_mask()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline CollideMask EggGroup::get_into_collide_mask(void) const
  CollideMask *return_value = new CollideMask((*(const EggGroup*)local_this).get_into_collide_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_EggGroup_into_collide_mask_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.into_collide_mask")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete into_collide_mask attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_into_collide_mask();
    return 0;
  }
  // 1-inline void EggGroup::set_into_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_into_collide_mask", "BitMask");
    return -1;
  }
  (*local_this).set_into_collide_mask(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_into_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_blend_mode_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggGroup::BlendMode EggGroup::get_blend_mode(void) const
  EggGroup::BlendMode return_value = (*(const EggGroup*)local_this).get_blend_mode();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_blend_mode_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.blend_mode")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete blend_mode attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_blend_mode(EggGroup::BlendMode blend_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_blend_mode((EggGroup::BlendMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blend_mode(const EggGroup self, int blend_mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_blend_operand_a_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggGroup::BlendOperand EggGroup::get_blend_operand_a(void) const
  EggGroup::BlendOperand return_value = (*(const EggGroup*)local_this).get_blend_operand_a();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_blend_operand_a_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.blend_operand_a")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete blend_operand_a attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_blend_operand_a(EggGroup::BlendOperand blend_operand_a)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_blend_operand_a((EggGroup::BlendOperand)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blend_operand_a(const EggGroup self, int blend_operand_a)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_blend_operand_b_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggGroup::BlendOperand EggGroup::get_blend_operand_b(void) const
  EggGroup::BlendOperand return_value = (*(const EggGroup*)local_this).get_blend_operand_b();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_blend_operand_b_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.blend_operand_b")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete blend_operand_b attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_blend_operand_b(EggGroup::BlendOperand blend_operand_b)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_blend_operand_b((EggGroup::BlendOperand)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blend_operand_b(const EggGroup self, int blend_operand_b)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_blend_color_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_blend_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor const &EggGroup::get_blend_color(void) const
  LColor const *return_value = &((*(const EggGroup*)local_this).get_blend_color());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_EggGroup_blend_color_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.blend_color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete blend_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_blend_color();
    return 0;
  }
  // 1-inline void EggGroup::set_blend_color(LColor const &blend_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_blend_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_blend_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blend_color(const EggGroup self, const LVecBase4f blend_color)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_lod_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_lod()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline EggSwitchCondition const &EggGroup::get_lod(void) const
  EggSwitchCondition const *return_value = &((*(const EggGroup*)local_this).get_lod());
  if (return_value != (EggSwitchCondition const *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (EggSwitchCondition const *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggSwitchCondition, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_EggGroup_lod_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.lod")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete lod attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_lod();
    return 0;
  }
  // 1-inline void EggGroup::set_lod(EggSwitchCondition const &lod)
  EggSwitchCondition const *arg_this = (EggSwitchCondition *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggSwitchCondition, 1, "EggGroup.set_lod", true, true);
  if (arg_this != NULL) {
    (*local_this).set_lod(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_lod(const EggGroup self, const EggSwitchCondition lod)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_default_pose_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTransform const &EggGroup::get_default_pose(void) const
  EggTransform const *return_value = &((*(const EggGroup*)local_this).get_default_pose());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, true);
}

static int Dtool_EggGroup_default_pose_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.default_pose")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete default_pose attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_default_pose(EggTransform const &transform)
  EggTransform const *arg_this = (EggTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTransform, 1, "EggGroup.set_default_pose", true, true);
  if (arg_this != NULL) {
    (*local_this).set_default_pose(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_default_pose(const EggGroup self, const EggTransform transform)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_scroll_u_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double EggGroup::get_scroll_u(void) const
  double return_value = (*(const EggGroup*)local_this).get_scroll_u();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_scroll_u_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.scroll_u")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete scroll_u attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_scroll_u(double const u_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_scroll_u(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scroll_u(const EggGroup self, double u_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_scroll_v_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double EggGroup::get_scroll_v(void) const
  double return_value = (*(const EggGroup*)local_this).get_scroll_v();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_scroll_v_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.scroll_v")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete scroll_v attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_scroll_v(double const v_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_scroll_v(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scroll_v(const EggGroup self, double v_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_scroll_w_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double EggGroup::get_scroll_w(void) const
  double return_value = (*(const EggGroup*)local_this).get_scroll_w();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_scroll_w_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.scroll_w")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete scroll_w attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_scroll_w(double const w_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_scroll_w(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scroll_w(const EggGroup self, double w_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_scroll_r_Getter(PyObject *self, void *) {
  const EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double EggGroup::get_scroll_r(void) const
  double return_value = (*(const EggGroup*)local_this).get_scroll_r();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_scroll_r_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.scroll_r")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete scroll_r attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_scroll_r(double const r_speed)
  if (PyNumber_Check(arg)) {
    (*local_this).set_scroll_r(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scroll_r(const EggGroup self, double r_speed)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * EggGroup::EggGroup(EggGroup const &copy)
 * EggGroup::EggGroup(std::string const &name = "")
 */
static int Dtool_Init_EggGroup(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggGroup::EggGroup(std::string const &name)
      EggGroup *return_value = new EggGroup();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroup, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 EggGroup::EggGroup(EggGroup const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggGroup", (char **)keyword_list, &param0)) {
          EggGroup const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggGroup, (void **)&param0_this);
          if (param0_this != NULL) {
            EggGroup *return_value = new EggGroup(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroup, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 EggGroup::EggGroup(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggGroup", (char **)keyword_list, &param0_str, &param0_len)) {
          EggGroup *return_value = new EggGroup(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroup, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 EggGroup::EggGroup(EggGroup const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggGroup", (char **)keyword_list, &param0)) {
          CPT(EggGroup) param0_this;
          if (Dtool_ConstCoerce_EggGroup(param0, param0_this)) {
            EggGroup *return_value = new EggGroup(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroup, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: EggGroup::EggGroup(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggGroup() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggGroup()\n"
      "EggGroup(const EggGroup copy)\n"
      "EggGroup(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggGroup(PyObject *args, CPT(EggGroup) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggGroup, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggGroup::EggGroup(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggGroup *return_value = new EggGroup(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_EggGroup(PyObject *args, PT(EggGroup) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggGroup, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggGroup::EggGroup(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggGroup *return_value = new EggGroup(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggGroup_get_object_types(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_object_types();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggGroup_get_object_type_439(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggGroup_get_group_refs(PyObject *self, PyObject *) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_group_refs();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggGroup_get_group_ref_563(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggGroup) {
    printf("EggGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggGroup *local_this = (EggGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggGroup) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroupNode) {
    return (EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggTransform) {
    return (EggTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggGroup) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    EggGroupNode* other_this = (EggGroupNode*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_EggTransform) {
    EggTransform* other_this = (EggTransform*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggGroup*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggBin
 */
/**
 * Python function wrapper for:
 * void EggBin::set_bin_number(int bin_number)
 */
static PyObject *Dtool_EggBin_set_bin_number_578(PyObject *self, PyObject *arg) {
  EggBin *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBin, (void **)&local_this, "EggBin.set_bin_number")) {
    return NULL;
  }
  // 1-void EggBin::set_bin_number(int bin_number)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_bin_number((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin_number(const EggBin self, int bin_number)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggBin_set_bin_number_578_comment =
  "C++ Interface:\n"
  "set_bin_number(const EggBin self, int bin_number)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggBin_set_bin_number_578_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggBin::get_bin_number(void) const
 */
static PyObject *Dtool_EggBin_get_bin_number_579(PyObject *self, PyObject *) {
  EggBin *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggBin, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggBin::get_bin_number(void) const
  int return_value = (*(const EggBin*)local_this).get_bin_number();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggBin_get_bin_number_579_comment =
  "C++ Interface:\n"
  "get_bin_number(EggBin self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggBin_get_bin_number_579_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggBin::get_class_type(void)
 */
static PyObject *Dtool_EggBin_get_class_type_580(PyObject *, PyObject *) {
  // 1-static TypeHandle EggBin::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggBin::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggBin_get_class_type_580_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggBin_get_class_type_580_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggBin::EggBin(EggBin const &copy)
 * EggBin::EggBin(EggGroup const &copy)
 * EggBin::EggBin(std::string const &name = "")
 */
static int Dtool_Init_EggBin(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggBin::EggBin(std::string const &name)
      EggBin *return_value = new EggBin();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggBin, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 EggBin::EggBin(EggBin const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggBin", (char **)keyword_list, &param0)) {
          EggBin const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggBin, (void **)&param0_this);
          if (param0_this != NULL) {
            EggBin *return_value = new EggBin(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggBin, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 EggBin::EggBin(EggGroup const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggBin", (char **)keyword_list, &param0)) {
          EggGroup const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggGroup, (void **)&param0_this);
          if (param0_this != NULL) {
            EggBin *return_value = new EggBin(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggBin, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 EggBin::EggBin(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggBin", (char **)keyword_list, &param0_str, &param0_len)) {
          EggBin *return_value = new EggBin(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggBin, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 EggBin::EggBin(EggBin const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggBin", (char **)keyword_list, &param0)) {
          CPT(EggBin) param0_this;
          if (Dtool_ConstCoerce_EggBin(param0, param0_this)) {
            EggBin *return_value = new EggBin(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggBin, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 EggBin::EggBin(EggGroup const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggBin", (char **)keyword_list, &param0)) {
          CPT(EggGroup) param0_this;
          if (Dtool_ConstCoerce_EggGroup(param0, param0_this)) {
            EggBin *return_value = new EggBin(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggBin, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: EggBin::EggBin(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggBin() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggBin()\n"
      "EggBin(const EggBin copy)\n"
      "EggBin(const EggGroup copy)\n"
      "EggBin(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggBin(PyObject *args, CPT(EggBin) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggBin, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 EggBin::EggBin(EggGroup const &copy)
      EggGroup const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggGroup, (void **)&arg_this);
      if (arg_this != NULL) {
        EggBin *return_value = new EggBin(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

    {
      // -2 EggBin::EggBin(std::string const &name)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        EggBin *return_value = new EggBin(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }

  }
  return false;
}

bool Dtool_Coerce_EggBin(PyObject *args, PT(EggBin) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggBin, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 EggBin::EggBin(EggGroup const &copy)
      EggGroup const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggGroup, (void **)&arg_this);
      if (arg_this != NULL) {
        EggBin *return_value = new EggBin(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

    {
      // -2 EggBin::EggBin(std::string const &name)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        EggBin *return_value = new EggBin(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }

  }
  return false;
}

static void *Dtool_UpcastInterface_EggBin(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggBin) {
    printf("EggBin ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggBin *local_this = (EggBin *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggBin) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroup) {
    return (EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroupNode) {
    return (EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggTransform) {
    return (EggTransform *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggBin(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggBin) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggGroup) {
    EggGroup* other_this = (EggGroup*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    EggGroupNode* other_this = (EggGroupNode*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggTransform) {
    EggTransform* other_this = (EggTransform*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggBin*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggBinMaker
 */
/**
 * Python function wrapper for:
 * int EggBinMaker::make_bins(EggGroupNode *root_group)
 */
static PyObject *Dtool_EggBinMaker_make_bins_583(PyObject *self, PyObject *arg) {
  EggBinMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.make_bins")) {
    return NULL;
  }
  // 1-int EggBinMaker::make_bins(EggGroupNode *root_group)
  PT(EggGroupNode) arg_this;
  if (!Dtool_Coerce_EggGroupNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggBinMaker.make_bins", "EggGroupNode");
  }
  int return_value = (*local_this).make_bins(MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_bins(const EggBinMaker self, EggGroupNode root_group)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_make_bins_583_comment =
  "C++ Interface:\n"
  "make_bins(const EggBinMaker self, EggGroupNode root_group)\n"
  "\n"
  "/**\n"
  " * The main entry point to EggBinMaker.  Walks the egg scene graph beginning\n"
  " * at the indicated root node, and moves all binnable nodes into EggBin\n"
  " * objects.  Returns the number of EggBins created.\n"
  " */";
#else
static const char *Dtool_EggBinMaker_make_bins_583_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggBinMaker::prepare_node(EggNode *node)
 */
static PyObject *Dtool_EggBinMaker_prepare_node_584(PyObject *self, PyObject *arg) {
  EggBinMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.prepare_node")) {
    return NULL;
  }
  // 1-virtual void EggBinMaker::prepare_node(EggNode *node)
  PT(EggNode) arg_this;
  if (!Dtool_Coerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggBinMaker.prepare_node", "EggNode");
  }
  (*local_this).prepare_node(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_node(const EggBinMaker self, EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_prepare_node_584_comment =
  "C++ Interface:\n"
  "prepare_node(const EggBinMaker self, EggNode node)\n"
  "\n"
  "/**\n"
  " * May be overridden in derived classes to perform some setup work as each\n"
  " * node is encountered.  This will be called once for each node in the egg\n"
  " * hierarchy.\n"
  " */";
#else
static const char *Dtool_EggBinMaker_prepare_node_584_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int EggBinMaker::get_bin_number(EggNode const *node) = 0
 */
static PyObject *Dtool_EggBinMaker_get_bin_number_585(PyObject *self, PyObject *arg) {
  EggBinMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.get_bin_number")) {
    return NULL;
  }
  // 1-virtual int EggBinMaker::get_bin_number(EggNode const *node) = 0
  CPT(EggNode) arg_this;
  if (!Dtool_ConstCoerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggBinMaker.get_bin_number", "EggNode");
  }
  int return_value = (*local_this).get_bin_number(MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bin_number(const EggBinMaker self, const EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_get_bin_number_585_comment =
  "C++ Interface:\n"
  "get_bin_number(const EggBinMaker self, const EggNode node)\n";
#else
static const char *Dtool_EggBinMaker_get_bin_number_585_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggBinMaker::sorts_less(int bin_number, EggNode const *a, EggNode const *b)
 */
static PyObject *Dtool_EggBinMaker_sorts_less_586(PyObject *self, PyObject *args, PyObject *kwds) {
  EggBinMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.sorts_less")) {
    return NULL;
  }
  // 1-virtual bool EggBinMaker::sorts_less(int bin_number, EggNode const *a, EggNode const *b)
  int param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"bin_number", "a", "b", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOO:sorts_less", (char **)keyword_list, &param1, &param2, &param3)) {
    CPT(EggNode) param2_this;
    if (!Dtool_ConstCoerce_EggNode(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggBinMaker.sorts_less", "EggNode");
    }
    CPT(EggNode) param3_this;
    if (!Dtool_ConstCoerce_EggNode(param3, param3_this)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "EggBinMaker.sorts_less", "EggNode");
    }
    bool return_value = (*local_this).sorts_less((int)param1, MOVE(param2_this), MOVE(param3_this));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sorts_less(const EggBinMaker self, int bin_number, const EggNode a, const EggNode b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_sorts_less_586_comment =
  "C++ Interface:\n"
  "sorts_less(const EggBinMaker self, int bin_number, const EggNode a, const EggNode b)\n"
  "\n"
  "/**\n"
  " * May be overridden in derived classes to create additional bins within a\n"
  " * particular bin number, based on some arbitrary property of nodes.  This\n"
  " * function establishes an arbitrary but fixed ordering between nodes; if two\n"
  " * nodes do not sort to the same position, different bins are created for each\n"
  " * one (with the same bin number on each bin).\n"
  " */";
#else
static const char *Dtool_EggBinMaker_sorts_less_586_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggBinMaker::collapse_group(EggGroup const *group, int bin_number)
 */
static PyObject *Dtool_EggBinMaker_collapse_group_587(PyObject *self, PyObject *args, PyObject *kwds) {
  EggBinMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.collapse_group")) {
    return NULL;
  }
  // 1-virtual bool EggBinMaker::collapse_group(EggGroup const *group, int bin_number)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"group", "bin_number", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:collapse_group", (char **)keyword_list, &param1, &param2)) {
    CPT(EggGroup) param1_this;
    if (!Dtool_ConstCoerce_EggGroup(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggBinMaker.collapse_group", "EggGroup");
    }
    bool return_value = (*local_this).collapse_group(MOVE(param1_this), (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collapse_group(const EggBinMaker self, const EggGroup group, int bin_number)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_collapse_group_587_comment =
  "C++ Interface:\n"
  "collapse_group(const EggBinMaker self, const EggGroup group, int bin_number)\n"
  "\n"
  "/**\n"
  " * May be overridden in derived classes to specify whether a particular group\n"
  " * node, apparently redundant, may be safely collapsed out.\n"
  " */";
#else
static const char *Dtool_EggBinMaker_collapse_group_587_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual std::string EggBinMaker::get_bin_name(int bin_number, EggNode const *child)
 */
static PyObject *Dtool_EggBinMaker_get_bin_name_588(PyObject *self, PyObject *args, PyObject *kwds) {
  EggBinMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.get_bin_name")) {
    return NULL;
  }
  // 1-virtual std::string EggBinMaker::get_bin_name(int bin_number, EggNode const *child)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"bin_number", "child", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_bin_name", (char **)keyword_list, &param1, &param2)) {
    CPT(EggNode) param2_this;
    if (!Dtool_ConstCoerce_EggNode(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggBinMaker.get_bin_name", "EggNode");
    }
    std::string return_value = (*local_this).get_bin_name((int)param1, MOVE(param2_this));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bin_name(const EggBinMaker self, int bin_number, const EggNode child)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_get_bin_name_588_comment =
  "C++ Interface:\n"
  "get_bin_name(const EggBinMaker self, int bin_number, const EggNode child)\n"
  "\n"
  "/**\n"
  " * May be overridden in derived classes to define a name for each new bin,\n"
  " * based on its bin number, and a sample child.\n"
  " */";
#else
static const char *Dtool_EggBinMaker_get_bin_name_588_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PointerTo< EggBin > EggBinMaker::make_bin(int bin_number, EggNode const *child, EggGroup *collapse_from)
 */
static PyObject *Dtool_EggBinMaker_make_bin_589(PyObject *self, PyObject *args, PyObject *kwds) {
  EggBinMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.make_bin")) {
    return NULL;
  }
  // 1-virtual PointerTo< EggBin > EggBinMaker::make_bin(int bin_number, EggNode const *child, EggGroup *collapse_from)
  int param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"bin_number", "child", "collapse_from", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOO:make_bin", (char **)keyword_list, &param1, &param2, &param3)) {
    CPT(EggNode) param2_this;
    if (!Dtool_ConstCoerce_EggNode(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggBinMaker.make_bin", "EggNode");
    }
    PT(EggGroup) param3_this;
    if (!Dtool_Coerce_EggGroup(param3, param3_this)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "EggBinMaker.make_bin", "EggGroup");
    }
    PointerTo< EggBin > return_value = (*local_this).make_bin((int)param1, MOVE(param2_this), MOVE(param3_this));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    EggBin *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggBin, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_bin(const EggBinMaker self, int bin_number, const EggNode child, EggGroup collapse_from)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_make_bin_589_comment =
  "C++ Interface:\n"
  "make_bin(const EggBinMaker self, int bin_number, const EggNode child, EggGroup collapse_from)\n"
  "\n"
  "/**\n"
  " * May be overridden in derived classes to construct a new EggBin object (or\n"
  " * some derived class, if needed), and preload some initial data into as\n"
  " * required.\n"
  " *\n"
  " * child is an arbitrary child of the bin, and collapse_from is the group the\n"
  " * bin is being collapsed with, if any (implying collapse_group() returned\n"
  " * true), or NULL if not.\n"
  " */";
#else
static const char *Dtool_EggBinMaker_make_bin_589_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggBinMaker::get_class_type(void)
 */
static PyObject *Dtool_EggBinMaker_get_class_type_590(PyObject *, PyObject *) {
  // 1-static TypeHandle EggBinMaker::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggBinMaker::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_get_class_type_590_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggBinMaker_get_class_type_590_comment = NULL;
#endif

static int Dtool_Init_EggBinMaker(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_EggBinMaker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggBinMaker) {
    printf("EggBinMaker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggBinMaker *local_this = (EggBinMaker *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggBinMaker) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggBinMaker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggBinMaker) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggBinMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggBinMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggBinMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggBinMaker*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggComment
 */
/**
 * Python function wrapper for:
 * inline EggComment &EggComment::operator =(EggComment const &copy)
 * inline EggComment &EggComment::operator =(std::string const &comment)
 */
static PyObject *Dtool_EggComment_operator_593(PyObject *self, PyObject *arg) {
  EggComment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggComment, (void **)&local_this, "EggComment.assign")) {
    return NULL;
  }
  {
    // -2 inline EggComment &EggComment::operator =(EggComment const &copy)
    EggComment const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggComment, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      EggComment *return_value = local_this;
      if (return_value != (EggComment *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (EggComment *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggComment, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline EggComment &EggComment::operator =(std::string const &comment)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (*local_this).operator =(std::string(param1_str, param1_len));
      EggComment *return_value = local_this;
      if (return_value != (EggComment *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (EggComment *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggComment, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline EggComment &EggComment::operator =(EggComment const &copy)
    CPT(EggComment) arg_this;
    if (Dtool_ConstCoerce_EggComment(arg, arg_this)) {
      (*local_this).operator =(*MOVE(arg_this));
      EggComment *return_value = local_this;
      if (return_value != (EggComment *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (EggComment *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggComment, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  // No coercion possible: inline EggComment &EggComment::operator =(std::string const &comment)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggComment self, const EggComment copy)\n"
      "assign(const EggComment self, str comment)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggComment_operator_593_comment =
  "C++ Interface:\n"
  "assign(const EggComment self, const EggComment copy)\n"
  "assign(const EggComment self, str comment)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggComment_operator_593_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggComment::set_comment(std::string const &comment)
 */
static PyObject *Dtool_EggComment_set_comment_595(PyObject *self, PyObject *arg) {
  EggComment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggComment, (void **)&local_this, "EggComment.set_comment")) {
    return NULL;
  }
  // 1-inline void EggComment::set_comment(std::string const &comment)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_comment(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_comment(const EggComment self, str comment)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggComment_set_comment_595_comment =
  "C++ Interface:\n"
  "set_comment(const EggComment self, str comment)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggComment_set_comment_595_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string EggComment::get_comment(void) const
 */
static PyObject *Dtool_EggComment_get_comment_596(PyObject *self, PyObject *) {
  EggComment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggComment, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string EggComment::get_comment(void) const
  std::string return_value = (*(const EggComment*)local_this).get_comment();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggComment_get_comment_596_comment =
  "C++ Interface:\n"
  "get_comment(EggComment self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggComment_get_comment_596_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggComment::get_class_type(void)
 */
static PyObject *Dtool_EggComment_get_class_type_597(PyObject *, PyObject *) {
  // 1-static TypeHandle EggComment::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggComment::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggComment_get_class_type_597_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggComment_get_class_type_597_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggComment::EggComment(EggComment const &copy)
 * inline EggComment::EggComment(std::string const &node_name, std::string const &comment)
 */
static int Dtool_Init_EggComment(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline EggComment::EggComment(EggComment const &copy)
      CPT(EggComment) arg_this;
      if (!Dtool_ConstCoerce_EggComment(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "EggComment.EggComment", "EggComment");
        return -1;
      }
      EggComment *return_value = new EggComment(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggComment, true, false);
    }
    break;
  case 2:
    {
      // 1-inline EggComment::EggComment(std::string const &node_name, std::string const &comment)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"node_name", "comment", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:EggComment", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
        EggComment *return_value = new EggComment(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggComment, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggComment() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggComment(const EggComment copy)\n"
      "EggComment(str node_name, str comment)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggComment(PyObject *args, CPT(EggComment) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggComment, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline EggComment::EggComment(std::string const &node_name, std::string const &comment)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "s#s#:EggComment", &param0_str, &param0_len, &param1_str, &param1_len)) {
        EggComment *return_value = new EggComment(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_EggComment(PyObject *args, PT(EggComment) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggComment, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline EggComment::EggComment(std::string const &node_name, std::string const &comment)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "s#s#:EggComment", &param0_str, &param0_len, &param1_str, &param1_len)) {
        EggComment *return_value = new EggComment(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggComment(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggComment) {
    printf("EggComment ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggComment *local_this = (EggComment *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggComment) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggComment(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggComment) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggComment*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggFilenameNode
 */
/**
 * Python function wrapper for:
 * inline EggFilenameNode &EggFilenameNode::operator =(EggFilenameNode const &copy)
 */
static PyObject *Dtool_EggFilenameNode_operator_600(PyObject *self, PyObject *arg) {
  EggFilenameNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggFilenameNode, (void **)&local_this, "EggFilenameNode.assign")) {
    return NULL;
  }
  // 1-inline EggFilenameNode &EggFilenameNode::operator =(EggFilenameNode const &copy)
  CPT(EggFilenameNode) arg_this;
  if (!Dtool_ConstCoerce_EggFilenameNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggFilenameNode.assign", "EggFilenameNode");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggFilenameNode *return_value = local_this;
  if (return_value != (EggFilenameNode *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggFilenameNode *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggFilenameNode, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggFilenameNode self, const EggFilenameNode copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_operator_600_comment =
  "C++ Interface:\n"
  "assign(const EggFilenameNode self, const EggFilenameNode copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_operator_600_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual std::string EggFilenameNode::get_default_extension(void) const
 */
static PyObject *Dtool_EggFilenameNode_get_default_extension_601(PyObject *self, PyObject *) {
  EggFilenameNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggFilenameNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual std::string EggFilenameNode::get_default_extension(void) const
  std::string return_value = (*(const EggFilenameNode*)local_this).get_default_extension();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_get_default_extension_601_comment =
  "C++ Interface:\n"
  "get_default_extension(EggFilenameNode self)\n"
  "\n"
  "/**\n"
  " * Returns the default extension for this filename type.\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_get_default_extension_601_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &EggFilenameNode::get_filename(void) const
 */
static PyObject *Dtool_EggFilenameNode_get_filename_602(PyObject *self, PyObject *) {
  EggFilenameNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggFilenameNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &EggFilenameNode::get_filename(void) const
  Filename const *return_value = &((*(const EggFilenameNode*)local_this).get_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_get_filename_602_comment =
  "C++ Interface:\n"
  "get_filename(EggFilenameNode self)\n"
  "\n"
  "/**\n"
  " * Returns a nonmodifiable reference to the filename.\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_get_filename_602_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggFilenameNode::set_filename(Filename const &filename)
 */
static PyObject *Dtool_EggFilenameNode_set_filename_603(PyObject *self, PyObject *arg) {
  EggFilenameNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggFilenameNode, (void **)&local_this, "EggFilenameNode.set_filename")) {
    return NULL;
  }
  // 1-inline void EggFilenameNode::set_filename(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggFilenameNode.set_filename", "Filename");
  }
  (*local_this).set_filename(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_filename(const EggFilenameNode self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_set_filename_603_comment =
  "C++ Interface:\n"
  "set_filename(const EggFilenameNode self, const Filename filename)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_set_filename_603_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &EggFilenameNode::get_fullpath(void) const
 */
static PyObject *Dtool_EggFilenameNode_get_fullpath_604(PyObject *self, PyObject *) {
  EggFilenameNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggFilenameNode, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &EggFilenameNode::get_fullpath(void) const
  Filename const *return_value = &((*(const EggFilenameNode*)local_this).get_fullpath());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_get_fullpath_604_comment =
  "C++ Interface:\n"
  "get_fullpath(EggFilenameNode self)\n"
  "\n"
  "/**\n"
  " * Returns the full pathname to the file, if it is known; otherwise, returns\n"
  " * the same thing as get_filename().\n"
  " *\n"
  " * This function simply returns whatever was set by the last call to\n"
  " * set_fullpath().  This string is not written to the egg file; its main\n"
  " * purpose is to record the full path to a filename (for instance, a texture\n"
  " * filename) if it is known, for egg structures that are generated in-memory\n"
  " * and then immediately converted to a scene graph.\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_get_fullpath_604_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggFilenameNode::set_fullpath(Filename const &fullpath)
 */
static PyObject *Dtool_EggFilenameNode_set_fullpath_605(PyObject *self, PyObject *arg) {
  EggFilenameNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggFilenameNode, (void **)&local_this, "EggFilenameNode.set_fullpath")) {
    return NULL;
  }
  // 1-inline void EggFilenameNode::set_fullpath(Filename const &fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggFilenameNode.set_fullpath", "Filename");
  }
  (*local_this).set_fullpath(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fullpath(const EggFilenameNode self, const Filename fullpath)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_set_fullpath_605_comment =
  "C++ Interface:\n"
  "set_fullpath(const EggFilenameNode self, const Filename fullpath)\n"
  "\n"
  "/**\n"
  " * Records the full pathname to the file, for the benefit of get_fullpath().\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_set_fullpath_605_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggFilenameNode::get_class_type(void)
 */
static PyObject *Dtool_EggFilenameNode_get_class_type_606(PyObject *, PyObject *) {
  // 1-static TypeHandle EggFilenameNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggFilenameNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_get_class_type_606_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggFilenameNode_get_class_type_606_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggTexture *EggFilenameNode::downcast_to_EggTexture(void)
 */
static PyObject *Dtool_EggFilenameNode_downcast_to_EggTexture_610(PyObject *self, PyObject *) {
  EggFilenameNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggFilenameNode, (void **)&local_this, "EggFilenameNode.downcast_to_EggTexture")) {
    return NULL;
  }
  // 1-EggTexture *EggFilenameNode::downcast_to_EggTexture(void)
  EggTexture *return_value = (EggTexture *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_downcast_to_EggTexture_610_comment =
  "C++ Interface:\n"
  "downcast_to_EggTexture(const EggFilenameNode self)\n"
  "\n"
  "downcast from EggFilenameNode to EggTexture";
#else
static const char *Dtool_EggFilenameNode_downcast_to_EggTexture_610_comment = NULL;
#endif

static int Dtool_Init_EggFilenameNode(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggFilenameNode(PyObject *args, CPT(EggFilenameNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggFilenameNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggFilenameNode(PyObject *args, PT(EggFilenameNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggFilenameNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggFilenameNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggFilenameNode) {
    printf("EggFilenameNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggFilenameNode *local_this = (EggFilenameNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggFilenameNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggFilenameNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggFilenameNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggFilenameNode*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggTexture
 */
/**
 * Python function wrapper for:
 * EggTexture &EggTexture::operator =(EggTexture const &copy)
 */
static PyObject *Dtool_EggTexture_operator_616(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.assign")) {
    return NULL;
  }
  // 1-EggTexture &EggTexture::operator =(EggTexture const &copy)
  CPT(EggTexture) arg_this;
  if (!Dtool_ConstCoerce_EggTexture(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.assign", "EggTexture");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggTexture *return_value = local_this;
  if (return_value != (EggTexture *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggTexture *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTexture self, const EggTexture copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_operator_616_comment =
  "C++ Interface:\n"
  "assign(const EggTexture self, const EggTexture copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_operator_616_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggTexture::write(ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggTexture_write_618(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void EggTexture::write(ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggTexture.write", false, true);
    if (param1_this != NULL) {
      (*(const EggTexture*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggTexture self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_write_618_comment =
  "C++ Interface:\n"
  "write(EggTexture self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the texture definition to the indicated output stream in Egg format.\n"
  " */";
#else
static const char *Dtool_EggTexture_write_618_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggTexture::is_equivalent_to(EggTexture const &other, int eq) const
 */
static PyObject *Dtool_EggTexture_is_equivalent_to_620(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggTexture::is_equivalent_to(EggTexture const &other, int eq) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"other", "eq", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:is_equivalent_to", (char **)keyword_list, &param1, &param2)) {
    CPT(EggTexture) param1_this;
    if (!Dtool_ConstCoerce_EggTexture(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggTexture.is_equivalent_to", "EggTexture");
    }
    bool return_value = (*(const EggTexture*)local_this).is_equivalent_to(*MOVE(param1_this), (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_equivalent_to(EggTexture self, const EggTexture other, int eq)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_is_equivalent_to_620_comment =
  "C++ Interface:\n"
  "is_equivalent_to(EggTexture self, const EggTexture other, int eq)\n"
  "\n"
  "/**\n"
  " * Returns true if the two textures are equivalent in all relevant properties\n"
  " * (according to eq), false otherwise.\n"
  " *\n"
  " * The Equivalence parameter, eq, should be set to the bitwise OR of the\n"
  " * following properties, according to what you consider relevant:\n"
  " *\n"
  " * EggTexture::E_basename: The basename part of the texture filename, without\n"
  " * the directory prefix *or* the filename extension.\n"
  " *\n"
  " * EggTexture::E_extension: The extension part of the texture filename.\n"
  " *\n"
  " * EggTexture::E_dirname: The directory prefix of the texture filename.\n"
  " *\n"
  " * EggTexture::E_complete_filename: The union of the above three; that is, the\n"
  " * complete filename, with directory, basename, and extension.\n"
  " *\n"
  " * EggTexture::E_transform: The texture matrix.\n"
  " *\n"
  " * EggTexture::E_attributes: All remaining texture attributes (mode, mipmap,\n"
  " * etc.) except TRef name.\n"
  " *\n"
  " * EggTexture::E_tref_name: The TRef name.\n"
  " */";
#else
static const char *Dtool_EggTexture_is_equivalent_to_620_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggTexture::sorts_less_than(EggTexture const &other, int eq) const
 */
static PyObject *Dtool_EggTexture_sorts_less_than_621(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggTexture::sorts_less_than(EggTexture const &other, int eq) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"other", "eq", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:sorts_less_than", (char **)keyword_list, &param1, &param2)) {
    CPT(EggTexture) param1_this;
    if (!Dtool_ConstCoerce_EggTexture(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggTexture.sorts_less_than", "EggTexture");
    }
    bool return_value = (*(const EggTexture*)local_this).sorts_less_than(*MOVE(param1_this), (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sorts_less_than(EggTexture self, const EggTexture other, int eq)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_sorts_less_than_621_comment =
  "C++ Interface:\n"
  "sorts_less_than(EggTexture self, const EggTexture other, int eq)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two textures for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique textures, according\n"
  " * to the indicated Equivalence factor.  See is_equivalent_to().\n"
  " */";
#else
static const char *Dtool_EggTexture_sorts_less_than_621_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggTexture::has_alpha_channel(int num_components) const
 */
static PyObject *Dtool_EggTexture_has_alpha_channel_622(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggTexture::has_alpha_channel(int num_components) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const EggTexture*)local_this).has_alpha_channel((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_alpha_channel(EggTexture self, int num_components)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_alpha_channel_622_comment =
  "C++ Interface:\n"
  "has_alpha_channel(EggTexture self, int num_components)\n"
  "\n"
  "/**\n"
  " * Given the number of color components (channels) in the image file as\n"
  " * actually read from the disk, return true if this texture seems to have an\n"
  " * alpha channel or not.  This depends on the EggTexture's format as well as\n"
  " * the number of channels.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_alpha_channel_622_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_texture_type(EggTexture::TextureType texture_type)
 */
static PyObject *Dtool_EggTexture_set_texture_type_636(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_texture_type")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_texture_type(EggTexture::TextureType texture_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_texture_type((EggTexture::TextureType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_type(const EggTexture self, int texture_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_texture_type_636_comment =
  "C++ Interface:\n"
  "set_texture_type(const EggTexture self, int texture_type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_texture_type_636_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::TextureType EggTexture::get_texture_type(void) const
 */
static PyObject *Dtool_EggTexture_get_texture_type_637(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::TextureType EggTexture::get_texture_type(void) const
  EggTexture::TextureType return_value = (*(const EggTexture*)local_this).get_texture_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_texture_type_637_comment =
  "C++ Interface:\n"
  "get_texture_type(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_texture_type_637_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_format(EggTexture::Format format)
 */
static PyObject *Dtool_EggTexture_set_format_638(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_format")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_format(EggTexture::Format format)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_format((EggTexture::Format)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_format(const EggTexture self, int format)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_format_638_comment =
  "C++ Interface:\n"
  "set_format(const EggTexture self, int format)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_format_638_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::Format EggTexture::get_format(void) const
 */
static PyObject *Dtool_EggTexture_get_format_639(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::Format EggTexture::get_format(void) const
  EggTexture::Format return_value = (*(const EggTexture*)local_this).get_format();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_format_639_comment =
  "C++ Interface:\n"
  "get_format(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_format_639_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_compression_mode(EggTexture::CompressionMode mode)
 */
static PyObject *Dtool_EggTexture_set_compression_mode_640(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_compression_mode")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_compression_mode(EggTexture::CompressionMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_compression_mode((EggTexture::CompressionMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_compression_mode(const EggTexture self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_compression_mode_640_comment =
  "C++ Interface:\n"
  "set_compression_mode(const EggTexture self, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_compression_mode_640_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::CompressionMode EggTexture::get_compression_mode(void) const
 */
static PyObject *Dtool_EggTexture_get_compression_mode_641(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::CompressionMode EggTexture::get_compression_mode(void) const
  EggTexture::CompressionMode return_value = (*(const EggTexture*)local_this).get_compression_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_compression_mode_641_comment =
  "C++ Interface:\n"
  "get_compression_mode(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_compression_mode_641_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_wrap_mode(EggTexture::WrapMode mode)
 */
static PyObject *Dtool_EggTexture_set_wrap_mode_642(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_wrap_mode")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_wrap_mode(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_wrap_mode((EggTexture::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_mode(const EggTexture self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_wrap_mode_642_comment =
  "C++ Interface:\n"
  "set_wrap_mode(const EggTexture self, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_wrap_mode_642_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::get_wrap_mode(void) const
 */
static PyObject *Dtool_EggTexture_get_wrap_mode_643(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_mode(void) const
  EggTexture::WrapMode return_value = (*(const EggTexture*)local_this).get_wrap_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_wrap_mode_643_comment =
  "C++ Interface:\n"
  "get_wrap_mode(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_wrap_mode_643_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_wrap_u(EggTexture::WrapMode mode)
 */
static PyObject *Dtool_EggTexture_set_wrap_u_644(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_wrap_u")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_wrap_u(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_wrap_u((EggTexture::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_u(const EggTexture self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_wrap_u_644_comment =
  "C++ Interface:\n"
  "set_wrap_u(const EggTexture self, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_wrap_u_644_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::get_wrap_u(void) const
 */
static PyObject *Dtool_EggTexture_get_wrap_u_645(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_u(void) const
  EggTexture::WrapMode return_value = (*(const EggTexture*)local_this).get_wrap_u();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_wrap_u_645_comment =
  "C++ Interface:\n"
  "get_wrap_u(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the amount specified for U wrap.  This may be unspecified, even if\n"
  " * there is an overall wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_wrap_u_645_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::determine_wrap_u(void) const
 */
static PyObject *Dtool_EggTexture_determine_wrap_u_646(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::WrapMode EggTexture::determine_wrap_u(void) const
  EggTexture::WrapMode return_value = (*(const EggTexture*)local_this).determine_wrap_u();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_determine_wrap_u_646_comment =
  "C++ Interface:\n"
  "determine_wrap_u(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Determines the appropriate wrap in the U direction.  This is different from\n"
  " * get_wrap_u() in that if the U wrap is unspecified, it returns the overall\n"
  " * wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_determine_wrap_u_646_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_wrap_v(EggTexture::WrapMode mode)
 */
static PyObject *Dtool_EggTexture_set_wrap_v_647(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_wrap_v")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_wrap_v(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_wrap_v((EggTexture::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_v(const EggTexture self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_wrap_v_647_comment =
  "C++ Interface:\n"
  "set_wrap_v(const EggTexture self, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_wrap_v_647_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::get_wrap_v(void) const
 */
static PyObject *Dtool_EggTexture_get_wrap_v_648(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_v(void) const
  EggTexture::WrapMode return_value = (*(const EggTexture*)local_this).get_wrap_v();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_wrap_v_648_comment =
  "C++ Interface:\n"
  "get_wrap_v(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the amount specified for V wrap.  This may be unspecified, even if\n"
  " * there is an overall wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_wrap_v_648_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::determine_wrap_v(void) const
 */
static PyObject *Dtool_EggTexture_determine_wrap_v_649(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::WrapMode EggTexture::determine_wrap_v(void) const
  EggTexture::WrapMode return_value = (*(const EggTexture*)local_this).determine_wrap_v();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_determine_wrap_v_649_comment =
  "C++ Interface:\n"
  "determine_wrap_v(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Determines the appropriate wrap in the V direction.  This is different from\n"
  " * get_wrap_v() in that if the V wrap is unspecified, it returns the overall\n"
  " * wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_determine_wrap_v_649_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_wrap_w(EggTexture::WrapMode mode)
 */
static PyObject *Dtool_EggTexture_set_wrap_w_650(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_wrap_w")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_wrap_w(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_wrap_w((EggTexture::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_w(const EggTexture self, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_wrap_w_650_comment =
  "C++ Interface:\n"
  "set_wrap_w(const EggTexture self, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_wrap_w_650_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::get_wrap_w(void) const
 */
static PyObject *Dtool_EggTexture_get_wrap_w_651(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_w(void) const
  EggTexture::WrapMode return_value = (*(const EggTexture*)local_this).get_wrap_w();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_wrap_w_651_comment =
  "C++ Interface:\n"
  "get_wrap_w(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the amount specified for W wrap.  This may be unspecified, even if\n"
  " * there is an overall wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_wrap_w_651_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::determine_wrap_w(void) const
 */
static PyObject *Dtool_EggTexture_determine_wrap_w_652(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::WrapMode EggTexture::determine_wrap_w(void) const
  EggTexture::WrapMode return_value = (*(const EggTexture*)local_this).determine_wrap_w();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_determine_wrap_w_652_comment =
  "C++ Interface:\n"
  "determine_wrap_w(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Determines the appropriate wrap in the W direction.  This is different from\n"
  " * get_wrap_w() in that if the W wrap is unspecified, it returns the overall\n"
  " * wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_determine_wrap_w_652_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_minfilter(EggTexture::FilterType type)
 */
static PyObject *Dtool_EggTexture_set_minfilter_653(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_minfilter")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_minfilter(EggTexture::FilterType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_minfilter((EggTexture::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_minfilter(const EggTexture self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_minfilter_653_comment =
  "C++ Interface:\n"
  "set_minfilter(const EggTexture self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_minfilter_653_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::FilterType EggTexture::get_minfilter(void) const
 */
static PyObject *Dtool_EggTexture_get_minfilter_654(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::FilterType EggTexture::get_minfilter(void) const
  EggTexture::FilterType return_value = (*(const EggTexture*)local_this).get_minfilter();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_minfilter_654_comment =
  "C++ Interface:\n"
  "get_minfilter(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_minfilter_654_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_magfilter(EggTexture::FilterType type)
 */
static PyObject *Dtool_EggTexture_set_magfilter_655(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_magfilter")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_magfilter(EggTexture::FilterType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_magfilter((EggTexture::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_magfilter(const EggTexture self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_magfilter_655_comment =
  "C++ Interface:\n"
  "set_magfilter(const EggTexture self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_magfilter_655_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::FilterType EggTexture::get_magfilter(void) const
 */
static PyObject *Dtool_EggTexture_get_magfilter_656(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::FilterType EggTexture::get_magfilter(void) const
  EggTexture::FilterType return_value = (*(const EggTexture*)local_this).get_magfilter();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_magfilter_656_comment =
  "C++ Interface:\n"
  "get_magfilter(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_magfilter_656_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_anisotropic_degree(int anisotropic_degree)
 */
static PyObject *Dtool_EggTexture_set_anisotropic_degree_657(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_anisotropic_degree")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_anisotropic_degree((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const EggTexture self, int anisotropic_degree)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_anisotropic_degree_657_comment =
  "C++ Interface:\n"
  "set_anisotropic_degree(const EggTexture self, int anisotropic_degree)\n"
  "\n"
  "/**\n"
  " * Sets the degree of anisotropic filtering for this texture.  1 is off;\n"
  " * higher levels indicate filtering in effect.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_anisotropic_degree_657_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_anisotropic_degree(void)
 */
static PyObject *Dtool_EggTexture_clear_anisotropic_degree_658(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_anisotropic_degree")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_anisotropic_degree(void)
  (*local_this).clear_anisotropic_degree();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_anisotropic_degree_658_comment =
  "C++ Interface:\n"
  "clear_anisotropic_degree(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of anisotropic filtering from the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_anisotropic_degree_658_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_anisotropic_degree(void) const
 */
static PyObject *Dtool_EggTexture_has_anisotropic_degree_659(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_anisotropic_degree(void) const
  bool return_value = (*(const EggTexture*)local_this).has_anisotropic_degree();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_anisotropic_degree_659_comment =
  "C++ Interface:\n"
  "has_anisotropic_degree(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a value for the anisotropic filtering degree has been\n"
  " * specified for this texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_anisotropic_degree_659_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_anisotropic_degree(void) const
 */
static PyObject *Dtool_EggTexture_get_anisotropic_degree_660(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggTexture::get_anisotropic_degree(void) const
  int return_value = (*(const EggTexture*)local_this).get_anisotropic_degree();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_anisotropic_degree_660_comment =
  "C++ Interface:\n"
  "get_anisotropic_degree(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the anisotropic filtering degree that has been specified for this\n"
  " * texture, or 0 if nothing has been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_anisotropic_degree_660_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_env_type(EggTexture::EnvType type)
 */
static PyObject *Dtool_EggTexture_set_env_type_661(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_env_type")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_env_type(EggTexture::EnvType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_env_type((EggTexture::EnvType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_env_type(const EggTexture self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_env_type_661_comment =
  "C++ Interface:\n"
  "set_env_type(const EggTexture self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_env_type_661_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::EnvType EggTexture::get_env_type(void) const
 */
static PyObject *Dtool_EggTexture_get_env_type_662(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::EnvType EggTexture::get_env_type(void) const
  EggTexture::EnvType return_value = (*(const EggTexture*)local_this).get_env_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_env_type_662_comment =
  "C++ Interface:\n"
  "get_env_type(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_env_type_662_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggTexture::affects_polygon_alpha(void) const
 */
static PyObject *Dtool_EggTexture_affects_polygon_alpha_663(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggTexture::affects_polygon_alpha(void) const
  bool return_value = (*(const EggTexture*)local_this).affects_polygon_alpha();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_affects_polygon_alpha_663_comment =
  "C++ Interface:\n"
  "affects_polygon_alpha(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if this texture's environment type or combine mode allows the\n"
  " * texture to have an effect on the polygon's alpha values, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_affects_polygon_alpha_663_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_combine_mode(EggTexture::CombineChannel channel, EggTexture::CombineMode cm)
 */
static PyObject *Dtool_EggTexture_set_combine_mode_664(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_combine_mode")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_combine_mode(EggTexture::CombineChannel channel, EggTexture::CombineMode cm)
  int param1;
  int param2;
  static const char *keyword_list[] = {"channel", "cm", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_combine_mode", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_combine_mode((EggTexture::CombineChannel)param1, (EggTexture::CombineMode)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_combine_mode(const EggTexture self, int channel, int cm)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_combine_mode_664_comment =
  "C++ Interface:\n"
  "set_combine_mode(const EggTexture self, int channel, int cm)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_combine_mode_664_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::CombineMode EggTexture::get_combine_mode(EggTexture::CombineChannel channel) const
 */
static PyObject *Dtool_EggTexture_get_combine_mode_665(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::CombineMode EggTexture::get_combine_mode(EggTexture::CombineChannel channel) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggTexture::CombineMode return_value = (*(const EggTexture*)local_this).get_combine_mode((EggTexture::CombineChannel)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_combine_mode(EggTexture self, int channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_combine_mode_665_comment =
  "C++ Interface:\n"
  "get_combine_mode(EggTexture self, int channel)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_combine_mode_665_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_combine_source(EggTexture::CombineChannel channel, int n, EggTexture::CombineSource cs)
 */
static PyObject *Dtool_EggTexture_set_combine_source_666(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_combine_source")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_combine_source(EggTexture::CombineChannel channel, int n, EggTexture::CombineSource cs)
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"channel", "n", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:set_combine_source", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_combine_source((EggTexture::CombineChannel)param1, (int)param2, (EggTexture::CombineSource)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_combine_source(const EggTexture self, int channel, int n, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_combine_source_666_comment =
  "C++ Interface:\n"
  "set_combine_source(const EggTexture self, int channel, int n, int cs)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_combine_source_666_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::CombineSource EggTexture::get_combine_source(EggTexture::CombineChannel channel, int n) const
 */
static PyObject *Dtool_EggTexture_get_combine_source_667(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::CombineSource EggTexture::get_combine_source(EggTexture::CombineChannel channel, int n) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"channel", "n", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_combine_source", (char **)keyword_list, &param1, &param2)) {
    EggTexture::CombineSource return_value = (*(const EggTexture*)local_this).get_combine_source((EggTexture::CombineChannel)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_combine_source(EggTexture self, int channel, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_combine_source_667_comment =
  "C++ Interface:\n"
  "get_combine_source(EggTexture self, int channel, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_combine_source_667_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_combine_operand(EggTexture::CombineChannel channel, int n, EggTexture::CombineOperand co)
 */
static PyObject *Dtool_EggTexture_set_combine_operand_668(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_combine_operand")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_combine_operand(EggTexture::CombineChannel channel, int n, EggTexture::CombineOperand co)
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"channel", "n", "co", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:set_combine_operand", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_combine_operand((EggTexture::CombineChannel)param1, (int)param2, (EggTexture::CombineOperand)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_combine_operand(const EggTexture self, int channel, int n, int co)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_combine_operand_668_comment =
  "C++ Interface:\n"
  "set_combine_operand(const EggTexture self, int channel, int n, int co)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_combine_operand_668_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::CombineOperand EggTexture::get_combine_operand(EggTexture::CombineChannel channel, int n) const
 */
static PyObject *Dtool_EggTexture_get_combine_operand_669(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::CombineOperand EggTexture::get_combine_operand(EggTexture::CombineChannel channel, int n) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"channel", "n", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_combine_operand", (char **)keyword_list, &param1, &param2)) {
    EggTexture::CombineOperand return_value = (*(const EggTexture*)local_this).get_combine_operand((EggTexture::CombineChannel)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_combine_operand(EggTexture self, int channel, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_combine_operand_669_comment =
  "C++ Interface:\n"
  "get_combine_operand(EggTexture self, int channel, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_combine_operand_669_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_saved_result(bool saved_result)
 */
static PyObject *Dtool_EggTexture_set_saved_result_670(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_saved_result")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_saved_result(bool saved_result)
  (*local_this).set_saved_result((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_saved_result(const EggTexture self, bool saved_result)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_saved_result_670_comment =
  "C++ Interface:\n"
  "set_saved_result(const EggTexture self, bool saved_result)\n"
  "\n"
  "/**\n"
  " * Sets the saved_result flag.  When this is true, the output of this stage is\n"
  " * not part of the normal pipeline--that is, it will not be supplied as the\n"
  " * \"previous\" source for the next texture stage--but it will instead be\n"
  " * supplied as the \"last_saved_result\" source for any future stages, until the\n"
  " * next TextureStage with a saved_result set true is encountered.\n"
  " *\n"
  " * This can be used to reuse the results of this texture stage as input to\n"
  " * more than one stage later in the pipeline.\n"
  " *\n"
  " * The last texture in the pipeline (the one with the highest sort value)\n"
  " * should not have this flag set.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_saved_result_670_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::get_saved_result(void) const
 */
static PyObject *Dtool_EggTexture_get_saved_result_671(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::get_saved_result(void) const
  bool return_value = (*(const EggTexture*)local_this).get_saved_result();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_saved_result_671_comment =
  "C++ Interface:\n"
  "get_saved_result(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the saved_result flag.  See\n"
  " * set_saved_result().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_saved_result_671_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_tex_gen(EggTexture::TexGen tex_gen)
 */
static PyObject *Dtool_EggTexture_set_tex_gen_672(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_tex_gen")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_tex_gen(EggTexture::TexGen tex_gen)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_tex_gen((EggTexture::TexGen)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_gen(const EggTexture self, int tex_gen)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_tex_gen_672_comment =
  "C++ Interface:\n"
  "set_tex_gen(const EggTexture self, int tex_gen)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_tex_gen_672_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::TexGen EggTexture::get_tex_gen(void) const
 */
static PyObject *Dtool_EggTexture_get_tex_gen_673(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::TexGen EggTexture::get_tex_gen(void) const
  EggTexture::TexGen return_value = (*(const EggTexture*)local_this).get_tex_gen();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_tex_gen_673_comment =
  "C++ Interface:\n"
  "get_tex_gen(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_tex_gen_673_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_quality_level(EggTexture::QualityLevel quality_level)
 */
static PyObject *Dtool_EggTexture_set_quality_level_674(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_quality_level")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_quality_level(EggTexture::QualityLevel quality_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_quality_level((EggTexture::QualityLevel)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quality_level(const EggTexture self, int quality_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_quality_level_674_comment =
  "C++ Interface:\n"
  "set_quality_level(const EggTexture self, int quality_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_quality_level_674_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::QualityLevel EggTexture::get_quality_level(void) const
 */
static PyObject *Dtool_EggTexture_get_quality_level_675(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTexture::QualityLevel EggTexture::get_quality_level(void) const
  EggTexture::QualityLevel return_value = (*(const EggTexture*)local_this).get_quality_level();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_quality_level_675_comment =
  "C++ Interface:\n"
  "get_quality_level(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_quality_level_675_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_stage_name(std::string const &stage_name)
 */
static PyObject *Dtool_EggTexture_set_stage_name_676(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_stage_name")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_stage_name(std::string const &stage_name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_stage_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_stage_name(const EggTexture self, str stage_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_stage_name_676_comment =
  "C++ Interface:\n"
  "set_stage_name(const EggTexture self, str stage_name)\n"
  "\n"
  "/**\n"
  " * Specifies the particular TextureStage this texture will be rendered on by\n"
  " * name.  If this is omitted, the texture will be rendered on the default\n"
  " * TextureStage, unless some other stage-specific property is specificied, in\n"
  " * which case the texture will be rendered on a TextureStage with the same\n"
  " * name as the tref.  This is in support of multitexturing.\n"
  " *\n"
  " * Each different TextureStage in the world must be uniquely named.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_stage_name_676_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_stage_name(void)
 */
static PyObject *Dtool_EggTexture_clear_stage_name_677(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_stage_name")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_stage_name(void)
  (*local_this).clear_stage_name();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_stage_name_677_comment =
  "C++ Interface:\n"
  "clear_stage_name(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the named TextureStage specification.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_stage_name_677_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_stage_name(void) const
 */
static PyObject *Dtool_EggTexture_has_stage_name_678(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_stage_name(void) const
  bool return_value = (*(const EggTexture*)local_this).has_stage_name();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_stage_name_678_comment =
  "C++ Interface:\n"
  "has_stage_name(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a stage name has been explicitly specified for this\n"
  " * texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_stage_name_678_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggTexture::get_stage_name(void) const
 */
static PyObject *Dtool_EggTexture_get_stage_name_679(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &EggTexture::get_stage_name(void) const
  std::string const &return_value = (*(const EggTexture*)local_this).get_stage_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_stage_name_679_comment =
  "C++ Interface:\n"
  "get_stage_name(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the stage name that has been specified for this texture, or the\n"
  " * tref name if no texture stage has explicitly been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_stage_name_679_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_priority(int priority)
 */
static PyObject *Dtool_EggTexture_set_priority_680(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_priority")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_priority((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_priority(const EggTexture self, int priority)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_priority_680_comment =
  "C++ Interface:\n"
  "set_priority(const EggTexture self, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the importance of this texture with respect to other textures also\n"
  " * applied on the same geometry.  This is only meaningful in the presence of\n"
  " * multitexturing.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_priority_680_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_priority(void)
 */
static PyObject *Dtool_EggTexture_clear_priority_681(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_priority")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_priority(void)
  (*local_this).clear_priority();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_priority_681_comment =
  "C++ Interface:\n"
  "clear_priority(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of multitexture priority from the texture.  The\n"
  " * default priority value is 0.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_priority_681_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_priority(void) const
 */
static PyObject *Dtool_EggTexture_has_priority_682(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_priority(void) const
  bool return_value = (*(const EggTexture*)local_this).has_priority();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_priority_682_comment =
  "C++ Interface:\n"
  "has_priority(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a priority value for multitexture importance has been\n"
  " * specified for the texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_priority_682_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_priority(void) const
 */
static PyObject *Dtool_EggTexture_get_priority_683(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggTexture::get_priority(void) const
  int return_value = (*(const EggTexture*)local_this).get_priority();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_priority_683_comment =
  "C++ Interface:\n"
  "get_priority(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the multitexture importance value that has been specified for the\n"
  " * texture, or 0 if no priority value has been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_priority_683_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_color(LColor const &color)
 */
static PyObject *Dtool_EggTexture_set_color_684(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_color")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_color", "LVecBase4f");
  }
  (*local_this).set_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const EggTexture self, const LVecBase4f color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_color_684_comment =
  "C++ Interface:\n"
  "set_color(const EggTexture self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_color_684_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_color(void)
 */
static PyObject *Dtool_EggTexture_clear_color_685(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_color")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_color(void)
  (*local_this).clear_color();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_color_685_comment =
  "C++ Interface:\n"
  "clear_color(const EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_color_685_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_color(void) const
 */
static PyObject *Dtool_EggTexture_has_color_686(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_color(void) const
  bool return_value = (*(const EggTexture*)local_this).has_color();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_color_686_comment =
  "C++ Interface:\n"
  "has_color(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a blend color has been specified for the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_color_686_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &EggTexture::get_color(void) const
 */
static PyObject *Dtool_EggTexture_get_color_687(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &EggTexture::get_color(void) const
  LColor const *return_value = &((*(const EggTexture*)local_this).get_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_color_687_comment =
  "C++ Interface:\n"
  "get_color(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the blend color if one has been specified, or (0, 0, 0, 1)\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_color_687_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_border_color(LColor const &border_color)
 */
static PyObject *Dtool_EggTexture_set_border_color_688(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_border_color")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_border_color(LColor const &border_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_border_color", "LVecBase4f");
  }
  (*local_this).set_border_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_border_color(const EggTexture self, const LVecBase4f border_color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_border_color_688_comment =
  "C++ Interface:\n"
  "set_border_color(const EggTexture self, const LVecBase4f border_color)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_border_color_688_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_border_color(void)
 */
static PyObject *Dtool_EggTexture_clear_border_color_689(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_border_color")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_border_color(void)
  (*local_this).clear_border_color();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_border_color_689_comment =
  "C++ Interface:\n"
  "clear_border_color(const EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_border_color_689_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_border_color(void) const
 */
static PyObject *Dtool_EggTexture_has_border_color_690(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_border_color(void) const
  bool return_value = (*(const EggTexture*)local_this).has_border_color();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_border_color_690_comment =
  "C++ Interface:\n"
  "has_border_color(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a border color has been specified for the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_border_color_690_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &EggTexture::get_border_color(void) const
 */
static PyObject *Dtool_EggTexture_get_border_color_691(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &EggTexture::get_border_color(void) const
  LColor const *return_value = &((*(const EggTexture*)local_this).get_border_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_border_color_691_comment =
  "C++ Interface:\n"
  "get_border_color(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the border color if one has been specified, or (0, 0, 0, 1)\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_border_color_691_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_uv_name(std::string const &uv_name)
 */
static PyObject *Dtool_EggTexture_set_uv_name_692(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_uv_name")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_uv_name(std::string const &uv_name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_uv_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_name(const EggTexture self, str uv_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_uv_name_692_comment =
  "C++ Interface:\n"
  "set_uv_name(const EggTexture self, str uv_name)\n"
  "\n"
  "/**\n"
  " * Specifies the named set of texture coordinates that this texture will use\n"
  " * when it is applied to geometry.  Geometry may have multiple sets of texture\n"
  " * coordinates defined, by name.\n"
  " *\n"
  " * If this is not specified for a particular texture, the default set of\n"
  " * texture coordinates will be used.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_uv_name_692_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_uv_name(void)
 */
static PyObject *Dtool_EggTexture_clear_uv_name_693(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_uv_name")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_uv_name(void)
  (*local_this).clear_uv_name();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_uv_name_693_comment =
  "C++ Interface:\n"
  "clear_uv_name(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the restriction to a particular named set of texture coordinates\n"
  " * and restores the texture to using the default texture coordinates.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_uv_name_693_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_uv_name(void) const
 */
static PyObject *Dtool_EggTexture_has_uv_name_694(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_uv_name(void) const
  bool return_value = (*(const EggTexture*)local_this).has_uv_name();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_uv_name_694_comment =
  "C++ Interface:\n"
  "has_uv_name(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a texcoord name has been explicitly specified for this\n"
  " * texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_uv_name_694_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggTexture::get_uv_name(void) const
 */
static PyObject *Dtool_EggTexture_get_uv_name_695(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &EggTexture::get_uv_name(void) const
  std::string const &return_value = (*(const EggTexture*)local_this).get_uv_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_uv_name_695_comment =
  "C++ Interface:\n"
  "get_uv_name(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the texcoord name that has been specified for this texture, or the\n"
  " * empty string if no texcoord name has explicitly been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_uv_name_695_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_rgb_scale(int rgb_scale)
 */
static PyObject *Dtool_EggTexture_set_rgb_scale_696(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_rgb_scale")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_rgb_scale(int rgb_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_rgb_scale((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rgb_scale(const EggTexture self, int rgb_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_rgb_scale_696_comment =
  "C++ Interface:\n"
  "set_rgb_scale(const EggTexture self, int rgb_scale)\n"
  "\n"
  "/**\n"
  " * Sets an additional factor that will scale all three r, g, b components\n"
  " * after the texture has been applied.  This is used only when a combine mode\n"
  " * is in effect.\n"
  " *\n"
  " * The only legal values are 1, 2, or 4.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_rgb_scale_696_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_rgb_scale(void)
 */
static PyObject *Dtool_EggTexture_clear_rgb_scale_697(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_rgb_scale")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_rgb_scale(void)
  (*local_this).clear_rgb_scale();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_rgb_scale_697_comment =
  "C++ Interface:\n"
  "clear_rgb_scale(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the rgb_scale from the texture and restores it to the default value\n"
  " * of 1.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_rgb_scale_697_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_rgb_scale(void) const
 */
static PyObject *Dtool_EggTexture_has_rgb_scale_698(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_rgb_scale(void) const
  bool return_value = (*(const EggTexture*)local_this).has_rgb_scale();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_rgb_scale_698_comment =
  "C++ Interface:\n"
  "has_rgb_scale(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if an rgb_scale has been specified for the texture, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_rgb_scale_698_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_rgb_scale(void) const
 */
static PyObject *Dtool_EggTexture_get_rgb_scale_699(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggTexture::get_rgb_scale(void) const
  int return_value = (*(const EggTexture*)local_this).get_rgb_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_rgb_scale_699_comment =
  "C++ Interface:\n"
  "get_rgb_scale(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the rgb_scale value that has been specified for the texture, or 1\n"
  " * if no rgb_scale value has been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_rgb_scale_699_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_alpha_scale(int alpha_scale)
 */
static PyObject *Dtool_EggTexture_set_alpha_scale_700(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_alpha_scale")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_alpha_scale(int alpha_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_alpha_scale((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_scale(const EggTexture self, int alpha_scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_alpha_scale_700_comment =
  "C++ Interface:\n"
  "set_alpha_scale(const EggTexture self, int alpha_scale)\n"
  "\n"
  "/**\n"
  " * Sets an additional factor that will scale the alpha component after the\n"
  " * texture has been applied.  This is used only when a combine mode is in\n"
  " * effect.\n"
  " *\n"
  " * The only legal values are 1, 2, or 4.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_alpha_scale_700_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_alpha_scale(void)
 */
static PyObject *Dtool_EggTexture_clear_alpha_scale_701(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_alpha_scale")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_alpha_scale(void)
  (*local_this).clear_alpha_scale();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_alpha_scale_701_comment =
  "C++ Interface:\n"
  "clear_alpha_scale(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the alpha_scale from the texture and restores it to the default\n"
  " * value of 1.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_alpha_scale_701_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_alpha_scale(void) const
 */
static PyObject *Dtool_EggTexture_has_alpha_scale_702(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_alpha_scale(void) const
  bool return_value = (*(const EggTexture*)local_this).has_alpha_scale();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_alpha_scale_702_comment =
  "C++ Interface:\n"
  "has_alpha_scale(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if an alpha_scale has been specified for the texture, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_alpha_scale_702_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_alpha_scale(void) const
 */
static PyObject *Dtool_EggTexture_get_alpha_scale_703(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggTexture::get_alpha_scale(void) const
  int return_value = (*(const EggTexture*)local_this).get_alpha_scale();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_alpha_scale_703_comment =
  "C++ Interface:\n"
  "get_alpha_scale(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the alpha_scale value that has been specified for the texture, or 1\n"
  " * if no alpha_scale value has been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_alpha_scale_703_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_alpha_filename(Filename const &filename)
 */
static PyObject *Dtool_EggTexture_set_alpha_filename_704(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_alpha_filename")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_alpha_filename(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_alpha_filename", "Filename");
  }
  (*local_this).set_alpha_filename(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_filename(const EggTexture self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_alpha_filename_704_comment =
  "C++ Interface:\n"
  "set_alpha_filename(const EggTexture self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Specifies a separate file that will be loaded in with the 1- or 3-component\n"
  " * texture and applied as the alpha channel.  This is useful when loading\n"
  " * textures from file formats that do not support alpha, for instance jpg.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_alpha_filename_704_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_alpha_filename(void)
 */
static PyObject *Dtool_EggTexture_clear_alpha_filename_705(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_alpha_filename")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_alpha_filename(void)
  (*local_this).clear_alpha_filename();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_alpha_filename_705_comment =
  "C++ Interface:\n"
  "clear_alpha_filename(const EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_alpha_filename_705_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_alpha_filename(void) const
 */
static PyObject *Dtool_EggTexture_has_alpha_filename_706(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_alpha_filename(void) const
  bool return_value = (*(const EggTexture*)local_this).has_alpha_filename();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_alpha_filename_706_comment =
  "C++ Interface:\n"
  "has_alpha_filename(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a separate file for the alpha component has been applied,\n"
  " * false otherwise.  See set_alpha_filename().\n"
  " */";
#else
static const char *Dtool_EggTexture_has_alpha_filename_706_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &EggTexture::get_alpha_filename(void) const
 */
static PyObject *Dtool_EggTexture_get_alpha_filename_707(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &EggTexture::get_alpha_filename(void) const
  Filename const *return_value = &((*(const EggTexture*)local_this).get_alpha_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_alpha_filename_707_comment =
  "C++ Interface:\n"
  "get_alpha_filename(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the separate file assigned for the alpha channel.  It is an error\n"
  " * to call this unless has_alpha_filename() returns true.  See\n"
  " * set_alpha_filename().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_alpha_filename_707_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_alpha_fullpath(Filename const &fullpath)
 */
static PyObject *Dtool_EggTexture_set_alpha_fullpath_708(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_alpha_fullpath")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_alpha_fullpath(Filename const &fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_alpha_fullpath", "Filename");
  }
  (*local_this).set_alpha_fullpath(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_fullpath(const EggTexture self, const Filename fullpath)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_alpha_fullpath_708_comment =
  "C++ Interface:\n"
  "set_alpha_fullpath(const EggTexture self, const Filename fullpath)\n"
  "\n"
  "/**\n"
  " * Records the full pathname to the file, for the benefit of\n"
  " * get_alpha_fullpath().\n"
  " */";
#else
static const char *Dtool_EggTexture_set_alpha_fullpath_708_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &EggTexture::get_alpha_fullpath(void) const
 */
static PyObject *Dtool_EggTexture_get_alpha_fullpath_709(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &EggTexture::get_alpha_fullpath(void) const
  Filename const *return_value = &((*(const EggTexture*)local_this).get_alpha_fullpath());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_alpha_fullpath_709_comment =
  "C++ Interface:\n"
  "get_alpha_fullpath(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the full pathname to the alpha file, if it is known; otherwise,\n"
  " * returns the same thing as get_alpha_filename().\n"
  " *\n"
  " * This function simply returns whatever was set by the last call to\n"
  " * set_alpha_fullpath().  This string is not written to the egg file; its main\n"
  " * purpose is to record the full path to the alpha filename if it is known,\n"
  " * for egg structures that are generated in-memory and then immediately\n"
  " * converted to a scene graph.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_alpha_fullpath_709_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_alpha_file_channel(int alpha_file_channel)
 */
static PyObject *Dtool_EggTexture_set_alpha_file_channel_710(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_alpha_file_channel")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_alpha_file_channel(int alpha_file_channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_alpha_file_channel((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_file_channel(const EggTexture self, int alpha_file_channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_alpha_file_channel_710_comment =
  "C++ Interface:\n"
  "set_alpha_file_channel(const EggTexture self, int alpha_file_channel)\n"
  "\n"
  "/**\n"
  " * If a separate alpha-file is specified, this indicates which channel number\n"
  " * should be extracted from this file to derive the alpha channel for the\n"
  " * final image.  The default is 0, which means the grayscale combination of r,\n"
  " * g, b.  Otherwise, this should be the 1-based channel number, for instance\n"
  " * 1, 2, or 3 for r, g, or b, respectively, or 4 for the alpha channel of a\n"
  " * four-component image.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_alpha_file_channel_710_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_alpha_file_channel(void)
 */
static PyObject *Dtool_EggTexture_clear_alpha_file_channel_711(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_alpha_file_channel")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_alpha_file_channel(void)
  (*local_this).clear_alpha_file_channel();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_alpha_file_channel_711_comment =
  "C++ Interface:\n"
  "clear_alpha_file_channel(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of a particular channel to use from the alpha-\n"
  " * file image.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_alpha_file_channel_711_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_alpha_file_channel(void) const
 */
static PyObject *Dtool_EggTexture_has_alpha_file_channel_712(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_alpha_file_channel(void) const
  bool return_value = (*(const EggTexture*)local_this).has_alpha_file_channel();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_alpha_file_channel_712_comment =
  "C++ Interface:\n"
  "has_alpha_file_channel(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a particular channel has been specified for the alpha-file\n"
  " * image, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_alpha_file_channel_712_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_alpha_file_channel(void) const
 */
static PyObject *Dtool_EggTexture_get_alpha_file_channel_713(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggTexture::get_alpha_file_channel(void) const
  int return_value = (*(const EggTexture*)local_this).get_alpha_file_channel();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_alpha_file_channel_713_comment =
  "C++ Interface:\n"
  "get_alpha_file_channel(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the particular channel that has been specified for the alpha-file\n"
  " * image, or 0 if no channel has been specified.  See\n"
  " * set_alpha_file_channel().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_alpha_file_channel_713_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_multiview(bool multiview)
 */
static PyObject *Dtool_EggTexture_set_multiview_714(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_multiview")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_multiview(bool multiview)
  (*local_this).set_multiview((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_multiview(const EggTexture self, bool multiview)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_multiview_714_comment =
  "C++ Interface:\n"
  "set_multiview(const EggTexture self, bool multiview)\n"
  "\n"
  "/**\n"
  " * Sets the multiview flag.\n"
  " *\n"
  " * If multiview is true, the filename should contain a hash mark ('#'), which\n"
  " * will be filled in with the view number; and a multiview texture will be\n"
  " * defined with a series of images, one for each view.\n"
  " *\n"
  " * A multiview texture is most often used for stereo textures, but other uses\n"
  " * are also possible, such as for texture animation.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_multiview_714_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::get_multiview(void) const
 */
static PyObject *Dtool_EggTexture_get_multiview_715(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::get_multiview(void) const
  bool return_value = (*(const EggTexture*)local_this).get_multiview();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_multiview_715_comment =
  "C++ Interface:\n"
  "get_multiview(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the multiview flag.  See set_multiview().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_multiview_715_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_num_views(int num_views)
 */
static PyObject *Dtool_EggTexture_set_num_views_716(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_num_views")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_num_views(int num_views)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_views((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_views(const EggTexture self, int num_views)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_num_views_716_comment =
  "C++ Interface:\n"
  "set_num_views(const EggTexture self, int num_views)\n"
  "\n"
  "/**\n"
  " * When loading a 3-D multiview texture, this parameter is necessary to\n"
  " * specify how many views will be expected.  The z size is determined\n"
  " * implicitly from the number of images loaded.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_num_views_716_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_num_views(void)
 */
static PyObject *Dtool_EggTexture_clear_num_views_717(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_num_views")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_num_views(void)
  (*local_this).clear_num_views();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_num_views_717_comment =
  "C++ Interface:\n"
  "clear_num_views(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of the number of views for a 3-D multiview\n"
  " * texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_num_views_717_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_num_views(void) const
 */
static PyObject *Dtool_EggTexture_has_num_views_718(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_num_views(void) const
  bool return_value = (*(const EggTexture*)local_this).has_num_views();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_num_views_718_comment =
  "C++ Interface:\n"
  "has_num_views(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the number of views has been specified for the 3-D\n"
  " * multiview texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_num_views_718_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_num_views(void) const
 */
static PyObject *Dtool_EggTexture_get_num_views_719(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggTexture::get_num_views(void) const
  int return_value = (*(const EggTexture*)local_this).get_num_views();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_num_views_719_comment =
  "C++ Interface:\n"
  "get_num_views(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the specified number of views specified for the 3-D multiview\n"
  " * texture.  See set_num_views().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_num_views_719_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_read_mipmaps(bool read_mipmaps)
 */
static PyObject *Dtool_EggTexture_set_read_mipmaps_720(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_read_mipmaps")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_read_mipmaps(bool read_mipmaps)
  (*local_this).set_read_mipmaps((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_read_mipmaps(const EggTexture self, bool read_mipmaps)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_read_mipmaps_720_comment =
  "C++ Interface:\n"
  "set_read_mipmaps(const EggTexture self, bool read_mipmaps)\n"
  "\n"
  "/**\n"
  " * Sets the read_mipmaps flag.\n"
  " *\n"
  " * If read_mipmaps is true, the filename should contain a hash mark ('#'),\n"
  " * which will be filled in with the mipmap level number; and the texture will\n"
  " * be defined with a series of images, one for each mipmap level.\n"
  " *\n"
  " * If the filename is of a type that already requires a hash mark, such as a\n"
  " * cube map or a 3-d texture, then the filename should now require two hash\n"
  " * marks, and the first one indicates the mipmap level number, while the\n"
  " * second indicates the face number or 3-d level number.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_read_mipmaps_720_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::get_read_mipmaps(void) const
 */
static PyObject *Dtool_EggTexture_get_read_mipmaps_721(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::get_read_mipmaps(void) const
  bool return_value = (*(const EggTexture*)local_this).get_read_mipmaps();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_read_mipmaps_721_comment =
  "C++ Interface:\n"
  "get_read_mipmaps(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the read_mipmaps flag.  See\n"
  " * set_read_mipmaps().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_read_mipmaps_721_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_min_lod(double min_lod)
 */
static PyObject *Dtool_EggTexture_set_min_lod_722(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_min_lod")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_min_lod(double min_lod)
  if (PyNumber_Check(arg)) {
    (*local_this).set_min_lod(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_lod(const EggTexture self, double min_lod)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_min_lod_722_comment =
  "C++ Interface:\n"
  "set_min_lod(const EggTexture self, double min_lod)\n"
  "\n"
  "/**\n"
  " * Sets the minimum mipmap level that may be sampled.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_min_lod_722_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_min_lod(void)
 */
static PyObject *Dtool_EggTexture_clear_min_lod_723(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_min_lod")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_min_lod(void)
  (*local_this).clear_min_lod();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_min_lod_723_comment =
  "C++ Interface:\n"
  "clear_min_lod(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of a minimum mipmap level from the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_min_lod_723_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_min_lod(void) const
 */
static PyObject *Dtool_EggTexture_has_min_lod_724(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_min_lod(void) const
  bool return_value = (*(const EggTexture*)local_this).has_min_lod();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_min_lod_724_comment =
  "C++ Interface:\n"
  "has_min_lod(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a value for the minimum mipmap level has been specified for\n"
  " * this texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_min_lod_724_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggTexture::get_min_lod(void) const
 */
static PyObject *Dtool_EggTexture_get_min_lod_725(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggTexture::get_min_lod(void) const
  double return_value = (*(const EggTexture*)local_this).get_min_lod();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_min_lod_725_comment =
  "C++ Interface:\n"
  "get_min_lod(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum mipmap level that has been specified for this texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_min_lod_725_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_max_lod(double max_lod)
 */
static PyObject *Dtool_EggTexture_set_max_lod_726(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_max_lod")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_max_lod(double max_lod)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_lod(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_lod(const EggTexture self, double max_lod)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_max_lod_726_comment =
  "C++ Interface:\n"
  "set_max_lod(const EggTexture self, double max_lod)\n"
  "\n"
  "/**\n"
  " * Sets the maximum mipmap level that may be sampled.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_max_lod_726_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_max_lod(void)
 */
static PyObject *Dtool_EggTexture_clear_max_lod_727(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_max_lod")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_max_lod(void)
  (*local_this).clear_max_lod();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_max_lod_727_comment =
  "C++ Interface:\n"
  "clear_max_lod(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of a maximum mipmap level from the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_max_lod_727_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_max_lod(void) const
 */
static PyObject *Dtool_EggTexture_has_max_lod_728(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_max_lod(void) const
  bool return_value = (*(const EggTexture*)local_this).has_max_lod();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_max_lod_728_comment =
  "C++ Interface:\n"
  "has_max_lod(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a value for the maximum mipmap level has been specified for\n"
  " * this texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_max_lod_728_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggTexture::get_max_lod(void) const
 */
static PyObject *Dtool_EggTexture_get_max_lod_729(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggTexture::get_max_lod(void) const
  double return_value = (*(const EggTexture*)local_this).get_max_lod();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_max_lod_729_comment =
  "C++ Interface:\n"
  "get_max_lod(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum mipmap level that has been specified for this texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_max_lod_729_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_lod_bias(double lod_bias)
 */
static PyObject *Dtool_EggTexture_set_lod_bias_730(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_lod_bias")) {
    return NULL;
  }
  // 1-inline void EggTexture::set_lod_bias(double lod_bias)
  if (PyNumber_Check(arg)) {
    (*local_this).set_lod_bias(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod_bias(const EggTexture self, double lod_bias)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_lod_bias_730_comment =
  "C++ Interface:\n"
  "set_lod_bias(const EggTexture self, double lod_bias)\n"
  "\n"
  "/**\n"
  " * Sets the mipmap level bias that is added to the mipmap level to be sampled.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_lod_bias_730_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_lod_bias(void)
 */
static PyObject *Dtool_EggTexture_clear_lod_bias_731(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_lod_bias")) {
    return NULL;
  }
  // 1-inline void EggTexture::clear_lod_bias(void)
  (*local_this).clear_lod_bias();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_lod_bias_731_comment =
  "C++ Interface:\n"
  "clear_lod_bias(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of a maximum mipmap level from the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_lod_bias_731_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_lod_bias(void) const
 */
static PyObject *Dtool_EggTexture_has_lod_bias_732(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggTexture::has_lod_bias(void) const
  bool return_value = (*(const EggTexture*)local_this).has_lod_bias();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_lod_bias_732_comment =
  "C++ Interface:\n"
  "has_lod_bias(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a value for the maximum mipmap level has been specified for\n"
  " * this texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_lod_bias_732_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggTexture::get_lod_bias(void) const
 */
static PyObject *Dtool_EggTexture_get_lod_bias_733(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggTexture::get_lod_bias(void) const
  double return_value = (*(const EggTexture*)local_this).get_lod_bias();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_lod_bias_733_comment =
  "C++ Interface:\n"
  "get_lod_bias(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum mipmap level that has been specified for this texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_lod_bias_733_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTexture::clear_multitexture(void)
 */
static PyObject *Dtool_EggTexture_clear_multitexture_734(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_multitexture")) {
    return NULL;
  }
  // 1-void EggTexture::clear_multitexture(void)
  (*local_this).clear_multitexture();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_multitexture_734_comment =
  "C++ Interface:\n"
  "clear_multitexture(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Resets the multitexture flags set by multitexture_over().  After this call,\n"
  " * get_multitexture() will return false, and get_multitexture_sort() will\n"
  " * return 0.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_multitexture_734_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggTexture::multitexture_over(EggTexture *other)
 */
static PyObject *Dtool_EggTexture_multitexture_over_735(PyObject *self, PyObject *arg) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.multitexture_over")) {
    return NULL;
  }
  // 1-bool EggTexture::multitexture_over(EggTexture *other)
  PT(EggTexture) arg_this;
  if (!Dtool_Coerce_EggTexture(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.multitexture_over", "EggTexture");
  }
  bool return_value = (*local_this).multitexture_over(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "multitexture_over(const EggTexture self, EggTexture other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_multitexture_over_735_comment =
  "C++ Interface:\n"
  "multitexture_over(const EggTexture self, EggTexture other)\n"
  "\n"
  "/**\n"
  " * Indicates that this texture should be layered on top of the other texture.\n"
  " * This will guarantee that this->get_multitexture_sort() >\n"
  " * other->get_multitexture_sort(), at least until clear_multitexture() is\n"
  " * called on either one.\n"
  " *\n"
  " * The return value is true if successful, or false if there is a failure\n"
  " * because the other texture was already layered on top of this one (or there\n"
  " * is a three- or more-way cycle).\n"
  " */";
#else
static const char *Dtool_EggTexture_multitexture_over_735_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_multitexture_sort(void) const
 */
static PyObject *Dtool_EggTexture_get_multitexture_sort_736(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggTexture::get_multitexture_sort(void) const
  int return_value = (*(const EggTexture*)local_this).get_multitexture_sort();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_multitexture_sort_736_comment =
  "C++ Interface:\n"
  "get_multitexture_sort(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns an integer that represents the depth to which this texture is\n"
  " * layered on all other textures in the egg file.  In general, if texture A is\n"
  " * layered over texture B, then sort(A) > sort(B).  If texture A is never\n"
  " * layered over any other texture, then sort(A) == 0.  More than that is\n"
  " * difficult to guarantee.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_multitexture_sort_736_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::TextureType EggTexture::string_texture_type(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_texture_type_737(PyObject *, PyObject *arg) {
  // 1-static EggTexture::TextureType EggTexture::string_texture_type(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTexture::TextureType return_value = EggTexture::string_texture_type(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_texture_type(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_texture_type_737_comment =
  "C++ Interface:\n"
  "string_texture_type(str string)\n"
  "\n"
  "/**\n"
  " * Returns the Texture_ype value associated with the given string\n"
  " * representation, or TT_unspecified if the string does not match any known\n"
  " * TextureType value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_texture_type_737_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::Format EggTexture::string_format(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_format_738(PyObject *, PyObject *arg) {
  // 1-static EggTexture::Format EggTexture::string_format(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTexture::Format return_value = EggTexture::string_format(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_format(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_format_738_comment =
  "C++ Interface:\n"
  "string_format(str string)\n"
  "\n"
  "/**\n"
  " * Returns the Format value associated with the given string representation,\n"
  " * or F_unspecified if the string does not match any known Format value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_format_738_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::CompressionMode EggTexture::string_compression_mode(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_compression_mode_739(PyObject *, PyObject *arg) {
  // 1-static EggTexture::CompressionMode EggTexture::string_compression_mode(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTexture::CompressionMode return_value = EggTexture::string_compression_mode(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_compression_mode(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_compression_mode_739_comment =
  "C++ Interface:\n"
  "string_compression_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the CompressionMode value associated with the given string\n"
  " * representation, or CM_default if the string does not match any known\n"
  " * CompressionMode value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_compression_mode_739_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::WrapMode EggTexture::string_wrap_mode(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_wrap_mode_740(PyObject *, PyObject *arg) {
  // 1-static EggTexture::WrapMode EggTexture::string_wrap_mode(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTexture::WrapMode return_value = EggTexture::string_wrap_mode(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_wrap_mode(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_wrap_mode_740_comment =
  "C++ Interface:\n"
  "string_wrap_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the WrapMode value associated with the given string representation,\n"
  " * or WM_unspecified if the string does not match any known WrapMode value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_wrap_mode_740_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::FilterType EggTexture::string_filter_type(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_filter_type_741(PyObject *, PyObject *arg) {
  // 1-static EggTexture::FilterType EggTexture::string_filter_type(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTexture::FilterType return_value = EggTexture::string_filter_type(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_filter_type(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_filter_type_741_comment =
  "C++ Interface:\n"
  "string_filter_type(str string)\n"
  "\n"
  "/**\n"
  " * Returns the FilterType value associated with the given string\n"
  " * representation, or FT_unspecified if the string does not match any known\n"
  " * FilterType value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_filter_type_741_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::EnvType EggTexture::string_env_type(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_env_type_742(PyObject *, PyObject *arg) {
  // 1-static EggTexture::EnvType EggTexture::string_env_type(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTexture::EnvType return_value = EggTexture::string_env_type(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_env_type(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_env_type_742_comment =
  "C++ Interface:\n"
  "string_env_type(str string)\n"
  "\n"
  "/**\n"
  " * Returns the EnvType value associated with the given string representation,\n"
  " * or ET_unspecified if the string does not match any known EnvType value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_env_type_742_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::CombineMode EggTexture::string_combine_mode(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_combine_mode_743(PyObject *, PyObject *arg) {
  // 1-static EggTexture::CombineMode EggTexture::string_combine_mode(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTexture::CombineMode return_value = EggTexture::string_combine_mode(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_combine_mode(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_combine_mode_743_comment =
  "C++ Interface:\n"
  "string_combine_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the CombineMode value associated with the given string\n"
  " * representation, or CM_unspecified if the string does not match any known\n"
  " * CombineMode value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_combine_mode_743_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::CombineSource EggTexture::string_combine_source(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_combine_source_744(PyObject *, PyObject *arg) {
  // 1-static EggTexture::CombineSource EggTexture::string_combine_source(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTexture::CombineSource return_value = EggTexture::string_combine_source(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_combine_source(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_combine_source_744_comment =
  "C++ Interface:\n"
  "string_combine_source(str string)\n"
  "\n"
  "/**\n"
  " * Returns the CombineSource value associated with the given string\n"
  " * representation, or CS_unspecified if the string does not match any known\n"
  " * CombineSource value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_combine_source_744_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::CombineOperand EggTexture::string_combine_operand(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_combine_operand_745(PyObject *, PyObject *arg) {
  // 1-static EggTexture::CombineOperand EggTexture::string_combine_operand(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTexture::CombineOperand return_value = EggTexture::string_combine_operand(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_combine_operand(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_combine_operand_745_comment =
  "C++ Interface:\n"
  "string_combine_operand(str string)\n"
  "\n"
  "/**\n"
  " * Returns the CombineOperand value associated with the given string\n"
  " * representation, or CO_unspecified if the string does not match any known\n"
  " * CombineOperand value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_combine_operand_745_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::TexGen EggTexture::string_tex_gen(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_tex_gen_746(PyObject *, PyObject *arg) {
  // 1-static EggTexture::TexGen EggTexture::string_tex_gen(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTexture::TexGen return_value = EggTexture::string_tex_gen(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_tex_gen(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_tex_gen_746_comment =
  "C++ Interface:\n"
  "string_tex_gen(str string)\n"
  "\n"
  "/**\n"
  " * Returns the TexGen value associated with the given string representation,\n"
  " * or ET_unspecified if the string does not match any known TexGen value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_tex_gen_746_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::QualityLevel EggTexture::string_quality_level(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_quality_level_747(PyObject *, PyObject *arg) {
  // 1-static EggTexture::QualityLevel EggTexture::string_quality_level(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTexture::QualityLevel return_value = EggTexture::string_quality_level(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_quality_level(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_quality_level_747_comment =
  "C++ Interface:\n"
  "string_quality_level(str string)\n"
  "\n"
  "/**\n"
  " * Returns the TexGen value associated with the given string representation,\n"
  " * or ET_unspecified if the string does not match any known TexGen value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_quality_level_747_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggTexture::get_class_type(void)
 */
static PyObject *Dtool_EggTexture_get_class_type_782(PyObject *, PyObject *) {
  // 1-static TypeHandle EggTexture::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggTexture::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_class_type_782_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggTexture_get_class_type_782_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggFilenameNode *EggTexture::upcast_to_EggFilenameNode(void)
 */
static PyObject *Dtool_EggTexture_upcast_to_EggFilenameNode_609(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.upcast_to_EggFilenameNode")) {
    return NULL;
  }
  // 1-EggFilenameNode *EggTexture::upcast_to_EggFilenameNode(void)
  EggFilenameNode *return_value = (EggFilenameNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggFilenameNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_upcast_to_EggFilenameNode_609_comment =
  "C++ Interface:\n"
  "upcast_to_EggFilenameNode(const EggTexture self)\n"
  "\n"
  "upcast from EggTexture to EggFilenameNode";
#else
static const char *Dtool_EggTexture_upcast_to_EggFilenameNode_609_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggRenderMode *EggTexture::upcast_to_EggRenderMode(void)
 */
static PyObject *Dtool_EggTexture_upcast_to_EggRenderMode_611(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.upcast_to_EggRenderMode")) {
    return NULL;
  }
  // 1-EggRenderMode *EggTexture::upcast_to_EggRenderMode(void)
  EggRenderMode *return_value = (EggRenderMode *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_upcast_to_EggRenderMode_611_comment =
  "C++ Interface:\n"
  "upcast_to_EggRenderMode(const EggTexture self)\n"
  "\n"
  "upcast from EggTexture to EggRenderMode";
#else
static const char *Dtool_EggTexture_upcast_to_EggRenderMode_611_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggTransform *EggTexture::upcast_to_EggTransform(void)
 */
static PyObject *Dtool_EggTexture_upcast_to_EggTransform_613(PyObject *self, PyObject *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.upcast_to_EggTransform")) {
    return NULL;
  }
  // 1-EggTransform *EggTexture::upcast_to_EggTransform(void)
  EggTransform *return_value = (EggTransform *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_upcast_to_EggTransform_613_comment =
  "C++ Interface:\n"
  "upcast_to_EggTransform(const EggTexture self)\n"
  "\n"
  "upcast from EggTexture to EggTransform";
#else
static const char *Dtool_EggTexture_upcast_to_EggTransform_613_comment = NULL;
#endif

static PyObject *Dtool_EggTexture_texture_type_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::TextureType EggTexture::get_texture_type(void) const
  EggTexture::TextureType return_value = (*(const EggTexture*)local_this).get_texture_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_texture_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.texture_type")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete texture_type attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_texture_type(EggTexture::TextureType texture_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_texture_type((EggTexture::TextureType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texture_type(const EggTexture self, int texture_type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_format_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::Format EggTexture::get_format(void) const
  EggTexture::Format return_value = (*(const EggTexture*)local_this).get_format();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_format_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.format")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete format attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_format(EggTexture::Format format)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_format((EggTexture::Format)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_format(const EggTexture self, int format)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_compression_mode_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::CompressionMode EggTexture::get_compression_mode(void) const
  EggTexture::CompressionMode return_value = (*(const EggTexture*)local_this).get_compression_mode();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_compression_mode_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.compression_mode")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete compression_mode attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_compression_mode(EggTexture::CompressionMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_compression_mode((EggTexture::CompressionMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_compression_mode(const EggTexture self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_wrap_mode_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_mode(void) const
  EggTexture::WrapMode return_value = (*(const EggTexture*)local_this).get_wrap_mode();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_wrap_mode_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.wrap_mode")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete wrap_mode attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_wrap_mode(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_wrap_mode((EggTexture::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_mode(const EggTexture self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_wrap_u_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_u(void) const
  EggTexture::WrapMode return_value = (*(const EggTexture*)local_this).get_wrap_u();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_wrap_u_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.wrap_u")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete wrap_u attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_wrap_u(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_wrap_u((EggTexture::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_u(const EggTexture self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_wrap_v_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_v(void) const
  EggTexture::WrapMode return_value = (*(const EggTexture*)local_this).get_wrap_v();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_wrap_v_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.wrap_v")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete wrap_v attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_wrap_v(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_wrap_v((EggTexture::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_v(const EggTexture self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_wrap_w_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_w(void) const
  EggTexture::WrapMode return_value = (*(const EggTexture*)local_this).get_wrap_w();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_wrap_w_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.wrap_w")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete wrap_w attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_wrap_w(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_wrap_w((EggTexture::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_w(const EggTexture self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_minfilter_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::FilterType EggTexture::get_minfilter(void) const
  EggTexture::FilterType return_value = (*(const EggTexture*)local_this).get_minfilter();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_minfilter_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.minfilter")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete minfilter attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_minfilter(EggTexture::FilterType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_minfilter((EggTexture::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_minfilter(const EggTexture self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_magfilter_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::FilterType EggTexture::get_magfilter(void) const
  EggTexture::FilterType return_value = (*(const EggTexture*)local_this).get_magfilter();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_magfilter_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.magfilter")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete magfilter attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_magfilter(EggTexture::FilterType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_magfilter((EggTexture::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_magfilter(const EggTexture self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_anisotropic_degree_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_anisotropic_degree()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_anisotropic_degree(void) const
  int return_value = (*(const EggTexture*)local_this).get_anisotropic_degree();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_anisotropic_degree_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.anisotropic_degree")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete anisotropic_degree attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_anisotropic_degree();
    return 0;
  }
  // 1-inline void EggTexture::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_anisotropic_degree((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const EggTexture self, int anisotropic_degree)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_env_type_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::EnvType EggTexture::get_env_type(void) const
  EggTexture::EnvType return_value = (*(const EggTexture*)local_this).get_env_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_env_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.env_type")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete env_type attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_env_type(EggTexture::EnvType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_env_type((EggTexture::EnvType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_env_type(const EggTexture self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_saved_result_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggTexture::get_saved_result(void) const
  bool return_value = (*(const EggTexture*)local_this).get_saved_result();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_saved_result_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.saved_result")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete saved_result attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_saved_result(bool saved_result)
  (*local_this).set_saved_result((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_saved_result(const EggTexture self, bool saved_result)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_tex_gen_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::TexGen EggTexture::get_tex_gen(void) const
  EggTexture::TexGen return_value = (*(const EggTexture*)local_this).get_tex_gen();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_tex_gen_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.tex_gen")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete tex_gen attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_tex_gen(EggTexture::TexGen tex_gen)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_tex_gen((EggTexture::TexGen)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tex_gen(const EggTexture self, int tex_gen)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_quality_level_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggTexture::QualityLevel EggTexture::get_quality_level(void) const
  EggTexture::QualityLevel return_value = (*(const EggTexture*)local_this).get_quality_level();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_quality_level_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.quality_level")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete quality_level attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_quality_level(EggTexture::QualityLevel quality_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_quality_level((EggTexture::QualityLevel)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_quality_level(const EggTexture self, int quality_level)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_stage_name_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_stage_name()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline std::string const &EggTexture::get_stage_name(void) const
  std::string const &return_value = (*(const EggTexture*)local_this).get_stage_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_stage_name_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.stage_name")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete stage_name attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_stage_name();
    return 0;
  }
  // 1-inline void EggTexture::set_stage_name(std::string const &stage_name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_stage_name(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_stage_name(const EggTexture self, str stage_name)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_priority_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_priority()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_priority(void) const
  int return_value = (*(const EggTexture*)local_this).get_priority();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_priority_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.priority")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete priority attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_priority();
    return 0;
  }
  // 1-inline void EggTexture::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_priority((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_priority(const EggTexture self, int priority)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_color_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor const &EggTexture::get_color(void) const
  LColor const *return_value = &((*(const EggTexture*)local_this).get_color());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_EggTexture_color_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_color();
    return 0;
  }
  // 1-inline void EggTexture::set_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_color(const EggTexture self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_border_color_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_border_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor const &EggTexture::get_border_color(void) const
  LColor const *return_value = &((*(const EggTexture*)local_this).get_border_color());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_EggTexture_border_color_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.border_color")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete border_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_border_color();
    return 0;
  }
  // 1-inline void EggTexture::set_border_color(LColor const &border_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_border_color", "LVecBase4f");
    return -1;
  }
  (*local_this).set_border_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_border_color(const EggTexture self, const LVecBase4f border_color)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_uv_name_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_uv_name()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline std::string const &EggTexture::get_uv_name(void) const
  std::string const &return_value = (*(const EggTexture*)local_this).get_uv_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_uv_name_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.uv_name")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete uv_name attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_uv_name();
    return 0;
  }
  // 1-inline void EggTexture::set_uv_name(std::string const &uv_name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_uv_name(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_uv_name(const EggTexture self, str uv_name)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_rgb_scale_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_rgb_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_rgb_scale(void) const
  int return_value = (*(const EggTexture*)local_this).get_rgb_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_rgb_scale_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.rgb_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete rgb_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_rgb_scale();
    return 0;
  }
  // 1-inline void EggTexture::set_rgb_scale(int rgb_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_rgb_scale((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_rgb_scale(const EggTexture self, int rgb_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_alpha_scale_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_alpha_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_alpha_scale(void) const
  int return_value = (*(const EggTexture*)local_this).get_alpha_scale();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_alpha_scale_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.alpha_scale")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete alpha_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_alpha_scale();
    return 0;
  }
  // 1-inline void EggTexture::set_alpha_scale(int alpha_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_alpha_scale((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_scale(const EggTexture self, int alpha_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_alpha_filename_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_alpha_filename()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline Filename const &EggTexture::get_alpha_filename(void) const
  Filename const *return_value = &((*(const EggTexture*)local_this).get_alpha_filename());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_EggTexture_alpha_filename_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.alpha_filename")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete alpha_filename attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_alpha_filename();
    return 0;
  }
  // 1-inline void EggTexture::set_alpha_filename(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_alpha_filename", "Filename");
    return -1;
  }
  (*local_this).set_alpha_filename(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_filename(const EggTexture self, const Filename filename)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_alpha_fullpath_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline Filename const &EggTexture::get_alpha_fullpath(void) const
  Filename const *return_value = &((*(const EggTexture*)local_this).get_alpha_fullpath());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_EggTexture_alpha_fullpath_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.alpha_fullpath")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete alpha_fullpath attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_alpha_fullpath(Filename const &fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_alpha_fullpath", "Filename");
    return -1;
  }
  (*local_this).set_alpha_fullpath(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_fullpath(const EggTexture self, const Filename fullpath)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_alpha_file_channel_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_alpha_file_channel()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_alpha_file_channel(void) const
  int return_value = (*(const EggTexture*)local_this).get_alpha_file_channel();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_alpha_file_channel_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.alpha_file_channel")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete alpha_file_channel attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_alpha_file_channel();
    return 0;
  }
  // 1-inline void EggTexture::set_alpha_file_channel(int alpha_file_channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_alpha_file_channel((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_file_channel(const EggTexture self, int alpha_file_channel)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_multiview_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggTexture::get_multiview(void) const
  bool return_value = (*(const EggTexture*)local_this).get_multiview();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_multiview_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.multiview")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete multiview attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_multiview(bool multiview)
  (*local_this).set_multiview((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_multiview(const EggTexture self, bool multiview)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_num_views_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_num_views()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_num_views(void) const
  int return_value = (*(const EggTexture*)local_this).get_num_views();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_num_views_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.num_views")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete num_views attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_num_views();
    return 0;
  }
  // 1-inline void EggTexture::set_num_views(int num_views)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_num_views((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_num_views(const EggTexture self, int num_views)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_read_mipmaps_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggTexture::get_read_mipmaps(void) const
  bool return_value = (*(const EggTexture*)local_this).get_read_mipmaps();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_read_mipmaps_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.read_mipmaps")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete read_mipmaps attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_read_mipmaps(bool read_mipmaps)
  (*local_this).set_read_mipmaps((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_read_mipmaps(const EggTexture self, bool read_mipmaps)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_min_lod_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_min_lod()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggTexture::get_min_lod(void) const
  double return_value = (*(const EggTexture*)local_this).get_min_lod();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_min_lod_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.min_lod")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete min_lod attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_min_lod();
    return 0;
  }
  // 1-inline void EggTexture::set_min_lod(double min_lod)
  if (PyNumber_Check(arg)) {
    (*local_this).set_min_lod(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_min_lod(const EggTexture self, double min_lod)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_max_lod_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_max_lod()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggTexture::get_max_lod(void) const
  double return_value = (*(const EggTexture*)local_this).get_max_lod();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_max_lod_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.max_lod")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete max_lod attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_max_lod();
    return 0;
  }
  // 1-inline void EggTexture::set_max_lod(double max_lod)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_lod(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_lod(const EggTexture self, double max_lod)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_lod_bias_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_lod_bias()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggTexture::get_lod_bias(void) const
  double return_value = (*(const EggTexture*)local_this).get_lod_bias();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_lod_bias_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.lod_bias")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete lod_bias attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_lod_bias();
    return 0;
  }
  // 1-inline void EggTexture::set_lod_bias(double lod_bias)
  if (PyNumber_Check(arg)) {
    (*local_this).set_lod_bias(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_lod_bias(const EggTexture self, double lod_bias)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_multitexture_sort_Getter(PyObject *self, void *) {
  const EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int EggTexture::get_multitexture_sort(void) const
  int return_value = (*(const EggTexture*)local_this).get_multitexture_sort();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * EggTexture::EggTexture(EggTexture const &copy)
 * EggTexture::EggTexture(std::string const &tref_name, Filename const &filename)
 */
static int Dtool_Init_EggTexture(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-EggTexture::EggTexture(EggTexture const &copy)
      CPT(EggTexture) arg_this;
      if (!Dtool_ConstCoerce_EggTexture(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "EggTexture.EggTexture", "EggTexture");
        return -1;
      }
      EggTexture *return_value = new EggTexture(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTexture, true, false);
    }
    break;
  case 2:
    {
      // 1-EggTexture::EggTexture(std::string const &tref_name, Filename const &filename)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"tref_name", "filename", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggTexture", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "EggTexture.EggTexture", "Filename");
          return -1;
        }
        EggTexture *return_value = new EggTexture(std::string(param0_str, param0_len), *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTexture, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggTexture() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggTexture(const EggTexture copy)\n"
      "EggTexture(str tref_name, const Filename filename)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggTexture(PyObject *args, CPT(EggTexture) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggTexture, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-EggTexture::EggTexture(std::string const &tref_name, Filename const &filename)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:EggTexture", &param0_str, &param0_len, &param1)) {
        Filename const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
        if (param1_this != NULL) {
          EggTexture *return_value = new EggTexture(std::string(param0_str, param0_len), *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_EggTexture(PyObject *args, PT(EggTexture) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggTexture, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-EggTexture::EggTexture(std::string const &tref_name, Filename const &filename)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:EggTexture", &param0_str, &param0_len, &param1)) {
        Filename const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
        if (param1_this != NULL) {
          EggTexture *return_value = new EggTexture(std::string(param0_str, param0_len), *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggTexture(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggTexture) {
    printf("EggTexture ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggTexture *local_this = (EggTexture *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggTexture) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggFilenameNode) {
    return (EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggTransform) {
    return (EggTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggTexture(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggTexture) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggFilenameNode) {
    EggFilenameNode* other_this = (EggFilenameNode*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_EggTransform) {
    EggTransform* other_this = (EggTransform*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggTexture*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggMaterial
 */
/**
 * Python function wrapper for:
 * bool EggMaterial::is_equivalent_to(EggMaterial const &other, int eq) const
 */
static PyObject *Dtool_EggMaterial_is_equivalent_to_786(PyObject *self, PyObject *args, PyObject *kwds) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggMaterial::is_equivalent_to(EggMaterial const &other, int eq) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"other", "eq", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:is_equivalent_to", (char **)keyword_list, &param1, &param2)) {
    CPT(EggMaterial) param1_this;
    if (!Dtool_ConstCoerce_EggMaterial(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggMaterial.is_equivalent_to", "EggMaterial");
    }
    bool return_value = (*(const EggMaterial*)local_this).is_equivalent_to(*MOVE(param1_this), (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_equivalent_to(EggMaterial self, const EggMaterial other, int eq)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_is_equivalent_to_786_comment =
  "C++ Interface:\n"
  "is_equivalent_to(EggMaterial self, const EggMaterial other, int eq)\n"
  "\n"
  "/**\n"
  " * Returns true if the two materials are equivalent in all relevant properties\n"
  " * (according to eq), false otherwise.\n"
  " *\n"
  " * The Equivalence parameter, eq, should be set to the bitwise OR of the\n"
  " * following properties, according to what you consider relevant:\n"
  " *\n"
  " * EggMaterial::E_attributes: All material attributes (diff, spec, etc.)\n"
  " * except MRef name.\n"
  " *\n"
  " * EggMaterial::E_mref_name: The MRef name.\n"
  " */";
#else
static const char *Dtool_EggMaterial_is_equivalent_to_786_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggMaterial::sorts_less_than(EggMaterial const &other, int eq) const
 */
static PyObject *Dtool_EggMaterial_sorts_less_than_787(PyObject *self, PyObject *args, PyObject *kwds) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggMaterial::sorts_less_than(EggMaterial const &other, int eq) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"other", "eq", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:sorts_less_than", (char **)keyword_list, &param1, &param2)) {
    CPT(EggMaterial) param1_this;
    if (!Dtool_ConstCoerce_EggMaterial(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggMaterial.sorts_less_than", "EggMaterial");
    }
    bool return_value = (*(const EggMaterial*)local_this).sorts_less_than(*MOVE(param1_this), (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sorts_less_than(EggMaterial self, const EggMaterial other, int eq)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_sorts_less_than_787_comment =
  "C++ Interface:\n"
  "sorts_less_than(EggMaterial self, const EggMaterial other, int eq)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two materials for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique materials,\n"
  " * according to the indicated Equivalence factor.  See is_equivalent_to().\n"
  " */";
#else
static const char *Dtool_EggMaterial_sorts_less_than_787_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_base(LColor const &base)
 */
static PyObject *Dtool_EggMaterial_set_base_788(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_base")) {
    return NULL;
  }
  // 1-inline void EggMaterial::set_base(LColor const &base)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_base", "LVecBase4f");
  }
  (*local_this).set_base(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_base(const EggMaterial self, const LVecBase4f base)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_base_788_comment =
  "C++ Interface:\n"
  "set_base(const EggMaterial self, const LVecBase4f base)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_base_788_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_base(void)
 */
static PyObject *Dtool_EggMaterial_clear_base_789(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_base")) {
    return NULL;
  }
  // 1-inline void EggMaterial::clear_base(void)
  (*local_this).clear_base();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_base_789_comment =
  "C++ Interface:\n"
  "clear_base(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_base_789_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_base(void) const
 */
static PyObject *Dtool_EggMaterial_has_base_790(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggMaterial::has_base(void) const
  bool return_value = (*(const EggMaterial*)local_this).has_base();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_base_790_comment =
  "C++ Interface:\n"
  "has_base(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_base_790_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggMaterial::get_base(void) const
 */
static PyObject *Dtool_EggMaterial_get_base_791(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor EggMaterial::get_base(void) const
  LColor *return_value = new LColor((*(const EggMaterial*)local_this).get_base());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_base_791_comment =
  "C++ Interface:\n"
  "get_base(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * It is legal to call this even if has_base() returns false.  If so, it\n"
  " * simply returns the default base color.\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_base_791_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_diff(LColor const &diff)
 */
static PyObject *Dtool_EggMaterial_set_diff_792(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_diff")) {
    return NULL;
  }
  // 1-inline void EggMaterial::set_diff(LColor const &diff)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_diff", "LVecBase4f");
  }
  (*local_this).set_diff(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_diff(const EggMaterial self, const LVecBase4f diff)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_diff_792_comment =
  "C++ Interface:\n"
  "set_diff(const EggMaterial self, const LVecBase4f diff)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_diff_792_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_diff(void)
 */
static PyObject *Dtool_EggMaterial_clear_diff_793(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_diff")) {
    return NULL;
  }
  // 1-inline void EggMaterial::clear_diff(void)
  (*local_this).clear_diff();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_diff_793_comment =
  "C++ Interface:\n"
  "clear_diff(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_diff_793_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_diff(void) const
 */
static PyObject *Dtool_EggMaterial_has_diff_794(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggMaterial::has_diff(void) const
  bool return_value = (*(const EggMaterial*)local_this).has_diff();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_diff_794_comment =
  "C++ Interface:\n"
  "has_diff(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_diff_794_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggMaterial::get_diff(void) const
 */
static PyObject *Dtool_EggMaterial_get_diff_795(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor EggMaterial::get_diff(void) const
  LColor *return_value = new LColor((*(const EggMaterial*)local_this).get_diff());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_diff_795_comment =
  "C++ Interface:\n"
  "get_diff(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * It is legal to call this even if has_diff() returns false.  If so, it\n"
  " * simply returns the default diff color.\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_diff_795_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_amb(LColor const &amb)
 */
static PyObject *Dtool_EggMaterial_set_amb_796(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_amb")) {
    return NULL;
  }
  // 1-inline void EggMaterial::set_amb(LColor const &amb)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_amb", "LVecBase4f");
  }
  (*local_this).set_amb(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_amb(const EggMaterial self, const LVecBase4f amb)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_amb_796_comment =
  "C++ Interface:\n"
  "set_amb(const EggMaterial self, const LVecBase4f amb)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_amb_796_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_amb(void)
 */
static PyObject *Dtool_EggMaterial_clear_amb_797(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_amb")) {
    return NULL;
  }
  // 1-inline void EggMaterial::clear_amb(void)
  (*local_this).clear_amb();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_amb_797_comment =
  "C++ Interface:\n"
  "clear_amb(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_amb_797_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_amb(void) const
 */
static PyObject *Dtool_EggMaterial_has_amb_798(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggMaterial::has_amb(void) const
  bool return_value = (*(const EggMaterial*)local_this).has_amb();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_amb_798_comment =
  "C++ Interface:\n"
  "has_amb(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_amb_798_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggMaterial::get_amb(void) const
 */
static PyObject *Dtool_EggMaterial_get_amb_799(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor EggMaterial::get_amb(void) const
  LColor *return_value = new LColor((*(const EggMaterial*)local_this).get_amb());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_amb_799_comment =
  "C++ Interface:\n"
  "get_amb(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * It is legal to call this even if has_amb() returns false.  If so, it simply\n"
  " * returns the default amb color.\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_amb_799_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_emit(LColor const &emit)
 */
static PyObject *Dtool_EggMaterial_set_emit_800(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_emit")) {
    return NULL;
  }
  // 1-inline void EggMaterial::set_emit(LColor const &emit)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_emit", "LVecBase4f");
  }
  (*local_this).set_emit(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_emit(const EggMaterial self, const LVecBase4f emit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_emit_800_comment =
  "C++ Interface:\n"
  "set_emit(const EggMaterial self, const LVecBase4f emit)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_emit_800_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_emit(void)
 */
static PyObject *Dtool_EggMaterial_clear_emit_801(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_emit")) {
    return NULL;
  }
  // 1-inline void EggMaterial::clear_emit(void)
  (*local_this).clear_emit();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_emit_801_comment =
  "C++ Interface:\n"
  "clear_emit(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_emit_801_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_emit(void) const
 */
static PyObject *Dtool_EggMaterial_has_emit_802(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggMaterial::has_emit(void) const
  bool return_value = (*(const EggMaterial*)local_this).has_emit();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_emit_802_comment =
  "C++ Interface:\n"
  "has_emit(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_emit_802_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggMaterial::get_emit(void) const
 */
static PyObject *Dtool_EggMaterial_get_emit_803(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor EggMaterial::get_emit(void) const
  LColor *return_value = new LColor((*(const EggMaterial*)local_this).get_emit());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_emit_803_comment =
  "C++ Interface:\n"
  "get_emit(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * It is legal to call this even if has_emit() returns false.  If so, it\n"
  " * simply returns the default emit color.\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_emit_803_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_spec(LColor const &spec)
 */
static PyObject *Dtool_EggMaterial_set_spec_804(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_spec")) {
    return NULL;
  }
  // 1-inline void EggMaterial::set_spec(LColor const &spec)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_spec", "LVecBase4f");
  }
  (*local_this).set_spec(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_spec(const EggMaterial self, const LVecBase4f spec)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_spec_804_comment =
  "C++ Interface:\n"
  "set_spec(const EggMaterial self, const LVecBase4f spec)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_spec_804_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_spec(void)
 */
static PyObject *Dtool_EggMaterial_clear_spec_805(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_spec")) {
    return NULL;
  }
  // 1-inline void EggMaterial::clear_spec(void)
  (*local_this).clear_spec();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_spec_805_comment =
  "C++ Interface:\n"
  "clear_spec(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_spec_805_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_spec(void) const
 */
static PyObject *Dtool_EggMaterial_has_spec_806(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggMaterial::has_spec(void) const
  bool return_value = (*(const EggMaterial*)local_this).has_spec();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_spec_806_comment =
  "C++ Interface:\n"
  "has_spec(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_spec_806_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggMaterial::get_spec(void) const
 */
static PyObject *Dtool_EggMaterial_get_spec_807(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor EggMaterial::get_spec(void) const
  LColor *return_value = new LColor((*(const EggMaterial*)local_this).get_spec());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_spec_807_comment =
  "C++ Interface:\n"
  "get_spec(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * It is legal to call this even if has_spec() returns false.  If so, it\n"
  " * simply returns the default spec color.\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_spec_807_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_shininess(double shininess)
 */
static PyObject *Dtool_EggMaterial_set_shininess_808(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_shininess")) {
    return NULL;
  }
  // 1-inline void EggMaterial::set_shininess(double shininess)
  if (PyNumber_Check(arg)) {
    (*local_this).set_shininess(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shininess(const EggMaterial self, double shininess)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_shininess_808_comment =
  "C++ Interface:\n"
  "set_shininess(const EggMaterial self, double shininess)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_shininess_808_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_shininess(void)
 */
static PyObject *Dtool_EggMaterial_clear_shininess_809(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_shininess")) {
    return NULL;
  }
  // 1-inline void EggMaterial::clear_shininess(void)
  (*local_this).clear_shininess();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_shininess_809_comment =
  "C++ Interface:\n"
  "clear_shininess(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_shininess_809_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_shininess(void) const
 */
static PyObject *Dtool_EggMaterial_has_shininess_810(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggMaterial::has_shininess(void) const
  bool return_value = (*(const EggMaterial*)local_this).has_shininess();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_shininess_810_comment =
  "C++ Interface:\n"
  "has_shininess(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_shininess_810_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggMaterial::get_shininess(void) const
 */
static PyObject *Dtool_EggMaterial_get_shininess_811(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggMaterial::get_shininess(void) const
  double return_value = (*(const EggMaterial*)local_this).get_shininess();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_shininess_811_comment =
  "C++ Interface:\n"
  "get_shininess(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_shininess_811_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_roughness(double roughness)
 */
static PyObject *Dtool_EggMaterial_set_roughness_812(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_roughness")) {
    return NULL;
  }
  // 1-inline void EggMaterial::set_roughness(double roughness)
  if (PyNumber_Check(arg)) {
    (*local_this).set_roughness(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_roughness(const EggMaterial self, double roughness)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_roughness_812_comment =
  "C++ Interface:\n"
  "set_roughness(const EggMaterial self, double roughness)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_roughness_812_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_roughness(void)
 */
static PyObject *Dtool_EggMaterial_clear_roughness_813(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_roughness")) {
    return NULL;
  }
  // 1-inline void EggMaterial::clear_roughness(void)
  (*local_this).clear_roughness();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_roughness_813_comment =
  "C++ Interface:\n"
  "clear_roughness(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_roughness_813_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_roughness(void) const
 */
static PyObject *Dtool_EggMaterial_has_roughness_814(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggMaterial::has_roughness(void) const
  bool return_value = (*(const EggMaterial*)local_this).has_roughness();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_roughness_814_comment =
  "C++ Interface:\n"
  "has_roughness(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_roughness_814_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggMaterial::get_roughness(void) const
 */
static PyObject *Dtool_EggMaterial_get_roughness_815(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggMaterial::get_roughness(void) const
  double return_value = (*(const EggMaterial*)local_this).get_roughness();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_roughness_815_comment =
  "C++ Interface:\n"
  "get_roughness(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_roughness_815_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_metallic(double metallic)
 */
static PyObject *Dtool_EggMaterial_set_metallic_816(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_metallic")) {
    return NULL;
  }
  // 1-inline void EggMaterial::set_metallic(double metallic)
  if (PyNumber_Check(arg)) {
    (*local_this).set_metallic(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_metallic(const EggMaterial self, double metallic)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_metallic_816_comment =
  "C++ Interface:\n"
  "set_metallic(const EggMaterial self, double metallic)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_metallic_816_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_metallic(void)
 */
static PyObject *Dtool_EggMaterial_clear_metallic_817(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_metallic")) {
    return NULL;
  }
  // 1-inline void EggMaterial::clear_metallic(void)
  (*local_this).clear_metallic();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_metallic_817_comment =
  "C++ Interface:\n"
  "clear_metallic(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_metallic_817_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_metallic(void) const
 */
static PyObject *Dtool_EggMaterial_has_metallic_818(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggMaterial::has_metallic(void) const
  bool return_value = (*(const EggMaterial*)local_this).has_metallic();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_metallic_818_comment =
  "C++ Interface:\n"
  "has_metallic(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_metallic_818_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggMaterial::get_metallic(void) const
 */
static PyObject *Dtool_EggMaterial_get_metallic_819(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggMaterial::get_metallic(void) const
  double return_value = (*(const EggMaterial*)local_this).get_metallic();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_metallic_819_comment =
  "C++ Interface:\n"
  "get_metallic(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_metallic_819_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_ior(double ior)
 */
static PyObject *Dtool_EggMaterial_set_ior_820(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_ior")) {
    return NULL;
  }
  // 1-inline void EggMaterial::set_ior(double ior)
  if (PyNumber_Check(arg)) {
    (*local_this).set_ior(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ior(const EggMaterial self, double ior)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_ior_820_comment =
  "C++ Interface:\n"
  "set_ior(const EggMaterial self, double ior)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_ior_820_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_ior(void)
 */
static PyObject *Dtool_EggMaterial_clear_ior_821(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_ior")) {
    return NULL;
  }
  // 1-inline void EggMaterial::clear_ior(void)
  (*local_this).clear_ior();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_ior_821_comment =
  "C++ Interface:\n"
  "clear_ior(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_ior_821_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_ior(void) const
 */
static PyObject *Dtool_EggMaterial_has_ior_822(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggMaterial::has_ior(void) const
  bool return_value = (*(const EggMaterial*)local_this).has_ior();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_ior_822_comment =
  "C++ Interface:\n"
  "has_ior(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_ior_822_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggMaterial::get_ior(void) const
 */
static PyObject *Dtool_EggMaterial_get_ior_823(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggMaterial::get_ior(void) const
  double return_value = (*(const EggMaterial*)local_this).get_ior();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_ior_823_comment =
  "C++ Interface:\n"
  "get_ior(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_ior_823_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_local(bool local)
 */
static PyObject *Dtool_EggMaterial_set_local_824(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_local")) {
    return NULL;
  }
  // 1-inline void EggMaterial::set_local(bool local)
  (*local_this).set_local((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_local(const EggMaterial self, bool local)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_local_824_comment =
  "C++ Interface:\n"
  "set_local(const EggMaterial self, bool local)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_local_824_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_local(void)
 */
static PyObject *Dtool_EggMaterial_clear_local_825(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_local")) {
    return NULL;
  }
  // 1-inline void EggMaterial::clear_local(void)
  (*local_this).clear_local();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_local_825_comment =
  "C++ Interface:\n"
  "clear_local(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_local_825_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_local(void) const
 */
static PyObject *Dtool_EggMaterial_has_local_826(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggMaterial::has_local(void) const
  bool return_value = (*(const EggMaterial*)local_this).has_local();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_local_826_comment =
  "C++ Interface:\n"
  "has_local(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_local_826_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::get_local(void) const
 */
static PyObject *Dtool_EggMaterial_get_local_827(PyObject *self, PyObject *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggMaterial::get_local(void) const
  bool return_value = (*(const EggMaterial*)local_this).get_local();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_local_827_comment =
  "C++ Interface:\n"
  "get_local(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_local_827_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggMaterial::get_class_type(void)
 */
static PyObject *Dtool_EggMaterial_get_class_type_838(PyObject *, PyObject *) {
  // 1-static TypeHandle EggMaterial::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggMaterial::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_class_type_838_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggMaterial_get_class_type_838_comment = NULL;
#endif

static PyObject *Dtool_EggMaterial_base_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_base()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor EggMaterial::get_base(void) const
  LColor *return_value = new LColor((*(const EggMaterial*)local_this).get_base());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_EggMaterial_base_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.base")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete base attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_base();
    return 0;
  }
  // 1-inline void EggMaterial::set_base(LColor const &base)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_base", "LVecBase4f");
    return -1;
  }
  (*local_this).set_base(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_base(const EggMaterial self, const LVecBase4f base)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_diff_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_diff()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor EggMaterial::get_diff(void) const
  LColor *return_value = new LColor((*(const EggMaterial*)local_this).get_diff());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_EggMaterial_diff_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.diff")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete diff attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_diff();
    return 0;
  }
  // 1-inline void EggMaterial::set_diff(LColor const &diff)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_diff", "LVecBase4f");
    return -1;
  }
  (*local_this).set_diff(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_diff(const EggMaterial self, const LVecBase4f diff)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_amb_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_amb()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor EggMaterial::get_amb(void) const
  LColor *return_value = new LColor((*(const EggMaterial*)local_this).get_amb());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_EggMaterial_amb_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.amb")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete amb attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_amb();
    return 0;
  }
  // 1-inline void EggMaterial::set_amb(LColor const &amb)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_amb", "LVecBase4f");
    return -1;
  }
  (*local_this).set_amb(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_amb(const EggMaterial self, const LVecBase4f amb)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_emit_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_emit()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor EggMaterial::get_emit(void) const
  LColor *return_value = new LColor((*(const EggMaterial*)local_this).get_emit());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_EggMaterial_emit_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.emit")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete emit attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_emit();
    return 0;
  }
  // 1-inline void EggMaterial::set_emit(LColor const &emit)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_emit", "LVecBase4f");
    return -1;
  }
  (*local_this).set_emit(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_emit(const EggMaterial self, const LVecBase4f emit)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_spec_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_spec()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor EggMaterial::get_spec(void) const
  LColor *return_value = new LColor((*(const EggMaterial*)local_this).get_spec());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_EggMaterial_spec_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.spec")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete spec attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_spec();
    return 0;
  }
  // 1-inline void EggMaterial::set_spec(LColor const &spec)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_spec", "LVecBase4f");
    return -1;
  }
  (*local_this).set_spec(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_spec(const EggMaterial self, const LVecBase4f spec)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_shininess_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_shininess()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggMaterial::get_shininess(void) const
  double return_value = (*(const EggMaterial*)local_this).get_shininess();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggMaterial_shininess_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.shininess")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete shininess attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_shininess();
    return 0;
  }
  // 1-inline void EggMaterial::set_shininess(double shininess)
  if (PyNumber_Check(arg)) {
    (*local_this).set_shininess(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shininess(const EggMaterial self, double shininess)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_roughness_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_roughness()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggMaterial::get_roughness(void) const
  double return_value = (*(const EggMaterial*)local_this).get_roughness();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggMaterial_roughness_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.roughness")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete roughness attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_roughness();
    return 0;
  }
  // 1-inline void EggMaterial::set_roughness(double roughness)
  if (PyNumber_Check(arg)) {
    (*local_this).set_roughness(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_roughness(const EggMaterial self, double roughness)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_metallic_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_metallic()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggMaterial::get_metallic(void) const
  double return_value = (*(const EggMaterial*)local_this).get_metallic();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggMaterial_metallic_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.metallic")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete metallic attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_metallic();
    return 0;
  }
  // 1-inline void EggMaterial::set_metallic(double metallic)
  if (PyNumber_Check(arg)) {
    (*local_this).set_metallic(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_metallic(const EggMaterial self, double metallic)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_ior_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_ior()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggMaterial::get_ior(void) const
  double return_value = (*(const EggMaterial*)local_this).get_ior();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggMaterial_ior_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.ior")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete ior attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_ior();
    return 0;
  }
  // 1-inline void EggMaterial::set_ior(double ior)
  if (PyNumber_Check(arg)) {
    (*local_this).set_ior(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_ior(const EggMaterial self, double ior)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_local_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_local()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool EggMaterial::get_local(void) const
  bool return_value = (*(const EggMaterial*)local_this).get_local();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggMaterial_local_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.local")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete local attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_local();
    return 0;
  }
  // 1-inline void EggMaterial::set_local(bool local)
  (*local_this).set_local((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_local(const EggMaterial self, bool local)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * EggMaterial::EggMaterial(EggMaterial const &copy)
 * EggMaterial::EggMaterial(std::string const &mref_name)
 */
static int Dtool_Init_EggMaterial(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EggMaterial() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 EggMaterial::EggMaterial(EggMaterial const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggMaterial", (char **)keyword_list, &param0)) {
      EggMaterial const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggMaterial, (void **)&param0_this);
      if (param0_this != NULL) {
        EggMaterial *return_value = new EggMaterial(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggMaterial, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 EggMaterial::EggMaterial(std::string const &mref_name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"mref_name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggMaterial", (char **)keyword_list, &param0_str, &param0_len)) {
      EggMaterial *return_value = new EggMaterial(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggMaterial, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 EggMaterial::EggMaterial(EggMaterial const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggMaterial", (char **)keyword_list, &param0)) {
      CPT(EggMaterial) param0_this;
      if (Dtool_ConstCoerce_EggMaterial(param0, param0_this)) {
        EggMaterial *return_value = new EggMaterial(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggMaterial, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: EggMaterial::EggMaterial(std::string const &mref_name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggMaterial(const EggMaterial copy)\n"
      "EggMaterial(str mref_name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggMaterial(PyObject *args, CPT(EggMaterial) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggMaterial, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggMaterial::EggMaterial(std::string const &mref_name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggMaterial *return_value = new EggMaterial(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_EggMaterial(PyObject *args, PT(EggMaterial) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggMaterial, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggMaterial::EggMaterial(std::string const &mref_name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggMaterial *return_value = new EggMaterial(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_EggMaterial(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggMaterial) {
    printf("EggMaterial ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggMaterial *local_this = (EggMaterial *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggMaterial) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggMaterial(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggMaterial) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggMaterial*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggPrimitive
 */
/**
 * Python function wrapper for:
 * inline EggPrimitive &EggPrimitive::operator =(EggPrimitive const &copy)
 */
static PyObject *Dtool_EggPrimitive_operator_848(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.assign")) {
    return NULL;
  }
  // 1-inline EggPrimitive &EggPrimitive::operator =(EggPrimitive const &copy)
  CPT(EggPrimitive) arg_this;
  if (!Dtool_ConstCoerce_EggPrimitive(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggPrimitive.assign", "EggPrimitive");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggPrimitive *return_value = local_this;
  if (return_value != (EggPrimitive *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggPrimitive *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPrimitive, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggPrimitive self, const EggPrimitive copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_operator_848_comment =
  "C++ Interface:\n"
  "assign(const EggPrimitive self, const EggPrimitive copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPrimitive_operator_848_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggPrimitive *EggPrimitive::make_copy(void) const = 0
 */
static PyObject *Dtool_EggPrimitive_make_copy_850(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual EggPrimitive *EggPrimitive::make_copy(void) const = 0
  EggPrimitive *return_value = (*(const EggPrimitive*)local_this).make_copy();
  if (return_value != (EggPrimitive *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggPrimitive *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPrimitive, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_make_copy_850_comment =
  "C++ Interface:\n"
  "make_copy(EggPrimitive self)\n";
#else
static const char *Dtool_EggPrimitive_make_copy_850_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_alpha_mode(void)
 */
static PyObject *Dtool_EggPrimitive_determine_alpha_mode_851(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_alpha_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_alpha_mode(void)
  EggRenderMode *return_value = (*local_this).determine_alpha_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_alpha_mode_851_comment =
  "C++ Interface:\n"
  "determine_alpha_mode(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this primitive that has an\n"
  " * alpha_mode other than AM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_alpha_mode_851_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_depth_write_mode(void)
 */
static PyObject *Dtool_EggPrimitive_determine_depth_write_mode_852(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_depth_write_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_depth_write_mode(void)
  EggRenderMode *return_value = (*local_this).determine_depth_write_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_depth_write_mode_852_comment =
  "C++ Interface:\n"
  "determine_depth_write_mode(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_depth_write_mode_852_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_depth_test_mode(void)
 */
static PyObject *Dtool_EggPrimitive_determine_depth_test_mode_853(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_depth_test_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_depth_test_mode(void)
  EggRenderMode *return_value = (*local_this).determine_depth_test_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_depth_test_mode_853_comment =
  "C++ Interface:\n"
  "determine_depth_test_mode(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_depth_test_mode_853_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_visibility_mode(void)
 */
static PyObject *Dtool_EggPrimitive_determine_visibility_mode_854(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_visibility_mode")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_visibility_mode(void)
  EggRenderMode *return_value = (*local_this).determine_visibility_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_visibility_mode_854_comment =
  "C++ Interface:\n"
  "determine_visibility_mode(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_visibility_mode_854_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_depth_offset(void)
 */
static PyObject *Dtool_EggPrimitive_determine_depth_offset_855(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_depth_offset")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_depth_offset(void)
  EggRenderMode *return_value = (*local_this).determine_depth_offset();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_depth_offset_855_comment =
  "C++ Interface:\n"
  "determine_depth_offset(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this primitive that has a\n"
  " * depth_offset specified.  Returns a valid EggRenderMode pointer if one is\n"
  " * found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_depth_offset_855_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_draw_order(void)
 */
static PyObject *Dtool_EggPrimitive_determine_draw_order_856(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_draw_order")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_draw_order(void)
  EggRenderMode *return_value = (*local_this).determine_draw_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_draw_order_856_comment =
  "C++ Interface:\n"
  "determine_draw_order(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this primitive that has a\n"
  " * draw_order specified.  Returns a valid EggRenderMode pointer if one is\n"
  " * found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_draw_order_856_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_bin(void)
 */
static PyObject *Dtool_EggPrimitive_determine_bin_857(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_bin")) {
    return NULL;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_bin(void)
  EggRenderMode *return_value = (*local_this).determine_bin();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_bin_857_comment =
  "C++ Interface:\n"
  "determine_bin(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this primitive that has a bin\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_bin_857_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string EggPrimitive::get_sort_name(void) const
 */
static PyObject *Dtool_EggPrimitive_get_sort_name_858(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string EggPrimitive::get_sort_name(void) const
  std::string return_value = (*(const EggPrimitive*)local_this).get_sort_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_sort_name_858_comment =
  "C++ Interface:\n"
  "get_sort_name(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the primitive for the purposes of sorting primitives\n"
  " * into different groups, if there is one.\n"
  " *\n"
  " * Presently, this is defined as the primitive name itself, unless it begins\n"
  " * with a digit.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_sort_name_858_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggPrimitive::Shading EggPrimitive::get_shading(void) const
 */
static PyObject *Dtool_EggPrimitive_get_shading_859(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual EggPrimitive::Shading EggPrimitive::get_shading(void) const
  EggPrimitive::Shading return_value = (*(const EggPrimitive*)local_this).get_shading();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_shading_859_comment =
  "C++ Interface:\n"
  "get_shading(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the shading properties apparent on this particular primitive.  This\n"
  " * returns S_per_vertex if the vertices have colors or normals (and they are\n"
  " * not all the same values), or for a simple primitive, S_overall otherwise.\n"
  " * A composite primitive may also return S_per_face if the individual\n"
  " * component primitives have colors or normals that are not all the same\n"
  " * values.\n"
  " *\n"
  " * To get the most accurate results, you should call clear_shading() on all\n"
  " * connected primitives (or on all primitives in the egg file), followed by\n"
  " * get_shading() on each primitive.  You may find it easiest to call these\n"
  " * methods on the EggData root node (they are defined on EggGroupNode).\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_shading_859_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::clear_connected_shading(void)
 */
static PyObject *Dtool_EggPrimitive_clear_connected_shading_860(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.clear_connected_shading")) {
    return NULL;
  }
  // 1-inline void EggPrimitive::clear_connected_shading(void)
  (*local_this).clear_connected_shading();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_clear_connected_shading_860_comment =
  "C++ Interface:\n"
  "clear_connected_shading(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Resets the connected_shading member in this primitive, so that\n"
  " * get_connected_shading() will recompute a new value.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_clear_connected_shading_860_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggPrimitive::Shading EggPrimitive::get_connected_shading(void) const
 */
static PyObject *Dtool_EggPrimitive_get_connected_shading_861(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggPrimitive::Shading EggPrimitive::get_connected_shading(void) const
  EggPrimitive::Shading return_value = (*(const EggPrimitive*)local_this).get_connected_shading();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_connected_shading_861_comment =
  "C++ Interface:\n"
  "get_connected_shading(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Determines what sort of shading properties this primitive's connected\n"
  " * neighbors have.\n"
  " *\n"
  " * To get the most accurate results, you should first call\n"
  " * clear_connected_shading() on all connected primitives (or on all primitives\n"
  " * in the egg file). It might also be a good idea to call\n"
  " * remove_unused_vertices() to ensure proper connectivity.\n"
  " *\n"
  " * You may find it easiest to call these other methods on the EggData root\n"
  " * node (they are defined on EggGroupNode).\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_connected_shading_861_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::set_texture(EggTexture *texture)
 */
static PyObject *Dtool_EggPrimitive_set_texture_862(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.set_texture")) {
    return NULL;
  }
  // 1-inline void EggPrimitive::set_texture(EggTexture *texture)
  PT(EggTexture) arg_this;
  if (!Dtool_Coerce_EggTexture(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggPrimitive.set_texture", "EggTexture");
  }
  (*local_this).set_texture(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture(const EggPrimitive self, EggTexture texture)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_set_texture_862_comment =
  "C++ Interface:\n"
  "set_texture(const EggPrimitive self, EggTexture texture)\n"
  "\n"
  "/**\n"
  " * Replaces the current list of textures with the indicated texture.\n"
  " *\n"
  " * This method is deprecated and is used in support of single-texturing only.\n"
  " * Please use the multitexture variant add_texture instead.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_set_texture_862_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPrimitive::has_texture(void) const
 * inline bool EggPrimitive::has_texture(EggTexture *texture) const
 */
static PyObject *Dtool_EggPrimitive_has_texture_863(PyObject *self, PyObject *args) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool EggPrimitive::has_texture(void) const
      bool return_value = (*(const EggPrimitive*)local_this).has_texture();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline bool EggPrimitive::has_texture(EggTexture *texture) const
      PT(EggTexture) arg_this;
      if (!Dtool_Coerce_EggTexture(arg, arg_this)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "EggPrimitive.has_texture", "EggTexture");
      }
      bool return_value = (*(const EggPrimitive*)local_this).has_texture(MOVE(arg_this));
      return Dtool_Return_Bool(return_value);
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_texture() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_texture(EggPrimitive self)\n"
      "has_texture(EggPrimitive self, EggTexture texture)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_texture_863_comment =
  "C++ Interface:\n"
  "has_texture(EggPrimitive self)\n"
  "has_texture(EggPrimitive self, EggTexture texture)\n"
  "\n"
  "/**\n"
  " * Returns true if the primitive has any textures specified, false otherwise.\n"
  " *\n"
  " * This method is deprecated and is used in support of single-texturing only.\n"
  " * New code should be written to use the multitexture variants instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the primitive has the particular indicated texture, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_texture_863_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture *EggPrimitive::get_texture(void) const
 * inline EggTexture *EggPrimitive::get_texture(int n) const
 */
static PyObject *Dtool_EggPrimitive_get_texture_864(PyObject *self, PyObject *args) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggTexture *EggPrimitive::get_texture(void) const
      EggTexture *return_value = (*(const EggPrimitive*)local_this).get_texture();
      if (return_value != (EggTexture *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (EggTexture *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline EggTexture *EggPrimitive::get_texture(int n) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        EggTexture *return_value = (*(const EggPrimitive*)local_this).get_texture((int)arg_val);
        if (return_value != (EggTexture *)NULL) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != (EggTexture *)NULL) {
            unref_delete(return_value);
          }
          return NULL;
        }
        if (return_value == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_texture() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture(EggPrimitive self)\n"
      "get_texture(EggPrimitive self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_texture_864_comment =
  "C++ Interface:\n"
  "get_texture(EggPrimitive self)\n"
  "get_texture(EggPrimitive self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the first texture on the primitive, if any, or NULL if there are no\n"
  " * textures on the primitive.\n"
  " *\n"
  " * This method is deprecated and is used in support of single-texturing only.\n"
  " * New code should be written to use the multitexture variants instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the nth texture that has been applied to the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_texture_864_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::add_texture(EggTexture *texture)
 */
static PyObject *Dtool_EggPrimitive_add_texture_865(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.add_texture")) {
    return NULL;
  }
  // 1-inline void EggPrimitive::add_texture(EggTexture *texture)
  PT(EggTexture) arg_this;
  if (!Dtool_Coerce_EggTexture(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggPrimitive.add_texture", "EggTexture");
  }
  (*local_this).add_texture(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_texture(const EggPrimitive self, EggTexture texture)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_add_texture_865_comment =
  "C++ Interface:\n"
  "add_texture(const EggPrimitive self, EggTexture texture)\n"
  "\n"
  "/**\n"
  " * Applies the indicated texture to the primitive.\n"
  " *\n"
  " * Note that, in the case of multiple textures being applied to a single\n"
  " * primitive, the order in which the textures are applied does not affect the\n"
  " * rendering order; use EggTexture::set_sort() to specify that.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_add_texture_865_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::clear_texture(void)
 */
static PyObject *Dtool_EggPrimitive_clear_texture_866(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.clear_texture")) {
    return NULL;
  }
  // 1-inline void EggPrimitive::clear_texture(void)
  (*local_this).clear_texture();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_clear_texture_866_comment =
  "C++ Interface:\n"
  "clear_texture(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Removes any texturing from the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_clear_texture_866_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggPrimitive::get_num_textures(void) const
 */
static PyObject *Dtool_EggPrimitive_get_num_textures_867(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggPrimitive::get_num_textures(void) const
  int return_value = (*(const EggPrimitive*)local_this).get_num_textures();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_num_textures_867_comment =
  "C++ Interface:\n"
  "get_num_textures(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the number of textures applied to the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_num_textures_867_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::set_material(EggMaterial *material)
 */
static PyObject *Dtool_EggPrimitive_set_material_869(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.set_material")) {
    return NULL;
  }
  // 1-inline void EggPrimitive::set_material(EggMaterial *material)
  PT(EggMaterial) arg_this;
  if (!Dtool_Coerce_EggMaterial(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggPrimitive.set_material", "EggMaterial");
  }
  (*local_this).set_material(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_material(const EggPrimitive self, EggMaterial material)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_set_material_869_comment =
  "C++ Interface:\n"
  "set_material(const EggPrimitive self, EggMaterial material)\n"
  "\n"
  "/**\n"
  " * Applies the indicated material to the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_set_material_869_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::clear_material(void)
 */
static PyObject *Dtool_EggPrimitive_clear_material_870(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.clear_material")) {
    return NULL;
  }
  // 1-inline void EggPrimitive::clear_material(void)
  (*local_this).clear_material();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_clear_material_870_comment =
  "C++ Interface:\n"
  "clear_material(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Removes any material from the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_clear_material_870_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggMaterial *EggPrimitive::get_material(void) const
 */
static PyObject *Dtool_EggPrimitive_get_material_871(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggMaterial *EggPrimitive::get_material(void) const
  EggMaterial *return_value = (*(const EggPrimitive*)local_this).get_material();
  if (return_value != (EggMaterial *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggMaterial *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggMaterial, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_material_871_comment =
  "C++ Interface:\n"
  "get_material(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the applied material, or NULL if there is no material\n"
  " * applied.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_material_871_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPrimitive::has_material(void) const
 */
static PyObject *Dtool_EggPrimitive_has_material_872(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggPrimitive::has_material(void) const
  bool return_value = (*(const EggPrimitive*)local_this).has_material();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_material_872_comment =
  "C++ Interface:\n"
  "has_material(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if the primitive is materiald (and get_material() will return\n"
  " * a real pointer), false otherwise (and get_material() will return NULL).\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_material_872_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::set_bface_flag(bool flag)
 */
static PyObject *Dtool_EggPrimitive_set_bface_flag_873(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.set_bface_flag")) {
    return NULL;
  }
  // 1-inline void EggPrimitive::set_bface_flag(bool flag)
  (*local_this).set_bface_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bface_flag(const EggPrimitive self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_set_bface_flag_873_comment =
  "C++ Interface:\n"
  "set_bface_flag(const EggPrimitive self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the backfacing flag of the polygon.  If this is true, the polygon will\n"
  " * be rendered so that both faces are visible; if it is false, only the front\n"
  " * face of the polygon will be visible.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_set_bface_flag_873_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPrimitive::get_bface_flag(void) const
 */
static PyObject *Dtool_EggPrimitive_get_bface_flag_874(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggPrimitive::get_bface_flag(void) const
  bool return_value = (*(const EggPrimitive*)local_this).get_bface_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_bface_flag_874_comment =
  "C++ Interface:\n"
  "get_bface_flag(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Retrieves the backfacing flag of the polygon.  See set_bface_flag().\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_bface_flag_874_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggPrimitive::copy_attributes(EggAttributes const &other)
 * void EggPrimitive::copy_attributes(EggPrimitive const &other)
 */
static PyObject *Dtool_EggPrimitive_copy_attributes_883(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.copy_attributes")) {
    return NULL;
  }
  {
    // -2 void EggPrimitive::copy_attributes(EggPrimitive const &other)
    EggPrimitive const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggPrimitive, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).copy_attributes(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void EggPrimitive::copy_attributes(EggAttributes const &other)
    EggAttributes const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggAttributes, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).copy_attributes(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void EggPrimitive::copy_attributes(EggPrimitive const &other)
    CPT(EggPrimitive) arg_this;
    if (Dtool_ConstCoerce_EggPrimitive(arg, arg_this)) {
      (*local_this).copy_attributes(*MOVE(arg_this));
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void EggPrimitive::copy_attributes(EggAttributes const &other)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_attributes(const EggPrimitive self, const EggPrimitive other)\n"
      "copy_attributes(const EggPrimitive self, const EggAttributes other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_copy_attributes_883_comment =
  "C++ Interface:\n"
  "copy_attributes(const EggPrimitive self, const EggPrimitive other)\n"
  "copy_attributes(const EggPrimitive self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * Copies the rendering attributes from the indicated primitive.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies the rendering attributes from the indicated primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_copy_attributes_883_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggPrimitive::has_vertex_normal(void) const
 */
static PyObject *Dtool_EggPrimitive_has_vertex_normal_884(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggPrimitive::has_vertex_normal(void) const
  bool return_value = (*(const EggPrimitive*)local_this).has_vertex_normal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_vertex_normal_884_comment =
  "C++ Interface:\n"
  "has_vertex_normal(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex on the primitive has a specific normal set,\n"
  " * false otherwise.\n"
  " *\n"
  " * If you call unify_attributes() first, this will also return false even if\n"
  " * all the vertices were set to the same value (since unify_attributes()\n"
  " * removes redundant vertex properties).\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_vertex_normal_884_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggPrimitive::has_vertex_color(void) const
 */
static PyObject *Dtool_EggPrimitive_has_vertex_color_885(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggPrimitive::has_vertex_color(void) const
  bool return_value = (*(const EggPrimitive*)local_this).has_vertex_color();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_vertex_color_885_comment =
  "C++ Interface:\n"
  "has_vertex_color(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex on the primitive has a specific color set, false\n"
  " * otherwise.\n"
  " *\n"
  " * If you call unify_attributes() first, this will also return false even if\n"
  " * all the vertices were set to the same value (since unify_attributes()\n"
  " * removes redundant vertex properties).\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_vertex_color_885_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::unify_attributes(EggPrimitive::Shading shading)
 */
static PyObject *Dtool_EggPrimitive_unify_attributes_886(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.unify_attributes")) {
    return NULL;
  }
  // 1-virtual void EggPrimitive::unify_attributes(EggPrimitive::Shading shading)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).unify_attributes((EggPrimitive::Shading)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unify_attributes(const EggPrimitive self, int shading)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_unify_attributes_886_comment =
  "C++ Interface:\n"
  "unify_attributes(const EggPrimitive self, int shading)\n"
  "\n"
  "/**\n"
  " * If the shading property is S_per_vertex, ensures that all vertices have a\n"
  " * normal and a color, and the overall primitive does not.\n"
  " *\n"
  " * If the shading property is S_per_face, and this is a composite primitive,\n"
  " * ensures that all components have a normal and a color, and the vertices and\n"
  " * overall primitive do not.  (If this is a simple primitive, S_per_face works\n"
  " * the same as S_overall, below).\n"
  " *\n"
  " * If the shading property is S_overall, ensures that no vertices or\n"
  " * components have a normal or a color, and the overall primitive does (if any\n"
  " * exists at all).\n"
  " *\n"
  " * After this call, either the primitive will have normals or its vertices\n"
  " * will, but not both.  Ditto for colors.\n"
  " *\n"
  " * This may create redundant vertices in the vertex pool.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_unify_attributes_886_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::apply_last_attribute(void)
 */
static PyObject *Dtool_EggPrimitive_apply_last_attribute_887(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.apply_last_attribute")) {
    return NULL;
  }
  // 1-virtual void EggPrimitive::apply_last_attribute(void)
  (*local_this).apply_last_attribute();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_apply_last_attribute_887_comment =
  "C++ Interface:\n"
  "apply_last_attribute(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Sets the last vertex of the triangle (or each component) to the primitive\n"
  " * normal and/or color, if the primitive is flat-shaded.  This reflects the\n"
  " * OpenGL convention of storing flat-shaded properties on the last vertex,\n"
  " * although it is not usually a convention in Egg.\n"
  " *\n"
  " * This may introduce redundant vertices to the vertex pool.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_apply_last_attribute_887_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::apply_first_attribute(void)
 */
static PyObject *Dtool_EggPrimitive_apply_first_attribute_888(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.apply_first_attribute")) {
    return NULL;
  }
  // 1-virtual void EggPrimitive::apply_first_attribute(void)
  (*local_this).apply_first_attribute();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_apply_first_attribute_888_comment =
  "C++ Interface:\n"
  "apply_first_attribute(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Sets the first vertex of the triangle (or each component) to the primitive\n"
  " * normal and/or color, if the primitive is flat-shaded.  This reflects the\n"
  " * DirectX convention of storing flat-shaded properties on the first vertex,\n"
  " * although it is not usually a convention in Egg.\n"
  " *\n"
  " * This may introduce redundant vertices to the vertex pool.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_apply_first_attribute_888_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::post_apply_flat_attribute(void)
 */
static PyObject *Dtool_EggPrimitive_post_apply_flat_attribute_889(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.post_apply_flat_attribute")) {
    return NULL;
  }
  // 1-virtual void EggPrimitive::post_apply_flat_attribute(void)
  (*local_this).post_apply_flat_attribute();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_post_apply_flat_attribute_889_comment =
  "C++ Interface:\n"
  "post_apply_flat_attribute(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Intended as a followup to apply_last_attribute(), this also sets an\n"
  " * attribute on the first vertices of the primitive, if they don't already\n"
  " * have an attribute set, just so they end up with *something*.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_post_apply_flat_attribute_889_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::reverse_vertex_ordering(void)
 */
static PyObject *Dtool_EggPrimitive_reverse_vertex_ordering_890(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.reverse_vertex_ordering")) {
    return NULL;
  }
  // 1-virtual void EggPrimitive::reverse_vertex_ordering(void)
  (*local_this).reverse_vertex_ordering();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_reverse_vertex_ordering_890_comment =
  "C++ Interface:\n"
  "reverse_vertex_ordering(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Reverses the ordering of the vertices in this primitive, if appropriate, in\n"
  " * order to change the direction the polygon appears to be facing.  Does not\n"
  " * adjust the surface normal, if any.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_reverse_vertex_ordering_890_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggPrimitive::cleanup(void)
 */
static PyObject *Dtool_EggPrimitive_cleanup_891(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.cleanup")) {
    return NULL;
  }
  // 1-virtual bool EggPrimitive::cleanup(void)
  bool return_value = (*local_this).cleanup();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_cleanup_891_comment =
  "C++ Interface:\n"
  "cleanup(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Cleans up modeling errors in whatever context this makes sense.  For\n"
  " * instance, for a polygon, this calls remove_doubled_verts(true).  For a\n"
  " * point, it calls remove_nonunique_verts().  Returns true if the primitive is\n"
  " * valid, or false if it is degenerate.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_cleanup_891_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggPrimitive::remove_doubled_verts(bool closed)
 */
static PyObject *Dtool_EggPrimitive_remove_doubled_verts_892(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.remove_doubled_verts")) {
    return NULL;
  }
  // 1-void EggPrimitive::remove_doubled_verts(bool closed)
  (*local_this).remove_doubled_verts((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_doubled_verts(const EggPrimitive self, bool closed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_remove_doubled_verts_892_comment =
  "C++ Interface:\n"
  "remove_doubled_verts(const EggPrimitive self, bool closed)\n"
  "\n"
  "/**\n"
  " * Certain kinds of primitives, particularly polygons, don't like to have the\n"
  " * same vertex repeated consecutively.  Unfortunately, some modeling programs\n"
  " * (like MultiGen) make this an easy mistake to make.\n"
  " *\n"
  " * It's handy to have a function to remove these redundant vertices.  If\n"
  " * closed is true, it also checks that the first and last vertices are not the\n"
  " * same.\n"
  " *\n"
  " * This function identifies repeated vertices by position only; it does not\n"
  " * consider any other properties, such as color or UV, significant in\n"
  " * differentiating vertices.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_remove_doubled_verts_892_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggPrimitive::remove_nonunique_verts(void)
 */
static PyObject *Dtool_EggPrimitive_remove_nonunique_verts_893(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.remove_nonunique_verts")) {
    return NULL;
  }
  // 1-void EggPrimitive::remove_nonunique_verts(void)
  (*local_this).remove_nonunique_verts();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_remove_nonunique_verts_893_comment =
  "C++ Interface:\n"
  "remove_nonunique_verts(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Removes any multiple appearances of the same vertex from the primitive.\n"
  " * This primarily makes sense for a point primitive, which is really a\n"
  " * collection of points and which doesn't make sense to include the same point\n"
  " * twice, in any order.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_remove_nonunique_verts_893_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggPrimitive::has_primitives(void) const
 */
static PyObject *Dtool_EggPrimitive_has_primitives_894(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool EggPrimitive::has_primitives(void) const
  bool return_value = (*(const EggPrimitive*)local_this).has_primitives();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_primitives_894_comment =
  "C++ Interface:\n"
  "has_primitives(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are any primitives (e.g.  polygons) defined within\n"
  " * this group or below, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_primitives_894_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggPrimitive::joint_has_primitives(void) const
 */
static PyObject *Dtool_EggPrimitive_joint_has_primitives_895(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool EggPrimitive::joint_has_primitives(void) const
  bool return_value = (*(const EggPrimitive*)local_this).joint_has_primitives();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_joint_has_primitives_895_comment =
  "C++ Interface:\n"
  "joint_has_primitives(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are any primitives (e.g.  polygons) defined within\n"
  " * this group or below, but the search does not include nested joints.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_joint_has_primitives_895_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggPrimitive::has_normals(void) const
 */
static PyObject *Dtool_EggPrimitive_has_normals_896(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool EggPrimitive::has_normals(void) const
  bool return_value = (*(const EggPrimitive*)local_this).has_normals();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_normals_896_comment =
  "C++ Interface:\n"
  "has_normals(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if any of the primitives (e.g.  polygons) defined within this\n"
  " * group or below have either face or vertex normals defined, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_normals_896_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::clear(void)
 */
static PyObject *Dtool_EggPrimitive_clear_897(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.clear")) {
    return NULL;
  }
  // 1-inline void EggPrimitive::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_clear_897_comment =
  "C++ Interface:\n"
  "clear(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Removes all of the vertices from the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_clear_897_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggPrimitive::add_vertex(EggVertex *vertex)
 */
static PyObject *Dtool_EggPrimitive_add_vertex_898(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.add_vertex")) {
    return NULL;
  }
  // 1-EggVertex *EggPrimitive::add_vertex(EggVertex *vertex)
  EggVertex *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggPrimitive.add_vertex", false, true);
  if (arg_this != NULL) {
    EggVertex *return_value = (*local_this).add_vertex(arg_this);
    if (return_value != (EggVertex *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertex *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const EggPrimitive self, EggVertex vertex)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_add_vertex_898_comment =
  "C++ Interface:\n"
  "add_vertex(const EggPrimitive self, EggVertex vertex)\n"
  "\n"
  "/**\n"
  " * Adds the indicated vertex to the end of the primitive's list of vertices,\n"
  " * and returns it.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_add_vertex_898_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggPrimitive::remove_vertex(EggVertex *vertex)
 * void EggPrimitive::remove_vertex(std::size_t index)
 */
static PyObject *Dtool_EggPrimitive_remove_vertex_899(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.remove_vertex")) {
    return NULL;
  }
  {
    // -2 EggVertex *EggPrimitive::remove_vertex(EggVertex *vertex)
    EggVertex *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggPrimitive.remove_vertex", false, false);
    if (arg_this != NULL) {
      EggVertex *return_value = (*local_this).remove_vertex(arg_this);
      if (return_value != (EggVertex *)NULL) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != (EggVertex *)NULL) {
          unref_delete(return_value);
        }
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 void EggPrimitive::remove_vertex(std::size_t index)
    Py_ssize_t param1;
    if (PyArg_Parse(arg, "n:remove_vertex", &param1)) {
#ifndef NDEBUG
      if (param1 < 0) {
        return PyErr_Format(PyExc_OverflowError,
                            "can't convert negative value %zd to size_t",
                            param1);
      }
#endif
      (*local_this).remove_vertex((std::size_t)param1);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: EggVertex *EggPrimitive::remove_vertex(EggVertex *vertex)
  // No coercion possible: void EggPrimitive::remove_vertex(std::size_t index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_vertex(const EggPrimitive self, EggVertex vertex)\n"
      "remove_vertex(const EggPrimitive self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_remove_vertex_899_comment =
  "C++ Interface:\n"
  "remove_vertex(const EggPrimitive self, EggVertex vertex)\n"
  "remove_vertex(const EggPrimitive self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the indicated vertex from the primitive and returns it.  If the\n"
  " * vertex was not already in the primitive, does nothing and returns NULL.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the indicated vertex from the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_remove_vertex_899_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggPrimitive::copy_vertices(EggPrimitive const &other)
 */
static PyObject *Dtool_EggPrimitive_copy_vertices_900(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.copy_vertices")) {
    return NULL;
  }
  // 1-void EggPrimitive::copy_vertices(EggPrimitive const &other)
  CPT(EggPrimitive) arg_this;
  if (!Dtool_ConstCoerce_EggPrimitive(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggPrimitive.copy_vertices", "EggPrimitive");
  }
  (*local_this).copy_vertices(*MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_vertices(const EggPrimitive self, const EggPrimitive other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_copy_vertices_900_comment =
  "C++ Interface:\n"
  "copy_vertices(const EggPrimitive self, const EggPrimitive other)\n"
  "\n"
  "/**\n"
  " * Replaces the current primitive's list of vertices with a copy of the list\n"
  " * of vertices on the other primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_copy_vertices_900_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t EggPrimitive::get_num_vertices(void) const
 */
static PyObject *Dtool_EggPrimitive_get_num_vertices_901(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t EggPrimitive::get_num_vertices(void) const
  std::size_t return_value = (*(const EggPrimitive*)local_this).get_num_vertices();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_num_vertices_901_comment =
  "C++ Interface:\n"
  "get_num_vertices(EggPrimitive self)\n"
  "\n"
  "// These are shorthands if you don't want to use the iterators.\n"
  "\n"
  "// These are shorthands if you don't want to use the iterators.\n"
  "\n"
  "// These are shorthands if you don't want to use the iterators.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_num_vertices_901_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::set_vertex(std::size_t index, EggVertex *vertex)
 */
static PyObject *Dtool_EggPrimitive_set_vertex_902(PyObject *self, PyObject *args, PyObject *kwds) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.set_vertex")) {
    return NULL;
  }
  // 1-inline void EggPrimitive::set_vertex(std::size_t index, EggVertex *vertex)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "vertex", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_vertex", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    EggVertex *param2_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_EggVertex, 2, "EggPrimitive.set_vertex", false, true);
    if (param2_this != NULL) {
      (*local_this).set_vertex((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex(const EggPrimitive self, int index, EggVertex vertex)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_set_vertex_902_comment =
  "C++ Interface:\n"
  "set_vertex(const EggPrimitive self, int index, EggVertex vertex)\n"
  "\n"
  "/**\n"
  " * Replaces a particular vertex based on its index number in the list of\n"
  " * vertices.  This is just a convenience function for people who don't want to\n"
  " * mess with the iterators.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_set_vertex_902_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggVertex *EggPrimitive::get_vertex(std::size_t index) const
 */
static PyObject *Dtool_EggPrimitive_get_vertex_903(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggVertex *EggPrimitive::get_vertex(std::size_t index) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_vertex", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    EggVertex *return_value = (*(const EggPrimitive*)local_this).get_vertex((std::size_t)param1);
    if (return_value != (EggVertex *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertex *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(EggPrimitive self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_vertex_903_comment =
  "C++ Interface:\n"
  "get_vertex(EggPrimitive self, int index)\n"
  "\n"
  "/**\n"
  " * Returns a particular index based on its index number.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_vertex_903_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggVertexPool *EggPrimitive::get_pool(void) const
 */
static PyObject *Dtool_EggPrimitive_get_pool_905(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggVertexPool *EggPrimitive::get_pool(void) const
  EggVertexPool *return_value = (*(const EggPrimitive*)local_this).get_pool();
  if (return_value != (EggVertexPool *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggVertexPool *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexPool, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_pool_905_comment =
  "C++ Interface:\n"
  "get_pool(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex pool associated with the vertices of the primitive, or\n"
  " * NULL if the primitive has no vertices.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_pool_905_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::write(ostream &out, int indent_level) const = 0
 */
static PyObject *Dtool_EggPrimitive_write_910(PyObject *self, PyObject *args, PyObject *kwds) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void EggPrimitive::write(ostream &out, int indent_level) const = 0
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "EggPrimitive.write", false, true);
    if (param1_this != NULL) {
      (*(const EggPrimitive*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggPrimitive self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_write_910_comment =
  "C++ Interface:\n"
  "write(EggPrimitive self, ostream out, int indent_level)\n";
#else
static const char *Dtool_EggPrimitive_write_910_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggPrimitive::test_vref_integrity(void) const
 */
static PyObject *Dtool_EggPrimitive_test_vref_integrity_911(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggPrimitive::test_vref_integrity(void) const
  (*(const EggPrimitive*)local_this).test_vref_integrity();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_test_vref_integrity_911_comment =
  "C++ Interface:\n"
  "test_vref_integrity(EggPrimitive self)\n";
#else
static const char *Dtool_EggPrimitive_test_vref_integrity_911_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggPrimitive::get_class_type(void)
 */
static PyObject *Dtool_EggPrimitive_get_class_type_912(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPrimitive::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggPrimitive::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_class_type_912_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPrimitive_get_class_type_912_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggPrimitive::upcast_to_EggNode(void)
 */
static PyObject *Dtool_EggPrimitive_upcast_to_EggNode_841(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.upcast_to_EggNode")) {
    return NULL;
  }
  // 1-EggNode *EggPrimitive::upcast_to_EggNode(void)
  EggNode *return_value = (EggNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_upcast_to_EggNode_841_comment =
  "C++ Interface:\n"
  "upcast_to_EggNode(const EggPrimitive self)\n"
  "\n"
  "upcast from EggPrimitive to EggNode";
#else
static const char *Dtool_EggPrimitive_upcast_to_EggNode_841_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggAttributes *EggPrimitive::upcast_to_EggAttributes(void)
 */
static PyObject *Dtool_EggPrimitive_upcast_to_EggAttributes_843(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.upcast_to_EggAttributes")) {
    return NULL;
  }
  // 1-EggAttributes *EggPrimitive::upcast_to_EggAttributes(void)
  EggAttributes *return_value = (EggAttributes *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_upcast_to_EggAttributes_843_comment =
  "C++ Interface:\n"
  "upcast_to_EggAttributes(const EggPrimitive self)\n"
  "\n"
  "upcast from EggPrimitive to EggAttributes";
#else
static const char *Dtool_EggPrimitive_upcast_to_EggAttributes_843_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggRenderMode *EggPrimitive::upcast_to_EggRenderMode(void)
 */
static PyObject *Dtool_EggPrimitive_upcast_to_EggRenderMode_845(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.upcast_to_EggRenderMode")) {
    return NULL;
  }
  // 1-EggRenderMode *EggPrimitive::upcast_to_EggRenderMode(void)
  EggRenderMode *return_value = (EggRenderMode *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_upcast_to_EggRenderMode_845_comment =
  "C++ Interface:\n"
  "upcast_to_EggRenderMode(const EggPrimitive self)\n"
  "\n"
  "upcast from EggPrimitive to EggRenderMode";
#else
static const char *Dtool_EggPrimitive_upcast_to_EggRenderMode_845_comment = NULL;
#endif

static PyObject *Dtool_EggPrimitive_sort_name_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string EggPrimitive::get_sort_name(void) const
  std::string return_value = (*(const EggPrimitive*)local_this).get_sort_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_EggPrimitive_shading_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }

  // 1-virtual EggPrimitive::Shading EggPrimitive::get_shading(void) const
  EggPrimitive::Shading return_value = (*(const EggPrimitive*)local_this).get_shading();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_EggPrimitive_connected_shading_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggPrimitive::Shading EggPrimitive::get_connected_shading(void) const
  EggPrimitive::Shading return_value = (*(const EggPrimitive*)local_this).get_connected_shading();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property EggPrimitive::textures
 */
static Py_ssize_t Dtool_EggPrimitive_textures_Len(PyObject *self) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_textures();
}

/**
 * sequence getter for property EggPrimitive::textures
 */
static PyObject *Dtool_EggPrimitive_textures_Getitem(PyObject *self, Py_ssize_t index) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_textures()) {
    PyErr_SetString(PyExc_IndexError, "EggPrimitive.textures[] index out of range");
    return NULL;
  }
  // 1-inline EggTexture *EggPrimitive::get_texture(int n) const
  EggTexture *return_value = (*(const EggPrimitive*)local_this).get_texture(index);
  if (return_value != (EggTexture *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (EggTexture *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture(EggPrimitive self, index)\n");
  }
}

static PyObject *Dtool_EggPrimitive_textures_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_EggPrimitive_textures_Len;
  wrap->_getitem_func = &Dtool_EggPrimitive_textures_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static PyObject *Dtool_EggPrimitive_material_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_material()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline EggMaterial *EggPrimitive::get_material(void) const
  EggMaterial *return_value = (*(const EggPrimitive*)local_this).get_material();
  if (return_value != (EggMaterial *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (EggMaterial *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggMaterial, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_EggPrimitive_material_Setter(PyObject *self, PyObject *arg, void *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.material")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete material attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_material();
    return 0;
  }
  // 1-inline void EggPrimitive::set_material(EggMaterial *material)
  PT(EggMaterial) arg_this;
  if (!Dtool_Coerce_EggMaterial(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggPrimitive.set_material", "EggMaterial");
    return -1;
  }
  (*local_this).set_material(MOVE(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_material(const EggPrimitive self, EggMaterial material)\n");
  }
  return -1;
}

static PyObject *Dtool_EggPrimitive_bface_flag_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool EggPrimitive::get_bface_flag(void) const
  bool return_value = (*(const EggPrimitive*)local_this).get_bface_flag();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggPrimitive_bface_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.bface_flag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete bface_flag attribute");
    return -1;
  }
  // 1-inline void EggPrimitive::set_bface_flag(bool flag)
  (*local_this).set_bface_flag((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bface_flag(const EggPrimitive self, bool flag)\n");
  }
  return -1;
}

/**
 * sequence length function for property EggPrimitive::vertices
 */
static Py_ssize_t Dtool_EggPrimitive_vertices_Len(PyObject *self) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_vertices();
}

/**
 * sequence getter for property EggPrimitive::vertices
 */
static PyObject *Dtool_EggPrimitive_vertices_Getitem(PyObject *self, Py_ssize_t index) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_vertices()) {
    PyErr_SetString(PyExc_IndexError, "EggPrimitive.vertices[] index out of range");
    return NULL;
  }
  // 1-inline EggVertex *EggPrimitive::get_vertex(std::size_t index) const
  EggVertex *return_value = (*(const EggPrimitive*)local_this).get_vertex(index);
  if (return_value != (EggVertex *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (EggVertex *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(EggPrimitive self, index)\n");
  }
}

static int Dtool_EggPrimitive_vertices_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.vertices")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    local_this->remove_vertex(index);
    return 0;
  }
  // 1-inline void EggPrimitive::set_vertex(std::size_t index, EggVertex *vertex)
  EggVertex *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 2, "EggPrimitive.set_vertex", false, true);
  if (arg_this != NULL) {
    (*local_this).set_vertex(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_vertex(const EggPrimitive self, index, EggVertex vertex)\n");
  }
  return -1;
}

static PyObject *Dtool_EggPrimitive_vertices_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_EggPrimitive_vertices_Len;
  wrap->_getitem_func = &Dtool_EggPrimitive_vertices_Getitem;
  wrap->_setitem_func = &Dtool_EggPrimitive_vertices_Setitem;
  return (PyObject *)wrap;
}

static PyObject *Dtool_EggPrimitive_pool_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline EggVertexPool *EggPrimitive::get_pool(void) const
  EggVertexPool *return_value = (*(const EggPrimitive*)local_this).get_pool();
  if (return_value != (EggVertexPool *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (EggVertexPool *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexPool, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Init_EggPrimitive(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggPrimitive(PyObject *args, CPT(EggPrimitive) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggPrimitive, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggPrimitive(PyObject *args, PT(EggPrimitive) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggPrimitive, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggPrimitive_get_textures(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_textures();
  PyTupleObject args;
  PyObject_INIT_VAR(&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_EggPrimitive_get_texture_864(self, (PyObject *)&args);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggPrimitive_get_vertices(PyObject *self, PyObject *) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_vertices();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggPrimitive_get_vertex_903(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggPrimitive(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggPrimitive) {
    printf("EggPrimitive ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggPrimitive *local_this = (EggPrimitive *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggPrimitive(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPrimitive*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggCompositePrimitive
 */
/**
 * Python function wrapper for:
 * inline EggCompositePrimitive &EggCompositePrimitive::operator =(EggCompositePrimitive const &copy)
 */
static PyObject *Dtool_EggCompositePrimitive_operator_914(PyObject *self, PyObject *arg) {
  EggCompositePrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCompositePrimitive, (void **)&local_this, "EggCompositePrimitive.assign")) {
    return NULL;
  }
  // 1-inline EggCompositePrimitive &EggCompositePrimitive::operator =(EggCompositePrimitive const &copy)
  CPT(EggCompositePrimitive) arg_this;
  if (!Dtool_ConstCoerce_EggCompositePrimitive(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggCompositePrimitive.assign", "EggCompositePrimitive");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggCompositePrimitive *return_value = local_this;
  if (return_value != (EggCompositePrimitive *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggCompositePrimitive *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggCompositePrimitive, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggCompositePrimitive self, const EggCompositePrimitive copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_operator_914_comment =
  "C++ Interface:\n"
  "assign(const EggCompositePrimitive self, const EggCompositePrimitive copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_operator_914_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggCompositePrimitive::get_num_components(void) const
 */
static PyObject *Dtool_EggCompositePrimitive_get_num_components_915(PyObject *self, PyObject *) {
  EggCompositePrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCompositePrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggCompositePrimitive::get_num_components(void) const
  int return_value = (*(const EggCompositePrimitive*)local_this).get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_get_num_components_915_comment =
  "C++ Interface:\n"
  "get_num_components(EggCompositePrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the number of individual component triangles within the composite.\n"
  " * Each one of these might have a different set of attributes.\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_get_num_components_915_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggAttributes *EggCompositePrimitive::get_component(int i)
 * inline EggAttributes const *EggCompositePrimitive::get_component(int i) const
 */
static PyObject *Dtool_EggCompositePrimitive_get_component_916(PyObject *self, PyObject *arg) {
  EggCompositePrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCompositePrimitive, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline EggAttributes *EggCompositePrimitive::get_component(int i)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      EggAttributes *return_value = (*local_this).get_component((int)arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, false);
    }
  }

  {
    // -2 inline EggAttributes const *EggCompositePrimitive::get_component(int i) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      EggAttributes const *return_value = (*(const EggCompositePrimitive*)local_this).get_component((int)arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, true);
    }
  }

  // No coercion possible: inline EggAttributes *EggCompositePrimitive::get_component(int i)
  // No coercion possible: inline EggAttributes const *EggCompositePrimitive::get_component(int i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(const EggCompositePrimitive self, int i)\n"
      "get_component(EggCompositePrimitive self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_get_component_916_comment =
  "C++ Interface:\n"
  "get_component(const EggCompositePrimitive self, int i)\n"
  "get_component(EggCompositePrimitive self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the attributes for the nth component triangle.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the attributes for the nth component triangle.\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_get_component_916_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggCompositePrimitive::set_component(int i, EggAttributes const *attrib)
 */
static PyObject *Dtool_EggCompositePrimitive_set_component_918(PyObject *self, PyObject *args, PyObject *kwds) {
  EggCompositePrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCompositePrimitive, (void **)&local_this, "EggCompositePrimitive.set_component")) {
    return NULL;
  }
  // 1-inline void EggCompositePrimitive::set_component(int i, EggAttributes const *attrib)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"i", "attrib", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_component", (char **)keyword_list, &param1, &param2)) {
    EggAttributes const *param2_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_EggAttributes, 2, "EggCompositePrimitive.set_component", true, true);
    if (param2_this != NULL) {
      (*local_this).set_component((int)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_component(const EggCompositePrimitive self, int i, const EggAttributes attrib)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_set_component_918_comment =
  "C++ Interface:\n"
  "set_component(const EggCompositePrimitive self, int i, const EggAttributes attrib)\n"
  "\n"
  "/**\n"
  " * Changes the attributes for the nth component triangle.\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_set_component_918_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggCompositePrimitive::triangulate_into(EggGroupNode *container) const
 */
static PyObject *Dtool_EggCompositePrimitive_triangulate_into_921(PyObject *self, PyObject *arg) {
  EggCompositePrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCompositePrimitive, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggCompositePrimitive::triangulate_into(EggGroupNode *container) const
  PT(EggGroupNode) arg_this;
  if (!Dtool_Coerce_EggGroupNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggCompositePrimitive.triangulate_into", "EggGroupNode");
  }
  bool return_value = (*(const EggCompositePrimitive*)local_this).triangulate_into(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "triangulate_into(EggCompositePrimitive self, EggGroupNode container)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_triangulate_into_921_comment =
  "C++ Interface:\n"
  "triangulate_into(EggCompositePrimitive self, EggGroupNode container)\n"
  "\n"
  "/**\n"
  " * Subdivides the composite primitive into triangles and adds those triangles\n"
  " * to the indicated container.  Does not remove the primitive from its\n"
  " * existing parent or modify it in any way.\n"
  " *\n"
  " * Returns true if the triangulation is successful, or false if there was some\n"
  " * error (in which case the container may contain some partial triangulation).\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_triangulate_into_921_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< EggCompositePrimitive > EggCompositePrimitive::triangulate_in_place(void)
 */
static PyObject *Dtool_EggCompositePrimitive_triangulate_in_place_922(PyObject *self, PyObject *) {
  EggCompositePrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCompositePrimitive, (void **)&local_this, "EggCompositePrimitive.triangulate_in_place")) {
    return NULL;
  }
  // 1-PointerTo< EggCompositePrimitive > EggCompositePrimitive::triangulate_in_place(void)
  PointerTo< EggCompositePrimitive > return_value = (*local_this).triangulate_in_place();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  EggCompositePrimitive *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggCompositePrimitive, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_triangulate_in_place_922_comment =
  "C++ Interface:\n"
  "triangulate_in_place(const EggCompositePrimitive self)\n"
  "\n"
  "/**\n"
  " * Subdivides the composite primitive into triangles and adds those triangles\n"
  " * to the parent group node in place of the original primitive.  Returns a\n"
  " * pointer to the original primitive, which is likely about to be destructed.\n"
  " *\n"
  " * If convex_also is true, both concave and convex polygons will be subdivided\n"
  " * into triangles; otherwise, only concave polygons will be subdivided, and\n"
  " * convex polygons will be copied unchanged into the container.\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_triangulate_in_place_922_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggCompositePrimitive::get_class_type(void)
 */
static PyObject *Dtool_EggCompositePrimitive_get_class_type_923(PyObject *, PyObject *) {
  // 1-static TypeHandle EggCompositePrimitive::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggCompositePrimitive::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_get_class_type_923_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggCompositePrimitive_get_class_type_923_comment = NULL;
#endif

/**
 * sequence length function for property EggCompositePrimitive::components
 */
static Py_ssize_t Dtool_EggCompositePrimitive_components_Len(PyObject *self) {
  EggCompositePrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCompositePrimitive, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_components();
}

/**
 * sequence getter for property EggCompositePrimitive::components
 */
static PyObject *Dtool_EggCompositePrimitive_components_Getitem(PyObject *self, Py_ssize_t index) {
  EggCompositePrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCompositePrimitive, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_components()) {
    PyErr_SetString(PyExc_IndexError, "EggCompositePrimitive.components[] index out of range");
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline EggAttributes *EggCompositePrimitive::get_component(int i)
    EggAttributes *return_value = (*local_this).get_component(index);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, false);
  }

  {
    // -2 inline EggAttributes const *EggCompositePrimitive::get_component(int i) const
    EggAttributes const *return_value = (*(const EggCompositePrimitive*)local_this).get_component(index);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, true);
  }

  // No coercion possible: inline EggAttributes *EggCompositePrimitive::get_component(int i)
  // No coercion possible: inline EggAttributes const *EggCompositePrimitive::get_component(int i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(const EggCompositePrimitive self, index)\n"
      "get_component(EggCompositePrimitive self, index)\n");
  }
}

static int Dtool_EggCompositePrimitive_components_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  EggCompositePrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCompositePrimitive, (void **)&local_this, "EggCompositePrimitive.components")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete components[] attribute");
    return -1;
  }
  // 1-inline void EggCompositePrimitive::set_component(int i, EggAttributes const *attrib)
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 2, "EggCompositePrimitive.set_component", true, true);
  if (arg_this != NULL) {
    (*local_this).set_component(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_component(const EggCompositePrimitive self, index, const EggAttributes attrib)\n");
  }
  return -1;
}

static PyObject *Dtool_EggCompositePrimitive_components_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_EggCompositePrimitive_components_Len;
  wrap->_getitem_func = &Dtool_EggCompositePrimitive_components_Getitem;
  wrap->_setitem_func = &Dtool_EggCompositePrimitive_components_Setitem;
  return (PyObject *)wrap;
}

static int Dtool_Init_EggCompositePrimitive(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggCompositePrimitive(PyObject *args, CPT(EggCompositePrimitive) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggCompositePrimitive, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggCompositePrimitive(PyObject *args, PT(EggCompositePrimitive) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggCompositePrimitive, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggCompositePrimitive_get_components(PyObject *self, PyObject *) {
  EggCompositePrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCompositePrimitive, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_components();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggCompositePrimitive_get_component_916(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggCompositePrimitive(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggCompositePrimitive) {
    printf("EggCompositePrimitive ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggCompositePrimitive *local_this = (EggCompositePrimitive *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggCompositePrimitive) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggCompositePrimitive(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggCompositePrimitive) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggData
 */
/**
 * Python function wrapper for:
 * inline EggData &EggData::operator =(EggData const &copy)
 */
static PyObject *Dtool_EggData_operator_926(PyObject *self, PyObject *arg) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.assign")) {
    return NULL;
  }
  // 1-inline EggData &EggData::operator =(EggData const &copy)
  EggData const *arg_this = (EggData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggData, 1, "EggData.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    EggData *return_value = local_this;
    if (return_value != (EggData *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggData *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggData, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggData self, const EggData copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggData_operator_926_comment =
  "C++ Interface:\n"
  "assign(const EggData self, const EggData copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggData_operator_926_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static bool EggData::resolve_egg_filename(Filename &egg_filename, DSearchPath const &searchpath = DSearchPath())
 */
static PyObject *Dtool_EggData_resolve_egg_filename_927(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "egg_filename");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'egg_filename' (pos 1) not found");
      }
      // 1-static bool EggData::resolve_egg_filename(Filename &egg_filename, DSearchPath const &searchpath)
      Filename arg_local;
      Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 0, "EggData.resolve_egg_filename", "Filename");
      }
      bool return_value = EggData::resolve_egg_filename(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-static bool EggData::resolve_egg_filename(Filename &egg_filename, DSearchPath const &searchpath)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"egg_filename", "searchpath", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:resolve_egg_filename", (char **)keyword_list, &param0, &param1)) {
        Filename param0_local;
        Filename *param0_this = Dtool_Coerce_Filename(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "EggData.resolve_egg_filename", "Filename");
        }
        DSearchPath const *param1_this;
        bool param1_manage = false;
        if (!Dtool_ConstCoerce_DSearchPath(param1, param1_this, param1_manage)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "EggData.resolve_egg_filename", "DSearchPath");
        }
        bool return_value = EggData::resolve_egg_filename(*param0_this, *param1_this);
        if (param1_manage) {
          delete param1_this;
        }
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "resolve_egg_filename() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resolve_egg_filename(Filename egg_filename)\n"
      "resolve_egg_filename(Filename egg_filename, const DSearchPath searchpath)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggData_resolve_egg_filename_927_comment =
  "C++ Interface:\n"
  "resolve_egg_filename(Filename egg_filename)\n"
  "resolve_egg_filename(Filename egg_filename, const DSearchPath searchpath)\n"
  "\n"
  "/**\n"
  " * Looks for the indicated filename, first along the indicated searchpath, and\n"
  " * then along the model_path.  If found, updates the filename to the full path\n"
  " * and returns true; otherwise, returns false.\n"
  " */";
#else
static const char *Dtool_EggData_resolve_egg_filename_927_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggData::read(Filename filename, std::string display_name = string())
 * bool EggData::read(istream &in)
 */
static PyObject *Dtool_EggData_read_928(PyObject *self, PyObject *args, PyObject *kwds) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.read")) {
    return NULL;
  }
  {
    // -2 bool EggData::read(Filename filename, std::string display_name = string())
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    static const char *keyword_list[] = {"filename", "display_name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:read", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      Filename *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
      if (param1_this != NULL) {
        bool return_value = (*local_this).read(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool EggData::read(istream &in)
    PyObject *param1;
    static const char *keyword_list[] = {"in", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:read", (char **)keyword_list, &param1)) {
      istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "EggData.read", false, false);
      if (param1_this != NULL) {
        bool return_value = (*local_this).read(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool EggData::read(Filename filename, std::string display_name = string())
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    static const char *keyword_list[] = {"filename", "display_name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:read", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      Filename param1_local;
      Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != NULL)) {
        bool return_value = (*local_this).read(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool EggData::read(istream &in)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const EggData self, Filename filename, str display_name)\n"
      "read(const EggData self, istream in)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggData_read_928_comment =
  "C++ Interface:\n"
  "read(const EggData self, Filename filename, str display_name)\n"
  "read(const EggData self, istream in)\n"
  "\n"
  "/**\n"
  " * Opens the indicated filename and reads the egg data contents from it.\n"
  " * Returns true if the file was successfully opened and read, false if there\n"
  " * were some errors, in which case the data may be partially read.\n"
  " *\n"
  " * error is the output stream to which to write error messages.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Parses the egg syntax contained in the indicated input stream.  Returns\n"
  " * true if the stream was a completely valid egg file, false if there were\n"
  " * some errors, in which case the data may be partially read.\n"
  " *\n"
  " * Before you call this routine, you should probably call set_egg_filename()\n"
  " * to set the name of the egg file we're processing, if at all possible.  If\n"
  " * there is no such filename, you may set it to the empty string.\n"
  " */";
#else
static const char *Dtool_EggData_read_928_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggData::merge(EggData &other)
 */
static PyObject *Dtool_EggData_merge_929(PyObject *self, PyObject *arg) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.merge")) {
    return NULL;
  }
  // 1-void EggData::merge(EggData &other)
  EggData *arg_this = (EggData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggData, 1, "EggData.merge", false, true);
  if (arg_this != NULL) {
    (*local_this).merge(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "merge(const EggData self, EggData other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggData_merge_929_comment =
  "C++ Interface:\n"
  "merge(const EggData self, EggData other)\n"
  "\n"
  "/**\n"
  " * Appends the other egg structure to the end of this one.  The other egg\n"
  " * structure is invalidated.\n"
  " */";
#else
static const char *Dtool_EggData_merge_929_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggData::load_externals(DSearchPath const &searchpath = DSearchPath())
 * bool EggData::load_externals(DSearchPath const &searchpath, BamCacheRecord *record)
 */
static PyObject *Dtool_EggData_load_externals_930(PyObject *self, PyObject *args, PyObject *kwds) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.load_externals")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-bool EggData::load_externals(DSearchPath const &searchpath)
      bool return_value = (*local_this).load_externals();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "searchpath");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'searchpath' (pos 1) not found");
      }
      // 1-bool EggData::load_externals(DSearchPath const &searchpath)
      DSearchPath const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_DSearchPath(arg, arg_this, arg_manage)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "EggData.load_externals", "DSearchPath");
      }
      bool return_value = (*local_this).load_externals(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-bool EggData::load_externals(DSearchPath const &searchpath, BamCacheRecord *record)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"searchpath", "record", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:load_externals", (char **)keyword_list, &param1, &param2)) {
        DSearchPath const *param1_this;
        bool param1_manage = false;
        if (!Dtool_ConstCoerce_DSearchPath(param1, param1_this, param1_manage)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "EggData.load_externals", "DSearchPath");
        }
        BamCacheRecord *param2_this = (BamCacheRecord *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_BamCacheRecord, 2, "EggData.load_externals", false, true);
        if (param2_this != NULL) {
          bool return_value = (*local_this).load_externals(*param1_this, param2_this);
          if (param1_manage) {
            delete param1_this;
          }
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "load_externals() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_externals(const EggData self)\n"
      "load_externals(const EggData self, const DSearchPath searchpath)\n"
      "load_externals(const EggData self, const DSearchPath searchpath, BamCacheRecord record)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggData_load_externals_930_comment =
  "C++ Interface:\n"
  "load_externals(const EggData self)\n"
  "load_externals(const EggData self, const DSearchPath searchpath)\n"
  "load_externals(const EggData self, const DSearchPath searchpath, BamCacheRecord record)\n"
  "\n"
  "/**\n"
  " * Loads up all the egg files referenced by <File> entries within the egg\n"
  " * structure, and inserts their contents in place of the <File> entries.\n"
  " * Searches for files in the searchpath, if not found directly, and writes\n"
  " * error messages to the indicated output stream.  Returns true if all\n"
  " * externals were loaded successfully, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Loads up all the egg files referenced by <File> entries within the egg\n"
  " * structure, and inserts their contents in place of the <File> entries.\n"
  " * Searches for files in the searchpath, if not found directly, and writes\n"
  " * error messages to the indicated output stream.  Returns true if all\n"
  " * externals were loaded successfully, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggData_load_externals_930_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggData::collapse_equivalent_textures(void)
 */
static PyObject *Dtool_EggData_collapse_equivalent_textures_931(PyObject *self, PyObject *) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.collapse_equivalent_textures")) {
    return NULL;
  }
  // 1-int EggData::collapse_equivalent_textures(void)
  int return_value = (*local_this).collapse_equivalent_textures();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_collapse_equivalent_textures_931_comment =
  "C++ Interface:\n"
  "collapse_equivalent_textures(const EggData self)\n"
  "\n"
  "/**\n"
  " * Removes duplicate references to the same texture image with the same\n"
  " * properties.  Considers two texture references with identical properties,\n"
  " * but different tref names, to be equivalent, and collapses them, choosing\n"
  " * one tref name to keep arbitrarily.  Returns the number of textures removed.\n"
  " */";
#else
static const char *Dtool_EggData_collapse_equivalent_textures_931_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggData::collapse_equivalent_materials(void)
 */
static PyObject *Dtool_EggData_collapse_equivalent_materials_932(PyObject *self, PyObject *) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.collapse_equivalent_materials")) {
    return NULL;
  }
  // 1-int EggData::collapse_equivalent_materials(void)
  int return_value = (*local_this).collapse_equivalent_materials();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_collapse_equivalent_materials_932_comment =
  "C++ Interface:\n"
  "collapse_equivalent_materials(const EggData self)\n"
  "\n"
  "/**\n"
  " * Removes duplicate references to the same material with the same properties.\n"
  " * Considers two material references with identical properties, but different\n"
  " * mref names, to be equivalent, and collapses them, choosing one mref name to\n"
  " * keep arbitrarily.  Returns the number of materials removed.\n"
  " */";
#else
static const char *Dtool_EggData_collapse_equivalent_materials_932_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggData::write_egg(Filename filename)
 * bool EggData::write_egg(ostream &out)
 */
static PyObject *Dtool_EggData_write_egg_933(PyObject *self, PyObject *arg) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.write_egg")) {
    return NULL;
  }
  {
    // -2 bool EggData::write_egg(ostream &out)
    ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "EggData.write_egg", false, false);
    if (arg_this != NULL) {
      bool return_value = (*local_this).write_egg(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: bool EggData::write_egg(ostream &out)
  {
    // -2 bool EggData::write_egg(Filename filename)
    Filename arg_local;
    Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != NULL)) {
      bool return_value = (*local_this).write_egg(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_egg(const EggData self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggData_write_egg_933_comment =
  "C++ Interface:\n"
  "write_egg(const EggData self, ostream out)\n"
  "\n"
  "/**\n"
  " * The main interface for writing complete egg files.\n"
  " */\n"
  "\n"
  "/**\n"
  " * The main interface for writing complete egg files.\n"
  " */";
#else
static const char *Dtool_EggData_write_egg_933_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::set_auto_resolve_externals(bool resolve)
 */
static PyObject *Dtool_EggData_set_auto_resolve_externals_934(PyObject *self, PyObject *arg) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.set_auto_resolve_externals")) {
    return NULL;
  }
  // 1-inline void EggData::set_auto_resolve_externals(bool resolve)
  (*local_this).set_auto_resolve_externals((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_resolve_externals(const EggData self, bool resolve)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggData_set_auto_resolve_externals_934_comment =
  "C++ Interface:\n"
  "set_auto_resolve_externals(const EggData self, bool resolve)\n"
  "\n"
  "/**\n"
  " * Indicates whether the EggData object will automatically resolve any\n"
  " * external references when read() is called.  The default is false.\n"
  " */";
#else
static const char *Dtool_EggData_set_auto_resolve_externals_934_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggData::get_auto_resolve_externals(void) const
 */
static PyObject *Dtool_EggData_get_auto_resolve_externals_935(PyObject *self, PyObject *) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggData::get_auto_resolve_externals(void) const
  bool return_value = (*(const EggData*)local_this).get_auto_resolve_externals();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_get_auto_resolve_externals_935_comment =
  "C++ Interface:\n"
  "get_auto_resolve_externals(EggData self)\n"
  "\n"
  "/**\n"
  " * Indicates whether the EggData object will automatically resolve any\n"
  " * external references when read() is called.  The default is false.\n"
  " */";
#else
static const char *Dtool_EggData_get_auto_resolve_externals_935_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggData::original_had_absolute_pathnames(void) const
 */
static PyObject *Dtool_EggData_original_had_absolute_pathnames_936(PyObject *self, PyObject *) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggData::original_had_absolute_pathnames(void) const
  bool return_value = (*(const EggData*)local_this).original_had_absolute_pathnames();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_original_had_absolute_pathnames_936_comment =
  "C++ Interface:\n"
  "original_had_absolute_pathnames(EggData self)\n"
  "\n"
  "/**\n"
  " * Returns true if the data processed in the last call to read() contained\n"
  " * absolute pathnames, or false if those pathnames were all relative.\n"
  " *\n"
  " * This method is necessary because if auto_resolve_externals() is in effect,\n"
  " * it may modify the pathnames to be absolute whether or not they were as\n"
  " * loaded from disk.  This method can be used to query the state of the\n"
  " * original egg file from disk.\n"
  " */";
#else
static const char *Dtool_EggData_original_had_absolute_pathnames_936_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggData::set_coordinate_system(CoordinateSystem coordsys)
 */
static PyObject *Dtool_EggData_set_coordinate_system_937(PyObject *self, PyObject *arg) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.set_coordinate_system")) {
    return NULL;
  }
  // 1-void EggData::set_coordinate_system(CoordinateSystem coordsys)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_coordinate_system((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const EggData self, int coordsys)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggData_set_coordinate_system_937_comment =
  "C++ Interface:\n"
  "set_coordinate_system(const EggData self, int coordsys)\n"
  "\n"
  "/**\n"
  " * Changes the coordinate system of the EggData.  If the coordinate system was\n"
  " * previously different, this may result in a conversion of the data.\n"
  " */";
#else
static const char *Dtool_EggData_set_coordinate_system_937_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem EggData::get_coordinate_system(void) const
 */
static PyObject *Dtool_EggData_get_coordinate_system_938(PyObject *self, PyObject *) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CoordinateSystem EggData::get_coordinate_system(void) const
  CoordinateSystem return_value = (*(const EggData*)local_this).get_coordinate_system();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_get_coordinate_system_938_comment =
  "C++ Interface:\n"
  "get_coordinate_system(EggData self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system in which the egg file is defined.\n"
  " */";
#else
static const char *Dtool_EggData_get_coordinate_system_938_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::set_egg_filename(Filename const &egg_filename)
 */
static PyObject *Dtool_EggData_set_egg_filename_939(PyObject *self, PyObject *arg) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.set_egg_filename")) {
    return NULL;
  }
  // 1-inline void EggData::set_egg_filename(Filename const &egg_filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggData.set_egg_filename", "Filename");
  }
  (*local_this).set_egg_filename(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_egg_filename(const EggData self, const Filename egg_filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggData_set_egg_filename_939_comment =
  "C++ Interface:\n"
  "set_egg_filename(const EggData self, const Filename egg_filename)\n"
  "\n"
  "/**\n"
  " * Sets the filename--especially the directory part--in which the egg file is\n"
  " * considered to reside.  This is also implicitly set by read().\n"
  " */";
#else
static const char *Dtool_EggData_set_egg_filename_939_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &EggData::get_egg_filename(void) const
 */
static PyObject *Dtool_EggData_get_egg_filename_940(PyObject *self, PyObject *) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &EggData::get_egg_filename(void) const
  Filename const *return_value = &((*(const EggData*)local_this).get_egg_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggData_get_egg_filename_940_comment =
  "C++ Interface:\n"
  "get_egg_filename(EggData self)\n"
  "\n"
  "/**\n"
  " * Returns the directory in which the egg file is considered to reside.\n"
  " */";
#else
static const char *Dtool_EggData_get_egg_filename_940_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::set_egg_timestamp(time_t egg_timestamp)
 */
static PyObject *Dtool_EggData_set_egg_timestamp_941(PyObject *self, PyObject *arg) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.set_egg_timestamp")) {
    return NULL;
  }
  // 1-inline void EggData::set_egg_timestamp(time_t egg_timestamp)
  if (PyLongOrInt_Check(arg)) {
    (*local_this).set_egg_timestamp(PyLongOrInt_AS_LONG(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_egg_timestamp(const EggData self, int egg_timestamp)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggData_set_egg_timestamp_941_comment =
  "C++ Interface:\n"
  "set_egg_timestamp(const EggData self, int egg_timestamp)\n"
  "\n"
  "/**\n"
  " * Sets the timestamp of the egg file on disk, at the time it was opened for\n"
  " * reading.  This is also implicitly set by read().\n"
  " */";
#else
static const char *Dtool_EggData_set_egg_timestamp_941_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline time_t EggData::get_egg_timestamp(void) const
 */
static PyObject *Dtool_EggData_get_egg_timestamp_942(PyObject *self, PyObject *) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline time_t EggData::get_egg_timestamp(void) const
  time_t return_value = (*(const EggData*)local_this).get_egg_timestamp();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_get_egg_timestamp_942_comment =
  "C++ Interface:\n"
  "get_egg_timestamp(EggData self)\n"
  "\n"
  "/**\n"
  " * Returns the timestamp of the egg file on disk, at the time it was opened\n"
  " * for reading, or 0 if this information is not available.\n"
  " */";
#else
static const char *Dtool_EggData_get_egg_timestamp_942_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::recompute_vertex_normals(double threshold)
 */
static PyObject *Dtool_EggData_recompute_vertex_normals_943(PyObject *self, PyObject *arg) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.recompute_vertex_normals")) {
    return NULL;
  }
  // 1-inline void EggData::recompute_vertex_normals(double threshold)
  if (PyNumber_Check(arg)) {
    (*local_this).recompute_vertex_normals(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "recompute_vertex_normals(const EggData self, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggData_recompute_vertex_normals_943_comment =
  "C++ Interface:\n"
  "recompute_vertex_normals(const EggData self, double threshold)\n"
  "\n"
  "/**\n"
  " * Recomputes all the vertex normals for polygon geometry at this group node\n"
  " * and below so that they accurately reflect the vertex positions.  A shared\n"
  " * edge between two polygons (even in different groups) is considered smooth\n"
  " * if the angle between the two edges is less than threshold degrees.\n"
  " *\n"
  " * This function also removes degenerate polygons that do not have enough\n"
  " * vertices to define a normal.  It does not affect normals for other kinds of\n"
  " * primitives like Nurbs or Points.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the correct normals.  Thus, it is a good idea\n"
  " * to call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggData_recompute_vertex_normals_943_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::recompute_polygon_normals(void)
 */
static PyObject *Dtool_EggData_recompute_polygon_normals_944(PyObject *self, PyObject *) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.recompute_polygon_normals")) {
    return NULL;
  }
  // 1-inline void EggData::recompute_polygon_normals(void)
  (*local_this).recompute_polygon_normals();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggData_recompute_polygon_normals_944_comment =
  "C++ Interface:\n"
  "recompute_polygon_normals(const EggData self)\n"
  "\n"
  "/**\n"
  " * Recomputes all the polygon normals for polygon geometry at this group node\n"
  " * and below so that they accurately reflect the vertex positions.  Normals\n"
  " * are removed from the vertices and defined only on polygons, giving the\n"
  " * geometry a faceted appearance.\n"
  " *\n"
  " * This function also removes degenerate polygons that do not have enough\n"
  " * vertices to define a normal.  It does not affect normals for other kinds of\n"
  " * primitives like Nurbs or Points.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the normals removed.  Thus, it is a good idea\n"
  " * to call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggData_recompute_polygon_normals_944_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::strip_normals(void)
 */
static PyObject *Dtool_EggData_strip_normals_945(PyObject *self, PyObject *) {
  EggData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.strip_normals")) {
    return NULL;
  }
  // 1-inline void EggData::strip_normals(void)
  (*local_this).strip_normals();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggData_strip_normals_945_comment =
  "C++ Interface:\n"
  "strip_normals(const EggData self)\n"
  "\n"
  "/**\n"
  " * Removes all normals from primitives, and the vertices they reference, at\n"
  " * this node and below.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the normal removed.  Thus, it is a good idea to\n"
  " * call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggData_strip_normals_945_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggData::get_class_type(void)
 */
static PyObject *Dtool_EggData_get_class_type_946(PyObject *, PyObject *) {
  // 1-static TypeHandle EggData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggData::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggData_get_class_type_946_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggData_get_class_type_946_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggData::EggData(void)
 * inline EggData::EggData(EggData const &copy)
 */
static int Dtool_Init_EggData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggData::EggData(void)
      EggData *return_value = new EggData();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggData, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline EggData::EggData(EggData const &copy)
      EggData const *arg_this = (EggData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggData, 0, "EggData.EggData", true, true);
      if (arg_this != NULL) {
        EggData *return_value = new EggData(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggData, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggData()\n"
      "EggData(const EggData copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggData) {
    printf("EggData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggData *local_this = (EggData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroupNode) {
    return (EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    EggGroupNode* other_this = (EggGroupNode*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggData*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggCoordinateSystem
 */
/**
 * Python function wrapper for:
 * inline void EggCoordinateSystem::set_value(CoordinateSystem value)
 */
static PyObject *Dtool_EggCoordinateSystem_set_value_950(PyObject *self, PyObject *arg) {
  EggCoordinateSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCoordinateSystem, (void **)&local_this, "EggCoordinateSystem.set_value")) {
    return NULL;
  }
  // 1-inline void EggCoordinateSystem::set_value(CoordinateSystem value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_value((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const EggCoordinateSystem self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggCoordinateSystem_set_value_950_comment =
  "C++ Interface:\n"
  "set_value(const EggCoordinateSystem self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggCoordinateSystem_set_value_950_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem EggCoordinateSystem::get_value(void) const
 */
static PyObject *Dtool_EggCoordinateSystem_get_value_951(PyObject *self, PyObject *) {
  EggCoordinateSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCoordinateSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CoordinateSystem EggCoordinateSystem::get_value(void) const
  CoordinateSystem return_value = (*(const EggCoordinateSystem*)local_this).get_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggCoordinateSystem_get_value_951_comment =
  "C++ Interface:\n"
  "get_value(EggCoordinateSystem self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggCoordinateSystem_get_value_951_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggCoordinateSystem::get_class_type(void)
 */
static PyObject *Dtool_EggCoordinateSystem_get_class_type_952(PyObject *, PyObject *) {
  // 1-static TypeHandle EggCoordinateSystem::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggCoordinateSystem::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggCoordinateSystem_get_class_type_952_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggCoordinateSystem_get_class_type_952_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value = ::CS_default)
 * inline EggCoordinateSystem::EggCoordinateSystem(EggCoordinateSystem const &copy)
 */
static int Dtool_Init_EggCoordinateSystem(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value)
      EggCoordinateSystem *return_value = new EggCoordinateSystem();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggCoordinateSystem, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggCoordinateSystem::EggCoordinateSystem(EggCoordinateSystem const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggCoordinateSystem", (char **)keyword_list, &param0)) {
          EggCoordinateSystem const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggCoordinateSystem, (void **)&param0_this);
          if (param0_this != NULL) {
            EggCoordinateSystem *return_value = new EggCoordinateSystem(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggCoordinateSystem, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value)
        int param0;
        static const char *keyword_list[] = {"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:EggCoordinateSystem", (char **)keyword_list, &param0)) {
          EggCoordinateSystem *return_value = new EggCoordinateSystem((CoordinateSystem)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggCoordinateSystem, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggCoordinateSystem::EggCoordinateSystem(EggCoordinateSystem const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggCoordinateSystem", (char **)keyword_list, &param0)) {
          CPT(EggCoordinateSystem) param0_this;
          if (Dtool_ConstCoerce_EggCoordinateSystem(param0, param0_this)) {
            EggCoordinateSystem *return_value = new EggCoordinateSystem(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggCoordinateSystem, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggCoordinateSystem() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggCoordinateSystem()\n"
      "EggCoordinateSystem(const EggCoordinateSystem copy)\n"
      "EggCoordinateSystem(int value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggCoordinateSystem(PyObject *args, CPT(EggCoordinateSystem) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggCoordinateSystem, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      EggCoordinateSystem *return_value = new EggCoordinateSystem((CoordinateSystem)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_EggCoordinateSystem(PyObject *args, PT(EggCoordinateSystem) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggCoordinateSystem, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      EggCoordinateSystem *return_value = new EggCoordinateSystem((CoordinateSystem)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_EggCoordinateSystem(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggCoordinateSystem) {
    printf("EggCoordinateSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggCoordinateSystem *local_this = (EggCoordinateSystem *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggCoordinateSystem) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggCoordinateSystem(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggCoordinateSystem) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggCurve
 */
/**
 * Python function wrapper for:
 * inline EggCurve &EggCurve::operator =(EggCurve const &copy)
 */
static PyObject *Dtool_EggCurve_operator_955(PyObject *self, PyObject *arg) {
  EggCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCurve, (void **)&local_this, "EggCurve.assign")) {
    return NULL;
  }
  // 1-inline EggCurve &EggCurve::operator =(EggCurve const &copy)
  CPT(EggCurve) arg_this;
  if (!Dtool_ConstCoerce_EggCurve(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggCurve.assign", "EggCurve");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggCurve *return_value = local_this;
  if (return_value != (EggCurve *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggCurve *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggCurve self, const EggCurve copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_operator_955_comment =
  "C++ Interface:\n"
  "assign(const EggCurve self, const EggCurve copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggCurve_operator_955_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggCurve::set_subdiv(int subdiv)
 */
static PyObject *Dtool_EggCurve_set_subdiv_957(PyObject *self, PyObject *arg) {
  EggCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCurve, (void **)&local_this, "EggCurve.set_subdiv")) {
    return NULL;
  }
  // 1-inline void EggCurve::set_subdiv(int subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_subdiv((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdiv(const EggCurve self, int subdiv)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_set_subdiv_957_comment =
  "C++ Interface:\n"
  "set_subdiv(const EggCurve self, int subdiv)\n"
  "\n"
  "/**\n"
  " * Sets the number of subdivisions that will be requested across the curve.\n"
  " * (This doesn't necessary guarantee that this number of subdivisions will be\n"
  " * made; it's just a hint to any curve renderer or quick tesselator.)  Set the\n"
  " * number to 0 to disable the hint.\n"
  " */";
#else
static const char *Dtool_EggCurve_set_subdiv_957_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggCurve::get_subdiv(void) const
 */
static PyObject *Dtool_EggCurve_get_subdiv_958(PyObject *self, PyObject *) {
  EggCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggCurve::get_subdiv(void) const
  int return_value = (*(const EggCurve*)local_this).get_subdiv();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_get_subdiv_958_comment =
  "C++ Interface:\n"
  "get_subdiv(EggCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the requested number of subdivisions, or 0 if no particular\n"
  " * subdivisions have been requested.\n"
  " */";
#else
static const char *Dtool_EggCurve_get_subdiv_958_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggCurve::set_curve_type(EggCurve::CurveType type)
 */
static PyObject *Dtool_EggCurve_set_curve_type_959(PyObject *self, PyObject *arg) {
  EggCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCurve, (void **)&local_this, "EggCurve.set_curve_type")) {
    return NULL;
  }
  // 1-inline void EggCurve::set_curve_type(EggCurve::CurveType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_curve_type((EggCurve::CurveType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_curve_type(const EggCurve self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_set_curve_type_959_comment =
  "C++ Interface:\n"
  "set_curve_type(const EggCurve self, int type)\n"
  "\n"
  "/**\n"
  " * Sets the type of the curve.  This is primarily used as a hint to any code\n"
  " * that may need to deal with this curve.\n"
  " */";
#else
static const char *Dtool_EggCurve_set_curve_type_959_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggCurve::CurveType EggCurve::get_curve_type(void) const
 */
static PyObject *Dtool_EggCurve_get_curve_type_960(PyObject *self, PyObject *) {
  EggCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggCurve::CurveType EggCurve::get_curve_type(void) const
  EggCurve::CurveType return_value = (*(const EggCurve*)local_this).get_curve_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_get_curve_type_960_comment =
  "C++ Interface:\n"
  "get_curve_type(EggCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the indicated type of the curve.\n"
  " */";
#else
static const char *Dtool_EggCurve_get_curve_type_960_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggCurve::CurveType EggCurve::string_curve_type(std::string const &string)
 */
static PyObject *Dtool_EggCurve_string_curve_type_961(PyObject *, PyObject *arg) {
  // 1-static EggCurve::CurveType EggCurve::string_curve_type(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggCurve::CurveType return_value = EggCurve::string_curve_type(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_curve_type(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_string_curve_type_961_comment =
  "C++ Interface:\n"
  "string_curve_type(str string)\n"
  "\n"
  "/**\n"
  " * Returns the CurveType value associated with the given string\n"
  " * representation, or CT_invalid if the string does not match any known\n"
  " * CurveType value.\n"
  " */";
#else
static const char *Dtool_EggCurve_string_curve_type_961_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggCurve::get_class_type(void)
 */
static PyObject *Dtool_EggCurve_get_class_type_962(PyObject *, PyObject *) {
  // 1-static TypeHandle EggCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggCurve::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_get_class_type_962_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggCurve_get_class_type_962_comment = NULL;
#endif

static int Dtool_Init_EggCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggCurve(PyObject *args, CPT(EggCurve) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggCurve, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggCurve(PyObject *args, PT(EggCurve) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggCurve, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggCurve) {
    printf("EggCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggCurve *local_this = (EggCurve *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggCurve*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggExternalReference
 */
/**
 * Python function wrapper for:
 * EggExternalReference &EggExternalReference::operator =(EggExternalReference const &copy)
 */
static PyObject *Dtool_EggExternalReference_operator_966(PyObject *self, PyObject *arg) {
  EggExternalReference *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggExternalReference, (void **)&local_this, "EggExternalReference.assign")) {
    return NULL;
  }
  // 1-EggExternalReference &EggExternalReference::operator =(EggExternalReference const &copy)
  CPT(EggExternalReference) arg_this;
  if (!Dtool_ConstCoerce_EggExternalReference(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggExternalReference.assign", "EggExternalReference");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggExternalReference *return_value = local_this;
  if (return_value != (EggExternalReference *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggExternalReference *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggExternalReference, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggExternalReference self, const EggExternalReference copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggExternalReference_operator_966_comment =
  "C++ Interface:\n"
  "assign(const EggExternalReference self, const EggExternalReference copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggExternalReference_operator_966_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggExternalReference::get_class_type(void)
 */
static PyObject *Dtool_EggExternalReference_get_class_type_967(PyObject *, PyObject *) {
  // 1-static TypeHandle EggExternalReference::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggExternalReference::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggExternalReference_get_class_type_967_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggExternalReference_get_class_type_967_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggExternalReference::EggExternalReference(EggExternalReference const &copy)
 * EggExternalReference::EggExternalReference(std::string const &node_name, std::string const &filename)
 */
static int Dtool_Init_EggExternalReference(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-EggExternalReference::EggExternalReference(EggExternalReference const &copy)
      CPT(EggExternalReference) arg_this;
      if (!Dtool_ConstCoerce_EggExternalReference(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "EggExternalReference.EggExternalReference", "EggExternalReference");
        return -1;
      }
      EggExternalReference *return_value = new EggExternalReference(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggExternalReference, true, false);
    }
    break;
  case 2:
    {
      // 1-EggExternalReference::EggExternalReference(std::string const &node_name, std::string const &filename)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"node_name", "filename", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:EggExternalReference", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
        EggExternalReference *return_value = new EggExternalReference(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggExternalReference, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggExternalReference() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggExternalReference(const EggExternalReference copy)\n"
      "EggExternalReference(str node_name, str filename)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggExternalReference(PyObject *args, CPT(EggExternalReference) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggExternalReference, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-EggExternalReference::EggExternalReference(std::string const &node_name, std::string const &filename)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "s#s#:EggExternalReference", &param0_str, &param0_len, &param1_str, &param1_len)) {
        EggExternalReference *return_value = new EggExternalReference(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_EggExternalReference(PyObject *args, PT(EggExternalReference) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggExternalReference, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-EggExternalReference::EggExternalReference(std::string const &node_name, std::string const &filename)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "s#s#:EggExternalReference", &param0_str, &param0_len, &param1_str, &param1_len)) {
        EggExternalReference *return_value = new EggExternalReference(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggExternalReference(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggExternalReference) {
    printf("EggExternalReference ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggExternalReference *local_this = (EggExternalReference *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggExternalReference) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggFilenameNode) {
    return (EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggExternalReference(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggExternalReference) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggFilenameNode) {
    EggFilenameNode* other_this = (EggFilenameNode*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggExternalReference*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggNameUniquifier
 */
/**
 * Python function wrapper for:
 * void EggNameUniquifier::clear(void)
 */
static PyObject *Dtool_EggNameUniquifier_clear_970(PyObject *self, PyObject *) {
  EggNameUniquifier *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.clear")) {
    return NULL;
  }
  // 1-void EggNameUniquifier::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_clear_970_comment =
  "C++ Interface:\n"
  "clear(const EggNameUniquifier self)\n"
  "\n"
  "/**\n"
  " * Empties the table of used named and prepares the Uniquifier for a new tree.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_clear_970_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggNameUniquifier::uniquify(EggNode *node)
 */
static PyObject *Dtool_EggNameUniquifier_uniquify_971(PyObject *self, PyObject *arg) {
  EggNameUniquifier *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.uniquify")) {
    return NULL;
  }
  // 1-void EggNameUniquifier::uniquify(EggNode *node)
  PT(EggNode) arg_this;
  if (!Dtool_Coerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggNameUniquifier.uniquify", "EggNode");
  }
  (*local_this).uniquify(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "uniquify(const EggNameUniquifier self, EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_uniquify_971_comment =
  "C++ Interface:\n"
  "uniquify(const EggNameUniquifier self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Begins the traversal from the indicated node.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_uniquify_971_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggNameUniquifier::get_node(std::string const &category, std::string const &name) const
 */
static PyObject *Dtool_EggNameUniquifier_get_node_972(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNameUniquifier *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNameUniquifier, (void **)&local_this)) {
    return NULL;
  }
  // 1-EggNode *EggNameUniquifier::get_node(std::string const &category, std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"category", "name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:get_node", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    EggNode *return_value = (*(const EggNameUniquifier*)local_this).get_node(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    if (return_value != (EggNode *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggNode *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(EggNameUniquifier self, str category, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_get_node_972_comment =
  "C++ Interface:\n"
  "get_node(EggNameUniquifier self, str category, str name)\n"
  "\n"
  "/**\n"
  " * Returns the node associated with the given category and name, or NULL if\n"
  " * the name has not been used.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_get_node_972_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggNameUniquifier::has_name(std::string const &category, std::string const &name) const
 */
static PyObject *Dtool_EggNameUniquifier_has_name_973(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNameUniquifier *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNameUniquifier, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggNameUniquifier::has_name(std::string const &category, std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"category", "name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:has_name", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    bool return_value = (*(const EggNameUniquifier*)local_this).has_name(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_name(EggNameUniquifier self, str category, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_has_name_973_comment =
  "C++ Interface:\n"
  "has_name(EggNameUniquifier self, str category, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if the name has been used for the indicated category already,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_has_name_973_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggNameUniquifier::add_name(std::string const &category, std::string const &name, EggNode *node = 0)
 */
static PyObject *Dtool_EggNameUniquifier_add_name_974(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNameUniquifier *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.add_name")) {
    return NULL;
  }
  // 1-bool EggNameUniquifier::add_name(std::string const &category, std::string const &name, EggNode *node = 0)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  PyObject *param3 = NULL;
  static const char *keyword_list[] = {"category", "name", "node", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|O:add_name", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
    PT(EggNode) param3_this = 0;
    if (param3 != NULL && !Dtool_Coerce_EggNode(param3, param3_this)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "EggNameUniquifier.add_name", "EggNode");
    }
    bool return_value = (*local_this).add_name(std::string(param1_str, param1_len), std::string(param2_str, param2_len), MOVE(param3_this));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_name(const EggNameUniquifier self, str category, str name, EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_add_name_974_comment =
  "C++ Interface:\n"
  "add_name(const EggNameUniquifier self, str category, str name, EggNode node)\n"
  "\n"
  "/**\n"
  " * Adds the name to the indicated category.  This name will not be used for\n"
  " * any other egg node within this category.  Returns true if the name was\n"
  " * added, or false if it was already in use for the category.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_add_name_974_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual std::string EggNameUniquifier::get_category(EggNode *node) = 0
 */
static PyObject *Dtool_EggNameUniquifier_get_category_975(PyObject *self, PyObject *arg) {
  EggNameUniquifier *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.get_category")) {
    return NULL;
  }
  // 1-virtual std::string EggNameUniquifier::get_category(EggNode *node) = 0
  PT(EggNode) arg_this;
  if (!Dtool_Coerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggNameUniquifier.get_category", "EggNode");
  }
  std::string return_value = (*local_this).get_category(MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_category(const EggNameUniquifier self, EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_get_category_975_comment =
  "C++ Interface:\n"
  "get_category(const EggNameUniquifier self, EggNode node)\n";
#else
static const char *Dtool_EggNameUniquifier_get_category_975_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual std::string EggNameUniquifier::filter_name(EggNode *node)
 */
static PyObject *Dtool_EggNameUniquifier_filter_name_976(PyObject *self, PyObject *arg) {
  EggNameUniquifier *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.filter_name")) {
    return NULL;
  }
  // 1-virtual std::string EggNameUniquifier::filter_name(EggNode *node)
  PT(EggNode) arg_this;
  if (!Dtool_Coerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggNameUniquifier.filter_name", "EggNode");
  }
  std::string return_value = (*local_this).filter_name(MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "filter_name(const EggNameUniquifier self, EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_filter_name_976_comment =
  "C++ Interface:\n"
  "filter_name(const EggNameUniquifier self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Returns the name of the given node, or at least the name it should be.\n"
  " * This provides a hook to adjust the name before attempting to uniquify it,\n"
  " * if desired, for instance to remove invalid characters.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_filter_name_976_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual std::string EggNameUniquifier::generate_name(EggNode *node, std::string const &category, int index)
 */
static PyObject *Dtool_EggNameUniquifier_generate_name_977(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNameUniquifier *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.generate_name")) {
    return NULL;
  }
  // 1-virtual std::string EggNameUniquifier::generate_name(EggNode *node, std::string const &category, int index)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  int param3;
  static const char *keyword_list[] = {"node", "category", "index", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#i:generate_name", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
    PT(EggNode) param1_this;
    if (!Dtool_Coerce_EggNode(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggNameUniquifier.generate_name", "EggNode");
    }
    std::string return_value = (*local_this).generate_name(MOVE(param1_this), std::string(param2_str, param2_len), (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generate_name(const EggNameUniquifier self, EggNode node, str category, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_generate_name_977_comment =
  "C++ Interface:\n"
  "generate_name(const EggNameUniquifier self, EggNode node, str category, int index)\n"
  "\n"
  "/**\n"
  " * Generates a new name for the given node when its existing name clashes with\n"
  " * some other node.  This function will be called repeatedly, if necessary,\n"
  " * until it returns a name that actually is unique.\n"
  " *\n"
  " * The category is the string returned by get_category(), and index is a\n"
  " * uniquely-generated number that may be useful for synthesizing the name.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_generate_name_977_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggNameUniquifier::get_class_type(void)
 */
static PyObject *Dtool_EggNameUniquifier_get_class_type_978(PyObject *, PyObject *) {
  // 1-static TypeHandle EggNameUniquifier::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggNameUniquifier::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_get_class_type_978_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggNameUniquifier_get_class_type_978_comment = NULL;
#endif

static int Dtool_Init_EggNameUniquifier(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_EggNameUniquifier(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggNameUniquifier) {
    printf("EggNameUniquifier ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggNameUniquifier *local_this = (EggNameUniquifier *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggNameUniquifier) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggNameUniquifier(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggNameUniquifier) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggNameUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggNameUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggNameUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggNameUniquifier*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggGroupUniquifier
 */
/**
 * Python function wrapper for:
 * static TypeHandle EggGroupUniquifier::get_class_type(void)
 */
static PyObject *Dtool_EggGroupUniquifier_get_class_type_981(PyObject *, PyObject *) {
  // 1-static TypeHandle EggGroupUniquifier::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggGroupUniquifier::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupUniquifier_get_class_type_981_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggGroupUniquifier_get_class_type_981_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggGroupUniquifier::EggGroupUniquifier(bool filter_names = true)
 */
static int Dtool_Init_EggGroupUniquifier(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-EggGroupUniquifier::EggGroupUniquifier(bool filter_names = true)
  PyObject *param0 = Py_True;
  static const char *keyword_list[] = {"filter_names", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:EggGroupUniquifier", (char **)keyword_list, &param0)) {
    EggGroupUniquifier *return_value = new EggGroupUniquifier((PyObject_IsTrue(param0) != 0));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroupUniquifier, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggGroupUniquifier(bool filter_names)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggGroupUniquifier(PyObject *args, CPT(EggGroupUniquifier) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggGroupUniquifier, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggGroupUniquifier::EggGroupUniquifier(bool filter_names)
    EggGroupUniquifier *return_value = new EggGroupUniquifier((PyObject_IsTrue(arg) != 0));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return false;
    }
    return_value->ref();
    if (_PyErr_OCCURRED()) {
      unref_delete(return_value);
      return false;
    } else {
      coerced = MOVE(return_value);
      return true;
    }
  }
  return false;
}

bool Dtool_Coerce_EggGroupUniquifier(PyObject *args, PT(EggGroupUniquifier) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggGroupUniquifier, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggGroupUniquifier::EggGroupUniquifier(bool filter_names)
    EggGroupUniquifier *return_value = new EggGroupUniquifier((PyObject_IsTrue(arg) != 0));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return false;
    }
    return_value->ref();
    if (_PyErr_OCCURRED()) {
      unref_delete(return_value);
      return false;
    } else {
      coerced = MOVE(return_value);
      return true;
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_EggGroupUniquifier(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggGroupUniquifier) {
    printf("EggGroupUniquifier ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggGroupUniquifier *local_this = (EggGroupUniquifier *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggGroupUniquifier) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNameUniquifier) {
    return (EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggGroupUniquifier(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggGroupUniquifier) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNameUniquifier) {
    EggNameUniquifier* other_this = (EggNameUniquifier*)from_this;
    return (EggGroupUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggGroupUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggGroupUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggGroupUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggGroupUniquifier*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggLine
 */
/**
 * Python function wrapper for:
 * inline EggLine &EggLine::operator =(EggLine const &copy)
 */
static PyObject *Dtool_EggLine_operator_984(PyObject *self, PyObject *arg) {
  EggLine *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggLine, (void **)&local_this, "EggLine.assign")) {
    return NULL;
  }
  // 1-inline EggLine &EggLine::operator =(EggLine const &copy)
  CPT(EggLine) arg_this;
  if (!Dtool_ConstCoerce_EggLine(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggLine.assign", "EggLine");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggLine *return_value = local_this;
  if (return_value != (EggLine *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggLine *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggLine, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggLine self, const EggLine copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggLine_operator_984_comment =
  "C++ Interface:\n"
  "assign(const EggLine self, const EggLine copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggLine_operator_984_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggLine *EggLine::make_copy(void) override
 */
static PyObject *Dtool_EggLine_make_copy_985(PyObject *self, PyObject *) {
  EggLine *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggLine, (void **)&local_this, "EggLine.make_copy")) {
    return NULL;
  }
  // 1-virtual EggLine *EggLine::make_copy(void) override
  EggLine *return_value = (*local_this).make_copy();
  if (return_value != (EggLine *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggLine *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggLine, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggLine_make_copy_985_comment =
  "C++ Interface:\n"
  "make_copy(const EggLine self)\n"
  "\n"
  "/**\n"
  " * Makes a copy of this object.\n"
  " */";
#else
static const char *Dtool_EggLine_make_copy_985_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggLine::has_thick(void) const
 */
static PyObject *Dtool_EggLine_has_thick_986(PyObject *self, PyObject *) {
  EggLine *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggLine, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggLine::has_thick(void) const
  bool return_value = (*(const EggLine*)local_this).has_thick();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggLine_has_thick_986_comment =
  "C++ Interface:\n"
  "has_thick(EggLine self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggLine_has_thick_986_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggLine::get_thick(void) const
 */
static PyObject *Dtool_EggLine_get_thick_987(PyObject *self, PyObject *) {
  EggLine *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggLine, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggLine::get_thick(void) const
  double return_value = (*(const EggLine*)local_this).get_thick();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggLine_get_thick_987_comment =
  "C++ Interface:\n"
  "get_thick(EggLine self)\n"
  "\n"
  "/**\n"
  " * Returns the thickness set on this particular line.  If there is no\n"
  " * thickness set, returns 1.0.\n"
  " */";
#else
static const char *Dtool_EggLine_get_thick_987_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggLine::set_thick(double thick)
 */
static PyObject *Dtool_EggLine_set_thick_988(PyObject *self, PyObject *arg) {
  EggLine *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggLine, (void **)&local_this, "EggLine.set_thick")) {
    return NULL;
  }
  // 1-inline void EggLine::set_thick(double thick)
  if (PyNumber_Check(arg)) {
    (*local_this).set_thick(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_thick(const EggLine self, double thick)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggLine_set_thick_988_comment =
  "C++ Interface:\n"
  "set_thick(const EggLine self, double thick)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggLine_set_thick_988_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggLine::clear_thick(void)
 */
static PyObject *Dtool_EggLine_clear_thick_989(PyObject *self, PyObject *) {
  EggLine *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggLine, (void **)&local_this, "EggLine.clear_thick")) {
    return NULL;
  }
  // 1-inline void EggLine::clear_thick(void)
  (*local_this).clear_thick();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggLine_clear_thick_989_comment =
  "C++ Interface:\n"
  "clear_thick(const EggLine self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggLine_clear_thick_989_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggLine::get_class_type(void)
 */
static PyObject *Dtool_EggLine_get_class_type_990(PyObject *, PyObject *) {
  // 1-static TypeHandle EggLine::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggLine::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggLine_get_class_type_990_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggLine_get_class_type_990_comment = NULL;
#endif

static int Dtool_Init_EggLine(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggLine(PyObject *args, CPT(EggLine) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggLine, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggLine(PyObject *args, PT(EggLine) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggLine, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggLine(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggLine) {
    printf("EggLine ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggLine *local_this = (EggLine *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggLine) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggCompositePrimitive) {
    return (EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggLine(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggLine) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggCompositePrimitive) {
    EggCompositePrimitive* other_this = (EggCompositePrimitive*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggLine*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggMaterialCollection
 */
/**
 * Python function wrapper for:
 * EggMaterialCollection &EggMaterialCollection::operator =(EggMaterialCollection const &copy)
 */
static PyObject *Dtool_EggMaterialCollection_operator_993(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.assign")) {
    return NULL;
  }
  // 1-EggMaterialCollection &EggMaterialCollection::operator =(EggMaterialCollection const &copy)
  EggMaterialCollection const *arg_this = (EggMaterialCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggMaterialCollection, 1, "EggMaterialCollection.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    EggMaterialCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggMaterialCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggMaterialCollection self, const EggMaterialCollection copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_operator_993_comment =
  "C++ Interface:\n"
  "assign(const EggMaterialCollection self, const EggMaterialCollection copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_operator_993_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggMaterialCollection::clear(void)
 */
static PyObject *Dtool_EggMaterialCollection_clear_995(PyObject *self, PyObject *) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.clear")) {
    return NULL;
  }
  // 1-void EggMaterialCollection::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_clear_995_comment =
  "C++ Interface:\n"
  "clear(const EggMaterialCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all materials from the collection.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_clear_995_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggMaterialCollection::extract_materials(EggGroupNode *node)
 */
static PyObject *Dtool_EggMaterialCollection_extract_materials_996(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.extract_materials")) {
    return NULL;
  }
  // 1-int EggMaterialCollection::extract_materials(EggGroupNode *node)
  PT(EggGroupNode) arg_this;
  if (!Dtool_Coerce_EggGroupNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterialCollection.extract_materials", "EggGroupNode");
  }
  int return_value = (*local_this).extract_materials(MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_materials(const EggMaterialCollection self, EggGroupNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_extract_materials_996_comment =
  "C++ Interface:\n"
  "extract_materials(const EggMaterialCollection self, EggGroupNode node)\n"
  "\n"
  "/**\n"
  " * Walks the egg hierarchy beginning at the indicated node, and removes any\n"
  " * EggMaterials encountered in the hierarchy, adding them to the collection.\n"
  " * Returns the number of EggMaterials encountered.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_extract_materials_996_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggMaterialCollection::find_used_materials(EggNode *node)
 */
static PyObject *Dtool_EggMaterialCollection_find_used_materials_997(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.find_used_materials")) {
    return NULL;
  }
  // 1-int EggMaterialCollection::find_used_materials(EggNode *node)
  PT(EggNode) arg_this;
  if (!Dtool_Coerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterialCollection.find_used_materials", "EggNode");
  }
  int return_value = (*local_this).find_used_materials(MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_used_materials(const EggMaterialCollection self, EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_find_used_materials_997_comment =
  "C++ Interface:\n"
  "find_used_materials(const EggMaterialCollection self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Walks the egg hierarchy beginning at the indicated node, looking for\n"
  " * materials that are referenced by primitives but are not already members of\n"
  " * the collection, adding them to the collection.\n"
  " *\n"
  " * If this is called following extract_materials(), it can be used to pick up\n"
  " * any additional material references that appeared in the egg hierarchy (but\n"
  " * whose EggMaterial node was not actually part of the hierarchy).\n"
  " *\n"
  " * If this is called in lieu of extract_materials(), it will fill up the\n"
  " * collection with all of the referenced materials (and only the referenced\n"
  " * materials), without destructively removing the EggMaterials from the\n"
  " * hierarchy.\n"
  " *\n"
  " * This also has the side effect of incrementing the internal usage count for\n"
  " * a material in the collection each time a material reference is encountered.\n"
  " * This side effect is taken advantage of by remove_unused_materials().\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_find_used_materials_997_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggMaterialCollection::remove_unused_materials(EggNode *node)
 */
static PyObject *Dtool_EggMaterialCollection_remove_unused_materials_998(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.remove_unused_materials")) {
    return NULL;
  }
  // 1-void EggMaterialCollection::remove_unused_materials(EggNode *node)
  PT(EggNode) arg_this;
  if (!Dtool_Coerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterialCollection.remove_unused_materials", "EggNode");
  }
  (*local_this).remove_unused_materials(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_unused_materials(const EggMaterialCollection self, EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_remove_unused_materials_998_comment =
  "C++ Interface:\n"
  "remove_unused_materials(const EggMaterialCollection self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Removes any materials from the collection that aren't referenced by any\n"
  " * primitives in the indicated egg hierarchy.  This also, incidentally, adds\n"
  " * materials to the collection that had been referenced by primitives but had\n"
  " * not previously appeared in the collection.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_remove_unused_materials_998_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggMaterialCollection::collapse_equivalent_materials(int eq, EggGroupNode *node)
 * Rejected Remap [int EggMaterialCollection::collapse_equivalent_materials(int eq, EggMaterialCollection::MaterialReplacement &removed)]
 */
static PyObject *Dtool_EggMaterialCollection_collapse_equivalent_materials_999(PyObject *self, PyObject *args, PyObject *kwds) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.collapse_equivalent_materials")) {
    return NULL;
  }
  // 1-int EggMaterialCollection::collapse_equivalent_materials(int eq, EggGroupNode *node)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"eq", "node", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:collapse_equivalent_materials", (char **)keyword_list, &param1, &param2)) {
    PT(EggGroupNode) param2_this;
    if (!Dtool_Coerce_EggGroupNode(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggMaterialCollection.collapse_equivalent_materials", "EggGroupNode");
    }
    int return_value = (*local_this).collapse_equivalent_materials((int)param1, MOVE(param2_this));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collapse_equivalent_materials(const EggMaterialCollection self, int eq, EggGroupNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_collapse_equivalent_materials_999_comment =
  "C++ Interface:\n"
  "collapse_equivalent_materials(const EggMaterialCollection self, int eq, EggGroupNode node)\n"
  "\n"
  "/**\n"
  " * Walks through the collection and collapses together any separate materials\n"
  " * that are equivalent according to the indicated equivalence factor, eq (see\n"
  " * EggMaterial::is_equivalent_to()).  The return value is the number of\n"
  " * materials removed.\n"
  " *\n"
  " * This flavor of collapse_equivalent_materials() automatically adjusts all\n"
  " * the primitives in the egg hierarchy to refer to the new material pointers.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Walks through the collection and collapses together any separate materials\n"
  " * that are equivalent according to the indicated equivalence factor, eq (see\n"
  " * EggMaterial::is_equivalent_to()).  The return value is the number of\n"
  " * materials removed.\n"
  " *\n"
  " * This flavor of collapse_equivalent_materials() does not adjust any\n"
  " * primitives in the egg hierarchy; instead, it fills up the 'removed' map\n"
  " * with an entry for each removed material, mapping it back to the equivalent\n"
  " * retained material.  It's up to the user to then call replace_materials()\n"
  " * with this map, if desired, to apply these changes to the egg hierarchy.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_collapse_equivalent_materials_999_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggMaterialCollection::uniquify_mrefs(void)
 */
static PyObject *Dtool_EggMaterialCollection_uniquify_mrefs_1001(PyObject *self, PyObject *) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.uniquify_mrefs")) {
    return NULL;
  }
  // 1-void EggMaterialCollection::uniquify_mrefs(void)
  (*local_this).uniquify_mrefs();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_uniquify_mrefs_1001_comment =
  "C++ Interface:\n"
  "uniquify_mrefs(const EggMaterialCollection self)\n"
  "\n"
  "/**\n"
  " * Guarantees that each material in the collection has a unique MRef name.\n"
  " * This is essential before writing an egg file.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_uniquify_mrefs_1001_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggMaterialCollection::sort_by_mref(void)
 */
static PyObject *Dtool_EggMaterialCollection_sort_by_mref_1002(PyObject *self, PyObject *) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.sort_by_mref")) {
    return NULL;
  }
  // 1-void EggMaterialCollection::sort_by_mref(void)
  (*local_this).sort_by_mref();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_sort_by_mref_1002_comment =
  "C++ Interface:\n"
  "sort_by_mref(const EggMaterialCollection self)\n"
  "\n"
  "/**\n"
  " * Sorts all the materials into alphabetical order by MRef name.  Subsequent\n"
  " * operations using begin()/end() will traverse in this sorted order.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_sort_by_mref_1002_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggMaterialCollection::add_material(EggMaterial *material)
 */
static PyObject *Dtool_EggMaterialCollection_add_material_1003(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.add_material")) {
    return NULL;
  }
  // 1-bool EggMaterialCollection::add_material(EggMaterial *material)
  PT(EggMaterial) arg_this;
  if (!Dtool_Coerce_EggMaterial(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterialCollection.add_material", "EggMaterial");
  }
  bool return_value = (*local_this).add_material(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_material(const EggMaterialCollection self, EggMaterial material)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_add_material_1003_comment =
  "C++ Interface:\n"
  "add_material(const EggMaterialCollection self, EggMaterial material)\n"
  "\n"
  "/**\n"
  " * Explicitly adds a new material to the collection.  Returns true if the\n"
  " * material was added, false if it was already there or if there was some\n"
  " * error.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_add_material_1003_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggMaterialCollection::remove_material(EggMaterial *material)
 */
static PyObject *Dtool_EggMaterialCollection_remove_material_1004(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.remove_material")) {
    return NULL;
  }
  // 1-bool EggMaterialCollection::remove_material(EggMaterial *material)
  PT(EggMaterial) arg_this;
  if (!Dtool_Coerce_EggMaterial(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterialCollection.remove_material", "EggMaterial");
  }
  bool return_value = (*local_this).remove_material(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_material(const EggMaterialCollection self, EggMaterial material)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_remove_material_1004_comment =
  "C++ Interface:\n"
  "remove_material(const EggMaterialCollection self, EggMaterial material)\n"
  "\n"
  "/**\n"
  " * Explicitly removes a material from the collection.  Returns true if the\n"
  " * material was removed, false if it wasn't there or if there was some error.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_remove_material_1004_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggMaterial *EggMaterialCollection::create_unique_material(EggMaterial const &copy, int eq)
 */
static PyObject *Dtool_EggMaterialCollection_create_unique_material_1005(PyObject *self, PyObject *args, PyObject *kwds) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.create_unique_material")) {
    return NULL;
  }
  // 1-EggMaterial *EggMaterialCollection::create_unique_material(EggMaterial const &copy, int eq)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"copy", "eq", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:create_unique_material", (char **)keyword_list, &param1, &param2)) {
    CPT(EggMaterial) param1_this;
    if (!Dtool_ConstCoerce_EggMaterial(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggMaterialCollection.create_unique_material", "EggMaterial");
    }
    EggMaterial *return_value = (*local_this).create_unique_material(*MOVE(param1_this), (int)param2);
    if (return_value != (EggMaterial *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggMaterial *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggMaterial, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "create_unique_material(const EggMaterialCollection self, const EggMaterial copy, int eq)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_create_unique_material_1005_comment =
  "C++ Interface:\n"
  "create_unique_material(const EggMaterialCollection self, const EggMaterial copy, int eq)\n"
  "\n"
  "// create_unique_material() creates a new material if there is not already\n"
  "// one equivalent (according to eq, see EggMaterial::is_equivalent_to()) to\n"
  "// the indicated material, or returns the existing one if there is.\n"
  "\n"
  "/**\n"
  " * Creates a new material if there is not already one equivalent (according to\n"
  " * eq, see EggMaterial::is_equivalent_to()) to the indicated material, or\n"
  " * returns the existing one if there is.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_create_unique_material_1005_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggMaterial *EggMaterialCollection::find_mref(std::string const &mref_name) const
 */
static PyObject *Dtool_EggMaterialCollection_find_mref_1006(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterialCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-EggMaterial *EggMaterialCollection::find_mref(std::string const &mref_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    EggMaterial *return_value = (*(const EggMaterialCollection*)local_this).find_mref(std::string(param1_str, param1_len));
    if (return_value != (EggMaterial *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggMaterial *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggMaterial, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_mref(EggMaterialCollection self, str mref_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_find_mref_1006_comment =
  "C++ Interface:\n"
  "find_mref(EggMaterialCollection self, str mref_name)\n"
  "\n"
  "// Find a material with a particular MRef name.\n"
  "\n"
  "/**\n"
  " * Returns the material with the indicated MRef name, or NULL if no material\n"
  " * matches.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_find_mref_1006_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggMaterialCollection::EggMaterialCollection(void)
 * EggMaterialCollection::EggMaterialCollection(EggMaterialCollection const &copy)
 */
static int Dtool_Init_EggMaterialCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggMaterialCollection::EggMaterialCollection(void)
      EggMaterialCollection *return_value = new EggMaterialCollection();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggMaterialCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-EggMaterialCollection::EggMaterialCollection(EggMaterialCollection const &copy)
      EggMaterialCollection const *arg_this = (EggMaterialCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggMaterialCollection, 0, "EggMaterialCollection.EggMaterialCollection", true, true);
      if (arg_this != NULL) {
        EggMaterialCollection *return_value = new EggMaterialCollection(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggMaterialCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggMaterialCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggMaterialCollection()\n"
      "EggMaterialCollection(const EggMaterialCollection copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggMaterialCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggMaterialCollection) {
    printf("EggMaterialCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggMaterialCollection *local_this = (EggMaterialCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggMaterialCollection) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggMaterialCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggMaterialCollection) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggPolygon
 */
/**
 * Python function wrapper for:
 * inline EggPolygon &EggPolygon::operator =(EggPolygon const &copy)
 */
static PyObject *Dtool_EggPolygon_operator_1008(PyObject *self, PyObject *arg) {
  EggPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPolygon, (void **)&local_this, "EggPolygon.assign")) {
    return NULL;
  }
  // 1-inline EggPolygon &EggPolygon::operator =(EggPolygon const &copy)
  CPT(EggPolygon) arg_this;
  if (!Dtool_ConstCoerce_EggPolygon(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggPolygon.assign", "EggPolygon");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggPolygon *return_value = local_this;
  if (return_value != (EggPolygon *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggPolygon *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPolygon, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggPolygon self, const EggPolygon copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_operator_1008_comment =
  "C++ Interface:\n"
  "assign(const EggPolygon self, const EggPolygon copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPolygon_operator_1008_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggPolygon *EggPolygon::make_copy(void) override
 */
static PyObject *Dtool_EggPolygon_make_copy_1009(PyObject *self, PyObject *) {
  EggPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPolygon, (void **)&local_this, "EggPolygon.make_copy")) {
    return NULL;
  }
  // 1-virtual EggPolygon *EggPolygon::make_copy(void) override
  EggPolygon *return_value = (*local_this).make_copy();
  if (return_value != (EggPolygon *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggPolygon *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPolygon, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_make_copy_1009_comment =
  "C++ Interface:\n"
  "make_copy(const EggPolygon self)\n"
  "\n"
  "/**\n"
  " * Makes a copy of this object.\n"
  " */";
#else
static const char *Dtool_EggPolygon_make_copy_1009_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggPolygon::calculate_normal(LNormald &result, CoordinateSystem cs = ::CS_default) const
 */
static PyObject *Dtool_EggPolygon_calculate_normal_1010(PyObject *self, PyObject *args, PyObject *kwds) {
  EggPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPolygon, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggPolygon::calculate_normal(LNormald &result, CoordinateSystem cs = ::CS_default) const
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"result", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:calculate_normal", (char **)keyword_list, &param1, &param2)) {
    LVector3d param1_local;
    LNormald *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggPolygon.calculate_normal", "LVector3d");
    }
    bool return_value = (*(const EggPolygon*)local_this).calculate_normal(*param1_this, (CoordinateSystem)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calculate_normal(EggPolygon self, LVector3d result, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_calculate_normal_1010_comment =
  "C++ Interface:\n"
  "calculate_normal(EggPolygon self, LVector3d result, int cs)\n"
  "\n"
  "/**\n"
  " * Calculates the true polygon normal--the vector pointing out of the front of\n"
  " * the polygon--based on the vertices.  This does not return or change the\n"
  " * polygon's normal as set via set_normal().\n"
  " *\n"
  " * The return value is true if the normal is computed correctly, or false if\n"
  " * the polygon is degenerate and does not have at least three noncollinear\n"
  " * vertices.\n"
  " */";
#else
static const char *Dtool_EggPolygon_calculate_normal_1010_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggPolygon::is_planar(void) const
 */
static PyObject *Dtool_EggPolygon_is_planar_1011(PyObject *self, PyObject *) {
  EggPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPolygon, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggPolygon::is_planar(void) const
  bool return_value = (*(const EggPolygon*)local_this).is_planar();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_is_planar_1011_comment =
  "C++ Interface:\n"
  "is_planar(EggPolygon self)\n"
  "\n"
  "/**\n"
  " * Returns true if all of the polygon's vertices lie within the same plane,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EggPolygon_is_planar_1011_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPolygon::recompute_polygon_normal(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_EggPolygon_recompute_polygon_normal_1012(PyObject *self, PyObject *args, PyObject *kwds) {
  EggPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPolygon, (void **)&local_this, "EggPolygon.recompute_polygon_normal")) {
    return NULL;
  }
  // 1-inline bool EggPolygon::recompute_polygon_normal(CoordinateSystem cs = ::CS_default)
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:recompute_polygon_normal", (char **)keyword_list, &param1)) {
    bool return_value = (*local_this).recompute_polygon_normal((CoordinateSystem)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "recompute_polygon_normal(const EggPolygon self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_recompute_polygon_normal_1012_comment =
  "C++ Interface:\n"
  "recompute_polygon_normal(const EggPolygon self, int cs)\n"
  "\n"
  "/**\n"
  " * Recalculates the normal according to the order of the vertices, and sets\n"
  " * it.  Returns true if the normal is computed correctly, or false if the\n"
  " * polygon is degenerate and does not have a normal.\n"
  " */";
#else
static const char *Dtool_EggPolygon_recompute_polygon_normal_1012_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPolygon::triangulate_into(EggGroupNode *container, bool convex_also) const
 */
static PyObject *Dtool_EggPolygon_triangulate_into_1013(PyObject *self, PyObject *args, PyObject *kwds) {
  EggPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPolygon, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggPolygon::triangulate_into(EggGroupNode *container, bool convex_also) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"container", "convex_also", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:triangulate_into", (char **)keyword_list, &param1, &param2)) {
    PT(EggGroupNode) param1_this;
    if (!Dtool_Coerce_EggGroupNode(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggPolygon.triangulate_into", "EggGroupNode");
    }
    bool return_value = (*(const EggPolygon*)local_this).triangulate_into(MOVE(param1_this), (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "triangulate_into(EggPolygon self, EggGroupNode container, bool convex_also)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_triangulate_into_1013_comment =
  "C++ Interface:\n"
  "triangulate_into(EggPolygon self, EggGroupNode container, bool convex_also)\n"
  "\n"
  "/**\n"
  " * Subdivides the polygon into triangles and adds each one to the indicated\n"
  " * container.  If the polygon is already a triangle, adds an exact copy of the\n"
  " * polygon to the container.  Does not remove the polygon from its existing\n"
  " * parent or modify it in any way.\n"
  " *\n"
  " * Returns true if the triangulation is successful, or false if there was some\n"
  " * error (in which case the container may contain some partial triangulation).\n"
  " *\n"
  " * If convex_also is true, both concave and convex polygons will be subdivided\n"
  " * into triangles; otherwise, only concave polygons will be subdivided, and\n"
  " * convex polygons will be copied unchanged into the container.\n"
  " */";
#else
static const char *Dtool_EggPolygon_triangulate_into_1013_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< EggPolygon > EggPolygon::triangulate_in_place(bool convex_also)
 */
static PyObject *Dtool_EggPolygon_triangulate_in_place_1014(PyObject *self, PyObject *arg) {
  EggPolygon *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPolygon, (void **)&local_this, "EggPolygon.triangulate_in_place")) {
    return NULL;
  }
  // 1-PointerTo< EggPolygon > EggPolygon::triangulate_in_place(bool convex_also)
  PointerTo< EggPolygon > return_value = (*local_this).triangulate_in_place((PyObject_IsTrue(arg) != 0));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  EggPolygon *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggPolygon, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "triangulate_in_place(const EggPolygon self, bool convex_also)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_triangulate_in_place_1014_comment =
  "C++ Interface:\n"
  "triangulate_in_place(const EggPolygon self, bool convex_also)\n"
  "\n"
  "/**\n"
  " * Subdivides the polygon into triangles and adds those triangles to the\n"
  " * parent group node in place of the original polygon.  Returns a pointer to\n"
  " * the original polygon, which is likely about to be destructed.\n"
  " *\n"
  " * If convex_also is true, both concave and convex polygons will be subdivided\n"
  " * into triangles; otherwise, only concave polygons will be subdivided, and\n"
  " * convex polygons will be copied unchanged into the container.\n"
  " */";
#else
static const char *Dtool_EggPolygon_triangulate_in_place_1014_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggPolygon::get_class_type(void)
 */
static PyObject *Dtool_EggPolygon_get_class_type_1015(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPolygon::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggPolygon::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_get_class_type_1015_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPolygon_get_class_type_1015_comment = NULL;
#endif

static int Dtool_Init_EggPolygon(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggPolygon(PyObject *args, CPT(EggPolygon) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggPolygon, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggPolygon(PyObject *args, PT(EggPolygon) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggPolygon, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggPolygon(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggPolygon) {
    printf("EggPolygon ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggPolygon *local_this = (EggPolygon *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggPolygon) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggPolygon(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggPolygon) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPolygon*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggNurbsCurve
 */
/**
 * Python function wrapper for:
 * inline EggNurbsCurve &EggNurbsCurve::operator =(EggNurbsCurve const &copy)
 */
static PyObject *Dtool_EggNurbsCurve_operator_1018(PyObject *self, PyObject *arg) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.assign")) {
    return NULL;
  }
  // 1-inline EggNurbsCurve &EggNurbsCurve::operator =(EggNurbsCurve const &copy)
  CPT(EggNurbsCurve) arg_this;
  if (!Dtool_ConstCoerce_EggNurbsCurve(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggNurbsCurve.assign", "EggNurbsCurve");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggNurbsCurve *return_value = local_this;
  if (return_value != (EggNurbsCurve *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggNurbsCurve *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNurbsCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggNurbsCurve self, const EggNurbsCurve copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_operator_1018_comment =
  "C++ Interface:\n"
  "assign(const EggNurbsCurve self, const EggNurbsCurve copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_operator_1018_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggNurbsCurve *EggNurbsCurve::make_copy(void) override
 */
static PyObject *Dtool_EggNurbsCurve_make_copy_1019(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.make_copy")) {
    return NULL;
  }
  // 1-virtual EggNurbsCurve *EggNurbsCurve::make_copy(void) override
  EggNurbsCurve *return_value = (*local_this).make_copy();
  if (return_value != (EggNurbsCurve *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggNurbsCurve *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNurbsCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_make_copy_1019_comment =
  "C++ Interface:\n"
  "make_copy(const EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Makes a copy of this object.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_make_copy_1019_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggNurbsCurve::setup(int order, int num_knots)
 */
static PyObject *Dtool_EggNurbsCurve_setup_1020(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.setup")) {
    return NULL;
  }
  // 1-void EggNurbsCurve::setup(int order, int num_knots)
  int param1;
  int param2;
  static const char *keyword_list[] = {"order", "num_knots", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:setup", (char **)keyword_list, &param1, &param2)) {
    (*local_this).setup((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup(const EggNurbsCurve self, int order, int num_knots)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_setup_1020_comment =
  "C++ Interface:\n"
  "setup(const EggNurbsCurve self, int order, int num_knots)\n"
  "\n"
  "/**\n"
  " * Prepares a new curve definition with the indicated order and number of\n"
  " * knots.  This also implies a particular number of vertices as well (the\n"
  " * number of knots minus the order), but it is up to the user to add the\n"
  " * correct number of vertices to the curve by repeatedly calling push_back().\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_setup_1020_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsCurve::set_order(int order)
 */
static PyObject *Dtool_EggNurbsCurve_set_order_1021(PyObject *self, PyObject *arg) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.set_order")) {
    return NULL;
  }
  // 1-inline void EggNurbsCurve::set_order(int order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_order((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_order(const EggNurbsCurve self, int order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_set_order_1021_comment =
  "C++ Interface:\n"
  "set_order(const EggNurbsCurve self, int order)\n"
  "\n"
  "/**\n"
  " * Directly changes the order to the indicated value (which must be an integer\n"
  " * in the range 1 <= order <= 4).  If possible, it is preferable to use the\n"
  " * setup() method instead of this method, since changing the order directly\n"
  " * may result in an invalid curve.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_set_order_1021_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggNurbsCurve::set_num_knots(int num)
 */
static PyObject *Dtool_EggNurbsCurve_set_num_knots_1022(PyObject *self, PyObject *arg) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.set_num_knots")) {
    return NULL;
  }
  // 1-void EggNurbsCurve::set_num_knots(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_knots((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_knots(const EggNurbsCurve self, int num)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_set_num_knots_1022_comment =
  "C++ Interface:\n"
  "set_num_knots(const EggNurbsCurve self, int num)\n"
  "\n"
  "/**\n"
  " * Directly changes the number of knots.  This will either add zero-valued\n"
  " * knots onto the end, or truncate knot values from the end, depending on\n"
  " * whether the list is being increased or decreased.  If possible, it is\n"
  " * preferable to use the setup() method instead of directly setting the number\n"
  " * of knots, as this may result in an invalid curve.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_set_num_knots_1022_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsCurve::set_knot(int k, double value)
 */
static PyObject *Dtool_EggNurbsCurve_set_knot_1023(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.set_knot")) {
    return NULL;
  }
  // 1-inline void EggNurbsCurve::set_knot(int k, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"k", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:set_knot", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_knot((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_knot(const EggNurbsCurve self, int k, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_set_knot_1023_comment =
  "C++ Interface:\n"
  "set_knot(const EggNurbsCurve self, int k, double value)\n"
  "\n"
  "/**\n"
  " * Resets the value of the indicated knot as indicated.  k must be in the\n"
  " * range 0 <= k < get_num_knots(), and the value must be in the range\n"
  " * get_knot(k - 1) <= value <= get_knot(k + 1).\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_set_knot_1023_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggNurbsCurve::is_valid(void) const
 */
static PyObject *Dtool_EggNurbsCurve_is_valid_1024(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggNurbsCurve::is_valid(void) const
  bool return_value = (*(const EggNurbsCurve*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_is_valid_1024_comment =
  "C++ Interface:\n"
  "is_valid(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns true if the NURBS parameters are all internally consistent (e.g.\n"
  " * it has the right number of vertices to match its number of knots and order\n"
  " * in each dimension), or false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_is_valid_1024_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsCurve::get_order(void) const
 */
static PyObject *Dtool_EggNurbsCurve_get_order_1025(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsCurve::get_order(void) const
  int return_value = (*(const EggNurbsCurve*)local_this).get_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_order_1025_comment =
  "C++ Interface:\n"
  "get_order(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the curve.  The order is the degree of the NURBS\n"
  " * equation plus 1; for a typical NURBS, the order is 4.  With this\n"
  " * implementation of NURBS, the order must be in the range [1, 4].\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_get_order_1025_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsCurve::get_degree(void) const
 */
static PyObject *Dtool_EggNurbsCurve_get_degree_1026(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsCurve::get_degree(void) const
  int return_value = (*(const EggNurbsCurve*)local_this).get_degree();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_degree_1026_comment =
  "C++ Interface:\n"
  "get_degree(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the degree of the curve.  For a typical NURBS, the degree is 3.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_get_degree_1026_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsCurve::get_num_knots(void) const
 */
static PyObject *Dtool_EggNurbsCurve_get_num_knots_1027(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsCurve::get_num_knots(void) const
  int return_value = (*(const EggNurbsCurve*)local_this).get_num_knots();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_num_knots_1027_comment =
  "C++ Interface:\n"
  "get_num_knots(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knots.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_get_num_knots_1027_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsCurve::get_num_cvs(void) const
 */
static PyObject *Dtool_EggNurbsCurve_get_num_cvs_1028(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsCurve::get_num_cvs(void) const
  int return_value = (*(const EggNurbsCurve*)local_this).get_num_cvs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_num_cvs_1028_comment =
  "C++ Interface:\n"
  "get_num_cvs(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of control vertices that *should* be defined for\n"
  " * the curve.  This is determined by the number of knots and the order, in\n"
  " * each direction; it does not necessarily reflect the number of vertices that\n"
  " * have actually been added to the curve.  (However, if the number of vertices\n"
  " * in the curve are wrong, the curve is invalid.)\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_get_num_cvs_1028_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggNurbsCurve::is_closed(void) const
 */
static PyObject *Dtool_EggNurbsCurve_is_closed_1029(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggNurbsCurve::is_closed(void) const
  bool return_value = (*(const EggNurbsCurve*)local_this).is_closed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_is_closed_1029_comment =
  "C++ Interface:\n"
  "is_closed(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns true if the curve appears to be closed.  Since the Egg syntax does\n"
  " * not provide a means for explicit indication of closure, this has to be\n"
  " * guessed at by examining the curve itself.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_is_closed_1029_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggNurbsCurve::get_knot(int k) const
 */
static PyObject *Dtool_EggNurbsCurve_get_knot_1030(PyObject *self, PyObject *arg) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggNurbsCurve::get_knot(int k) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const EggNurbsCurve*)local_this).get_knot((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_knot(EggNurbsCurve self, int k)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_knot_1030_comment =
  "C++ Interface:\n"
  "get_knot(EggNurbsCurve self, int k)\n"
  "\n"
  "/**\n"
  " * Returns the nth knot value defined.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_get_knot_1030_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggNurbsCurve::get_class_type(void)
 */
static PyObject *Dtool_EggNurbsCurve_get_class_type_1036(PyObject *, PyObject *) {
  // 1-static TypeHandle EggNurbsCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggNurbsCurve::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_class_type_1036_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggNurbsCurve_get_class_type_1036_comment = NULL;
#endif

static PyObject *Dtool_EggNurbsCurve_order_Getter(PyObject *self, void *) {
  const EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int EggNurbsCurve::get_order(void) const
  int return_value = (*(const EggNurbsCurve*)local_this).get_order();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggNurbsCurve_order_Setter(PyObject *self, PyObject *arg, void *) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.order")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete order attribute");
    return -1;
  }
  // 1-inline void EggNurbsCurve::set_order(int order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_order((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_order(const EggNurbsCurve self, int order)\n");
  }
  return -1;
}

static PyObject *Dtool_EggNurbsCurve_degree_Getter(PyObject *self, void *) {
  const EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int EggNurbsCurve::get_degree(void) const
  int return_value = (*(const EggNurbsCurve*)local_this).get_degree();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_EggNurbsCurve_closed_Getter(PyObject *self, void *) {
  const EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }

  // 1-bool EggNurbsCurve::is_closed(void) const
  bool return_value = (*(const EggNurbsCurve*)local_this).is_closed();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property EggNurbsCurve::knots
 */
static Py_ssize_t Dtool_EggNurbsCurve_knots_Len(PyObject *self) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_knots();
}

/**
 * sequence getter for property EggNurbsCurve::knots
 */
static PyObject *Dtool_EggNurbsCurve_knots_Getitem(PyObject *self, Py_ssize_t index) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_knots()) {
    PyErr_SetString(PyExc_IndexError, "EggNurbsCurve.knots[] index out of range");
    return NULL;
  }
  // 1-inline double EggNurbsCurve::get_knot(int k) const
  double return_value = (*(const EggNurbsCurve*)local_this).get_knot(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_knot(EggNurbsCurve self, index)\n");
  }
}

static int Dtool_EggNurbsCurve_knots_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.knots")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete knots[] attribute");
    return -1;
  }
  // 1-inline void EggNurbsCurve::set_knot(int k, double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_knot(index, PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_knot(const EggNurbsCurve self, index, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_EggNurbsCurve_knots_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_EggNurbsCurve_knots_Len;
  wrap->_getitem_func = &Dtool_EggNurbsCurve_knots_Getitem;
  wrap->_setitem_func = &Dtool_EggNurbsCurve_knots_Setitem;
  return (PyObject *)wrap;
}

static int Dtool_Init_EggNurbsCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggNurbsCurve(PyObject *args, CPT(EggNurbsCurve) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggNurbsCurve, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggNurbsCurve(PyObject *args, PT(EggNurbsCurve) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggNurbsCurve, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggNurbsCurve_get_knots(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_knots();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggNurbsCurve_get_knot_1030(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggNurbsCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggNurbsCurve) {
    printf("EggNurbsCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggNurbsCurve *local_this = (EggNurbsCurve *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggNurbsCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggCurve) {
    return (EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggNurbsCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggNurbsCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggCurve) {
    EggCurve* other_this = (EggCurve*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggSurface
 */
/**
 * Python function wrapper for:
 * inline EggSurface &EggSurface::operator =(EggSurface const &copy)
 */
static PyObject *Dtool_EggSurface_operator_1039(PyObject *self, PyObject *arg) {
  EggSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSurface, (void **)&local_this, "EggSurface.assign")) {
    return NULL;
  }
  // 1-inline EggSurface &EggSurface::operator =(EggSurface const &copy)
  CPT(EggSurface) arg_this;
  if (!Dtool_ConstCoerce_EggSurface(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggSurface.assign", "EggSurface");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggSurface *return_value = local_this;
  if (return_value != (EggSurface *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggSurface *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggSurface, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggSurface self, const EggSurface copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_operator_1039_comment =
  "C++ Interface:\n"
  "assign(const EggSurface self, const EggSurface copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggSurface_operator_1039_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggSurface::set_u_subdiv(int subdiv)
 */
static PyObject *Dtool_EggSurface_set_u_subdiv_1040(PyObject *self, PyObject *arg) {
  EggSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSurface, (void **)&local_this, "EggSurface.set_u_subdiv")) {
    return NULL;
  }
  // 1-inline void EggSurface::set_u_subdiv(int subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_u_subdiv((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_subdiv(const EggSurface self, int subdiv)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_set_u_subdiv_1040_comment =
  "C++ Interface:\n"
  "set_u_subdiv(const EggSurface self, int subdiv)\n"
  "\n"
  "/**\n"
  " * Sets the number of subdivisions in the U direction that will be requested\n"
  " * across the surface.  (This doesn't necessary guarantee that this number of\n"
  " * subdivisions will be made; it's just a hint to any surface renderer or\n"
  " * quick tesselator.)  Set the number to 0 to disable the hint.\n"
  " */";
#else
static const char *Dtool_EggSurface_set_u_subdiv_1040_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggSurface::get_u_subdiv(void) const
 */
static PyObject *Dtool_EggSurface_get_u_subdiv_1041(PyObject *self, PyObject *) {
  EggSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggSurface::get_u_subdiv(void) const
  int return_value = (*(const EggSurface*)local_this).get_u_subdiv();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_get_u_subdiv_1041_comment =
  "C++ Interface:\n"
  "get_u_subdiv(EggSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the requested number of subdivisions in the U direction, or 0 if no\n"
  " * particular subdivisions have been requested.\n"
  " */";
#else
static const char *Dtool_EggSurface_get_u_subdiv_1041_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggSurface::set_v_subdiv(int subdiv)
 */
static PyObject *Dtool_EggSurface_set_v_subdiv_1042(PyObject *self, PyObject *arg) {
  EggSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSurface, (void **)&local_this, "EggSurface.set_v_subdiv")) {
    return NULL;
  }
  // 1-inline void EggSurface::set_v_subdiv(int subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_v_subdiv((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_subdiv(const EggSurface self, int subdiv)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_set_v_subdiv_1042_comment =
  "C++ Interface:\n"
  "set_v_subdiv(const EggSurface self, int subdiv)\n"
  "\n"
  "/**\n"
  " * Sets the number of subdivisions in the U direction that will be requested\n"
  " * across the surface.  (This doesn't necessary guarantee that this number of\n"
  " * subdivisions will be made; it's just a hint to any surface renderer or\n"
  " * quick tesselator.)  Set the number to 0 to disable the hint.\n"
  " */";
#else
static const char *Dtool_EggSurface_set_v_subdiv_1042_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggSurface::get_v_subdiv(void) const
 */
static PyObject *Dtool_EggSurface_get_v_subdiv_1043(PyObject *self, PyObject *) {
  EggSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggSurface::get_v_subdiv(void) const
  int return_value = (*(const EggSurface*)local_this).get_v_subdiv();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_get_v_subdiv_1043_comment =
  "C++ Interface:\n"
  "get_v_subdiv(EggSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the requested number of subdivisions in the U direction, or 0 if no\n"
  " * particular subdivisions have been requested.\n"
  " */";
#else
static const char *Dtool_EggSurface_get_v_subdiv_1043_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggSurface::get_class_type(void)
 */
static PyObject *Dtool_EggSurface_get_class_type_1044(PyObject *, PyObject *) {
  // 1-static TypeHandle EggSurface::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggSurface::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_get_class_type_1044_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggSurface_get_class_type_1044_comment = NULL;
#endif

static int Dtool_Init_EggSurface(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggSurface(PyObject *args, CPT(EggSurface) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggSurface, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggSurface(PyObject *args, PT(EggSurface) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggSurface, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggSurface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggSurface) {
    printf("EggSurface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggSurface *local_this = (EggSurface *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggSurface) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggSurface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggSurface) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggSurface*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggNurbsSurface
 */
/**
 * Python function wrapper for:
 * inline EggNurbsSurface &EggNurbsSurface::operator =(EggNurbsSurface const &copy)
 */
static PyObject *Dtool_EggNurbsSurface_operator_1055(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.assign")) {
    return NULL;
  }
  // 1-inline EggNurbsSurface &EggNurbsSurface::operator =(EggNurbsSurface const &copy)
  CPT(EggNurbsSurface) arg_this;
  if (!Dtool_ConstCoerce_EggNurbsSurface(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggNurbsSurface.assign", "EggNurbsSurface");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggNurbsSurface *return_value = local_this;
  if (return_value != (EggNurbsSurface *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggNurbsSurface *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNurbsSurface, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggNurbsSurface self, const EggNurbsSurface copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_operator_1055_comment =
  "C++ Interface:\n"
  "assign(const EggNurbsSurface self, const EggNurbsSurface copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_operator_1055_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggNurbsSurface *EggNurbsSurface::make_copy(void) override
 */
static PyObject *Dtool_EggNurbsSurface_make_copy_1056(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.make_copy")) {
    return NULL;
  }
  // 1-virtual EggNurbsSurface *EggNurbsSurface::make_copy(void) override
  EggNurbsSurface *return_value = (*local_this).make_copy();
  if (return_value != (EggNurbsSurface *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggNurbsSurface *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNurbsSurface, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_make_copy_1056_comment =
  "C++ Interface:\n"
  "make_copy(const EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Makes a copy of this object.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_make_copy_1056_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggNurbsSurface::setup(int u_order, int v_order, int num_u_knots, int num_v_knots)
 */
static PyObject *Dtool_EggNurbsSurface_setup_1057(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.setup")) {
    return NULL;
  }
  // 1-void EggNurbsSurface::setup(int u_order, int v_order, int num_u_knots, int num_v_knots)
  int param1;
  int param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"u_order", "v_order", "num_u_knots", "num_v_knots", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:setup", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).setup((int)param1, (int)param2, (int)param3, (int)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup(const EggNurbsSurface self, int u_order, int v_order, int num_u_knots, int num_v_knots)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_setup_1057_comment =
  "C++ Interface:\n"
  "setup(const EggNurbsSurface self, int u_order, int v_order, int num_u_knots, int num_v_knots)\n"
  "\n"
  "/**\n"
  " * Prepares a new surface definition with the indicated order and number of\n"
  " * knots in each dimension.  This also implies a particular number of vertices\n"
  " * in each dimension as well (the number of knots minus the order), but it is\n"
  " * up to the user to add the correct number of vertices to the surface by\n"
  " * repeatedly calling push_back().\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_setup_1057_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsSurface::set_u_order(int u_order)
 */
static PyObject *Dtool_EggNurbsSurface_set_u_order_1058(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_u_order")) {
    return NULL;
  }
  // 1-inline void EggNurbsSurface::set_u_order(int u_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_u_order((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_order(const EggNurbsSurface self, int u_order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_u_order_1058_comment =
  "C++ Interface:\n"
  "set_u_order(const EggNurbsSurface self, int u_order)\n"
  "\n"
  "/**\n"
  " * Directly changes the order in the U direction to the indicated value (which\n"
  " * must be an integer in the range 1 <= u_order <= 4).  If possible, it is\n"
  " * preferable to use the setup() method instead of this method, since changing\n"
  " * the order directly may result in an invalid surface.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_u_order_1058_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsSurface::set_v_order(int v_order)
 */
static PyObject *Dtool_EggNurbsSurface_set_v_order_1059(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_v_order")) {
    return NULL;
  }
  // 1-inline void EggNurbsSurface::set_v_order(int v_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_v_order((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_order(const EggNurbsSurface self, int v_order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_v_order_1059_comment =
  "C++ Interface:\n"
  "set_v_order(const EggNurbsSurface self, int v_order)\n"
  "\n"
  "/**\n"
  " * Directly changes the order in the V direction to the indicated value (which\n"
  " * must be an integer in the range 1 <= v_order <= 4).  If possible, it is\n"
  " * preferable to use the setup() method instead of this method, since changing\n"
  " * the order directly may result in an invalid surface.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_v_order_1059_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggNurbsSurface::set_num_u_knots(int num)
 */
static PyObject *Dtool_EggNurbsSurface_set_num_u_knots_1060(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_num_u_knots")) {
    return NULL;
  }
  // 1-void EggNurbsSurface::set_num_u_knots(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_u_knots((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_u_knots(const EggNurbsSurface self, int num)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_num_u_knots_1060_comment =
  "C++ Interface:\n"
  "set_num_u_knots(const EggNurbsSurface self, int num)\n"
  "\n"
  "/**\n"
  " * Directly changes the number of knots in the U direction.  This will either\n"
  " * add zero-valued knots onto the end, or truncate knot values from the end,\n"
  " * depending on whether the list is being increased or decreased.  If\n"
  " * possible, it is preferable to use the setup() method instead of directly\n"
  " * setting the number of knots, as this may result in an invalid surface.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_num_u_knots_1060_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggNurbsSurface::set_num_v_knots(int num)
 */
static PyObject *Dtool_EggNurbsSurface_set_num_v_knots_1061(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_num_v_knots")) {
    return NULL;
  }
  // 1-void EggNurbsSurface::set_num_v_knots(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_num_v_knots((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_v_knots(const EggNurbsSurface self, int num)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_num_v_knots_1061_comment =
  "C++ Interface:\n"
  "set_num_v_knots(const EggNurbsSurface self, int num)\n"
  "\n"
  "/**\n"
  " * Directly changes the number of knots in the V direction.  This will either\n"
  " * add zero-valued knots onto the end, or truncate knot values from the end,\n"
  " * depending on whether the list is being increased or decreased.  If\n"
  " * possible, it is preferable to use the setup() method instead of directly\n"
  " * setting the number of knots, as this may result in an invalid surface.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_num_v_knots_1061_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsSurface::set_u_knot(int k, double value)
 */
static PyObject *Dtool_EggNurbsSurface_set_u_knot_1062(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_u_knot")) {
    return NULL;
  }
  // 1-inline void EggNurbsSurface::set_u_knot(int k, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"k", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:set_u_knot", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_u_knot((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_knot(const EggNurbsSurface self, int k, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_u_knot_1062_comment =
  "C++ Interface:\n"
  "set_u_knot(const EggNurbsSurface self, int k, double value)\n"
  "\n"
  "/**\n"
  " * Resets the value of the indicated knot as indicated.  k must be in the\n"
  " * range 0 <= k < get_num_u_knots(), and the value must be in the range\n"
  " * get_u_knot(k - 1) <= value <= get_u_knot(k + 1).\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_u_knot_1062_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsSurface::set_v_knot(int k, double value)
 */
static PyObject *Dtool_EggNurbsSurface_set_v_knot_1063(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_v_knot")) {
    return NULL;
  }
  // 1-inline void EggNurbsSurface::set_v_knot(int k, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"k", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:set_v_knot", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_v_knot((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_knot(const EggNurbsSurface self, int k, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_v_knot_1063_comment =
  "C++ Interface:\n"
  "set_v_knot(const EggNurbsSurface self, int k, double value)\n"
  "\n"
  "/**\n"
  " * Resets the value of the indicated knot as indicated.  k must be in the\n"
  " * range 0 <= k < get_num_v_knots(), and the value must be in the range\n"
  " * get_v_knot(k - 1) <= value <= get_v_knot(k + 1).\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_v_knot_1063_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsSurface::set_cv(int ui, int vi, EggVertex *vertex)
 */
static PyObject *Dtool_EggNurbsSurface_set_cv_1064(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_cv")) {
    return NULL;
  }
  // 1-inline void EggNurbsSurface::set_cv(int ui, int vi, EggVertex *vertex)
  int param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"ui", "vi", "vertex", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_cv", (char **)keyword_list, &param1, &param2, &param3)) {
    EggVertex *param3_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_EggVertex, 3, "EggNurbsSurface.set_cv", false, true);
    if (param3_this != NULL) {
      (*local_this).set_cv((int)param1, (int)param2, param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv(const EggNurbsSurface self, int ui, int vi, EggVertex vertex)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_cv_1064_comment =
  "C++ Interface:\n"
  "set_cv(const EggNurbsSurface self, int ui, int vi, EggVertex vertex)\n"
  "\n"
  "/**\n"
  " * Redefines the control vertex associated with a particular u, v coordinate\n"
  " * pair.  This is just a shorthand to access the EggPrimitive's normal vertex\n"
  " * assignment for a 2-d control vertex.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_cv_1064_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggNurbsSurface::is_valid(void) const
 */
static PyObject *Dtool_EggNurbsSurface_is_valid_1065(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggNurbsSurface::is_valid(void) const
  bool return_value = (*(const EggNurbsSurface*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_is_valid_1065_comment =
  "C++ Interface:\n"
  "is_valid(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns true if the NURBS parameters are all internally consistent (e.g.\n"
  " * it has the right number of vertices to match its number of knots and order\n"
  " * in each dimension), or false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_is_valid_1065_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_u_order(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_u_order_1066(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_u_order(void) const
  int return_value = (*(const EggNurbsSurface*)local_this).get_u_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_u_order_1066_comment =
  "C++ Interface:\n"
  "get_u_order(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the surface in the U direction.  The order is the\n"
  " * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.\n"
  " * With this implementation of NURBS, the order must be in the range [1, 4].\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_u_order_1066_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_v_order(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_v_order_1067(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_v_order(void) const
  int return_value = (*(const EggNurbsSurface*)local_this).get_v_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_v_order_1067_comment =
  "C++ Interface:\n"
  "get_v_order(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the surface in the V direction.  The order is the\n"
  " * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.\n"
  " * With this implementation of NURBS, the order must be in the range [1, 4].\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_v_order_1067_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_u_degree(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_u_degree_1068(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_u_degree(void) const
  int return_value = (*(const EggNurbsSurface*)local_this).get_u_degree();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_u_degree_1068_comment =
  "C++ Interface:\n"
  "get_u_degree(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the degree of the surface in the U direction.  For a typical NURBS,\n"
  " * the degree is 3.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_u_degree_1068_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_v_degree(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_v_degree_1069(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_v_degree(void) const
  int return_value = (*(const EggNurbsSurface*)local_this).get_v_degree();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_v_degree_1069_comment =
  "C++ Interface:\n"
  "get_v_degree(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the degree of the surface in the V direction.  for a typical NURBS,\n"
  " * the degree is 3.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_v_degree_1069_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_num_u_knots(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_num_u_knots_1070(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_num_u_knots(void) const
  int return_value = (*(const EggNurbsSurface*)local_this).get_num_u_knots();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_num_u_knots_1070_comment =
  "C++ Interface:\n"
  "get_num_u_knots(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knots in the U direction.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_num_u_knots_1070_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_num_v_knots(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_num_v_knots_1071(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_num_v_knots(void) const
  int return_value = (*(const EggNurbsSurface*)local_this).get_num_v_knots();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_num_v_knots_1071_comment =
  "C++ Interface:\n"
  "get_num_v_knots(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knots in the V direction.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_num_v_knots_1071_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_num_u_cvs(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_num_u_cvs_1072(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_num_u_cvs(void) const
  int return_value = (*(const EggNurbsSurface*)local_this).get_num_u_cvs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_num_u_cvs_1072_comment =
  "C++ Interface:\n"
  "get_num_u_cvs(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the number of control vertices that should be present in the U\n"
  " * direction.  This is determined by the number of knots and the order; it\n"
  " * does not necessarily reflect the number of vertices that have actually been\n"
  " * added to the surface.  (However, if the number of vertices in the surface\n"
  " * are wrong, the surface is invalid.)\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_num_u_cvs_1072_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_num_v_cvs(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_num_v_cvs_1073(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_num_v_cvs(void) const
  int return_value = (*(const EggNurbsSurface*)local_this).get_num_v_cvs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_num_v_cvs_1073_comment =
  "C++ Interface:\n"
  "get_num_v_cvs(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the number of control vertices that should be present in the V\n"
  " * direction.  This is determined by the number of knots and the order; it\n"
  " * does not necessarily reflect the number of vertices that have actually been\n"
  " * added to the surface.  (However, if the number of vertices in the surface\n"
  " * are wrong, the surface is invalid.)\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_num_v_cvs_1073_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_num_cvs(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_num_cvs_1074(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_num_cvs(void) const
  int return_value = (*(const EggNurbsSurface*)local_this).get_num_cvs();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_num_cvs_1074_comment =
  "C++ Interface:\n"
  "get_num_cvs(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of control vertices that *should* be defined for\n"
  " * the surface.  This is determined by the number of knots and the order, in\n"
  " * each direction; it does not necessarily reflect the number of vertices that\n"
  " * have actually been added to the surface.  (However, if the number of\n"
  " * vertices in the surface are wrong, the surface is invalid.)\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_num_cvs_1074_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_u_index(int vertex_index) const
 */
static PyObject *Dtool_EggNurbsSurface_get_u_index_1075(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_u_index(int vertex_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const EggNurbsSurface*)local_this).get_u_index((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_u_index(EggNurbsSurface self, int vertex_index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_u_index_1075_comment =
  "C++ Interface:\n"
  "get_u_index(EggNurbsSurface self, int vertex_index)\n"
  "\n"
  "/**\n"
  " * Returns the U index number of the given vertex within the EggPrimitive's\n"
  " * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices\n"
  " * to its 2-d mesh; this returns the U index number that corresponds to the\n"
  " * nth vertex in the list.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_u_index_1075_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_v_index(int vertex_index) const
 */
static PyObject *Dtool_EggNurbsSurface_get_v_index_1076(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_v_index(int vertex_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const EggNurbsSurface*)local_this).get_v_index((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_v_index(EggNurbsSurface self, int vertex_index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_v_index_1076_comment =
  "C++ Interface:\n"
  "get_v_index(EggNurbsSurface self, int vertex_index)\n"
  "\n"
  "/**\n"
  " * Returns the V index number of the given vertex within the EggPrimitive's\n"
  " * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices\n"
  " * to its 2-d mesh; this returns the V index number that corresponds to the\n"
  " * nth vertex in the list.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_v_index_1076_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_vertex_index(int ui, int vi) const
 */
static PyObject *Dtool_EggNurbsSurface_get_vertex_index_1077(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggNurbsSurface::get_vertex_index(int ui, int vi) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"ui", "vi", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_vertex_index", (char **)keyword_list, &param1, &param2)) {
    int return_value = (*(const EggNurbsSurface*)local_this).get_vertex_index((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex_index(EggNurbsSurface self, int ui, int vi)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_vertex_index_1077_comment =
  "C++ Interface:\n"
  "get_vertex_index(EggNurbsSurface self, int ui, int vi)\n"
  "\n"
  "/**\n"
  " * Returns the index number within the EggPrimitive's list of the control\n"
  " * vertex at position ui, vi.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_vertex_index_1077_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggNurbsSurface::is_closed_u(void) const
 */
static PyObject *Dtool_EggNurbsSurface_is_closed_u_1078(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggNurbsSurface::is_closed_u(void) const
  bool return_value = (*(const EggNurbsSurface*)local_this).is_closed_u();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_is_closed_u_1078_comment =
  "C++ Interface:\n"
  "is_closed_u(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns true if the surface appears to be closed in the U direction.  Since\n"
  " * the Egg syntax does not provide a means for explicit indication of closure,\n"
  " * this has to be guessed at by examining the surface itself.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_is_closed_u_1078_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggNurbsSurface::is_closed_v(void) const
 */
static PyObject *Dtool_EggNurbsSurface_is_closed_v_1079(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggNurbsSurface::is_closed_v(void) const
  bool return_value = (*(const EggNurbsSurface*)local_this).is_closed_v();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_is_closed_v_1079_comment =
  "C++ Interface:\n"
  "is_closed_v(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns true if the surface appears to be closed in the V direction.  Since\n"
  " * the Egg syntax does not provide a means for explicit indication of closure,\n"
  " * this has to be guessed at by examining the surface itself.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_is_closed_v_1079_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggNurbsSurface::get_u_knot(int k) const
 */
static PyObject *Dtool_EggNurbsSurface_get_u_knot_1080(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggNurbsSurface::get_u_knot(int k) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const EggNurbsSurface*)local_this).get_u_knot((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_u_knot(EggNurbsSurface self, int k)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_u_knot_1080_comment =
  "C++ Interface:\n"
  "get_u_knot(EggNurbsSurface self, int k)\n"
  "\n"
  "/**\n"
  " * Returns the nth knot value defined in the U direction.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_u_knot_1080_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggNurbsSurface::get_v_knot(int k) const
 */
static PyObject *Dtool_EggNurbsSurface_get_v_knot_1082(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggNurbsSurface::get_v_knot(int k) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const EggNurbsSurface*)local_this).get_v_knot((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_v_knot(EggNurbsSurface self, int k)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_v_knot_1082_comment =
  "C++ Interface:\n"
  "get_v_knot(EggNurbsSurface self, int k)\n"
  "\n"
  "/**\n"
  " * Returns the nth knot value defined in the V direction.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_v_knot_1082_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggVertex *EggNurbsSurface::get_cv(int ui, int vi) const
 */
static PyObject *Dtool_EggNurbsSurface_get_cv_1084(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggVertex *EggNurbsSurface::get_cv(int ui, int vi) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"ui", "vi", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_cv", (char **)keyword_list, &param1, &param2)) {
    EggVertex *return_value = (*(const EggNurbsSurface*)local_this).get_cv((int)param1, (int)param2);
    if (return_value != (EggVertex *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggVertex *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv(EggNurbsSurface self, int ui, int vi)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_cv_1084_comment =
  "C++ Interface:\n"
  "get_cv(EggNurbsSurface self, int ui, int vi)\n"
  "\n"
  "/**\n"
  " * Returns the control vertex at the indicate U, V position.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_cv_1084_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggNurbsSurface::get_class_type(void)
 */
static PyObject *Dtool_EggNurbsSurface_get_class_type_1085(PyObject *, PyObject *) {
  // 1-static TypeHandle EggNurbsSurface::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggNurbsSurface::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_class_type_1085_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggNurbsSurface_get_class_type_1085_comment = NULL;
#endif

static int Dtool_Init_EggNurbsSurface(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggNurbsSurface(PyObject *args, CPT(EggNurbsSurface) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggNurbsSurface, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggNurbsSurface(PyObject *args, PT(EggNurbsSurface) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggNurbsSurface, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggNurbsSurface_get_u_knots(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_u_knots();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggNurbsSurface_get_u_knot_1080(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggNurbsSurface_get_v_knots(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_v_knots();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggNurbsSurface_get_v_knot_1082(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggNurbsSurface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggNurbsSurface) {
    printf("EggNurbsSurface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggNurbsSurface *local_this = (EggNurbsSurface *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggNurbsSurface) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggSurface) {
    return (EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggNurbsSurface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggNurbsSurface) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggSurface) {
    EggSurface* other_this = (EggSurface*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggPatch
 */
/**
 * Python function wrapper for:
 * inline EggPatch &EggPatch::operator =(EggPatch const &copy)
 */
static PyObject *Dtool_EggPatch_operator_1088(PyObject *self, PyObject *arg) {
  EggPatch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPatch, (void **)&local_this, "EggPatch.assign")) {
    return NULL;
  }
  // 1-inline EggPatch &EggPatch::operator =(EggPatch const &copy)
  CPT(EggPatch) arg_this;
  if (!Dtool_ConstCoerce_EggPatch(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggPatch.assign", "EggPatch");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggPatch *return_value = local_this;
  if (return_value != (EggPatch *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggPatch *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPatch, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggPatch self, const EggPatch copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPatch_operator_1088_comment =
  "C++ Interface:\n"
  "assign(const EggPatch self, const EggPatch copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPatch_operator_1088_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggPatch *EggPatch::make_copy(void) override
 */
static PyObject *Dtool_EggPatch_make_copy_1089(PyObject *self, PyObject *) {
  EggPatch *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPatch, (void **)&local_this, "EggPatch.make_copy")) {
    return NULL;
  }
  // 1-virtual EggPatch *EggPatch::make_copy(void) override
  EggPatch *return_value = (*local_this).make_copy();
  if (return_value != (EggPatch *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggPatch *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPatch, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggPatch_make_copy_1089_comment =
  "C++ Interface:\n"
  "make_copy(const EggPatch self)\n"
  "\n"
  "/**\n"
  " * Makes a copy of this object.\n"
  " */";
#else
static const char *Dtool_EggPatch_make_copy_1089_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggPatch::get_class_type(void)
 */
static PyObject *Dtool_EggPatch_get_class_type_1090(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPatch::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggPatch::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPatch_get_class_type_1090_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPatch_get_class_type_1090_comment = NULL;
#endif

static int Dtool_Init_EggPatch(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggPatch(PyObject *args, CPT(EggPatch) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggPatch, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggPatch(PyObject *args, PT(EggPatch) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggPatch, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggPatch(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggPatch) {
    printf("EggPatch ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggPatch *local_this = (EggPatch *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggPatch) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggPatch(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggPatch) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPatch*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggPoint
 */
/**
 * Python function wrapper for:
 * inline EggPoint &EggPoint::operator =(EggPoint const &copy)
 */
static PyObject *Dtool_EggPoint_operator_1093(PyObject *self, PyObject *arg) {
  EggPoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPoint, (void **)&local_this, "EggPoint.assign")) {
    return NULL;
  }
  // 1-inline EggPoint &EggPoint::operator =(EggPoint const &copy)
  CPT(EggPoint) arg_this;
  if (!Dtool_ConstCoerce_EggPoint(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggPoint.assign", "EggPoint");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggPoint *return_value = local_this;
  if (return_value != (EggPoint *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggPoint *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPoint, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggPoint self, const EggPoint copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_operator_1093_comment =
  "C++ Interface:\n"
  "assign(const EggPoint self, const EggPoint copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_operator_1093_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggPoint *EggPoint::make_copy(void) override
 */
static PyObject *Dtool_EggPoint_make_copy_1094(PyObject *self, PyObject *) {
  EggPoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPoint, (void **)&local_this, "EggPoint.make_copy")) {
    return NULL;
  }
  // 1-virtual EggPoint *EggPoint::make_copy(void) override
  EggPoint *return_value = (*local_this).make_copy();
  if (return_value != (EggPoint *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggPoint *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_make_copy_1094_comment =
  "C++ Interface:\n"
  "make_copy(const EggPoint self)\n"
  "\n"
  "/**\n"
  " * Makes a copy of this object.\n"
  " */";
#else
static const char *Dtool_EggPoint_make_copy_1094_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPoint::has_thick(void) const
 */
static PyObject *Dtool_EggPoint_has_thick_1095(PyObject *self, PyObject *) {
  EggPoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggPoint::has_thick(void) const
  bool return_value = (*(const EggPoint*)local_this).has_thick();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_has_thick_1095_comment =
  "C++ Interface:\n"
  "has_thick(EggPoint self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_has_thick_1095_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggPoint::get_thick(void) const
 */
static PyObject *Dtool_EggPoint_get_thick_1096(PyObject *self, PyObject *) {
  EggPoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggPoint::get_thick(void) const
  double return_value = (*(const EggPoint*)local_this).get_thick();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_get_thick_1096_comment =
  "C++ Interface:\n"
  "get_thick(EggPoint self)\n"
  "\n"
  "/**\n"
  " * Returns the thickness set on this particular point.  If there is no\n"
  " * thickness set, returns 1.0.\n"
  " */";
#else
static const char *Dtool_EggPoint_get_thick_1096_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPoint::set_thick(double thick)
 */
static PyObject *Dtool_EggPoint_set_thick_1097(PyObject *self, PyObject *arg) {
  EggPoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPoint, (void **)&local_this, "EggPoint.set_thick")) {
    return NULL;
  }
  // 1-inline void EggPoint::set_thick(double thick)
  if (PyNumber_Check(arg)) {
    (*local_this).set_thick(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_thick(const EggPoint self, double thick)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_set_thick_1097_comment =
  "C++ Interface:\n"
  "set_thick(const EggPoint self, double thick)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_set_thick_1097_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPoint::clear_thick(void)
 */
static PyObject *Dtool_EggPoint_clear_thick_1098(PyObject *self, PyObject *) {
  EggPoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPoint, (void **)&local_this, "EggPoint.clear_thick")) {
    return NULL;
  }
  // 1-inline void EggPoint::clear_thick(void)
  (*local_this).clear_thick();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_clear_thick_1098_comment =
  "C++ Interface:\n"
  "clear_thick(const EggPoint self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_clear_thick_1098_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPoint::has_perspective(void) const
 */
static PyObject *Dtool_EggPoint_has_perspective_1099(PyObject *self, PyObject *) {
  EggPoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggPoint::has_perspective(void) const
  bool return_value = (*(const EggPoint*)local_this).has_perspective();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_has_perspective_1099_comment =
  "C++ Interface:\n"
  "has_perspective(EggPoint self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_has_perspective_1099_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPoint::get_perspective(void) const
 */
static PyObject *Dtool_EggPoint_get_perspective_1100(PyObject *self, PyObject *) {
  EggPoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggPoint::get_perspective(void) const
  bool return_value = (*(const EggPoint*)local_this).get_perspective();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_get_perspective_1100_comment =
  "C++ Interface:\n"
  "get_perspective(EggPoint self)\n"
  "\n"
  "/**\n"
  " * Returns the perspective flag set on this particular point.  If there is no\n"
  " * perspective flag set, returns false.\n"
  " */";
#else
static const char *Dtool_EggPoint_get_perspective_1100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPoint::set_perspective(bool perspective)
 */
static PyObject *Dtool_EggPoint_set_perspective_1101(PyObject *self, PyObject *arg) {
  EggPoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPoint, (void **)&local_this, "EggPoint.set_perspective")) {
    return NULL;
  }
  // 1-inline void EggPoint::set_perspective(bool perspective)
  (*local_this).set_perspective((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_perspective(const EggPoint self, bool perspective)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_set_perspective_1101_comment =
  "C++ Interface:\n"
  "set_perspective(const EggPoint self, bool perspective)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_set_perspective_1101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggPoint::clear_perspective(void)
 */
static PyObject *Dtool_EggPoint_clear_perspective_1102(PyObject *self, PyObject *) {
  EggPoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPoint, (void **)&local_this, "EggPoint.clear_perspective")) {
    return NULL;
  }
  // 1-inline void EggPoint::clear_perspective(void)
  (*local_this).clear_perspective();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_clear_perspective_1102_comment =
  "C++ Interface:\n"
  "clear_perspective(const EggPoint self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_clear_perspective_1102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggPoint::get_class_type(void)
 */
static PyObject *Dtool_EggPoint_get_class_type_1103(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggPoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_get_class_type_1103_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPoint_get_class_type_1103_comment = NULL;
#endif

static int Dtool_Init_EggPoint(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggPoint(PyObject *args, CPT(EggPoint) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggPoint, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggPoint(PyObject *args, PT(EggPoint) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggPoint, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggPoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggPoint) {
    printf("EggPoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggPoint *local_this = (EggPoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggPoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggPoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggPoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggPolysetMaker
 */
/**
 * Python function wrapper for:
 * void EggPolysetMaker::set_properties(int properties)
 */
static PyObject *Dtool_EggPolysetMaker_set_properties_1109(PyObject *self, PyObject *arg) {
  EggPolysetMaker *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPolysetMaker, (void **)&local_this, "EggPolysetMaker.set_properties")) {
    return NULL;
  }
  // 1-void EggPolysetMaker::set_properties(int properties)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_properties((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_properties(const EggPolysetMaker self, int properties)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggPolysetMaker_set_properties_1109_comment =
  "C++ Interface:\n"
  "set_properties(const EggPolysetMaker self, int properties)\n"
  "\n"
  "/**\n"
  " * Sets the set of properties that determines which polygons are allowed to be\n"
  " * grouped together into a single polyset.  This is the bitwise 'or' of all\n"
  " * the properties that matter.  If this is 0, all polygons (within a given\n"
  " * group) will be lumped into a common polyset regardless of their properties.\n"
  " */";
#else
static const char *Dtool_EggPolysetMaker_set_properties_1109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggPolysetMaker::get_class_type(void)
 */
static PyObject *Dtool_EggPolysetMaker_get_class_type_1110(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPolysetMaker::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggPolysetMaker::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPolysetMaker_get_class_type_1110_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPolysetMaker_get_class_type_1110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggPolysetMaker::EggPolysetMaker(void)
 */
static int Dtool_Init_EggPolysetMaker(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EggPolysetMaker() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EggPolysetMaker::EggPolysetMaker(void)
  EggPolysetMaker *return_value = new EggPolysetMaker();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPolysetMaker, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggPolysetMaker()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggPolysetMaker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggPolysetMaker) {
    printf("EggPolysetMaker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggPolysetMaker *local_this = (EggPolysetMaker *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggPolysetMaker) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggBinMaker) {
    return (EggBinMaker *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggBinMaker *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggBinMaker *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggBinMaker *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggBinMaker *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggPolysetMaker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggPolysetMaker) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggBinMaker) {
    EggBinMaker* other_this = (EggBinMaker*)from_this;
    return (EggPolysetMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPolysetMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPolysetMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPolysetMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPolysetMaker*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggPoolUniquifier
 */
/**
 * Python function wrapper for:
 * static TypeHandle EggPoolUniquifier::get_class_type(void)
 */
static PyObject *Dtool_EggPoolUniquifier_get_class_type_1114(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPoolUniquifier::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggPoolUniquifier::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPoolUniquifier_get_class_type_1114_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPoolUniquifier_get_class_type_1114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggPoolUniquifier::EggPoolUniquifier(void)
 */
static int Dtool_Init_EggPoolUniquifier(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EggPoolUniquifier() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EggPoolUniquifier::EggPoolUniquifier(void)
  EggPoolUniquifier *return_value = new EggPoolUniquifier();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPoolUniquifier, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggPoolUniquifier()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggPoolUniquifier(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggPoolUniquifier) {
    printf("EggPoolUniquifier ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggPoolUniquifier *local_this = (EggPoolUniquifier *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggPoolUniquifier) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNameUniquifier) {
    return (EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggPoolUniquifier(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggPoolUniquifier) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNameUniquifier) {
    EggNameUniquifier* other_this = (EggNameUniquifier*)from_this;
    return (EggPoolUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPoolUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPoolUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPoolUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPoolUniquifier*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggSAnimData
 */
/**
 * Python function wrapper for:
 * inline EggSAnimData &EggSAnimData::operator =(EggSAnimData const &copy)
 */
static PyObject *Dtool_EggSAnimData_operator_1118(PyObject *self, PyObject *arg) {
  EggSAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSAnimData, (void **)&local_this, "EggSAnimData.assign")) {
    return NULL;
  }
  // 1-inline EggSAnimData &EggSAnimData::operator =(EggSAnimData const &copy)
  CPT(EggSAnimData) arg_this;
  if (!Dtool_ConstCoerce_EggSAnimData(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggSAnimData.assign", "EggSAnimData");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggSAnimData *return_value = local_this;
  if (return_value != (EggSAnimData *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggSAnimData *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggSAnimData, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggSAnimData self, const EggSAnimData copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_operator_1118_comment =
  "C++ Interface:\n"
  "assign(const EggSAnimData self, const EggSAnimData copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggSAnimData_operator_1118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggSAnimData::get_num_rows(void) const
 */
static PyObject *Dtool_EggSAnimData_get_num_rows_1119(PyObject *self, PyObject *) {
  EggSAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggSAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggSAnimData::get_num_rows(void) const
  int return_value = (*(const EggSAnimData*)local_this).get_num_rows();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_get_num_rows_1119_comment =
  "C++ Interface:\n"
  "get_num_rows(EggSAnimData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of rows in the table.  For an SAnim table, each row has\n"
  " * one column.\n"
  " */";
#else
static const char *Dtool_EggSAnimData_get_num_rows_1119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggSAnimData::get_value(int row) const
 */
static PyObject *Dtool_EggSAnimData_get_value_1120(PyObject *self, PyObject *arg) {
  EggSAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggSAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggSAnimData::get_value(int row) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const EggSAnimData*)local_this).get_value((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(EggSAnimData self, int row)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_get_value_1120_comment =
  "C++ Interface:\n"
  "get_value(EggSAnimData self, int row)\n"
  "\n"
  "/**\n"
  " * Returns the value at the indicated row.  Row must be in the range 0 <= row\n"
  " * < get_num_rows().\n"
  " */";
#else
static const char *Dtool_EggSAnimData_get_value_1120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggSAnimData::set_value(int row, double value)
 */
static PyObject *Dtool_EggSAnimData_set_value_1121(PyObject *self, PyObject *args, PyObject *kwds) {
  EggSAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSAnimData, (void **)&local_this, "EggSAnimData.set_value")) {
    return NULL;
  }
  // 1-inline void EggSAnimData::set_value(int row, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"row", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:set_value", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_value((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const EggSAnimData self, int row, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_set_value_1121_comment =
  "C++ Interface:\n"
  "set_value(const EggSAnimData self, int row, double value)\n"
  "\n"
  "/**\n"
  " * Changes the value at the indicated row.  Row must be in the range 0 <= row\n"
  " * < get_num_rows().\n"
  " */";
#else
static const char *Dtool_EggSAnimData_set_value_1121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggSAnimData::optimize(void)
 */
static PyObject *Dtool_EggSAnimData_optimize_1122(PyObject *self, PyObject *) {
  EggSAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSAnimData, (void **)&local_this, "EggSAnimData.optimize")) {
    return NULL;
  }
  // 1-void EggSAnimData::optimize(void)
  (*local_this).optimize();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_optimize_1122_comment =
  "C++ Interface:\n"
  "optimize(const EggSAnimData self)\n"
  "\n"
  "/**\n"
  " * Optimizes the data by collapsing a long table of duplicate values into a\n"
  " * single value.\n"
  " */";
#else
static const char *Dtool_EggSAnimData_optimize_1122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggSAnimData::get_class_type(void)
 */
static PyObject *Dtool_EggSAnimData_get_class_type_1123(PyObject *, PyObject *) {
  // 1-static TypeHandle EggSAnimData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggSAnimData::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_get_class_type_1123_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggSAnimData_get_class_type_1123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggSAnimData::EggSAnimData(EggSAnimData const &copy)
 * inline EggSAnimData::EggSAnimData(std::string const &name = "")
 */
static int Dtool_Init_EggSAnimData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggSAnimData::EggSAnimData(std::string const &name)
      EggSAnimData *return_value = new EggSAnimData();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggSAnimData, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggSAnimData::EggSAnimData(EggSAnimData const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggSAnimData", (char **)keyword_list, &param0)) {
          EggSAnimData const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggSAnimData, (void **)&param0_this);
          if (param0_this != NULL) {
            EggSAnimData *return_value = new EggSAnimData(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggSAnimData, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggSAnimData::EggSAnimData(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggSAnimData", (char **)keyword_list, &param0_str, &param0_len)) {
          EggSAnimData *return_value = new EggSAnimData(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggSAnimData, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggSAnimData::EggSAnimData(EggSAnimData const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggSAnimData", (char **)keyword_list, &param0)) {
          CPT(EggSAnimData) param0_this;
          if (Dtool_ConstCoerce_EggSAnimData(param0, param0_this)) {
            EggSAnimData *return_value = new EggSAnimData(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggSAnimData, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggSAnimData::EggSAnimData(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggSAnimData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggSAnimData()\n"
      "EggSAnimData(const EggSAnimData copy)\n"
      "EggSAnimData(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggSAnimData(PyObject *args, CPT(EggSAnimData) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggSAnimData, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggSAnimData::EggSAnimData(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggSAnimData *return_value = new EggSAnimData(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_EggSAnimData(PyObject *args, PT(EggSAnimData) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggSAnimData, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggSAnimData::EggSAnimData(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggSAnimData *return_value = new EggSAnimData(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_EggSAnimData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggSAnimData) {
    printf("EggSAnimData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggSAnimData *local_this = (EggSAnimData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggSAnimData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAnimData) {
    return (EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggSAnimData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggSAnimData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAnimData) {
    EggAnimData* other_this = (EggAnimData*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggSAnimData*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggTable
 */
/**
 * Python function wrapper for:
 * inline EggTable &EggTable::operator =(EggTable const &copy)
 */
static PyObject *Dtool_EggTable_operator_1128(PyObject *self, PyObject *arg) {
  EggTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTable, (void **)&local_this, "EggTable.assign")) {
    return NULL;
  }
  // 1-inline EggTable &EggTable::operator =(EggTable const &copy)
  CPT(EggTable) arg_this;
  if (!Dtool_ConstCoerce_EggTable(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTable.assign", "EggTable");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggTable *return_value = local_this;
  if (return_value != (EggTable *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggTable *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTable, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTable self, const EggTable copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTable_operator_1128_comment =
  "C++ Interface:\n"
  "assign(const EggTable self, const EggTable copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTable_operator_1128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggTable::set_table_type(EggTable::TableType type)
 */
static PyObject *Dtool_EggTable_set_table_type_1129(PyObject *self, PyObject *arg) {
  EggTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTable, (void **)&local_this, "EggTable.set_table_type")) {
    return NULL;
  }
  // 1-inline void EggTable::set_table_type(EggTable::TableType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_table_type((EggTable::TableType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_table_type(const EggTable self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTable_set_table_type_1129_comment =
  "C++ Interface:\n"
  "set_table_type(const EggTable self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTable_set_table_type_1129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTable::TableType EggTable::get_table_type(void) const
 */
static PyObject *Dtool_EggTable_get_table_type_1130(PyObject *self, PyObject *) {
  EggTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline EggTable::TableType EggTable::get_table_type(void) const
  EggTable::TableType return_value = (*(const EggTable*)local_this).get_table_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTable_get_table_type_1130_comment =
  "C++ Interface:\n"
  "get_table_type(EggTable self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTable_get_table_type_1130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggTable::has_transform(void) const
 */
static PyObject *Dtool_EggTable_has_transform_1131(PyObject *self, PyObject *) {
  EggTable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTable, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggTable::has_transform(void) const
  bool return_value = (*(const EggTable*)local_this).has_transform();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTable_has_transform_1131_comment =
  "C++ Interface:\n"
  "has_transform(EggTable self)\n"
  "\n"
  "/**\n"
  " * Returns true if the table contains a transform description, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggTable_has_transform_1131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static EggTable::TableType EggTable::string_table_type(std::string const &string)
 */
static PyObject *Dtool_EggTable_string_table_type_1132(PyObject *, PyObject *arg) {
  // 1-static EggTable::TableType EggTable::string_table_type(std::string const &string)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    EggTable::TableType return_value = EggTable::string_table_type(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_table_type(str string)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTable_string_table_type_1132_comment =
  "C++ Interface:\n"
  "string_table_type(str string)\n"
  "\n"
  "/**\n"
  " * Returns the TableType value associated with the given string\n"
  " * representation, or TT_invalid if the string does not match any known\n"
  " * TableType value.\n"
  " */";
#else
static const char *Dtool_EggTable_string_table_type_1132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggTable::get_class_type(void)
 */
static PyObject *Dtool_EggTable_get_class_type_1133(PyObject *, PyObject *) {
  // 1-static TypeHandle EggTable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggTable::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTable_get_class_type_1133_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggTable_get_class_type_1133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggTable::EggTable(EggTable const &copy)
 * inline EggTable::EggTable(std::string const &name = "")
 */
static int Dtool_Init_EggTable(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggTable::EggTable(std::string const &name)
      EggTable *return_value = new EggTable();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTable, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggTable::EggTable(EggTable const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggTable", (char **)keyword_list, &param0)) {
          EggTable const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggTable, (void **)&param0_this);
          if (param0_this != NULL) {
            EggTable *return_value = new EggTable(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTable, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggTable::EggTable(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggTable", (char **)keyword_list, &param0_str, &param0_len)) {
          EggTable *return_value = new EggTable(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTable, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggTable::EggTable(EggTable const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggTable", (char **)keyword_list, &param0)) {
          CPT(EggTable) param0_this;
          if (Dtool_ConstCoerce_EggTable(param0, param0_this)) {
            EggTable *return_value = new EggTable(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTable, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggTable::EggTable(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggTable() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggTable()\n"
      "EggTable(const EggTable copy)\n"
      "EggTable(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggTable(PyObject *args, CPT(EggTable) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggTable, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggTable::EggTable(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggTable *return_value = new EggTable(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_EggTable(PyObject *args, PT(EggTable) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggTable, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggTable::EggTable(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      EggTable *return_value = new EggTable(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_EggTable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggTable) {
    printf("EggTable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggTable *local_this = (EggTable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggTable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroupNode) {
    return (EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggTable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggTable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    EggGroupNode* other_this = (EggGroupNode*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggTable*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggTextureCollection
 */
/**
 * Python function wrapper for:
 * EggTextureCollection &EggTextureCollection::operator =(EggTextureCollection const &copy)
 */
static PyObject *Dtool_EggTextureCollection_operator_1137(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.assign")) {
    return NULL;
  }
  // 1-EggTextureCollection &EggTextureCollection::operator =(EggTextureCollection const &copy)
  EggTextureCollection const *arg_this = (EggTextureCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTextureCollection, 1, "EggTextureCollection.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    EggTextureCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTextureCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTextureCollection self, const EggTextureCollection copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_operator_1137_comment =
  "C++ Interface:\n"
  "assign(const EggTextureCollection self, const EggTextureCollection copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_operator_1137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTextureCollection::clear(void)
 */
static PyObject *Dtool_EggTextureCollection_clear_1139(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.clear")) {
    return NULL;
  }
  // 1-void EggTextureCollection::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_clear_1139_comment =
  "C++ Interface:\n"
  "clear(const EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all textures from the collection.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_clear_1139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggTextureCollection::extract_textures(EggGroupNode *node)
 */
static PyObject *Dtool_EggTextureCollection_extract_textures_1140(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.extract_textures")) {
    return NULL;
  }
  // 1-int EggTextureCollection::extract_textures(EggGroupNode *node)
  PT(EggGroupNode) arg_this;
  if (!Dtool_Coerce_EggGroupNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTextureCollection.extract_textures", "EggGroupNode");
  }
  int return_value = (*local_this).extract_textures(MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_textures(const EggTextureCollection self, EggGroupNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_extract_textures_1140_comment =
  "C++ Interface:\n"
  "extract_textures(const EggTextureCollection self, EggGroupNode node)\n"
  "\n"
  "/**\n"
  " * Walks the egg hierarchy beginning at the indicated node, and removes any\n"
  " * EggTextures encountered in the hierarchy, adding them to the collection.\n"
  " * Returns the number of EggTextures encountered.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_extract_textures_1140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggTextureCollection::is_empty(void) const
 */
static PyObject *Dtool_EggTextureCollection_is_empty_1141(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTextureCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EggTextureCollection::is_empty(void) const
  bool return_value = (*(const EggTextureCollection*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_is_empty_1141_comment =
  "C++ Interface:\n"
  "is_empty(EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are no EggTexures in the collection, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_is_empty_1141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggTextureCollection::get_num_textures(void) const
 */
static PyObject *Dtool_EggTextureCollection_get_num_textures_1142(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTextureCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggTextureCollection::get_num_textures(void) const
  int return_value = (*(const EggTextureCollection*)local_this).get_num_textures();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_get_num_textures_1142_comment =
  "C++ Interface:\n"
  "get_num_textures(EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of EggTextures in the collection.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_get_num_textures_1142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggTexture *EggTextureCollection::get_texture(int index) const
 */
static PyObject *Dtool_EggTextureCollection_get_texture_1143(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTextureCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-EggTexture *EggTextureCollection::get_texture(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggTexture *return_value = (*(const EggTextureCollection*)local_this).get_texture((int)arg_val);
    if (return_value != (EggTexture *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggTexture *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture(EggTextureCollection self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_get_texture_1143_comment =
  "C++ Interface:\n"
  "get_texture(EggTextureCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth EggTexture in the collection.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_get_texture_1143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggTextureCollection::find_used_textures(EggNode *node)
 */
static PyObject *Dtool_EggTextureCollection_find_used_textures_1145(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.find_used_textures")) {
    return NULL;
  }
  // 1-int EggTextureCollection::find_used_textures(EggNode *node)
  PT(EggNode) arg_this;
  if (!Dtool_Coerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTextureCollection.find_used_textures", "EggNode");
  }
  int return_value = (*local_this).find_used_textures(MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_used_textures(const EggTextureCollection self, EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_find_used_textures_1145_comment =
  "C++ Interface:\n"
  "find_used_textures(const EggTextureCollection self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Walks the egg hierarchy beginning at the indicated node, looking for\n"
  " * textures that are referenced by primitives but are not already members of\n"
  " * the collection, adding them to the collection.\n"
  " *\n"
  " * If this is called following extract_textures(), it can be used to pick up\n"
  " * any additional texture references that appeared in the egg hierarchy (but\n"
  " * whose EggTexture node was not actually part of the hierarchy).\n"
  " *\n"
  " * If this is called in lieu of extract_textures(), it will fill up the\n"
  " * collection with all of the referenced textures (and only the referenced\n"
  " * textures), without destructively removing the EggTextures from the\n"
  " * hierarchy.\n"
  " *\n"
  " * This also has the side effect of incrementing the internal usage count for\n"
  " * a texture in the collection each time a texture reference is encountered.\n"
  " * This side effect is taken advantage of by remove_unused_textures().\n"
  " *\n"
  " * And one more side effect: this function identifies the presence of\n"
  " * multitexturing in the egg file, and calls multitexture_over() on each\n"
  " * texture appropriately so that, after this call, you may expect\n"
  " * get_multitexture_sort() to return a reasonable value for each texture.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_find_used_textures_1145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTextureCollection::remove_unused_textures(EggNode *node)
 */
static PyObject *Dtool_EggTextureCollection_remove_unused_textures_1146(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.remove_unused_textures")) {
    return NULL;
  }
  // 1-void EggTextureCollection::remove_unused_textures(EggNode *node)
  PT(EggNode) arg_this;
  if (!Dtool_Coerce_EggNode(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTextureCollection.remove_unused_textures", "EggNode");
  }
  (*local_this).remove_unused_textures(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_unused_textures(const EggTextureCollection self, EggNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_remove_unused_textures_1146_comment =
  "C++ Interface:\n"
  "remove_unused_textures(const EggTextureCollection self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Removes any textures from the collection that aren't referenced by any\n"
  " * primitives in the indicated egg hierarchy.  This also, incidentally, adds\n"
  " * textures to the collection that had been referenced by primitives but had\n"
  " * not previously appeared in the collection.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_remove_unused_textures_1146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggTextureCollection::collapse_equivalent_textures(int eq, EggGroupNode *node)
 * Rejected Remap [int EggTextureCollection::collapse_equivalent_textures(int eq, EggTextureCollection::TextureReplacement &removed)]
 */
static PyObject *Dtool_EggTextureCollection_collapse_equivalent_textures_1147(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.collapse_equivalent_textures")) {
    return NULL;
  }
  // 1-int EggTextureCollection::collapse_equivalent_textures(int eq, EggGroupNode *node)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"eq", "node", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:collapse_equivalent_textures", (char **)keyword_list, &param1, &param2)) {
    PT(EggGroupNode) param2_this;
    if (!Dtool_Coerce_EggGroupNode(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggTextureCollection.collapse_equivalent_textures", "EggGroupNode");
    }
    int return_value = (*local_this).collapse_equivalent_textures((int)param1, MOVE(param2_this));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collapse_equivalent_textures(const EggTextureCollection self, int eq, EggGroupNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_collapse_equivalent_textures_1147_comment =
  "C++ Interface:\n"
  "collapse_equivalent_textures(const EggTextureCollection self, int eq, EggGroupNode node)\n"
  "\n"
  "/**\n"
  " * Walks through the collection and collapses together any separate textures\n"
  " * that are equivalent according to the indicated equivalence factor, eq (see\n"
  " * EggTexture::is_equivalent_to()).  The return value is the number of\n"
  " * textures removed.\n"
  " *\n"
  " * This flavor of collapse_equivalent_textures() automatically adjusts all the\n"
  " * primitives in the egg hierarchy to refer to the new texture pointers.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Walks through the collection and collapses together any separate textures\n"
  " * that are equivalent according to the indicated equivalence factor, eq (see\n"
  " * EggTexture::is_equivalent_to()).  The return value is the number of\n"
  " * textures removed.\n"
  " *\n"
  " * This flavor of collapse_equivalent_textures() does not adjust any\n"
  " * primitives in the egg hierarchy; instead, it fills up the 'removed' map\n"
  " * with an entry for each removed texture, mapping it back to the equivalent\n"
  " * retained texture.  It's up to the user to then call replace_textures() with\n"
  " * this map, if desired, to apply these changes to the egg hierarchy.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_collapse_equivalent_textures_1147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTextureCollection::uniquify_trefs(void)
 */
static PyObject *Dtool_EggTextureCollection_uniquify_trefs_1149(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.uniquify_trefs")) {
    return NULL;
  }
  // 1-void EggTextureCollection::uniquify_trefs(void)
  (*local_this).uniquify_trefs();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_uniquify_trefs_1149_comment =
  "C++ Interface:\n"
  "uniquify_trefs(const EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Guarantees that each texture in the collection has a unique TRef name.\n"
  " * This is essential before writing an egg file.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_uniquify_trefs_1149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTextureCollection::sort_by_tref(void)
 */
static PyObject *Dtool_EggTextureCollection_sort_by_tref_1150(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.sort_by_tref")) {
    return NULL;
  }
  // 1-void EggTextureCollection::sort_by_tref(void)
  (*local_this).sort_by_tref();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_sort_by_tref_1150_comment =
  "C++ Interface:\n"
  "sort_by_tref(const EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Sorts all the textures into alphabetical order by TRef name.  Subsequent\n"
  " * operations using begin()/end() will traverse in this sorted order.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_sort_by_tref_1150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggTextureCollection::sort_by_basename(void)
 */
static PyObject *Dtool_EggTextureCollection_sort_by_basename_1151(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.sort_by_basename")) {
    return NULL;
  }
  // 1-void EggTextureCollection::sort_by_basename(void)
  (*local_this).sort_by_basename();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_sort_by_basename_1151_comment =
  "C++ Interface:\n"
  "sort_by_basename(const EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Sorts all the textures into alphabetical order by the basename part\n"
  " * (including extension) of the filename.  Subsequent operations using\n"
  " * begin()/end() will traverse in this sorted order.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_sort_by_basename_1151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggTextureCollection::add_texture(EggTexture *texture)
 */
static PyObject *Dtool_EggTextureCollection_add_texture_1154(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.add_texture")) {
    return NULL;
  }
  // 1-bool EggTextureCollection::add_texture(EggTexture *texture)
  PT(EggTexture) arg_this;
  if (!Dtool_Coerce_EggTexture(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTextureCollection.add_texture", "EggTexture");
  }
  bool return_value = (*local_this).add_texture(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_texture(const EggTextureCollection self, EggTexture texture)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_add_texture_1154_comment =
  "C++ Interface:\n"
  "add_texture(const EggTextureCollection self, EggTexture texture)\n"
  "\n"
  "/**\n"
  " * Explicitly adds a new texture to the collection.  Returns true if the\n"
  " * texture was added, false if it was already there or if there was some\n"
  " * error.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_add_texture_1154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggTextureCollection::remove_texture(EggTexture *texture)
 */
static PyObject *Dtool_EggTextureCollection_remove_texture_1155(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.remove_texture")) {
    return NULL;
  }
  // 1-bool EggTextureCollection::remove_texture(EggTexture *texture)
  PT(EggTexture) arg_this;
  if (!Dtool_Coerce_EggTexture(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTextureCollection.remove_texture", "EggTexture");
  }
  bool return_value = (*local_this).remove_texture(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_texture(const EggTextureCollection self, EggTexture texture)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_remove_texture_1155_comment =
  "C++ Interface:\n"
  "remove_texture(const EggTextureCollection self, EggTexture texture)\n"
  "\n"
  "/**\n"
  " * Explicitly removes a texture from the collection.  Returns true if the\n"
  " * texture was removed, false if it wasn't there or if there was some error.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_remove_texture_1155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggTexture *EggTextureCollection::create_unique_texture(EggTexture const &copy, int eq)
 */
static PyObject *Dtool_EggTextureCollection_create_unique_texture_1156(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.create_unique_texture")) {
    return NULL;
  }
  // 1-EggTexture *EggTextureCollection::create_unique_texture(EggTexture const &copy, int eq)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"copy", "eq", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:create_unique_texture", (char **)keyword_list, &param1, &param2)) {
    CPT(EggTexture) param1_this;
    if (!Dtool_ConstCoerce_EggTexture(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggTextureCollection.create_unique_texture", "EggTexture");
    }
    EggTexture *return_value = (*local_this).create_unique_texture(*MOVE(param1_this), (int)param2);
    if (return_value != (EggTexture *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggTexture *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "create_unique_texture(const EggTextureCollection self, const EggTexture copy, int eq)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_create_unique_texture_1156_comment =
  "C++ Interface:\n"
  "create_unique_texture(const EggTextureCollection self, const EggTexture copy, int eq)\n"
  "\n"
  "// create_unique_texture() creates a new texture if there is not already one\n"
  "// equivalent (according to eq, see EggTexture::is_equivalent_to()) to the\n"
  "// indicated texture, or returns the existing one if there is.\n"
  "\n"
  "/**\n"
  " * Creates a new texture if there is not already one equivalent (according to\n"
  " * eq, see EggTexture::is_equivalent_to()) to the indicated texture, or\n"
  " * returns the existing one if there is.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_create_unique_texture_1156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggTexture *EggTextureCollection::find_tref(std::string const &tref_name) const
 */
static PyObject *Dtool_EggTextureCollection_find_tref_1157(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTextureCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-EggTexture *EggTextureCollection::find_tref(std::string const &tref_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    EggTexture *return_value = (*(const EggTextureCollection*)local_this).find_tref(std::string(param1_str, param1_len));
    if (return_value != (EggTexture *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (EggTexture *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_tref(EggTextureCollection self, str tref_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_find_tref_1157_comment =
  "C++ Interface:\n"
  "find_tref(EggTextureCollection self, str tref_name)\n"
  "\n"
  "// Find a texture with a particular TRef name.\n"
  "\n"
  "/**\n"
  " * Returns the texture with the indicated TRef name, or NULL if no texture\n"
  " * matches.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_find_tref_1157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggTexture *EggTextureCollection::find_filename(Filename const &filename) const
 */
static PyObject *Dtool_EggTextureCollection_find_filename_1158(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTextureCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-EggTexture *EggTextureCollection::find_filename(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTextureCollection.find_filename", "Filename");
  }
  EggTexture *return_value = (*(const EggTextureCollection*)local_this).find_filename(*arg_this);
  if (return_value != (EggTexture *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggTexture *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_filename(EggTextureCollection self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_find_filename_1158_comment =
  "C++ Interface:\n"
  "find_filename(EggTextureCollection self, const Filename filename)\n"
  "\n"
  "// Find a texture with a particular filename.\n"
  "\n"
  "/**\n"
  " * Returns the texture with the indicated filename, or NULL if no texture\n"
  " * matches.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_find_filename_1158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggTextureCollection::EggTextureCollection(void)
 * EggTextureCollection::EggTextureCollection(EggTextureCollection const &copy)
 */
static int Dtool_Init_EggTextureCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggTextureCollection::EggTextureCollection(void)
      EggTextureCollection *return_value = new EggTextureCollection();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTextureCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-EggTextureCollection::EggTextureCollection(EggTextureCollection const &copy)
      EggTextureCollection const *arg_this = (EggTextureCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTextureCollection, 0, "EggTextureCollection.EggTextureCollection", true, true);
      if (arg_this != NULL) {
        EggTextureCollection *return_value = new EggTextureCollection(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTextureCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggTextureCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggTextureCollection()\n"
      "EggTextureCollection(const EggTextureCollection copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggTextureCollection_get_textures(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTextureCollection, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_textures();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggTextureCollection_get_texture_1143(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggTextureCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggTextureCollection) {
    printf("EggTextureCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggTextureCollection *local_this = (EggTextureCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggTextureCollection) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggTextureCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggTextureCollection) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggTriangleFan
 */
/**
 * Python function wrapper for:
 * inline EggTriangleFan &EggTriangleFan::operator =(EggTriangleFan const &copy)
 */
static PyObject *Dtool_EggTriangleFan_operator_1160(PyObject *self, PyObject *arg) {
  EggTriangleFan *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTriangleFan, (void **)&local_this, "EggTriangleFan.assign")) {
    return NULL;
  }
  // 1-inline EggTriangleFan &EggTriangleFan::operator =(EggTriangleFan const &copy)
  CPT(EggTriangleFan) arg_this;
  if (!Dtool_ConstCoerce_EggTriangleFan(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTriangleFan.assign", "EggTriangleFan");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggTriangleFan *return_value = local_this;
  if (return_value != (EggTriangleFan *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggTriangleFan *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTriangleFan, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTriangleFan self, const EggTriangleFan copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTriangleFan_operator_1160_comment =
  "C++ Interface:\n"
  "assign(const EggTriangleFan self, const EggTriangleFan copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTriangleFan_operator_1160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggTriangleFan *EggTriangleFan::make_copy(void) override
 */
static PyObject *Dtool_EggTriangleFan_make_copy_1161(PyObject *self, PyObject *) {
  EggTriangleFan *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTriangleFan, (void **)&local_this, "EggTriangleFan.make_copy")) {
    return NULL;
  }
  // 1-virtual EggTriangleFan *EggTriangleFan::make_copy(void) override
  EggTriangleFan *return_value = (*local_this).make_copy();
  if (return_value != (EggTriangleFan *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggTriangleFan *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTriangleFan, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggTriangleFan_make_copy_1161_comment =
  "C++ Interface:\n"
  "make_copy(const EggTriangleFan self)\n"
  "\n"
  "/**\n"
  " * Makes a copy of this object.\n"
  " */";
#else
static const char *Dtool_EggTriangleFan_make_copy_1161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggTriangleFan::get_class_type(void)
 */
static PyObject *Dtool_EggTriangleFan_get_class_type_1162(PyObject *, PyObject *) {
  // 1-static TypeHandle EggTriangleFan::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggTriangleFan::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTriangleFan_get_class_type_1162_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggTriangleFan_get_class_type_1162_comment = NULL;
#endif

static int Dtool_Init_EggTriangleFan(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggTriangleFan(PyObject *args, CPT(EggTriangleFan) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggTriangleFan, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggTriangleFan(PyObject *args, PT(EggTriangleFan) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggTriangleFan, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggTriangleFan(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggTriangleFan) {
    printf("EggTriangleFan ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggTriangleFan *local_this = (EggTriangleFan *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggTriangleFan) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggCompositePrimitive) {
    return (EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggTriangleFan(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggTriangleFan) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggCompositePrimitive) {
    EggCompositePrimitive* other_this = (EggCompositePrimitive*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggTriangleFan*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggTriangleStrip
 */
/**
 * Python function wrapper for:
 * inline EggTriangleStrip &EggTriangleStrip::operator =(EggTriangleStrip const &copy)
 */
static PyObject *Dtool_EggTriangleStrip_operator_1164(PyObject *self, PyObject *arg) {
  EggTriangleStrip *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTriangleStrip, (void **)&local_this, "EggTriangleStrip.assign")) {
    return NULL;
  }
  // 1-inline EggTriangleStrip &EggTriangleStrip::operator =(EggTriangleStrip const &copy)
  CPT(EggTriangleStrip) arg_this;
  if (!Dtool_ConstCoerce_EggTriangleStrip(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTriangleStrip.assign", "EggTriangleStrip");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggTriangleStrip *return_value = local_this;
  if (return_value != (EggTriangleStrip *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggTriangleStrip *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTriangleStrip, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTriangleStrip self, const EggTriangleStrip copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggTriangleStrip_operator_1164_comment =
  "C++ Interface:\n"
  "assign(const EggTriangleStrip self, const EggTriangleStrip copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTriangleStrip_operator_1164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual EggTriangleStrip *EggTriangleStrip::make_copy(void) override
 */
static PyObject *Dtool_EggTriangleStrip_make_copy_1165(PyObject *self, PyObject *) {
  EggTriangleStrip *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTriangleStrip, (void **)&local_this, "EggTriangleStrip.make_copy")) {
    return NULL;
  }
  // 1-virtual EggTriangleStrip *EggTriangleStrip::make_copy(void) override
  EggTriangleStrip *return_value = (*local_this).make_copy();
  if (return_value != (EggTriangleStrip *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggTriangleStrip *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTriangleStrip, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggTriangleStrip_make_copy_1165_comment =
  "C++ Interface:\n"
  "make_copy(const EggTriangleStrip self)\n"
  "\n"
  "/**\n"
  " * Makes a copy of this object.\n"
  " */";
#else
static const char *Dtool_EggTriangleStrip_make_copy_1165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggTriangleStrip::get_class_type(void)
 */
static PyObject *Dtool_EggTriangleStrip_get_class_type_1166(PyObject *, PyObject *) {
  // 1-static TypeHandle EggTriangleStrip::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggTriangleStrip::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTriangleStrip_get_class_type_1166_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggTriangleStrip_get_class_type_1166_comment = NULL;
#endif

static int Dtool_Init_EggTriangleStrip(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_EggTriangleStrip(PyObject *args, CPT(EggTriangleStrip) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggTriangleStrip, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_EggTriangleStrip(PyObject *args, PT(EggTriangleStrip) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggTriangleStrip, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggTriangleStrip(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggTriangleStrip) {
    printf("EggTriangleStrip ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggTriangleStrip *local_this = (EggTriangleStrip *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggTriangleStrip) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggCompositePrimitive) {
    return (EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggTriangleStrip(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggTriangleStrip) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggCompositePrimitive) {
    EggCompositePrimitive* other_this = (EggCompositePrimitive*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggXfmSAnim
 */
/**
 * Python function wrapper for:
 * inline EggXfmSAnim &EggXfmSAnim::operator =(EggXfmSAnim const &copy)
 */
static PyObject *Dtool_EggXfmSAnim_operator_1169(PyObject *self, PyObject *arg) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.assign")) {
    return NULL;
  }
  // 1-inline EggXfmSAnim &EggXfmSAnim::operator =(EggXfmSAnim const &copy)
  CPT(EggXfmSAnim) arg_this;
  if (!Dtool_ConstCoerce_EggXfmSAnim(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggXfmSAnim.assign", "EggXfmSAnim");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggXfmSAnim *return_value = local_this;
  if (return_value != (EggXfmSAnim *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggXfmSAnim *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggXfmSAnim, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggXfmSAnim self, const EggXfmSAnim copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_operator_1169_comment =
  "C++ Interface:\n"
  "assign(const EggXfmSAnim self, const EggXfmSAnim copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_operator_1169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmSAnim::set_fps(double fps)
 */
static PyObject *Dtool_EggXfmSAnim_set_fps_1170(PyObject *self, PyObject *arg) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.set_fps")) {
    return NULL;
  }
  // 1-inline void EggXfmSAnim::set_fps(double fps)
  if (PyNumber_Check(arg)) {
    (*local_this).set_fps(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fps(const EggXfmSAnim self, double fps)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_set_fps_1170_comment =
  "C++ Interface:\n"
  "set_fps(const EggXfmSAnim self, double fps)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_set_fps_1170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmSAnim::clear_fps(void)
 */
static PyObject *Dtool_EggXfmSAnim_clear_fps_1171(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.clear_fps")) {
    return NULL;
  }
  // 1-inline void EggXfmSAnim::clear_fps(void)
  (*local_this).clear_fps();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_clear_fps_1171_comment =
  "C++ Interface:\n"
  "clear_fps(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_clear_fps_1171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggXfmSAnim::has_fps(void) const
 */
static PyObject *Dtool_EggXfmSAnim_has_fps_1172(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmSAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggXfmSAnim::has_fps(void) const
  bool return_value = (*(const EggXfmSAnim*)local_this).has_fps();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_has_fps_1172_comment =
  "C++ Interface:\n"
  "has_fps(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_has_fps_1172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EggXfmSAnim::get_fps(void) const
 */
static PyObject *Dtool_EggXfmSAnim_get_fps_1173(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmSAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EggXfmSAnim::get_fps(void) const
  double return_value = (*(const EggXfmSAnim*)local_this).get_fps();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_fps_1173_comment =
  "C++ Interface:\n"
  "get_fps(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * This is only valid if has_fps() returns true.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_fps_1173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmSAnim::set_order(std::string const &order)
 */
static PyObject *Dtool_EggXfmSAnim_set_order_1174(PyObject *self, PyObject *arg) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.set_order")) {
    return NULL;
  }
  // 1-inline void EggXfmSAnim::set_order(std::string const &order)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_order(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_order(const EggXfmSAnim self, str order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_set_order_1174_comment =
  "C++ Interface:\n"
  "set_order(const EggXfmSAnim self, str order)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_set_order_1174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmSAnim::clear_order(void)
 */
static PyObject *Dtool_EggXfmSAnim_clear_order_1175(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.clear_order")) {
    return NULL;
  }
  // 1-inline void EggXfmSAnim::clear_order(void)
  (*local_this).clear_order();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_clear_order_1175_comment =
  "C++ Interface:\n"
  "clear_order(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_clear_order_1175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggXfmSAnim::has_order(void) const
 */
static PyObject *Dtool_EggXfmSAnim_has_order_1176(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmSAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggXfmSAnim::has_order(void) const
  bool return_value = (*(const EggXfmSAnim*)local_this).has_order();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_has_order_1176_comment =
  "C++ Interface:\n"
  "has_order(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_has_order_1176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggXfmSAnim::get_order(void) const
 */
static PyObject *Dtool_EggXfmSAnim_get_order_1177(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmSAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &EggXfmSAnim::get_order(void) const
  std::string const &return_value = (*(const EggXfmSAnim*)local_this).get_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_order_1177_comment =
  "C++ Interface:\n"
  "get_order(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_order_1177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string const &EggXfmSAnim::get_standard_order(void)
 */
static PyObject *Dtool_EggXfmSAnim_get_standard_order_1178(PyObject *, PyObject *) {
  // 1-static inline std::string const &EggXfmSAnim::get_standard_order(void)
  std::string const &return_value = EggXfmSAnim::get_standard_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_standard_order_1178_comment =
  "C++ Interface:\n"
  "get_standard_order()\n"
  "\n"
  "/**\n"
  " * Returns the standard order of matrix component composition.  This is what\n"
  " * the order string must be set to in order to use set_value() or add_data()\n"
  " * successfully.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_standard_order_1178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem EggXfmSAnim::get_coordinate_system(void) const
 */
static PyObject *Dtool_EggXfmSAnim_get_coordinate_system_1179(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmSAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CoordinateSystem EggXfmSAnim::get_coordinate_system(void) const
  CoordinateSystem return_value = (*(const EggXfmSAnim*)local_this).get_coordinate_system();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_coordinate_system_1179_comment =
  "C++ Interface:\n"
  "get_coordinate_system(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system this table believes it is defined within.\n"
  " * This should always match the coordinate system of the EggData structure\n"
  " * that owns it.  It is necessary to store it here because the meaning of the\n"
  " * h, p, and r columns depends on the coordinate system.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_coordinate_system_1179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggXfmSAnim::optimize(void)
 */
static PyObject *Dtool_EggXfmSAnim_optimize_1180(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.optimize")) {
    return NULL;
  }
  // 1-void EggXfmSAnim::optimize(void)
  (*local_this).optimize();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_optimize_1180_comment =
  "C++ Interface:\n"
  "optimize(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * Optimizes the table by collapsing redundant sub-tables.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_optimize_1180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggXfmSAnim::optimize_to_standard_order(void)
 */
static PyObject *Dtool_EggXfmSAnim_optimize_to_standard_order_1181(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.optimize_to_standard_order")) {
    return NULL;
  }
  // 1-void EggXfmSAnim::optimize_to_standard_order(void)
  (*local_this).optimize_to_standard_order();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_optimize_to_standard_order_1181_comment =
  "C++ Interface:\n"
  "optimize_to_standard_order(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * Optimizes the table by collapsing redundant sub-tables, and simultaneously\n"
  " * ensures that the order string is the standard order (which is the same as\n"
  " * that supported by compose_matrix() and decompose_matrix()).\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_optimize_to_standard_order_1181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggXfmSAnim::normalize(void)
 */
static PyObject *Dtool_EggXfmSAnim_normalize_1182(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.normalize")) {
    return NULL;
  }
  // 1-void EggXfmSAnim::normalize(void)
  (*local_this).normalize();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_normalize_1182_comment =
  "C++ Interface:\n"
  "normalize(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * The inverse operation of optimize(), this ensures that all the sub-tables\n"
  " * have the same length by duplicating rows as necessary.  This is needed\n"
  " * before doing operations like add_data() or set_value() on an existing\n"
  " * table.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_normalize_1182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int EggXfmSAnim::get_num_rows(void) const
 */
static PyObject *Dtool_EggXfmSAnim_get_num_rows_1183(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmSAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-int EggXfmSAnim::get_num_rows(void) const
  int return_value = (*(const EggXfmSAnim*)local_this).get_num_rows();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_num_rows_1183_comment =
  "C++ Interface:\n"
  "get_num_rows(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * Returns the effective number of rows in the table.  This is actually the\n"
  " * number of rows of the smallest subtable larger than one row.  This is a\n"
  " * convenience function that treats the table of tables as if it were a single\n"
  " * table of matrices.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_num_rows_1183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggXfmSAnim::get_value(int row, LMatrix4d &mat) const
 */
static PyObject *Dtool_EggXfmSAnim_get_value_1184(PyObject *self, PyObject *args, PyObject *kwds) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmSAnim, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EggXfmSAnim::get_value(int row, LMatrix4d &mat) const
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"row", "mat", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_value", (char **)keyword_list, &param1, &param2)) {
    LMatrix4d param2_local;
    LMatrix4d *param2_this = Dtool_Coerce_LMatrix4d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggXfmSAnim.get_value", "LMatrix4d");
    }
    (*(const EggXfmSAnim*)local_this).get_value((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(EggXfmSAnim self, int row, LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_value_1184_comment =
  "C++ Interface:\n"
  "get_value(EggXfmSAnim self, int row, LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Returns the value of the aggregate row of the table as a matrix.  This is a\n"
  " * convenience function that treats the table of tables as if it were a single\n"
  " * table of matrices.  It is an error to call this if any SAnimData children\n"
  " * of this node have an improper name (e.g.  not a single letter, or not one\n"
  " * of \"ijkabchprxyz\").\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_value_1184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggXfmSAnim::set_value(int row, LMatrix4d const &mat)
 */
static PyObject *Dtool_EggXfmSAnim_set_value_1185(PyObject *self, PyObject *args, PyObject *kwds) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.set_value")) {
    return NULL;
  }
  // 1-bool EggXfmSAnim::set_value(int row, LMatrix4d const &mat)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"row", "mat", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_value", (char **)keyword_list, &param1, &param2)) {
    LMatrix4d param2_local;
    LMatrix4d const *param2_this = Dtool_Coerce_LMatrix4d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggXfmSAnim.set_value", "LMatrix4d");
    }
    bool return_value = (*local_this).set_value((int)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const EggXfmSAnim self, int row, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_set_value_1185_comment =
  "C++ Interface:\n"
  "set_value(const EggXfmSAnim self, int row, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated row of the table with the given matrix.\n"
  " *\n"
  " * This function can only be called if all the constraints of add_data(),\n"
  " * below, are met.  Call normalize() first if you are not sure.\n"
  " *\n"
  " * The return value is true if the matrix can be decomposed and stored as\n"
  " * scale, shear, rotate, and translate, or false otherwise.  The data is set\n"
  " * in either case.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_set_value_1185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmSAnim::clear_data(void)
 */
static PyObject *Dtool_EggXfmSAnim_clear_data_1186(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.clear_data")) {
    return NULL;
  }
  // 1-inline void EggXfmSAnim::clear_data(void)
  (*local_this).clear_data();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_clear_data_1186_comment =
  "C++ Interface:\n"
  "clear_data(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * Removes all data from the table.  It does this by removing all of its\n"
  " * children.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_clear_data_1186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EggXfmSAnim::add_data(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggXfmSAnim_add_data_1187(PyObject *self, PyObject *arg) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.add_data")) {
    return NULL;
  }
  // 1-bool EggXfmSAnim::add_data(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggXfmSAnim.add_data", "LMatrix4d");
  }
  bool return_value = (*local_this).add_data(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data(const EggXfmSAnim self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_add_data_1187_comment =
  "C++ Interface:\n"
  "add_data(const EggXfmSAnim self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Adds a new matrix to the table, by adding a new row to each of the\n"
  " * subtables.\n"
  " *\n"
  " * This is a convenience function that treats the table of tables as if it\n"
  " * were a single table of matrices.  It is an error to call this if any\n"
  " * SAnimData children of this node have an improper name (e.g.  not a single\n"
  " * letter, or not one of \"ijkabchprxyz\").\n"
  " *\n"
  " * This function has the further requirement that all nine of the subtables\n"
  " * must exist and be of the same length.  Furthermore, the order string must\n"
  " * be the standard order string, which matches the system compose_matrix() and\n"
  " * decompose_matrix() functions.\n"
  " *\n"
  " * Thus, you probably cannot take an existing EggXfmSAnim object and start\n"
  " * adding matrices to the end; you must clear out the original data first.\n"
  " * (As a special exception, if no tables exist, they will be created.)  The\n"
  " * method normalize() will do this for you on an existing EggXfmSAnim.\n"
  " *\n"
  " * This function may fail silently if the matrix cannot be decomposed into\n"
  " * scale, shear, rotate, and translate.  In this case, the closest\n"
  " * approximation is added to the table, and false is returned.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_add_data_1187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggXfmSAnim::add_component_data(int component, double value)
 * void EggXfmSAnim::add_component_data(std::string const &component_name, double value)
 */
static PyObject *Dtool_EggXfmSAnim_add_component_data_1188(PyObject *self, PyObject *args, PyObject *kwds) {
  EggXfmSAnim *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.add_component_data")) {
    return NULL;
  }
  {
    // -2 void EggXfmSAnim::add_component_data(std::string const &component_name, double value)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
    double param2;
    static const char *keyword_list[] = {"component_name", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#d:add_component_data", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      (*local_this).add_component_data(std::string(param1_str, param1_len), (double)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void EggXfmSAnim::add_component_data(int component, double value)
    int param1;
    double param2;
    static const char *keyword_list[] = {"component", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "id:add_component_data", (char **)keyword_list, &param1, &param2)) {
      (*local_this).add_component_data((int)param1, (double)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: void EggXfmSAnim::add_component_data(std::string const &component_name, double value)
  // No coercion possible: void EggXfmSAnim::add_component_data(int component, double value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_component_data(const EggXfmSAnim self, str component_name, double value)\n"
      "add_component_data(const EggXfmSAnim self, int component, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_add_component_data_1188_comment =
  "C++ Interface:\n"
  "add_component_data(const EggXfmSAnim self, str component_name, double value)\n"
  "add_component_data(const EggXfmSAnim self, int component, double value)\n"
  "\n"
  "/**\n"
  " * Adds a new row to the named component (one of matrix_component_letters) of\n"
  " * the table.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new row to the indicated component (0-12) of the table.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_add_component_data_1188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void EggXfmSAnim::compose_with_order(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &trans, std::string const &order, CoordinateSystem cs)
 */
static PyObject *Dtool_EggXfmSAnim_compose_with_order_1189(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static void EggXfmSAnim::compose_with_order(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &trans, std::string const &order, CoordinateSystem cs)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  PyObject *param4;
  char *param5_str = NULL;
  Py_ssize_t param5_len;
  int param6;
  static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "trans", "order", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOs#i:compose_with_order", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5_str, &param5_len, &param6)) {
    LMatrix4d param0_local;
    LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
    if (!(param0_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "EggXfmSAnim.compose_with_order", "LMatrix4d");
    }
    LVecBase3d param1_local;
    LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggXfmSAnim.compose_with_order", "LVecBase3d");
    }
    LVecBase3d param2_local;
    LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggXfmSAnim.compose_with_order", "LVecBase3d");
    }
    LVecBase3d param3_local;
    LVecBase3d const *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "EggXfmSAnim.compose_with_order", "LVecBase3d");
    }
    LVecBase3d param4_local;
    LVecBase3d const *param4_this = Dtool_Coerce_LVecBase3d(param4, param4_local);
    if (!(param4_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "EggXfmSAnim.compose_with_order", "LVecBase3d");
    }
    EggXfmSAnim::compose_with_order(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, std::string(param5_str, param5_len), (CoordinateSystem)param6);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compose_with_order(LMatrix4d mat, const LVecBase3d scale, const LVecBase3d shear, const LVecBase3d hpr, const LVecBase3d trans, str order, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_compose_with_order_1189_comment =
  "C++ Interface:\n"
  "compose_with_order(LMatrix4d mat, const LVecBase3d scale, const LVecBase3d shear, const LVecBase3d hpr, const LVecBase3d trans, str order, int cs)\n"
  "\n"
  "/**\n"
  " * Composes a matrix out of the nine individual components, respecting the\n"
  " * order string.  The components will be applied in the order indicated by the\n"
  " * string.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_compose_with_order_1189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggXfmSAnim::get_class_type(void)
 */
static PyObject *Dtool_EggXfmSAnim_get_class_type_1190(PyObject *, PyObject *) {
  // 1-static TypeHandle EggXfmSAnim::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggXfmSAnim::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_class_type_1190_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggXfmSAnim_get_class_type_1190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from)
 * inline EggXfmSAnim::EggXfmSAnim(EggXfmSAnim const &copy)
 * inline EggXfmSAnim::EggXfmSAnim(std::string const &name = "", CoordinateSystem cs = ::CS_default)
 */
static int Dtool_Init_EggXfmSAnim(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggXfmSAnim::EggXfmSAnim(std::string const &name, CoordinateSystem cs)
      EggXfmSAnim *return_value = new EggXfmSAnim();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 inline EggXfmSAnim::EggXfmSAnim(std::string const &name, CoordinateSystem cs = ::CS_default)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        int param1 = ::CS_default;
        static const char *keyword_list[] = {"name", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|i:EggXfmSAnim", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          EggXfmSAnim *return_value = new EggXfmSAnim(std::string(param0_str, param0_len), (CoordinateSystem)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from)
        PyObject *param0;
        static const char *keyword_list[] = {"convert_from", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggXfmSAnim", (char **)keyword_list, &param0)) {
          EggXfmAnimData const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggXfmAnimData, (void **)&param0_this);
          if (param0_this != NULL) {
            EggXfmSAnim *return_value = new EggXfmSAnim(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggXfmSAnim::EggXfmSAnim(EggXfmSAnim const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggXfmSAnim", (char **)keyword_list, &param0)) {
          EggXfmSAnim const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggXfmSAnim, (void **)&param0_this);
          if (param0_this != NULL) {
            EggXfmSAnim *return_value = new EggXfmSAnim(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggXfmSAnim::EggXfmSAnim(std::string const &name, CoordinateSystem cs = ::CS_default)
      {
        // -2 EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from)
        PyObject *param0;
        static const char *keyword_list[] = {"convert_from", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggXfmSAnim", (char **)keyword_list, &param0)) {
          CPT(EggXfmAnimData) param0_this;
          if (Dtool_ConstCoerce_EggXfmAnimData(param0, param0_this)) {
            EggXfmSAnim *return_value = new EggXfmSAnim(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggXfmSAnim::EggXfmSAnim(EggXfmSAnim const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggXfmSAnim", (char **)keyword_list, &param0)) {
          CPT(EggXfmSAnim) param0_this;
          if (Dtool_ConstCoerce_EggXfmSAnim(param0, param0_this)) {
            EggXfmSAnim *return_value = new EggXfmSAnim(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggXfmSAnim() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggXfmSAnim()\n"
      "EggXfmSAnim(str name, int cs)\n"
      "EggXfmSAnim(const EggXfmAnimData convert_from)\n"
      "EggXfmSAnim(const EggXfmSAnim copy)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggXfmSAnim(PyObject *args, CPT(EggXfmSAnim) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggXfmSAnim, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline EggXfmSAnim::EggXfmSAnim(std::string const &name, CoordinateSystem cs)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        EggXfmSAnim *return_value = new EggXfmSAnim(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from)
      EggXfmAnimData const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggXfmAnimData, (void **)&arg_this);
      if (arg_this != NULL) {
        EggXfmSAnim *return_value = new EggXfmSAnim(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline EggXfmSAnim::EggXfmSAnim(std::string const &name, CoordinateSystem cs)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      int param1;
      if (PyArg_ParseTuple(args, "s#i:EggXfmSAnim", &param0_str, &param0_len, &param1)) {
        EggXfmSAnim *return_value = new EggXfmSAnim(std::string(param0_str, param0_len), (CoordinateSystem)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_EggXfmSAnim(PyObject *args, PT(EggXfmSAnim) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggXfmSAnim, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline EggXfmSAnim::EggXfmSAnim(std::string const &name, CoordinateSystem cs)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        EggXfmSAnim *return_value = new EggXfmSAnim(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from)
      EggXfmAnimData const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggXfmAnimData, (void **)&arg_this);
      if (arg_this != NULL) {
        EggXfmSAnim *return_value = new EggXfmSAnim(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline EggXfmSAnim::EggXfmSAnim(std::string const &name, CoordinateSystem cs)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      int param1;
      if (PyArg_ParseTuple(args, "s#i:EggXfmSAnim", &param0_str, &param0_len, &param1)) {
        EggXfmSAnim *return_value = new EggXfmSAnim(std::string(param0_str, param0_len), (CoordinateSystem)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggXfmSAnim(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggXfmSAnim) {
    printf("EggXfmSAnim ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggXfmSAnim *local_this = (EggXfmSAnim *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggXfmSAnim) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroupNode) {
    return (EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggXfmSAnim(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggXfmSAnim) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    EggGroupNode* other_this = (EggGroupNode*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EggXfmAnimData
 */
/**
 * Python function wrapper for:
 * inline EggXfmAnimData &EggXfmAnimData::operator =(EggXfmAnimData const &copy)
 */
static PyObject *Dtool_EggXfmAnimData_operator_1194(PyObject *self, PyObject *arg) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmAnimData, (void **)&local_this, "EggXfmAnimData.assign")) {
    return NULL;
  }
  // 1-inline EggXfmAnimData &EggXfmAnimData::operator =(EggXfmAnimData const &copy)
  CPT(EggXfmAnimData) arg_this;
  if (!Dtool_ConstCoerce_EggXfmAnimData(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggXfmAnimData.assign", "EggXfmAnimData");
  }
  (*local_this).operator =(*MOVE(arg_this));
  EggXfmAnimData *return_value = local_this;
  if (return_value != (EggXfmAnimData *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (EggXfmAnimData *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggXfmAnimData, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggXfmAnimData self, const EggXfmAnimData copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_operator_1194_comment =
  "C++ Interface:\n"
  "assign(const EggXfmAnimData self, const EggXfmAnimData copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_operator_1194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmAnimData::set_order(std::string const &order)
 */
static PyObject *Dtool_EggXfmAnimData_set_order_1195(PyObject *self, PyObject *arg) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmAnimData, (void **)&local_this, "EggXfmAnimData.set_order")) {
    return NULL;
  }
  // 1-inline void EggXfmAnimData::set_order(std::string const &order)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_order(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_order(const EggXfmAnimData self, str order)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_set_order_1195_comment =
  "C++ Interface:\n"
  "set_order(const EggXfmAnimData self, str order)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_set_order_1195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmAnimData::clear_order(void)
 */
static PyObject *Dtool_EggXfmAnimData_clear_order_1196(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmAnimData, (void **)&local_this, "EggXfmAnimData.clear_order")) {
    return NULL;
  }
  // 1-inline void EggXfmAnimData::clear_order(void)
  (*local_this).clear_order();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_clear_order_1196_comment =
  "C++ Interface:\n"
  "clear_order(const EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_clear_order_1196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggXfmAnimData::has_order(void) const
 */
static PyObject *Dtool_EggXfmAnimData_has_order_1197(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggXfmAnimData::has_order(void) const
  bool return_value = (*(const EggXfmAnimData*)local_this).has_order();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_has_order_1197_comment =
  "C++ Interface:\n"
  "has_order(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_has_order_1197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggXfmAnimData::get_order(void) const
 */
static PyObject *Dtool_EggXfmAnimData_get_order_1198(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &EggXfmAnimData::get_order(void) const
  std::string const &return_value = (*(const EggXfmAnimData*)local_this).get_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_order_1198_comment =
  "C++ Interface:\n"
  "get_order(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_order_1198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string const &EggXfmAnimData::get_standard_order(void)
 */
static PyObject *Dtool_EggXfmAnimData_get_standard_order_1199(PyObject *, PyObject *) {
  // 1-static inline std::string const &EggXfmAnimData::get_standard_order(void)
  std::string const &return_value = EggXfmAnimData::get_standard_order();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_standard_order_1199_comment =
  "C++ Interface:\n"
  "get_standard_order()\n"
  "\n"
  "/**\n"
  " * Returns the standard order of matrix component composition.  This is what\n"
  " * the order string must be set to in order to use set_value() or add_data()\n"
  " * successfully.\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_standard_order_1199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmAnimData::set_contents(std::string const &contents)
 */
static PyObject *Dtool_EggXfmAnimData_set_contents_1200(PyObject *self, PyObject *arg) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmAnimData, (void **)&local_this, "EggXfmAnimData.set_contents")) {
    return NULL;
  }
  // 1-inline void EggXfmAnimData::set_contents(std::string const &contents)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_contents(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contents(const EggXfmAnimData self, str contents)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_set_contents_1200_comment =
  "C++ Interface:\n"
  "set_contents(const EggXfmAnimData self, str contents)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_set_contents_1200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmAnimData::clear_contents(void)
 */
static PyObject *Dtool_EggXfmAnimData_clear_contents_1201(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmAnimData, (void **)&local_this, "EggXfmAnimData.clear_contents")) {
    return NULL;
  }
  // 1-inline void EggXfmAnimData::clear_contents(void)
  (*local_this).clear_contents();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_clear_contents_1201_comment =
  "C++ Interface:\n"
  "clear_contents(const EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_clear_contents_1201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EggXfmAnimData::has_contents(void) const
 */
static PyObject *Dtool_EggXfmAnimData_has_contents_1202(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EggXfmAnimData::has_contents(void) const
  bool return_value = (*(const EggXfmAnimData*)local_this).has_contents();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_has_contents_1202_comment =
  "C++ Interface:\n"
  "has_contents(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_has_contents_1202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggXfmAnimData::get_contents(void) const
 */
static PyObject *Dtool_EggXfmAnimData_get_contents_1203(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &EggXfmAnimData::get_contents(void) const
  std::string const &return_value = (*(const EggXfmAnimData*)local_this).get_contents();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_contents_1203_comment =
  "C++ Interface:\n"
  "get_contents(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_contents_1203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem EggXfmAnimData::get_coordinate_system(void) const
 */
static PyObject *Dtool_EggXfmAnimData_get_coordinate_system_1204(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CoordinateSystem EggXfmAnimData::get_coordinate_system(void) const
  CoordinateSystem return_value = (*(const EggXfmAnimData*)local_this).get_coordinate_system();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_coordinate_system_1204_comment =
  "C++ Interface:\n"
  "get_coordinate_system(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system this table believes it is defined within.\n"
  " * This should always match the coordinate system of the EggData structure\n"
  " * that owns it.  It is necessary to store it here because the meaning of the\n"
  " * h, p, and r columns depends on the coordinate system.\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_coordinate_system_1204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggXfmAnimData::get_num_rows(void) const
 */
static PyObject *Dtool_EggXfmAnimData_get_num_rows_1205(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggXfmAnimData::get_num_rows(void) const
  int return_value = (*(const EggXfmAnimData*)local_this).get_num_rows();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_num_rows_1205_comment =
  "C++ Interface:\n"
  "get_num_rows(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of rows in the table.\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_num_rows_1205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EggXfmAnimData::get_num_cols(void) const
 */
static PyObject *Dtool_EggXfmAnimData_get_num_cols_1206(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmAnimData, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EggXfmAnimData::get_num_cols(void) const
  int return_value = (*(const EggXfmAnimData*)local_this).get_num_cols();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_num_cols_1206_comment =
  "C++ Interface:\n"
  "get_num_cols(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of columns in the table.  This is set according to the\n"
  " * \"contents\" string, which defines the meaning of each column.\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_num_cols_1206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EggXfmAnimData::get_value(int row, LMatrix4d &mat) const
 * inline double EggXfmAnimData::get_value(int row, int col) const
 */
static PyObject *Dtool_EggXfmAnimData_get_value_1207(PyObject *self, PyObject *args, PyObject *kwds) {
  EggXfmAnimData *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggXfmAnimData, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 void EggXfmAnimData::get_value(int row, LMatrix4d &mat) const
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "mat", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_value", (char **)keyword_list, &param1, &param2)) {
      LMatrix4d *param2_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LMatrix4d, 2, "EggXfmAnimData.get_value", false, false);
      if (param2_this != NULL) {
        (*(const EggXfmAnimData*)local_this).get_value((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline double EggXfmAnimData::get_value(int row, int col) const
    int param1;
    int param2;
    static const char *keyword_list[] = {"row", "col", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_value", (char **)keyword_list, &param1, &param2)) {
      double return_value = (*(const EggXfmAnimData*)local_this).get_value((int)param1, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 void EggXfmAnimData::get_value(int row, LMatrix4d &mat) const
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "mat", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_value", (char **)keyword_list, &param1, &param2)) {
      LMatrix4d param2_local;
      LMatrix4d *param2_this = Dtool_Coerce_LMatrix4d(param2, param2_local);
      if ((param2_this != NULL)) {
        (*(const EggXfmAnimData*)local_this).get_value((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline double EggXfmAnimData::get_value(int row, int col) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(EggXfmAnimData self, int row, LMatrix4d mat)\n"
      "get_value(EggXfmAnimData self, int row, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_value_1207_comment =
  "C++ Interface:\n"
  "get_value(EggXfmAnimData self, int row, LMatrix4d mat)\n"
  "get_value(EggXfmAnimData self, int row, int col)\n"
  "\n"
  "/**\n"
  " * Returns the value at the indicated row.  Row must be in the range 0 <= row\n"
  " * < get_num_rows(); col must be in the range 0 <= col < get_num_cols().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the value of the aggregate row of the table as a matrix.  This is a\n"
  " * convenience function that treats the 2-d table as if it were a single table\n"
  " * of matrices.\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_value_1207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggXfmAnimData::get_class_type(void)
 */
static PyObject *Dtool_EggXfmAnimData_get_class_type_1208(PyObject *, PyObject *) {
  // 1-static TypeHandle EggXfmAnimData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EggXfmAnimData::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_class_type_1208_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggXfmAnimData_get_class_type_1208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EggXfmAnimData::EggXfmAnimData(EggXfmAnimData const &copy)
 * EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from)
 * inline EggXfmAnimData::EggXfmAnimData(std::string const &name = "", CoordinateSystem cs = ::CS_default)
 */
static int Dtool_Init_EggXfmAnimData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggXfmAnimData::EggXfmAnimData(std::string const &name, CoordinateSystem cs)
      EggXfmAnimData *return_value = new EggXfmAnimData();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 inline EggXfmAnimData::EggXfmAnimData(std::string const &name, CoordinateSystem cs = ::CS_default)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        int param1 = ::CS_default;
        static const char *keyword_list[] = {"name", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|i:EggXfmAnimData", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          EggXfmAnimData *return_value = new EggXfmAnimData(std::string(param0_str, param0_len), (CoordinateSystem)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from)
        PyObject *param0;
        static const char *keyword_list[] = {"convert_from", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggXfmAnimData", (char **)keyword_list, &param0)) {
          EggXfmSAnim const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggXfmSAnim, (void **)&param0_this);
          if (param0_this != NULL) {
            EggXfmAnimData *return_value = new EggXfmAnimData(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggXfmAnimData::EggXfmAnimData(EggXfmAnimData const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggXfmAnimData", (char **)keyword_list, &param0)) {
          EggXfmAnimData const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EggXfmAnimData, (void **)&param0_this);
          if (param0_this != NULL) {
            EggXfmAnimData *return_value = new EggXfmAnimData(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggXfmAnimData::EggXfmAnimData(std::string const &name, CoordinateSystem cs = ::CS_default)
      {
        // -2 EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from)
        PyObject *param0;
        static const char *keyword_list[] = {"convert_from", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggXfmAnimData", (char **)keyword_list, &param0)) {
          CPT(EggXfmSAnim) param0_this;
          if (Dtool_ConstCoerce_EggXfmSAnim(param0, param0_this)) {
            EggXfmAnimData *return_value = new EggXfmAnimData(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggXfmAnimData::EggXfmAnimData(EggXfmAnimData const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EggXfmAnimData", (char **)keyword_list, &param0)) {
          CPT(EggXfmAnimData) param0_this;
          if (Dtool_ConstCoerce_EggXfmAnimData(param0, param0_this)) {
            EggXfmAnimData *return_value = new EggXfmAnimData(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggXfmAnimData() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggXfmAnimData()\n"
      "EggXfmAnimData(str name, int cs)\n"
      "EggXfmAnimData(const EggXfmSAnim convert_from)\n"
      "EggXfmAnimData(const EggXfmAnimData copy)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggXfmAnimData(PyObject *args, CPT(EggXfmAnimData) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggXfmAnimData, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline EggXfmAnimData::EggXfmAnimData(std::string const &name, CoordinateSystem cs)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        EggXfmAnimData *return_value = new EggXfmAnimData(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from)
      EggXfmSAnim const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggXfmSAnim, (void **)&arg_this);
      if (arg_this != NULL) {
        EggXfmAnimData *return_value = new EggXfmAnimData(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline EggXfmAnimData::EggXfmAnimData(std::string const &name, CoordinateSystem cs)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      int param1;
      if (PyArg_ParseTuple(args, "s#i:EggXfmAnimData", &param0_str, &param0_len, &param1)) {
        EggXfmAnimData *return_value = new EggXfmAnimData(std::string(param0_str, param0_len), (CoordinateSystem)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_EggXfmAnimData(PyObject *args, PT(EggXfmAnimData) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EggXfmAnimData, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline EggXfmAnimData::EggXfmAnimData(std::string const &name, CoordinateSystem cs)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        EggXfmAnimData *return_value = new EggXfmAnimData(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from)
      EggXfmSAnim const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggXfmSAnim, (void **)&arg_this);
      if (arg_this != NULL) {
        EggXfmAnimData *return_value = new EggXfmAnimData(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline EggXfmAnimData::EggXfmAnimData(std::string const &name, CoordinateSystem cs)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      int param1;
      if (PyArg_ParseTuple(args, "s#i:EggXfmAnimData", &param0_str, &param0_len, &param1)) {
        EggXfmAnimData *return_value = new EggXfmAnimData(std::string(param0_str, param0_len), (CoordinateSystem)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_EggXfmAnimData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EggXfmAnimData) {
    printf("EggXfmAnimData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EggXfmAnimData *local_this = (EggXfmAnimData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EggXfmAnimData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAnimData) {
    return (EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EggXfmAnimData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EggXfmAnimData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAnimData) {
    EggAnimData* other_this = (EggAnimData*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for EggUserData (EggUserData)
 */
static PyMethodDef Dtool_Methods_EggUserData[] = {
  {"assign", &Dtool_EggUserData_operator_4, METH_O, (const char *)Dtool_EggUserData_operator_4_comment},
  {"get_class_type", &Dtool_EggUserData_get_class_type_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggUserData_get_class_type_5_comment},
  {"getClassType", &Dtool_EggUserData_get_class_type_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggUserData_get_class_type_5_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggUserData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggUserData = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggUserData = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggUserData = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggUserData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggUserData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggUserData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggUserData,
    &Dtool_SequenceMethods_EggUserData,
    &Dtool_MappingMethods_EggUserData,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggUserData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a base class for a user-defined data type to extend egg structures\n"
    " * in processing code.  The user of the egg library may derive from\n"
    " * EggUserData to associate any arbitrary data with various egg objects.\n"
    " *\n"
    " * However, this data will not be written out to the disk when the egg file is\n"
    " * written; it is an in-memory object only.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggUserData,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggUserData,
    PyType_GenericAlloc,
    Dtool_new_EggUserData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggUserData,
  Dtool_UpcastInterface_EggUserData,
  Dtool_DowncastInterface_EggUserData,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggUserData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_EggUserData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_EggUserData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggUserData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggUserData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggUserData);
  }
}

/**
 * Python method tables for EggObject (EggObject)
 */
static PyMethodDef Dtool_Methods_EggObject[] = {
  {"assign", &Dtool_EggObject_operator_8, METH_O, (const char *)Dtool_EggObject_operator_8_comment},
  {"set_user_data", &Dtool_EggObject_set_user_data_9, METH_O, (const char *)Dtool_EggObject_set_user_data_9_comment},
  {"setUserData", &Dtool_EggObject_set_user_data_9, METH_O, (const char *)Dtool_EggObject_set_user_data_9_comment},
  {"get_user_data", &Dtool_EggObject_get_user_data_10, METH_VARARGS, (const char *)Dtool_EggObject_get_user_data_10_comment},
  {"getUserData", &Dtool_EggObject_get_user_data_10, METH_VARARGS, (const char *)Dtool_EggObject_get_user_data_10_comment},
  {"has_user_data", &Dtool_EggObject_has_user_data_11, METH_VARARGS, (const char *)Dtool_EggObject_has_user_data_11_comment},
  {"hasUserData", &Dtool_EggObject_has_user_data_11, METH_VARARGS, (const char *)Dtool_EggObject_has_user_data_11_comment},
  {"clear_user_data", &Dtool_EggObject_clear_user_data_12, METH_VARARGS, (const char *)Dtool_EggObject_clear_user_data_12_comment},
  {"clearUserData", &Dtool_EggObject_clear_user_data_12, METH_VARARGS, (const char *)Dtool_EggObject_clear_user_data_12_comment},
  {"get_class_type", &Dtool_EggObject_get_class_type_13, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggObject_get_class_type_13_comment},
  {"getClassType", &Dtool_EggObject_get_class_type_13, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggObject_get_class_type_13_comment},
  {"downcast_to_EggNamedObject", &Dtool_EggObject_downcast_to_EggNamedObject_16, METH_NOARGS, (const char *)Dtool_EggObject_downcast_to_EggNamedObject_16_comment},
  {"downcastToEggNamedObject", &Dtool_EggObject_downcast_to_EggNamedObject_16, METH_NOARGS, (const char *)Dtool_EggObject_downcast_to_EggNamedObject_16_comment},
  {"downcast_to_EggVertex", &Dtool_EggObject_downcast_to_EggVertex_162, METH_NOARGS, (const char *)Dtool_EggObject_downcast_to_EggVertex_162_comment},
  {"downcastToEggVertex", &Dtool_EggObject_downcast_to_EggVertex_162, METH_NOARGS, (const char *)Dtool_EggObject_downcast_to_EggVertex_162_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggObject = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggObject = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggObject = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggObject = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggObject = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggObject",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggObject,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggObject,
    &Dtool_SequenceMethods_EggObject,
    &Dtool_MappingMethods_EggObject,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The highest-level base class in the egg directory.  (Almost) all things egg\n"
    " * inherit from this.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggObject,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggObject,
    PyType_GenericAlloc,
    Dtool_new_EggObject,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggObject,
  Dtool_UpcastInterface_EggObject,
  Dtool_DowncastInterface_EggObject,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_EggObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_EggObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggObject);
  }
}

/**
 * Python method tables for EggNamedObject (EggNamedObject)
 */
static PyMethodDef Dtool_Methods_EggNamedObject[] = {
  {"assign", &Dtool_EggNamedObject_operator_21, METH_O, (const char *)Dtool_EggNamedObject_operator_21_comment},
  {"output", &Dtool_EggNamedObject_output_22, METH_O, (const char *)Dtool_EggNamedObject_output_22_comment},
  {"get_class_type", &Dtool_EggNamedObject_get_class_type_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNamedObject_get_class_type_23_comment},
  {"getClassType", &Dtool_EggNamedObject_get_class_type_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNamedObject_get_class_type_23_comment},
  {"upcast_to_EggObject", &Dtool_EggNamedObject_upcast_to_EggObject_15, METH_NOARGS, (const char *)Dtool_EggNamedObject_upcast_to_EggObject_15_comment},
  {"upcastToEggObject", &Dtool_EggNamedObject_upcast_to_EggObject_15, METH_NOARGS, (const char *)Dtool_EggNamedObject_upcast_to_EggObject_15_comment},
  {"upcast_to_Namable", &Dtool_EggNamedObject_upcast_to_Namable_18, METH_NOARGS, (const char *)Dtool_EggNamedObject_upcast_to_Namable_18_comment},
  {"upcastToNamable", &Dtool_EggNamedObject_upcast_to_Namable_18, METH_NOARGS, (const char *)Dtool_EggNamedObject_upcast_to_Namable_18_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     EggNamedObject
//////////////////
static PyObject *Dtool_Repr_EggNamedObject(PyObject *self) {
  EggNamedObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNamedObject, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EggNamedObject = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggNamedObject = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggNamedObject = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggNamedObject = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggNamedObject = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggNamedObject",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggNamedObject,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_EggNamedObject,
    &Dtool_NumberMethods_EggNamedObject,
    &Dtool_SequenceMethods_EggNamedObject,
    &Dtool_MappingMethods_EggNamedObject,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_EggNamedObject,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggNamedObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a fairly low-level base class--any egg object that has a name.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggNamedObject,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggNamedObject,
    PyType_GenericAlloc,
    Dtool_new_EggNamedObject,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggNamedObject,
  Dtool_UpcastInterface_EggNamedObject,
  Dtool_DowncastInterface_EggNamedObject,
  (CoerceFunction)Dtool_ConstCoerce_EggNamedObject,
  (CoerceFunction)Dtool_Coerce_EggNamedObject,
};

static void Dtool_PyModuleClassInit_EggNamedObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggObject(NULL);
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_EggNamedObject._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_EggObject, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_EggNamedObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggNamedObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggNamedObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggNamedObject);
  }
}

/**
 * Python method tables for EggNode (EggNode)
 */
static PyMethodDef Dtool_Methods_EggNode[] = {
  {"assign", &Dtool_EggNode_operator_26, METH_O, (const char *)Dtool_EggNode_operator_26_comment},
  {"get_parent", &Dtool_EggNode_get_parent_27, METH_NOARGS, (const char *)Dtool_EggNode_get_parent_27_comment},
  {"getParent", &Dtool_EggNode_get_parent_27, METH_NOARGS, (const char *)Dtool_EggNode_get_parent_27_comment},
  {"get_depth", &Dtool_EggNode_get_depth_28, METH_NOARGS, (const char *)Dtool_EggNode_get_depth_28_comment},
  {"getDepth", &Dtool_EggNode_get_depth_28, METH_NOARGS, (const char *)Dtool_EggNode_get_depth_28_comment},
  {"is_under_instance", &Dtool_EggNode_is_under_instance_29, METH_NOARGS, (const char *)Dtool_EggNode_is_under_instance_29_comment},
  {"isUnderInstance", &Dtool_EggNode_is_under_instance_29, METH_NOARGS, (const char *)Dtool_EggNode_is_under_instance_29_comment},
  {"is_under_transform", &Dtool_EggNode_is_under_transform_30, METH_NOARGS, (const char *)Dtool_EggNode_is_under_transform_30_comment},
  {"isUnderTransform", &Dtool_EggNode_is_under_transform_30, METH_NOARGS, (const char *)Dtool_EggNode_is_under_transform_30_comment},
  {"is_local_coord", &Dtool_EggNode_is_local_coord_31, METH_NOARGS, (const char *)Dtool_EggNode_is_local_coord_31_comment},
  {"isLocalCoord", &Dtool_EggNode_is_local_coord_31, METH_NOARGS, (const char *)Dtool_EggNode_is_local_coord_31_comment},
  {"get_vertex_frame", &Dtool_EggNode_get_vertex_frame_32, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_32_comment},
  {"getVertexFrame", &Dtool_EggNode_get_vertex_frame_32, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_32_comment},
  {"get_node_frame", &Dtool_EggNode_get_node_frame_33, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_33_comment},
  {"getNodeFrame", &Dtool_EggNode_get_node_frame_33, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_33_comment},
  {"get_vertex_frame_inv", &Dtool_EggNode_get_vertex_frame_inv_34, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_inv_34_comment},
  {"getVertexFrameInv", &Dtool_EggNode_get_vertex_frame_inv_34, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_inv_34_comment},
  {"get_node_frame_inv", &Dtool_EggNode_get_node_frame_inv_35, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_inv_35_comment},
  {"getNodeFrameInv", &Dtool_EggNode_get_node_frame_inv_35, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_inv_35_comment},
  {"get_vertex_to_node", &Dtool_EggNode_get_vertex_to_node_36, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_to_node_36_comment},
  {"getVertexToNode", &Dtool_EggNode_get_vertex_to_node_36, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_to_node_36_comment},
  {"get_node_to_vertex", &Dtool_EggNode_get_node_to_vertex_37, METH_NOARGS, (const char *)Dtool_EggNode_get_node_to_vertex_37_comment},
  {"getNodeToVertex", &Dtool_EggNode_get_node_to_vertex_37, METH_NOARGS, (const char *)Dtool_EggNode_get_node_to_vertex_37_comment},
  {"get_vertex_frame_ptr", &Dtool_EggNode_get_vertex_frame_ptr_38, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_ptr_38_comment},
  {"getVertexFramePtr", &Dtool_EggNode_get_vertex_frame_ptr_38, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_ptr_38_comment},
  {"get_node_frame_ptr", &Dtool_EggNode_get_node_frame_ptr_39, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_ptr_39_comment},
  {"getNodeFramePtr", &Dtool_EggNode_get_node_frame_ptr_39, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_ptr_39_comment},
  {"get_vertex_frame_inv_ptr", &Dtool_EggNode_get_vertex_frame_inv_ptr_40, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_inv_ptr_40_comment},
  {"getVertexFrameInvPtr", &Dtool_EggNode_get_vertex_frame_inv_ptr_40, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_inv_ptr_40_comment},
  {"get_node_frame_inv_ptr", &Dtool_EggNode_get_node_frame_inv_ptr_41, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_inv_ptr_41_comment},
  {"getNodeFrameInvPtr", &Dtool_EggNode_get_node_frame_inv_ptr_41, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_inv_ptr_41_comment},
  {"get_vertex_to_node_ptr", &Dtool_EggNode_get_vertex_to_node_ptr_42, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_to_node_ptr_42_comment},
  {"getVertexToNodePtr", &Dtool_EggNode_get_vertex_to_node_ptr_42, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_to_node_ptr_42_comment},
  {"get_node_to_vertex_ptr", &Dtool_EggNode_get_node_to_vertex_ptr_43, METH_NOARGS, (const char *)Dtool_EggNode_get_node_to_vertex_ptr_43_comment},
  {"getNodeToVertexPtr", &Dtool_EggNode_get_node_to_vertex_ptr_43, METH_NOARGS, (const char *)Dtool_EggNode_get_node_to_vertex_ptr_43_comment},
  {"transform", &Dtool_EggNode_transform_44, METH_O, (const char *)Dtool_EggNode_transform_44_comment},
  {"transform_vertices_only", &Dtool_EggNode_transform_vertices_only_45, METH_O, (const char *)Dtool_EggNode_transform_vertices_only_45_comment},
  {"transformVerticesOnly", &Dtool_EggNode_transform_vertices_only_45, METH_O, (const char *)Dtool_EggNode_transform_vertices_only_45_comment},
  {"flatten_transforms", &Dtool_EggNode_flatten_transforms_46, METH_NOARGS, (const char *)Dtool_EggNode_flatten_transforms_46_comment},
  {"flattenTransforms", &Dtool_EggNode_flatten_transforms_46, METH_NOARGS, (const char *)Dtool_EggNode_flatten_transforms_46_comment},
  {"apply_texmats", &Dtool_EggNode_apply_texmats_47, METH_NOARGS, (const char *)Dtool_EggNode_apply_texmats_47_comment},
  {"applyTexmats", &Dtool_EggNode_apply_texmats_47, METH_NOARGS, (const char *)Dtool_EggNode_apply_texmats_47_comment},
  {"is_joint", &Dtool_EggNode_is_joint_49, METH_NOARGS, (const char *)Dtool_EggNode_is_joint_49_comment},
  {"isJoint", &Dtool_EggNode_is_joint_49, METH_NOARGS, (const char *)Dtool_EggNode_is_joint_49_comment},
  {"is_anim_matrix", &Dtool_EggNode_is_anim_matrix_50, METH_NOARGS, (const char *)Dtool_EggNode_is_anim_matrix_50_comment},
  {"isAnimMatrix", &Dtool_EggNode_is_anim_matrix_50, METH_NOARGS, (const char *)Dtool_EggNode_is_anim_matrix_50_comment},
  {"determine_alpha_mode", &Dtool_EggNode_determine_alpha_mode_51, METH_NOARGS, (const char *)Dtool_EggNode_determine_alpha_mode_51_comment},
  {"determineAlphaMode", &Dtool_EggNode_determine_alpha_mode_51, METH_NOARGS, (const char *)Dtool_EggNode_determine_alpha_mode_51_comment},
  {"determine_depth_write_mode", &Dtool_EggNode_determine_depth_write_mode_52, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_write_mode_52_comment},
  {"determineDepthWriteMode", &Dtool_EggNode_determine_depth_write_mode_52, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_write_mode_52_comment},
  {"determine_depth_test_mode", &Dtool_EggNode_determine_depth_test_mode_53, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_test_mode_53_comment},
  {"determineDepthTestMode", &Dtool_EggNode_determine_depth_test_mode_53, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_test_mode_53_comment},
  {"determine_visibility_mode", &Dtool_EggNode_determine_visibility_mode_54, METH_NOARGS, (const char *)Dtool_EggNode_determine_visibility_mode_54_comment},
  {"determineVisibilityMode", &Dtool_EggNode_determine_visibility_mode_54, METH_NOARGS, (const char *)Dtool_EggNode_determine_visibility_mode_54_comment},
  {"determine_depth_offset", &Dtool_EggNode_determine_depth_offset_55, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_offset_55_comment},
  {"determineDepthOffset", &Dtool_EggNode_determine_depth_offset_55, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_offset_55_comment},
  {"determine_draw_order", &Dtool_EggNode_determine_draw_order_56, METH_NOARGS, (const char *)Dtool_EggNode_determine_draw_order_56_comment},
  {"determineDrawOrder", &Dtool_EggNode_determine_draw_order_56, METH_NOARGS, (const char *)Dtool_EggNode_determine_draw_order_56_comment},
  {"determine_bin", &Dtool_EggNode_determine_bin_57, METH_NOARGS, (const char *)Dtool_EggNode_determine_bin_57_comment},
  {"determineBin", &Dtool_EggNode_determine_bin_57, METH_NOARGS, (const char *)Dtool_EggNode_determine_bin_57_comment},
  {"determine_indexed", &Dtool_EggNode_determine_indexed_58, METH_NOARGS, (const char *)Dtool_EggNode_determine_indexed_58_comment},
  {"determineIndexed", &Dtool_EggNode_determine_indexed_58, METH_NOARGS, (const char *)Dtool_EggNode_determine_indexed_58_comment},
  {"determine_decal", &Dtool_EggNode_determine_decal_59, METH_NOARGS, (const char *)Dtool_EggNode_determine_decal_59_comment},
  {"determineDecal", &Dtool_EggNode_determine_decal_59, METH_NOARGS, (const char *)Dtool_EggNode_determine_decal_59_comment},
  {"write", (PyCFunction) &Dtool_EggNode_write_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNode_write_60_comment},
  {"parse_egg", &Dtool_EggNode_parse_egg_61, METH_O, (const char *)Dtool_EggNode_parse_egg_61_comment},
  {"parseEgg", &Dtool_EggNode_parse_egg_61, METH_O, (const char *)Dtool_EggNode_parse_egg_61_comment},
  {"test_under_integrity", &Dtool_EggNode_test_under_integrity_62, METH_NOARGS, (const char *)Dtool_EggNode_test_under_integrity_62_comment},
  {"testUnderIntegrity", &Dtool_EggNode_test_under_integrity_62, METH_NOARGS, (const char *)Dtool_EggNode_test_under_integrity_62_comment},
  {"get_class_type", &Dtool_EggNode_get_class_type_63, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNode_get_class_type_63_comment},
  {"getClassType", &Dtool_EggNode_get_class_type_63, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNode_get_class_type_63_comment},
  {"downcast_to_EggPrimitive", &Dtool_EggNode_downcast_to_EggPrimitive_842, METH_NOARGS, (const char *)Dtool_EggNode_downcast_to_EggPrimitive_842_comment},
  {"downcastToEggPrimitive", &Dtool_EggNode_downcast_to_EggPrimitive_842, METH_NOARGS, (const char *)Dtool_EggNode_downcast_to_EggPrimitive_842_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     EggNode
//////////////////
static PyObject *Dtool_Str_EggNode(PyObject *self) {
  EggNode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EggNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggNode,
    &Dtool_SequenceMethods_EggNode,
    &Dtool_MappingMethods_EggNode,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_EggNode,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for things that may be directly added into the egg hierarchy.\n"
    " * This includes groups, joints, polygons, vertex pools, etc., but does not\n"
    " * include things like vertices.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggNode,
    PyType_GenericAlloc,
    Dtool_new_EggNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggNode,
  Dtool_UpcastInterface_EggNode,
  Dtool_DowncastInterface_EggNode,
  (CoerceFunction)Dtool_ConstCoerce_EggNode,
  (CoerceFunction)Dtool_Coerce_EggNode,
};

static void Dtool_PyModuleClassInit_EggNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNamedObject(NULL);
    Dtool_EggNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNamedObject);
    PyObject *dict = PyDict_New();
    Dtool_EggNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggNode);
  }
}

/**
 * Python method tables for EggAnimData (EggAnimData)
 */
static PyMethodDef Dtool_Methods_EggAnimData[] = {
  {"assign", &Dtool_EggAnimData_operator_66, METH_O, (const char *)Dtool_EggAnimData_operator_66_comment},
  {"set_fps", &Dtool_EggAnimData_set_fps_67, METH_O, (const char *)Dtool_EggAnimData_set_fps_67_comment},
  {"setFps", &Dtool_EggAnimData_set_fps_67, METH_O, (const char *)Dtool_EggAnimData_set_fps_67_comment},
  {"clear_fps", &Dtool_EggAnimData_clear_fps_68, METH_NOARGS, (const char *)Dtool_EggAnimData_clear_fps_68_comment},
  {"clearFps", &Dtool_EggAnimData_clear_fps_68, METH_NOARGS, (const char *)Dtool_EggAnimData_clear_fps_68_comment},
  {"has_fps", &Dtool_EggAnimData_has_fps_69, METH_NOARGS, (const char *)Dtool_EggAnimData_has_fps_69_comment},
  {"hasFps", &Dtool_EggAnimData_has_fps_69, METH_NOARGS, (const char *)Dtool_EggAnimData_has_fps_69_comment},
  {"get_fps", &Dtool_EggAnimData_get_fps_70, METH_NOARGS, (const char *)Dtool_EggAnimData_get_fps_70_comment},
  {"getFps", &Dtool_EggAnimData_get_fps_70, METH_NOARGS, (const char *)Dtool_EggAnimData_get_fps_70_comment},
  {"clear_data", &Dtool_EggAnimData_clear_data_71, METH_NOARGS, (const char *)Dtool_EggAnimData_clear_data_71_comment},
  {"clearData", &Dtool_EggAnimData_clear_data_71, METH_NOARGS, (const char *)Dtool_EggAnimData_clear_data_71_comment},
  {"add_data", &Dtool_EggAnimData_add_data_72, METH_O, (const char *)Dtool_EggAnimData_add_data_72_comment},
  {"addData", &Dtool_EggAnimData_add_data_72, METH_O, (const char *)Dtool_EggAnimData_add_data_72_comment},
  {"get_size", &Dtool_EggAnimData_get_size_73, METH_NOARGS, (const char *)Dtool_EggAnimData_get_size_73_comment},
  {"getSize", &Dtool_EggAnimData_get_size_73, METH_NOARGS, (const char *)Dtool_EggAnimData_get_size_73_comment},
  {"quantize", &Dtool_EggAnimData_quantize_74, METH_O, (const char *)Dtool_EggAnimData_quantize_74_comment},
  {"get_class_type", &Dtool_EggAnimData_get_class_type_75, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAnimData_get_class_type_75_comment},
  {"getClassType", &Dtool_EggAnimData_get_class_type_75, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAnimData_get_class_type_75_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggAnimData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggAnimData = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggAnimData = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggAnimData = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggAnimData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggAnimData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggAnimData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggAnimData,
    &Dtool_SequenceMethods_EggAnimData,
    &Dtool_MappingMethods_EggAnimData,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggAnimData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for EggSAnimData and EggXfmAnimData, which contain rows and\n"
    " * columns of numbers.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggAnimData,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggAnimData,
    PyType_GenericAlloc,
    Dtool_new_EggAnimData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggAnimData,
  Dtool_UpcastInterface_EggAnimData,
  Dtool_DowncastInterface_EggAnimData,
  (CoerceFunction)Dtool_ConstCoerce_EggAnimData,
  (CoerceFunction)Dtool_Coerce_EggAnimData,
};

static void Dtool_PyModuleClassInit_EggAnimData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(NULL);
    Dtool_EggAnimData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    PyObject *dict = PyDict_New();
    Dtool_EggAnimData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggAnimData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggAnimData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggAnimData);
  }
}

/**
 * Python method tables for EggAnimPreload (EggAnimPreload)
 */
static PyMethodDef Dtool_Methods_EggAnimPreload[] = {
  {"assign", &Dtool_EggAnimPreload_operator_79, METH_O, (const char *)Dtool_EggAnimPreload_operator_79_comment},
  {"set_fps", &Dtool_EggAnimPreload_set_fps_80, METH_O, (const char *)Dtool_EggAnimPreload_set_fps_80_comment},
  {"setFps", &Dtool_EggAnimPreload_set_fps_80, METH_O, (const char *)Dtool_EggAnimPreload_set_fps_80_comment},
  {"clear_fps", &Dtool_EggAnimPreload_clear_fps_81, METH_NOARGS, (const char *)Dtool_EggAnimPreload_clear_fps_81_comment},
  {"clearFps", &Dtool_EggAnimPreload_clear_fps_81, METH_NOARGS, (const char *)Dtool_EggAnimPreload_clear_fps_81_comment},
  {"has_fps", &Dtool_EggAnimPreload_has_fps_82, METH_NOARGS, (const char *)Dtool_EggAnimPreload_has_fps_82_comment},
  {"hasFps", &Dtool_EggAnimPreload_has_fps_82, METH_NOARGS, (const char *)Dtool_EggAnimPreload_has_fps_82_comment},
  {"get_fps", &Dtool_EggAnimPreload_get_fps_83, METH_NOARGS, (const char *)Dtool_EggAnimPreload_get_fps_83_comment},
  {"getFps", &Dtool_EggAnimPreload_get_fps_83, METH_NOARGS, (const char *)Dtool_EggAnimPreload_get_fps_83_comment},
  {"set_num_frames", &Dtool_EggAnimPreload_set_num_frames_84, METH_O, (const char *)Dtool_EggAnimPreload_set_num_frames_84_comment},
  {"setNumFrames", &Dtool_EggAnimPreload_set_num_frames_84, METH_O, (const char *)Dtool_EggAnimPreload_set_num_frames_84_comment},
  {"clear_num_frames", &Dtool_EggAnimPreload_clear_num_frames_85, METH_NOARGS, (const char *)Dtool_EggAnimPreload_clear_num_frames_85_comment},
  {"clearNumFrames", &Dtool_EggAnimPreload_clear_num_frames_85, METH_NOARGS, (const char *)Dtool_EggAnimPreload_clear_num_frames_85_comment},
  {"has_num_frames", &Dtool_EggAnimPreload_has_num_frames_86, METH_NOARGS, (const char *)Dtool_EggAnimPreload_has_num_frames_86_comment},
  {"hasNumFrames", &Dtool_EggAnimPreload_has_num_frames_86, METH_NOARGS, (const char *)Dtool_EggAnimPreload_has_num_frames_86_comment},
  {"get_num_frames", &Dtool_EggAnimPreload_get_num_frames_87, METH_NOARGS, (const char *)Dtool_EggAnimPreload_get_num_frames_87_comment},
  {"getNumFrames", &Dtool_EggAnimPreload_get_num_frames_87, METH_NOARGS, (const char *)Dtool_EggAnimPreload_get_num_frames_87_comment},
  {"get_class_type", &Dtool_EggAnimPreload_get_class_type_88, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAnimPreload_get_class_type_88_comment},
  {"getClassType", &Dtool_EggAnimPreload_get_class_type_88, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAnimPreload_get_class_type_88_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggAnimPreload = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggAnimPreload = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggAnimPreload = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggAnimPreload = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggAnimPreload = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggAnimPreload",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggAnimPreload,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggAnimPreload,
    &Dtool_SequenceMethods_EggAnimPreload,
    &Dtool_MappingMethods_EggAnimPreload,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggAnimPreload,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This corresponds to an <AnimPreload> entry.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggAnimPreload,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggAnimPreload,
    PyType_GenericAlloc,
    Dtool_new_EggAnimPreload,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggAnimPreload,
  Dtool_UpcastInterface_EggAnimPreload,
  Dtool_DowncastInterface_EggAnimPreload,
  (CoerceFunction)Dtool_ConstCoerce_EggAnimPreload,
  (CoerceFunction)Dtool_Coerce_EggAnimPreload,
};

static void Dtool_PyModuleClassInit_EggAnimPreload(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(NULL);
    Dtool_EggAnimPreload._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    PyObject *dict = PyDict_New();
    Dtool_EggAnimPreload._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggAnimPreload) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggAnimPreload)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggAnimPreload);
  }
}

/**
 * Python method tables for EggAttributes (EggAttributes)
 */
static PyMethodDef Dtool_Methods_EggAttributes[] = {
  {"assign", &Dtool_EggAttributes_operator_95, METH_O, (const char *)Dtool_EggAttributes_operator_95_comment},
  {"has_normal", &Dtool_EggAttributes_has_normal_97, METH_NOARGS, (const char *)Dtool_EggAttributes_has_normal_97_comment},
  {"hasNormal", &Dtool_EggAttributes_has_normal_97, METH_NOARGS, (const char *)Dtool_EggAttributes_has_normal_97_comment},
  {"get_normal", &Dtool_EggAttributes_get_normal_98, METH_NOARGS, (const char *)Dtool_EggAttributes_get_normal_98_comment},
  {"getNormal", &Dtool_EggAttributes_get_normal_98, METH_NOARGS, (const char *)Dtool_EggAttributes_get_normal_98_comment},
  {"set_normal", &Dtool_EggAttributes_set_normal_99, METH_O, (const char *)Dtool_EggAttributes_set_normal_99_comment},
  {"setNormal", &Dtool_EggAttributes_set_normal_99, METH_O, (const char *)Dtool_EggAttributes_set_normal_99_comment},
  {"clear_normal", &Dtool_EggAttributes_clear_normal_100, METH_NOARGS, (const char *)Dtool_EggAttributes_clear_normal_100_comment},
  {"clearNormal", &Dtool_EggAttributes_clear_normal_100, METH_NOARGS, (const char *)Dtool_EggAttributes_clear_normal_100_comment},
  {"matches_normal", &Dtool_EggAttributes_matches_normal_101, METH_O, (const char *)Dtool_EggAttributes_matches_normal_101_comment},
  {"matchesNormal", &Dtool_EggAttributes_matches_normal_101, METH_O, (const char *)Dtool_EggAttributes_matches_normal_101_comment},
  {"copy_normal", &Dtool_EggAttributes_copy_normal_102, METH_O, (const char *)Dtool_EggAttributes_copy_normal_102_comment},
  {"copyNormal", &Dtool_EggAttributes_copy_normal_102, METH_O, (const char *)Dtool_EggAttributes_copy_normal_102_comment},
  {"has_color", &Dtool_EggAttributes_has_color_103, METH_NOARGS, (const char *)Dtool_EggAttributes_has_color_103_comment},
  {"hasColor", &Dtool_EggAttributes_has_color_103, METH_NOARGS, (const char *)Dtool_EggAttributes_has_color_103_comment},
  {"get_color", &Dtool_EggAttributes_get_color_104, METH_NOARGS, (const char *)Dtool_EggAttributes_get_color_104_comment},
  {"getColor", &Dtool_EggAttributes_get_color_104, METH_NOARGS, (const char *)Dtool_EggAttributes_get_color_104_comment},
  {"set_color", &Dtool_EggAttributes_set_color_105, METH_O, (const char *)Dtool_EggAttributes_set_color_105_comment},
  {"setColor", &Dtool_EggAttributes_set_color_105, METH_O, (const char *)Dtool_EggAttributes_set_color_105_comment},
  {"clear_color", &Dtool_EggAttributes_clear_color_106, METH_NOARGS, (const char *)Dtool_EggAttributes_clear_color_106_comment},
  {"clearColor", &Dtool_EggAttributes_clear_color_106, METH_NOARGS, (const char *)Dtool_EggAttributes_clear_color_106_comment},
  {"matches_color", &Dtool_EggAttributes_matches_color_107, METH_O, (const char *)Dtool_EggAttributes_matches_color_107_comment},
  {"matchesColor", &Dtool_EggAttributes_matches_color_107, METH_O, (const char *)Dtool_EggAttributes_matches_color_107_comment},
  {"copy_color", &Dtool_EggAttributes_copy_color_108, METH_O, (const char *)Dtool_EggAttributes_copy_color_108_comment},
  {"copyColor", &Dtool_EggAttributes_copy_color_108, METH_O, (const char *)Dtool_EggAttributes_copy_color_108_comment},
  {"write", (PyCFunction) &Dtool_EggAttributes_write_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggAttributes_write_109_comment},
  {"sorts_less_than", &Dtool_EggAttributes_sorts_less_than_110, METH_O, (const char *)Dtool_EggAttributes_sorts_less_than_110_comment},
  {"sortsLessThan", &Dtool_EggAttributes_sorts_less_than_110, METH_O, (const char *)Dtool_EggAttributes_sorts_less_than_110_comment},
  {"compare_to", &Dtool_EggAttributes_compare_to_111, METH_O, (const char *)Dtool_EggAttributes_compare_to_111_comment},
  {"compareTo", &Dtool_EggAttributes_compare_to_111, METH_O, (const char *)Dtool_EggAttributes_compare_to_111_comment},
  {"transform", &Dtool_EggAttributes_transform_112, METH_O, (const char *)Dtool_EggAttributes_transform_112_comment},
  {"get_class_type", &Dtool_EggAttributes_get_class_type_121, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAttributes_get_class_type_121_comment},
  {"getClassType", &Dtool_EggAttributes_get_class_type_121, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAttributes_get_class_type_121_comment},
  {"downcast_to_EggVertex", &Dtool_EggAttributes_downcast_to_EggVertex_164, METH_NOARGS, (const char *)Dtool_EggAttributes_downcast_to_EggVertex_164_comment},
  {"downcastToEggVertex", &Dtool_EggAttributes_downcast_to_EggVertex_164, METH_NOARGS, (const char *)Dtool_EggAttributes_downcast_to_EggVertex_164_comment},
  {"downcast_to_EggPrimitive", &Dtool_EggAttributes_downcast_to_EggPrimitive_844, METH_NOARGS, (const char *)Dtool_EggAttributes_downcast_to_EggPrimitive_844_comment},
  {"downcastToEggPrimitive", &Dtool_EggAttributes_downcast_to_EggPrimitive_844, METH_NOARGS, (const char *)Dtool_EggAttributes_downcast_to_EggPrimitive_844_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggAttributes slot tp_compare -> compare_to
//////////////////
static int Dtool_EggAttributes_compare_to_111_tp_compare(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return -1;
  }

  // 1-int EggAttributes::compare_to(EggAttributes const &other) const
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const EggAttributes*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(EggAttributes self, const EggAttributes other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     EggAttributes
//////////////////
static PyObject *Dtool_Str_EggAttributes(PyObject *self) {
  EggAttributes *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EggAttributes = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggAttributes = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggAttributes = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggAttributes = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggAttributes = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggAttributes",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggAttributes,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_EggAttributes_compare_to_111_tp_compare,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggAttributes,
    &Dtool_SequenceMethods_EggAttributes,
    &Dtool_MappingMethods_EggAttributes,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_EggAttributes,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggAttributes,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The set of attributes that may be applied to vertices as well as polygons,\n"
    " * such as surface normal and color.\n"
    " *\n"
    " * This class cannot inherit from EggObject, because it causes problems at the\n"
    " * EggPolygon level with multiple appearances of the EggObject base class.\n"
    " * And making EggObject a virtual base class is just no fun.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DTOOL_PyObject_RichCompare,
#else
    0, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggAttributes,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggAttributes,
    PyType_GenericAlloc,
    Dtool_new_EggAttributes,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggAttributes,
  Dtool_UpcastInterface_EggAttributes,
  Dtool_DowncastInterface_EggAttributes,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggAttributes(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EggAttributes._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_EggAttributes._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggAttributes) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggAttributes)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggAttributes);
  }
}

/**
 * Python method tables for EggVertexUV (EggVertexUV)
 */
static PyMethodDef Dtool_Methods_EggVertexUV[] = {
  {"assign", &Dtool_EggVertexUV_operator_124, METH_O, (const char *)Dtool_EggVertexUV_operator_124_comment},
  {"filter_name", &Dtool_EggVertexUV_filter_name_125, METH_O | METH_STATIC, (const char *)Dtool_EggVertexUV_filter_name_125_comment},
  {"filterName", &Dtool_EggVertexUV_filter_name_125, METH_O | METH_STATIC, (const char *)Dtool_EggVertexUV_filter_name_125_comment},
  {"set_name", &Dtool_EggVertexUV_set_name_126, METH_O, (const char *)Dtool_EggVertexUV_set_name_126_comment},
  {"setName", &Dtool_EggVertexUV_set_name_126, METH_O, (const char *)Dtool_EggVertexUV_set_name_126_comment},
  {"get_num_dimensions", &Dtool_EggVertexUV_get_num_dimensions_127, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_num_dimensions_127_comment},
  {"getNumDimensions", &Dtool_EggVertexUV_get_num_dimensions_127, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_num_dimensions_127_comment},
  {"has_w", &Dtool_EggVertexUV_has_w_128, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_w_128_comment},
  {"hasW", &Dtool_EggVertexUV_has_w_128, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_w_128_comment},
  {"get_uv", &Dtool_EggVertexUV_get_uv_129, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_uv_129_comment},
  {"getUv", &Dtool_EggVertexUV_get_uv_129, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_uv_129_comment},
  {"get_uvw", &Dtool_EggVertexUV_get_uvw_130, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_uvw_130_comment},
  {"getUvw", &Dtool_EggVertexUV_get_uvw_130, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_uvw_130_comment},
  {"set_uv", &Dtool_EggVertexUV_set_uv_131, METH_O, (const char *)Dtool_EggVertexUV_set_uv_131_comment},
  {"setUv", &Dtool_EggVertexUV_set_uv_131, METH_O, (const char *)Dtool_EggVertexUV_set_uv_131_comment},
  {"set_uvw", &Dtool_EggVertexUV_set_uvw_132, METH_O, (const char *)Dtool_EggVertexUV_set_uvw_132_comment},
  {"setUvw", &Dtool_EggVertexUV_set_uvw_132, METH_O, (const char *)Dtool_EggVertexUV_set_uvw_132_comment},
  {"has_tangent", &Dtool_EggVertexUV_has_tangent_133, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_tangent_133_comment},
  {"hasTangent", &Dtool_EggVertexUV_has_tangent_133, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_tangent_133_comment},
  {"get_tangent", &Dtool_EggVertexUV_get_tangent_134, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_tangent_134_comment},
  {"getTangent", &Dtool_EggVertexUV_get_tangent_134, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_tangent_134_comment},
  {"set_tangent", &Dtool_EggVertexUV_set_tangent_135, METH_O, (const char *)Dtool_EggVertexUV_set_tangent_135_comment},
  {"setTangent", &Dtool_EggVertexUV_set_tangent_135, METH_O, (const char *)Dtool_EggVertexUV_set_tangent_135_comment},
  {"clear_tangent", &Dtool_EggVertexUV_clear_tangent_136, METH_NOARGS, (const char *)Dtool_EggVertexUV_clear_tangent_136_comment},
  {"clearTangent", &Dtool_EggVertexUV_clear_tangent_136, METH_NOARGS, (const char *)Dtool_EggVertexUV_clear_tangent_136_comment},
  {"has_binormal", &Dtool_EggVertexUV_has_binormal_137, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_binormal_137_comment},
  {"hasBinormal", &Dtool_EggVertexUV_has_binormal_137, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_binormal_137_comment},
  {"get_binormal", &Dtool_EggVertexUV_get_binormal_138, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_binormal_138_comment},
  {"getBinormal", &Dtool_EggVertexUV_get_binormal_138, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_binormal_138_comment},
  {"set_binormal", &Dtool_EggVertexUV_set_binormal_139, METH_O, (const char *)Dtool_EggVertexUV_set_binormal_139_comment},
  {"setBinormal", &Dtool_EggVertexUV_set_binormal_139, METH_O, (const char *)Dtool_EggVertexUV_set_binormal_139_comment},
  {"clear_binormal", &Dtool_EggVertexUV_clear_binormal_140, METH_NOARGS, (const char *)Dtool_EggVertexUV_clear_binormal_140_comment},
  {"clearBinormal", &Dtool_EggVertexUV_clear_binormal_140, METH_NOARGS, (const char *)Dtool_EggVertexUV_clear_binormal_140_comment},
  {"make_average", (PyCFunction) &Dtool_EggVertexUV_make_average_141, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertexUV_make_average_141_comment},
  {"makeAverage", (PyCFunction) &Dtool_EggVertexUV_make_average_141, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertexUV_make_average_141_comment},
  {"transform", &Dtool_EggVertexUV_transform_142, METH_O, (const char *)Dtool_EggVertexUV_transform_142_comment},
  {"write", (PyCFunction) &Dtool_EggVertexUV_write_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertexUV_write_143_comment},
  {"compare_to", &Dtool_EggVertexUV_compare_to_144, METH_O, (const char *)Dtool_EggVertexUV_compare_to_144_comment},
  {"compareTo", &Dtool_EggVertexUV_compare_to_144, METH_O, (const char *)Dtool_EggVertexUV_compare_to_144_comment},
  {"get_class_type", &Dtool_EggVertexUV_get_class_type_149, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexUV_get_class_type_149_comment},
  {"getClassType", &Dtool_EggVertexUV_get_class_type_149, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexUV_get_class_type_149_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggVertexUV slot tp_compare -> compare_to
//////////////////
static int Dtool_EggVertexUV_compare_to_144_tp_compare(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return -1;
  }

  // 1-int EggVertexUV::compare_to(EggVertexUV const &other) const
  CPT(EggVertexUV) arg_this;
  if (!Dtool_ConstCoerce_EggVertexUV(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.compare_to", "EggVertexUV");
    return -1;
  }
  int return_value = (*(const EggVertexUV*)local_this).compare_to(*MOVE(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertexUV self, const EggVertexUV other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     EggVertexUV
//////////////////
static PyObject *Dtool_Str_EggVertexUV(PyObject *self) {
  EggVertexUV *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EggVertexUV = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggVertexUV = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggVertexUV = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggVertexUV = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggVertexUV = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggVertexUV",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggVertexUV,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_EggVertexUV_compare_to_144_tp_compare,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggVertexUV,
    &Dtool_SequenceMethods_EggVertexUV,
    &Dtool_MappingMethods_EggVertexUV,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_EggVertexUV,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggVertexUV,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The set of UV's that may or may not be assigned to a vertex.  To support\n"
    " * multitexturing, there may be multiple sets of UV's on a particular vertex,\n"
    " * each with its own name.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DTOOL_PyObject_RichCompare,
#else
    0, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggVertexUV,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggVertexUV,
    PyType_GenericAlloc,
    Dtool_new_EggVertexUV,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggVertexUV,
  Dtool_UpcastInterface_EggVertexUV,
  Dtool_DowncastInterface_EggVertexUV,
  (CoerceFunction)Dtool_ConstCoerce_EggVertexUV,
  (CoerceFunction)Dtool_Coerce_EggVertexUV,
};

static void Dtool_PyModuleClassInit_EggVertexUV(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNamedObject(NULL);
    Dtool_EggVertexUV._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNamedObject);
    PyObject *dict = PyDict_New();
    Dtool_EggVertexUV._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggVertexUV) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggVertexUV)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggVertexUV);
  }
}

/**
 * Python method tables for EggVertexAux (EggVertexAux)
 */
static PyMethodDef Dtool_Methods_EggVertexAux[] = {
  {"assign", &Dtool_EggVertexAux_operator_152, METH_O, (const char *)Dtool_EggVertexAux_operator_152_comment},
  {"set_name", &Dtool_EggVertexAux_set_name_153, METH_O, (const char *)Dtool_EggVertexAux_set_name_153_comment},
  {"setName", &Dtool_EggVertexAux_set_name_153, METH_O, (const char *)Dtool_EggVertexAux_set_name_153_comment},
  {"get_aux", &Dtool_EggVertexAux_get_aux_154, METH_NOARGS, (const char *)Dtool_EggVertexAux_get_aux_154_comment},
  {"getAux", &Dtool_EggVertexAux_get_aux_154, METH_NOARGS, (const char *)Dtool_EggVertexAux_get_aux_154_comment},
  {"set_aux", &Dtool_EggVertexAux_set_aux_155, METH_O, (const char *)Dtool_EggVertexAux_set_aux_155_comment},
  {"setAux", &Dtool_EggVertexAux_set_aux_155, METH_O, (const char *)Dtool_EggVertexAux_set_aux_155_comment},
  {"make_average", (PyCFunction) &Dtool_EggVertexAux_make_average_156, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertexAux_make_average_156_comment},
  {"makeAverage", (PyCFunction) &Dtool_EggVertexAux_make_average_156, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertexAux_make_average_156_comment},
  {"write", (PyCFunction) &Dtool_EggVertexAux_write_157, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertexAux_write_157_comment},
  {"compare_to", &Dtool_EggVertexAux_compare_to_158, METH_O, (const char *)Dtool_EggVertexAux_compare_to_158_comment},
  {"compareTo", &Dtool_EggVertexAux_compare_to_158, METH_O, (const char *)Dtool_EggVertexAux_compare_to_158_comment},
  {"get_class_type", &Dtool_EggVertexAux_get_class_type_159, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexAux_get_class_type_159_comment},
  {"getClassType", &Dtool_EggVertexAux_get_class_type_159, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexAux_get_class_type_159_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggVertexAux slot tp_compare -> compare_to
//////////////////
static int Dtool_EggVertexAux_compare_to_158_tp_compare(PyObject *self, PyObject *arg) {
  EggVertexAux *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexAux, (void **)&local_this)) {
    return -1;
  }

  // 1-int EggVertexAux::compare_to(EggVertexAux const &other) const
  CPT(EggVertexAux) arg_this;
  if (!Dtool_ConstCoerce_EggVertexAux(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggVertexAux.compare_to", "EggVertexAux");
    return -1;
  }
  int return_value = (*(const EggVertexAux*)local_this).compare_to(*MOVE(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertexAux self, const EggVertexAux other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     EggVertexAux
//////////////////
static PyObject *Dtool_Str_EggVertexAux(PyObject *self) {
  EggVertexAux *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexAux, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EggVertexAux = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggVertexAux = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggVertexAux = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggVertexAux = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggVertexAux = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggVertexAux",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggVertexAux,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_EggVertexAux_compare_to_158_tp_compare,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggVertexAux,
    &Dtool_SequenceMethods_EggVertexAux,
    &Dtool_MappingMethods_EggVertexAux,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_EggVertexAux,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggVertexAux,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The set of named auxiliary data that may or may not be assigned to a\n"
    " * vertex.  Panda will import this data and create a custom column for it in\n"
    " * the vertex data, but will not otherwise interpret it.  Presumably, a shader\n"
    " * will process the data later.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DTOOL_PyObject_RichCompare,
#else
    0, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggVertexAux,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggVertexAux,
    PyType_GenericAlloc,
    Dtool_new_EggVertexAux,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggVertexAux,
  Dtool_UpcastInterface_EggVertexAux,
  Dtool_DowncastInterface_EggVertexAux,
  (CoerceFunction)Dtool_ConstCoerce_EggVertexAux,
  (CoerceFunction)Dtool_Coerce_EggVertexAux,
};

static void Dtool_PyModuleClassInit_EggVertexAux(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNamedObject(NULL);
    Dtool_EggVertexAux._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNamedObject);
    PyObject *dict = PyDict_New();
    Dtool_EggVertexAux._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggVertexAux) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggVertexAux)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggVertexAux);
  }
}

/**
 * Python method tables for EggVertex (EggVertex)
 */
static PyMethodDef Dtool_Methods_EggVertex[] = {
  {"assign", &Dtool_EggVertex_operator_166, METH_O, (const char *)Dtool_EggVertex_operator_166_comment},
  {"get_pool", &Dtool_EggVertex_get_pool_168, METH_NOARGS, (const char *)Dtool_EggVertex_get_pool_168_comment},
  {"getPool", &Dtool_EggVertex_get_pool_168, METH_NOARGS, (const char *)Dtool_EggVertex_get_pool_168_comment},
  {"is_forward_reference", &Dtool_EggVertex_is_forward_reference_169, METH_NOARGS, (const char *)Dtool_EggVertex_is_forward_reference_169_comment},
  {"isForwardReference", &Dtool_EggVertex_is_forward_reference_169, METH_NOARGS, (const char *)Dtool_EggVertex_is_forward_reference_169_comment},
  {"set_pos", &Dtool_EggVertex_set_pos_170, METH_O, (const char *)Dtool_EggVertex_set_pos_170_comment},
  {"setPos", &Dtool_EggVertex_set_pos_170, METH_O, (const char *)Dtool_EggVertex_set_pos_170_comment},
  {"set_pos4", &Dtool_EggVertex_set_pos4_171, METH_O, (const char *)Dtool_EggVertex_set_pos4_171_comment},
  {"setPos4", &Dtool_EggVertex_set_pos4_171, METH_O, (const char *)Dtool_EggVertex_set_pos4_171_comment},
  {"get_num_dimensions", &Dtool_EggVertex_get_num_dimensions_172, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_dimensions_172_comment},
  {"getNumDimensions", &Dtool_EggVertex_get_num_dimensions_172, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_dimensions_172_comment},
  {"get_pos1", &Dtool_EggVertex_get_pos1_173, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos1_173_comment},
  {"getPos1", &Dtool_EggVertex_get_pos1_173, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos1_173_comment},
  {"get_pos2", &Dtool_EggVertex_get_pos2_174, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos2_174_comment},
  {"getPos2", &Dtool_EggVertex_get_pos2_174, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos2_174_comment},
  {"get_pos3", &Dtool_EggVertex_get_pos3_175, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos3_175_comment},
  {"getPos3", &Dtool_EggVertex_get_pos3_175, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos3_175_comment},
  {"get_pos4", &Dtool_EggVertex_get_pos4_176, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos4_176_comment},
  {"getPos4", &Dtool_EggVertex_get_pos4_176, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos4_176_comment},
  {"has_uv", &Dtool_EggVertex_has_uv_177, METH_VARARGS, (const char *)Dtool_EggVertex_has_uv_177_comment},
  {"hasUv", &Dtool_EggVertex_has_uv_177, METH_VARARGS, (const char *)Dtool_EggVertex_has_uv_177_comment},
  {"get_uv", &Dtool_EggVertex_get_uv_178, METH_VARARGS, (const char *)Dtool_EggVertex_get_uv_178_comment},
  {"getUv", &Dtool_EggVertex_get_uv_178, METH_VARARGS, (const char *)Dtool_EggVertex_get_uv_178_comment},
  {"set_uv", (PyCFunction) &Dtool_EggVertex_set_uv_179, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_uv_179_comment},
  {"setUv", (PyCFunction) &Dtool_EggVertex_set_uv_179, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_uv_179_comment},
  {"clear_uv", &Dtool_EggVertex_clear_uv_180, METH_VARARGS, (const char *)Dtool_EggVertex_clear_uv_180_comment},
  {"clearUv", &Dtool_EggVertex_clear_uv_180, METH_VARARGS, (const char *)Dtool_EggVertex_clear_uv_180_comment},
  {"has_uvw", &Dtool_EggVertex_has_uvw_181, METH_O, (const char *)Dtool_EggVertex_has_uvw_181_comment},
  {"hasUvw", &Dtool_EggVertex_has_uvw_181, METH_O, (const char *)Dtool_EggVertex_has_uvw_181_comment},
  {"get_uvw", &Dtool_EggVertex_get_uvw_182, METH_O, (const char *)Dtool_EggVertex_get_uvw_182_comment},
  {"getUvw", &Dtool_EggVertex_get_uvw_182, METH_O, (const char *)Dtool_EggVertex_get_uvw_182_comment},
  {"set_uvw", (PyCFunction) &Dtool_EggVertex_set_uvw_183, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_uvw_183_comment},
  {"setUvw", (PyCFunction) &Dtool_EggVertex_set_uvw_183, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_uvw_183_comment},
  {"get_uv_obj", &Dtool_EggVertex_get_uv_obj_184, METH_O, (const char *)Dtool_EggVertex_get_uv_obj_184_comment},
  {"getUvObj", &Dtool_EggVertex_get_uv_obj_184, METH_O, (const char *)Dtool_EggVertex_get_uv_obj_184_comment},
  {"modify_uv_obj", &Dtool_EggVertex_modify_uv_obj_185, METH_O, (const char *)Dtool_EggVertex_modify_uv_obj_185_comment},
  {"modifyUvObj", &Dtool_EggVertex_modify_uv_obj_185, METH_O, (const char *)Dtool_EggVertex_modify_uv_obj_185_comment},
  {"set_uv_obj", &Dtool_EggVertex_set_uv_obj_186, METH_O, (const char *)Dtool_EggVertex_set_uv_obj_186_comment},
  {"setUvObj", &Dtool_EggVertex_set_uv_obj_186, METH_O, (const char *)Dtool_EggVertex_set_uv_obj_186_comment},
  {"has_aux", &Dtool_EggVertex_has_aux_187, METH_VARARGS, (const char *)Dtool_EggVertex_has_aux_187_comment},
  {"hasAux", &Dtool_EggVertex_has_aux_187, METH_VARARGS, (const char *)Dtool_EggVertex_has_aux_187_comment},
  {"clear_aux", &Dtool_EggVertex_clear_aux_188, METH_VARARGS, (const char *)Dtool_EggVertex_clear_aux_188_comment},
  {"clearAux", &Dtool_EggVertex_clear_aux_188, METH_VARARGS, (const char *)Dtool_EggVertex_clear_aux_188_comment},
  {"get_aux", &Dtool_EggVertex_get_aux_189, METH_O, (const char *)Dtool_EggVertex_get_aux_189_comment},
  {"getAux", &Dtool_EggVertex_get_aux_189, METH_O, (const char *)Dtool_EggVertex_get_aux_189_comment},
  {"set_aux", (PyCFunction) &Dtool_EggVertex_set_aux_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_aux_190_comment},
  {"setAux", (PyCFunction) &Dtool_EggVertex_set_aux_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_aux_190_comment},
  {"get_aux_obj", &Dtool_EggVertex_get_aux_obj_191, METH_O, (const char *)Dtool_EggVertex_get_aux_obj_191_comment},
  {"getAuxObj", &Dtool_EggVertex_get_aux_obj_191, METH_O, (const char *)Dtool_EggVertex_get_aux_obj_191_comment},
  {"modify_aux_obj", &Dtool_EggVertex_modify_aux_obj_192, METH_O, (const char *)Dtool_EggVertex_modify_aux_obj_192_comment},
  {"modifyAuxObj", &Dtool_EggVertex_modify_aux_obj_192, METH_O, (const char *)Dtool_EggVertex_modify_aux_obj_192_comment},
  {"set_aux_obj", &Dtool_EggVertex_set_aux_obj_193, METH_O, (const char *)Dtool_EggVertex_set_aux_obj_193_comment},
  {"setAuxObj", &Dtool_EggVertex_set_aux_obj_193, METH_O, (const char *)Dtool_EggVertex_set_aux_obj_193_comment},
  {"make_average", (PyCFunction) &Dtool_EggVertex_make_average_194, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertex_make_average_194_comment},
  {"makeAverage", (PyCFunction) &Dtool_EggVertex_make_average_194, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertex_make_average_194_comment},
  {"get_index", &Dtool_EggVertex_get_index_195, METH_NOARGS, (const char *)Dtool_EggVertex_get_index_195_comment},
  {"getIndex", &Dtool_EggVertex_get_index_195, METH_NOARGS, (const char *)Dtool_EggVertex_get_index_195_comment},
  {"set_external_index", &Dtool_EggVertex_set_external_index_196, METH_O, (const char *)Dtool_EggVertex_set_external_index_196_comment},
  {"setExternalIndex", &Dtool_EggVertex_set_external_index_196, METH_O, (const char *)Dtool_EggVertex_set_external_index_196_comment},
  {"get_external_index", &Dtool_EggVertex_get_external_index_197, METH_NOARGS, (const char *)Dtool_EggVertex_get_external_index_197_comment},
  {"getExternalIndex", &Dtool_EggVertex_get_external_index_197, METH_NOARGS, (const char *)Dtool_EggVertex_get_external_index_197_comment},
  {"set_external_index2", &Dtool_EggVertex_set_external_index2_198, METH_O, (const char *)Dtool_EggVertex_set_external_index2_198_comment},
  {"setExternalIndex2", &Dtool_EggVertex_set_external_index2_198, METH_O, (const char *)Dtool_EggVertex_set_external_index2_198_comment},
  {"get_external_index2", &Dtool_EggVertex_get_external_index2_199, METH_NOARGS, (const char *)Dtool_EggVertex_get_external_index2_199_comment},
  {"getExternalIndex2", &Dtool_EggVertex_get_external_index2_199, METH_NOARGS, (const char *)Dtool_EggVertex_get_external_index2_199_comment},
  {"write", (PyCFunction) &Dtool_EggVertex_write_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_write_200_comment},
  {"sorts_less_than", &Dtool_EggVertex_sorts_less_than_201, METH_O, (const char *)Dtool_EggVertex_sorts_less_than_201_comment},
  {"sortsLessThan", &Dtool_EggVertex_sorts_less_than_201, METH_O, (const char *)Dtool_EggVertex_sorts_less_than_201_comment},
  {"compare_to", &Dtool_EggVertex_compare_to_202, METH_O, (const char *)Dtool_EggVertex_compare_to_202_comment},
  {"compareTo", &Dtool_EggVertex_compare_to_202, METH_O, (const char *)Dtool_EggVertex_compare_to_202_comment},
  {"get_num_local_coord", &Dtool_EggVertex_get_num_local_coord_203, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_local_coord_203_comment},
  {"getNumLocalCoord", &Dtool_EggVertex_get_num_local_coord_203, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_local_coord_203_comment},
  {"get_num_global_coord", &Dtool_EggVertex_get_num_global_coord_204, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_global_coord_204_comment},
  {"getNumGlobalCoord", &Dtool_EggVertex_get_num_global_coord_204, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_global_coord_204_comment},
  {"transform", &Dtool_EggVertex_transform_205, METH_O, (const char *)Dtool_EggVertex_transform_205_comment},
  {"has_gref", &Dtool_EggVertex_has_gref_206, METH_O, (const char *)Dtool_EggVertex_has_gref_206_comment},
  {"hasGref", &Dtool_EggVertex_has_gref_206, METH_O, (const char *)Dtool_EggVertex_has_gref_206_comment},
  {"copy_grefs_from", &Dtool_EggVertex_copy_grefs_from_207, METH_O, (const char *)Dtool_EggVertex_copy_grefs_from_207_comment},
  {"copyGrefsFrom", &Dtool_EggVertex_copy_grefs_from_207, METH_O, (const char *)Dtool_EggVertex_copy_grefs_from_207_comment},
  {"clear_grefs", &Dtool_EggVertex_clear_grefs_208, METH_NOARGS, (const char *)Dtool_EggVertex_clear_grefs_208_comment},
  {"clearGrefs", &Dtool_EggVertex_clear_grefs_208, METH_NOARGS, (const char *)Dtool_EggVertex_clear_grefs_208_comment},
  {"has_pref", &Dtool_EggVertex_has_pref_209, METH_O, (const char *)Dtool_EggVertex_has_pref_209_comment},
  {"hasPref", &Dtool_EggVertex_has_pref_209, METH_O, (const char *)Dtool_EggVertex_has_pref_209_comment},
  {"test_gref_integrity", &Dtool_EggVertex_test_gref_integrity_210, METH_NOARGS, (const char *)Dtool_EggVertex_test_gref_integrity_210_comment},
  {"testGrefIntegrity", &Dtool_EggVertex_test_gref_integrity_210, METH_NOARGS, (const char *)Dtool_EggVertex_test_gref_integrity_210_comment},
  {"test_pref_integrity", &Dtool_EggVertex_test_pref_integrity_211, METH_NOARGS, (const char *)Dtool_EggVertex_test_pref_integrity_211_comment},
  {"testPrefIntegrity", &Dtool_EggVertex_test_pref_integrity_211, METH_NOARGS, (const char *)Dtool_EggVertex_test_pref_integrity_211_comment},
  {"output", &Dtool_EggVertex_output_212, METH_O, (const char *)Dtool_EggVertex_output_212_comment},
  {"get_class_type", &Dtool_EggVertex_get_class_type_217, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertex_get_class_type_217_comment},
  {"getClassType", &Dtool_EggVertex_get_class_type_217, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertex_get_class_type_217_comment},
  {"upcast_to_EggObject", &Dtool_EggVertex_upcast_to_EggObject_161, METH_NOARGS, (const char *)Dtool_EggVertex_upcast_to_EggObject_161_comment},
  {"upcastToEggObject", &Dtool_EggVertex_upcast_to_EggObject_161, METH_NOARGS, (const char *)Dtool_EggVertex_upcast_to_EggObject_161_comment},
  {"upcast_to_EggAttributes", &Dtool_EggVertex_upcast_to_EggAttributes_163, METH_NOARGS, (const char *)Dtool_EggVertex_upcast_to_EggAttributes_163_comment},
  {"upcastToEggAttributes", &Dtool_EggVertex_upcast_to_EggAttributes_163, METH_NOARGS, (const char *)Dtool_EggVertex_upcast_to_EggAttributes_163_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggVertex slot tp_compare -> compare_to
//////////////////
static int Dtool_EggVertex_compare_to_202_tp_compare(PyObject *self, PyObject *arg) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return -1;
  }

  // 1-int EggVertex::compare_to(EggVertex const &other) const
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertex.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const EggVertex*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertex self, const EggVertex other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     EggVertex
//////////////////
static PyObject *Dtool_Repr_EggVertex(PyObject *self) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     EggVertex
//////////////////
static PyObject *Dtool_Str_EggVertex(PyObject *self) {
  EggVertex *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EggVertex = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggVertex = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggVertex = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggVertex = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggVertex = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggVertex",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggVertex,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_EggVertex_compare_to_202_tp_compare,
#endif
    &Dtool_Repr_EggVertex,
    &Dtool_NumberMethods_EggVertex,
    &Dtool_SequenceMethods_EggVertex,
    &Dtool_MappingMethods_EggVertex,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_EggVertex,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggVertex,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Any one-, two-, three-, or four-component vertex, possibly with attributes\n"
    " * such as a normal.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DTOOL_PyObject_RichCompare,
#else
    0, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggVertex,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggVertex,
    PyType_GenericAlloc,
    Dtool_new_EggVertex,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggVertex,
  Dtool_UpcastInterface_EggVertex,
  Dtool_DowncastInterface_EggVertex,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggVertex(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggObject(NULL);
    Dtool_PyModuleClassInit_EggAttributes(NULL);
    Dtool_EggVertex._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_EggObject, (PyTypeObject *)&Dtool_EggAttributes);
    PyObject *dict = PyDict_New();
    Dtool_EggVertex._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggVertex) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggVertex)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggVertex);
  }
}

/**
 * Python method tables for EggVertexPool (EggVertexPool)
 */
static PyMethodDef Dtool_Methods_EggVertexPool[] = {
  {"has_vertex", &Dtool_EggVertexPool_has_vertex_220, METH_O, (const char *)Dtool_EggVertexPool_has_vertex_220_comment},
  {"hasVertex", &Dtool_EggVertexPool_has_vertex_220, METH_O, (const char *)Dtool_EggVertexPool_has_vertex_220_comment},
  {"has_forward_vertices", &Dtool_EggVertexPool_has_forward_vertices_221, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_forward_vertices_221_comment},
  {"hasForwardVertices", &Dtool_EggVertexPool_has_forward_vertices_221, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_forward_vertices_221_comment},
  {"has_defined_vertices", &Dtool_EggVertexPool_has_defined_vertices_222, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_defined_vertices_222_comment},
  {"hasDefinedVertices", &Dtool_EggVertexPool_has_defined_vertices_222, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_defined_vertices_222_comment},
  {"get_vertex", &Dtool_EggVertexPool_get_vertex_223, METH_O, (const char *)Dtool_EggVertexPool_get_vertex_223_comment},
  {"getVertex", &Dtool_EggVertexPool_get_vertex_223, METH_O, (const char *)Dtool_EggVertexPool_get_vertex_223_comment},
  {"get_forward_vertex", &Dtool_EggVertexPool_get_forward_vertex_225, METH_O, (const char *)Dtool_EggVertexPool_get_forward_vertex_225_comment},
  {"getForwardVertex", &Dtool_EggVertexPool_get_forward_vertex_225, METH_O, (const char *)Dtool_EggVertexPool_get_forward_vertex_225_comment},
  {"get_highest_index", &Dtool_EggVertexPool_get_highest_index_226, METH_NOARGS, (const char *)Dtool_EggVertexPool_get_highest_index_226_comment},
  {"getHighestIndex", &Dtool_EggVertexPool_get_highest_index_226, METH_NOARGS, (const char *)Dtool_EggVertexPool_get_highest_index_226_comment},
  {"set_highest_index", &Dtool_EggVertexPool_set_highest_index_227, METH_O, (const char *)Dtool_EggVertexPool_set_highest_index_227_comment},
  {"setHighestIndex", &Dtool_EggVertexPool_set_highest_index_227, METH_O, (const char *)Dtool_EggVertexPool_set_highest_index_227_comment},
  {"get_num_dimensions", &Dtool_EggVertexPool_get_num_dimensions_228, METH_NOARGS, (const char *)Dtool_EggVertexPool_get_num_dimensions_228_comment},
  {"getNumDimensions", &Dtool_EggVertexPool_get_num_dimensions_228, METH_NOARGS, (const char *)Dtool_EggVertexPool_get_num_dimensions_228_comment},
  {"has_normals", &Dtool_EggVertexPool_has_normals_229, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_normals_229_comment},
  {"hasNormals", &Dtool_EggVertexPool_has_normals_229, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_normals_229_comment},
  {"has_colors", &Dtool_EggVertexPool_has_colors_230, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_colors_230_comment},
  {"hasColors", &Dtool_EggVertexPool_has_colors_230, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_colors_230_comment},
  {"has_nonwhite_colors", &Dtool_EggVertexPool_has_nonwhite_colors_231, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_nonwhite_colors_231_comment},
  {"hasNonwhiteColors", &Dtool_EggVertexPool_has_nonwhite_colors_231, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_nonwhite_colors_231_comment},
  {"has_uvs", &Dtool_EggVertexPool_has_uvs_233, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_uvs_233_comment},
  {"hasUvs", &Dtool_EggVertexPool_has_uvs_233, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_uvs_233_comment},
  {"has_aux", &Dtool_EggVertexPool_has_aux_234, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_aux_234_comment},
  {"hasAux", &Dtool_EggVertexPool_has_aux_234, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_aux_234_comment},
  {"add_vertex", (PyCFunction) &Dtool_EggVertexPool_add_vertex_238, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertexPool_add_vertex_238_comment},
  {"addVertex", (PyCFunction) &Dtool_EggVertexPool_add_vertex_238, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertexPool_add_vertex_238_comment},
  {"make_new_vertex", &Dtool_EggVertexPool_make_new_vertex_239, METH_VARARGS, (const char *)Dtool_EggVertexPool_make_new_vertex_239_comment},
  {"makeNewVertex", &Dtool_EggVertexPool_make_new_vertex_239, METH_VARARGS, (const char *)Dtool_EggVertexPool_make_new_vertex_239_comment},
  {"create_unique_vertex", &Dtool_EggVertexPool_create_unique_vertex_240, METH_O, (const char *)Dtool_EggVertexPool_create_unique_vertex_240_comment},
  {"createUniqueVertex", &Dtool_EggVertexPool_create_unique_vertex_240, METH_O, (const char *)Dtool_EggVertexPool_create_unique_vertex_240_comment},
  {"find_matching_vertex", &Dtool_EggVertexPool_find_matching_vertex_241, METH_O, (const char *)Dtool_EggVertexPool_find_matching_vertex_241_comment},
  {"findMatchingVertex", &Dtool_EggVertexPool_find_matching_vertex_241, METH_O, (const char *)Dtool_EggVertexPool_find_matching_vertex_241_comment},
  {"remove_vertex", &Dtool_EggVertexPool_remove_vertex_242, METH_O, (const char *)Dtool_EggVertexPool_remove_vertex_242_comment},
  {"removeVertex", &Dtool_EggVertexPool_remove_vertex_242, METH_O, (const char *)Dtool_EggVertexPool_remove_vertex_242_comment},
  {"remove_unused_vertices", &Dtool_EggVertexPool_remove_unused_vertices_243, METH_NOARGS, (const char *)Dtool_EggVertexPool_remove_unused_vertices_243_comment},
  {"removeUnusedVertices", &Dtool_EggVertexPool_remove_unused_vertices_243, METH_NOARGS, (const char *)Dtool_EggVertexPool_remove_unused_vertices_243_comment},
  {"add_unused_vertices_to_prim", &Dtool_EggVertexPool_add_unused_vertices_to_prim_244, METH_O, (const char *)Dtool_EggVertexPool_add_unused_vertices_to_prim_244_comment},
  {"addUnusedVerticesToPrim", &Dtool_EggVertexPool_add_unused_vertices_to_prim_244, METH_O, (const char *)Dtool_EggVertexPool_add_unused_vertices_to_prim_244_comment},
  {"transform", &Dtool_EggVertexPool_transform_245, METH_O, (const char *)Dtool_EggVertexPool_transform_245_comment},
  {"sort_by_external_index", &Dtool_EggVertexPool_sort_by_external_index_246, METH_NOARGS, (const char *)Dtool_EggVertexPool_sort_by_external_index_246_comment},
  {"sortByExternalIndex", &Dtool_EggVertexPool_sort_by_external_index_246, METH_NOARGS, (const char *)Dtool_EggVertexPool_sort_by_external_index_246_comment},
  {"get_class_type", &Dtool_EggVertexPool_get_class_type_247, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexPool_get_class_type_247_comment},
  {"getClassType", &Dtool_EggVertexPool_get_class_type_247, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexPool_get_class_type_247_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggVertexPool slot sq_item -> operator []
//////////////////
static PyObject *Dtool_EggVertexPool_operator_224_sq_item(PyObject *self, Py_ssize_t index) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "EggVertexPool index out of range");
    return NULL;
  }
  // 1-inline EggVertex *EggVertexPool::operator [](int index) const
  EggVertex *return_value = (*(const EggVertexPool*)local_this).operator [](index);
  if (return_value != (EggVertex *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (EggVertex *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(EggVertexPool self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggVertexPool slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_EggVertexPool_size_237_sq_length(PyObject *self) {
  EggVertexPool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_EggVertexPool = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggVertexPool = {
  &Dtool_EggVertexPool_size_237_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_EggVertexPool_operator_224_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggVertexPool = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggVertexPool = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggVertexPool = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggVertexPool",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggVertexPool,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggVertexPool,
    &Dtool_SequenceMethods_EggVertexPool,
    &Dtool_MappingMethods_EggVertexPool,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggVertexPool,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A collection of vertices.  There may be any number of vertex pools in a\n"
    " * single egg structure.  The vertices in a single pool need not necessarily\n"
    " * have any connection to each other, but it is necessary that any one\n"
    " * primitive (e.g.  a polygon) must pull all its vertices from the same pool.\n"
    " *\n"
    " * An EggVertexPool is an STL-style container of pointers to EggVertex's.\n"
    " * Functions add_vertex() and remove_vertex() are provided to manipulate the\n"
    " * list.  The list may also be operated on (read-only) via iterators and\n"
    " * begin()/end().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggVertexPool,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggVertexPool,
    PyType_GenericAlloc,
    Dtool_new_EggVertexPool,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggVertexPool,
  Dtool_UpcastInterface_EggVertexPool,
  Dtool_DowncastInterface_EggVertexPool,
  (CoerceFunction)Dtool_ConstCoerce_EggVertexPool,
  (CoerceFunction)Dtool_Coerce_EggVertexPool,
};

static void Dtool_PyModuleClassInit_EggVertexPool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(NULL);
    Dtool_EggVertexPool._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    PyObject *dict = PyDict_New();
    Dtool_EggVertexPool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggVertexPool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggVertexPool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggVertexPool);
  }
}

/**
 * Python method tables for EggGroupNode (EggGroupNode)
 */
static PyMethodDef Dtool_Methods_EggGroupNode[] = {
  {"assign", &Dtool_EggGroupNode_operator_250, METH_O, (const char *)Dtool_EggGroupNode_operator_250_comment},
  {"empty", &Dtool_EggGroupNode_empty_251, METH_NOARGS, (const char *)Dtool_EggGroupNode_empty_251_comment},
  {"size", &Dtool_EggGroupNode_size_252, METH_NOARGS, (const char *)Dtool_EggGroupNode_size_252_comment},
  {"clear", &Dtool_EggGroupNode_clear_253, METH_NOARGS, (const char *)Dtool_EggGroupNode_clear_253_comment},
  {"get_first_child", &Dtool_EggGroupNode_get_first_child_254, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_first_child_254_comment},
  {"getFirstChild", &Dtool_EggGroupNode_get_first_child_254, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_first_child_254_comment},
  {"get_next_child", &Dtool_EggGroupNode_get_next_child_255, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_next_child_255_comment},
  {"getNextChild", &Dtool_EggGroupNode_get_next_child_255, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_next_child_255_comment},
  {"get_children", &Dtool_EggGroupNode_get_children_256, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_children_256_comment},
  {"getChildren", &Dtool_EggGroupNode_get_children_256, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_children_256_comment},
  {"add_child", &Dtool_EggGroupNode_add_child_257, METH_O, (const char *)Dtool_EggGroupNode_add_child_257_comment},
  {"addChild", &Dtool_EggGroupNode_add_child_257, METH_O, (const char *)Dtool_EggGroupNode_add_child_257_comment},
  {"remove_child", &Dtool_EggGroupNode_remove_child_258, METH_O, (const char *)Dtool_EggGroupNode_remove_child_258_comment},
  {"removeChild", &Dtool_EggGroupNode_remove_child_258, METH_O, (const char *)Dtool_EggGroupNode_remove_child_258_comment},
  {"steal_children", &Dtool_EggGroupNode_steal_children_259, METH_O, (const char *)Dtool_EggGroupNode_steal_children_259_comment},
  {"stealChildren", &Dtool_EggGroupNode_steal_children_259, METH_O, (const char *)Dtool_EggGroupNode_steal_children_259_comment},
  {"find_child", &Dtool_EggGroupNode_find_child_260, METH_O, (const char *)Dtool_EggGroupNode_find_child_260_comment},
  {"findChild", &Dtool_EggGroupNode_find_child_260, METH_O, (const char *)Dtool_EggGroupNode_find_child_260_comment},
  {"has_absolute_pathnames", &Dtool_EggGroupNode_has_absolute_pathnames_261, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_absolute_pathnames_261_comment},
  {"hasAbsolutePathnames", &Dtool_EggGroupNode_has_absolute_pathnames_261, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_absolute_pathnames_261_comment},
  {"resolve_filenames", &Dtool_EggGroupNode_resolve_filenames_262, METH_O, (const char *)Dtool_EggGroupNode_resolve_filenames_262_comment},
  {"resolveFilenames", &Dtool_EggGroupNode_resolve_filenames_262, METH_O, (const char *)Dtool_EggGroupNode_resolve_filenames_262_comment},
  {"force_filenames", &Dtool_EggGroupNode_force_filenames_263, METH_O, (const char *)Dtool_EggGroupNode_force_filenames_263_comment},
  {"forceFilenames", &Dtool_EggGroupNode_force_filenames_263, METH_O, (const char *)Dtool_EggGroupNode_force_filenames_263_comment},
  {"reverse_vertex_ordering", &Dtool_EggGroupNode_reverse_vertex_ordering_264, METH_NOARGS, (const char *)Dtool_EggGroupNode_reverse_vertex_ordering_264_comment},
  {"reverseVertexOrdering", &Dtool_EggGroupNode_reverse_vertex_ordering_264, METH_NOARGS, (const char *)Dtool_EggGroupNode_reverse_vertex_ordering_264_comment},
  {"recompute_vertex_normals", (PyCFunction) &Dtool_EggGroupNode_recompute_vertex_normals_265, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_recompute_vertex_normals_265_comment},
  {"recomputeVertexNormals", (PyCFunction) &Dtool_EggGroupNode_recompute_vertex_normals_265, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_recompute_vertex_normals_265_comment},
  {"recompute_polygon_normals", (PyCFunction) &Dtool_EggGroupNode_recompute_polygon_normals_266, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_recompute_polygon_normals_266_comment},
  {"recomputePolygonNormals", (PyCFunction) &Dtool_EggGroupNode_recompute_polygon_normals_266, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_recompute_polygon_normals_266_comment},
  {"strip_normals", &Dtool_EggGroupNode_strip_normals_267, METH_NOARGS, (const char *)Dtool_EggGroupNode_strip_normals_267_comment},
  {"stripNormals", &Dtool_EggGroupNode_strip_normals_267, METH_NOARGS, (const char *)Dtool_EggGroupNode_strip_normals_267_comment},
  {"recompute_tangent_binormal", &Dtool_EggGroupNode_recompute_tangent_binormal_268, METH_O, (const char *)Dtool_EggGroupNode_recompute_tangent_binormal_268_comment},
  {"recomputeTangentBinormal", &Dtool_EggGroupNode_recompute_tangent_binormal_268, METH_O, (const char *)Dtool_EggGroupNode_recompute_tangent_binormal_268_comment},
  {"recompute_tangent_binormal_auto", &Dtool_EggGroupNode_recompute_tangent_binormal_auto_269, METH_NOARGS, (const char *)Dtool_EggGroupNode_recompute_tangent_binormal_auto_269_comment},
  {"recomputeTangentBinormalAuto", &Dtool_EggGroupNode_recompute_tangent_binormal_auto_269, METH_NOARGS, (const char *)Dtool_EggGroupNode_recompute_tangent_binormal_auto_269_comment},
  {"triangulate_polygons", &Dtool_EggGroupNode_triangulate_polygons_271, METH_O, (const char *)Dtool_EggGroupNode_triangulate_polygons_271_comment},
  {"triangulatePolygons", &Dtool_EggGroupNode_triangulate_polygons_271, METH_O, (const char *)Dtool_EggGroupNode_triangulate_polygons_271_comment},
  {"mesh_triangles", &Dtool_EggGroupNode_mesh_triangles_272, METH_O, (const char *)Dtool_EggGroupNode_mesh_triangles_272_comment},
  {"meshTriangles", &Dtool_EggGroupNode_mesh_triangles_272, METH_O, (const char *)Dtool_EggGroupNode_mesh_triangles_272_comment},
  {"make_point_primitives", &Dtool_EggGroupNode_make_point_primitives_273, METH_NOARGS, (const char *)Dtool_EggGroupNode_make_point_primitives_273_comment},
  {"makePointPrimitives", &Dtool_EggGroupNode_make_point_primitives_273, METH_NOARGS, (const char *)Dtool_EggGroupNode_make_point_primitives_273_comment},
  {"remove_unused_vertices", &Dtool_EggGroupNode_remove_unused_vertices_275, METH_O, (const char *)Dtool_EggGroupNode_remove_unused_vertices_275_comment},
  {"removeUnusedVertices", &Dtool_EggGroupNode_remove_unused_vertices_275, METH_O, (const char *)Dtool_EggGroupNode_remove_unused_vertices_275_comment},
  {"remove_invalid_primitives", &Dtool_EggGroupNode_remove_invalid_primitives_276, METH_O, (const char *)Dtool_EggGroupNode_remove_invalid_primitives_276_comment},
  {"removeInvalidPrimitives", &Dtool_EggGroupNode_remove_invalid_primitives_276, METH_O, (const char *)Dtool_EggGroupNode_remove_invalid_primitives_276_comment},
  {"clear_connected_shading", &Dtool_EggGroupNode_clear_connected_shading_277, METH_NOARGS, (const char *)Dtool_EggGroupNode_clear_connected_shading_277_comment},
  {"clearConnectedShading", &Dtool_EggGroupNode_clear_connected_shading_277, METH_NOARGS, (const char *)Dtool_EggGroupNode_clear_connected_shading_277_comment},
  {"get_connected_shading", &Dtool_EggGroupNode_get_connected_shading_278, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_connected_shading_278_comment},
  {"getConnectedShading", &Dtool_EggGroupNode_get_connected_shading_278, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_connected_shading_278_comment},
  {"unify_attributes", (PyCFunction) &Dtool_EggGroupNode_unify_attributes_279, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_unify_attributes_279_comment},
  {"unifyAttributes", (PyCFunction) &Dtool_EggGroupNode_unify_attributes_279, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_unify_attributes_279_comment},
  {"apply_last_attribute", &Dtool_EggGroupNode_apply_last_attribute_280, METH_O, (const char *)Dtool_EggGroupNode_apply_last_attribute_280_comment},
  {"applyLastAttribute", &Dtool_EggGroupNode_apply_last_attribute_280, METH_O, (const char *)Dtool_EggGroupNode_apply_last_attribute_280_comment},
  {"apply_first_attribute", &Dtool_EggGroupNode_apply_first_attribute_281, METH_O, (const char *)Dtool_EggGroupNode_apply_first_attribute_281_comment},
  {"applyFirstAttribute", &Dtool_EggGroupNode_apply_first_attribute_281, METH_O, (const char *)Dtool_EggGroupNode_apply_first_attribute_281_comment},
  {"post_apply_flat_attribute", &Dtool_EggGroupNode_post_apply_flat_attribute_282, METH_O, (const char *)Dtool_EggGroupNode_post_apply_flat_attribute_282_comment},
  {"postApplyFlatAttribute", &Dtool_EggGroupNode_post_apply_flat_attribute_282, METH_O, (const char *)Dtool_EggGroupNode_post_apply_flat_attribute_282_comment},
  {"has_primitives", &Dtool_EggGroupNode_has_primitives_283, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_primitives_283_comment},
  {"hasPrimitives", &Dtool_EggGroupNode_has_primitives_283, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_primitives_283_comment},
  {"joint_has_primitives", &Dtool_EggGroupNode_joint_has_primitives_284, METH_NOARGS, (const char *)Dtool_EggGroupNode_joint_has_primitives_284_comment},
  {"jointHasPrimitives", &Dtool_EggGroupNode_joint_has_primitives_284, METH_NOARGS, (const char *)Dtool_EggGroupNode_joint_has_primitives_284_comment},
  {"has_normals", &Dtool_EggGroupNode_has_normals_285, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_normals_285_comment},
  {"hasNormals", &Dtool_EggGroupNode_has_normals_285, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_normals_285_comment},
  {"is_right", (PyCFunction) &Dtool_EggGroupNode_is_right_286, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggGroupNode_is_right_286_comment},
  {"isRight", (PyCFunction) &Dtool_EggGroupNode_is_right_286, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggGroupNode_is_right_286_comment},
  {"get_class_type", &Dtool_EggGroupNode_get_class_type_287, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroupNode_get_class_type_287_comment},
  {"getClassType", &Dtool_EggGroupNode_get_class_type_287, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroupNode_get_class_type_287_comment},
  {"downcast_to_EggGroup", &Dtool_EggGroupNode_downcast_to_EggGroup_371, METH_NOARGS, (const char *)Dtool_EggGroupNode_downcast_to_EggGroup_371_comment},
  {"downcastToEggGroup", &Dtool_EggGroupNode_downcast_to_EggGroup_371, METH_NOARGS, (const char *)Dtool_EggGroupNode_downcast_to_EggGroup_371_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggGroupNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggGroupNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggGroupNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggGroupNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggGroupNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggGroupNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggGroupNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggGroupNode,
    &Dtool_SequenceMethods_EggGroupNode,
    &Dtool_MappingMethods_EggGroupNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggGroupNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for nodes in the hierarchy that are not leaf nodes.  (See also\n"
    " * EggGroup, which is specifically the \"<Group>\" node in egg.)\n"
    " *\n"
    " * An EggGroupNode is an STL-style container of pointers to EggNodes, like a\n"
    " * vector.  Functions push_back()/pop_back() and insert()/erase() are provided\n"
    " * to manipulate the list.  The list may also be operated on (read-only) via\n"
    " * iterators and begin()/end().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggGroupNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggGroupNode,
    PyType_GenericAlloc,
    Dtool_new_EggGroupNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggGroupNode,
  Dtool_UpcastInterface_EggGroupNode,
  Dtool_DowncastInterface_EggGroupNode,
  (CoerceFunction)Dtool_ConstCoerce_EggGroupNode,
  (CoerceFunction)Dtool_Coerce_EggGroupNode,
};

static void Dtool_PyModuleClassInit_EggGroupNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(NULL);
    Dtool_EggGroupNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_EggGroupNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggGroupNode::TriangulateFlags;
    PyDict_SetItemString(dict, "T_polygon", Dtool_WrapValue(EggGroupNode::T_polygon));
    PyDict_SetItemString(dict, "TPolygon", Dtool_WrapValue(EggGroupNode::T_polygon));
    PyDict_SetItemString(dict, "T_convex", Dtool_WrapValue(EggGroupNode::T_convex));
    PyDict_SetItemString(dict, "TConvex", Dtool_WrapValue(EggGroupNode::T_convex));
    PyDict_SetItemString(dict, "T_composite", Dtool_WrapValue(EggGroupNode::T_composite));
    PyDict_SetItemString(dict, "TComposite", Dtool_WrapValue(EggGroupNode::T_composite));
    PyDict_SetItemString(dict, "T_recurse", Dtool_WrapValue(EggGroupNode::T_recurse));
    PyDict_SetItemString(dict, "TRecurse", Dtool_WrapValue(EggGroupNode::T_recurse));
    PyDict_SetItemString(dict, "T_flat_shaded", Dtool_WrapValue(EggGroupNode::T_flat_shaded));
    PyDict_SetItemString(dict, "TFlatShaded", Dtool_WrapValue(EggGroupNode::T_flat_shaded));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggGroupNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggGroupNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggGroupNode);
  }
}

/**
 * Python method tables for EggRenderMode (EggRenderMode)
 */
static PyMethodDef Dtool_Methods_EggRenderMode[] = {
  {"assign", &Dtool_EggRenderMode_operator_290, METH_O, (const char *)Dtool_EggRenderMode_operator_290_comment},
  {"write", (PyCFunction) &Dtool_EggRenderMode_write_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggRenderMode_write_291_comment},
  {"set_alpha_mode", &Dtool_EggRenderMode_set_alpha_mode_296, METH_O, (const char *)Dtool_EggRenderMode_set_alpha_mode_296_comment},
  {"setAlphaMode", &Dtool_EggRenderMode_set_alpha_mode_296, METH_O, (const char *)Dtool_EggRenderMode_set_alpha_mode_296_comment},
  {"get_alpha_mode", &Dtool_EggRenderMode_get_alpha_mode_297, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_alpha_mode_297_comment},
  {"getAlphaMode", &Dtool_EggRenderMode_get_alpha_mode_297, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_alpha_mode_297_comment},
  {"set_depth_write_mode", &Dtool_EggRenderMode_set_depth_write_mode_298, METH_O, (const char *)Dtool_EggRenderMode_set_depth_write_mode_298_comment},
  {"setDepthWriteMode", &Dtool_EggRenderMode_set_depth_write_mode_298, METH_O, (const char *)Dtool_EggRenderMode_set_depth_write_mode_298_comment},
  {"get_depth_write_mode", &Dtool_EggRenderMode_get_depth_write_mode_299, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_write_mode_299_comment},
  {"getDepthWriteMode", &Dtool_EggRenderMode_get_depth_write_mode_299, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_write_mode_299_comment},
  {"set_depth_test_mode", &Dtool_EggRenderMode_set_depth_test_mode_300, METH_O, (const char *)Dtool_EggRenderMode_set_depth_test_mode_300_comment},
  {"setDepthTestMode", &Dtool_EggRenderMode_set_depth_test_mode_300, METH_O, (const char *)Dtool_EggRenderMode_set_depth_test_mode_300_comment},
  {"get_depth_test_mode", &Dtool_EggRenderMode_get_depth_test_mode_301, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_test_mode_301_comment},
  {"getDepthTestMode", &Dtool_EggRenderMode_get_depth_test_mode_301, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_test_mode_301_comment},
  {"set_visibility_mode", &Dtool_EggRenderMode_set_visibility_mode_302, METH_O, (const char *)Dtool_EggRenderMode_set_visibility_mode_302_comment},
  {"setVisibilityMode", &Dtool_EggRenderMode_set_visibility_mode_302, METH_O, (const char *)Dtool_EggRenderMode_set_visibility_mode_302_comment},
  {"get_visibility_mode", &Dtool_EggRenderMode_get_visibility_mode_303, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_visibility_mode_303_comment},
  {"getVisibilityMode", &Dtool_EggRenderMode_get_visibility_mode_303, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_visibility_mode_303_comment},
  {"set_depth_offset", &Dtool_EggRenderMode_set_depth_offset_304, METH_O, (const char *)Dtool_EggRenderMode_set_depth_offset_304_comment},
  {"setDepthOffset", &Dtool_EggRenderMode_set_depth_offset_304, METH_O, (const char *)Dtool_EggRenderMode_set_depth_offset_304_comment},
  {"get_depth_offset", &Dtool_EggRenderMode_get_depth_offset_305, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_offset_305_comment},
  {"getDepthOffset", &Dtool_EggRenderMode_get_depth_offset_305, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_offset_305_comment},
  {"has_depth_offset", &Dtool_EggRenderMode_has_depth_offset_306, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_depth_offset_306_comment},
  {"hasDepthOffset", &Dtool_EggRenderMode_has_depth_offset_306, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_depth_offset_306_comment},
  {"clear_depth_offset", &Dtool_EggRenderMode_clear_depth_offset_307, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_depth_offset_307_comment},
  {"clearDepthOffset", &Dtool_EggRenderMode_clear_depth_offset_307, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_depth_offset_307_comment},
  {"set_draw_order", &Dtool_EggRenderMode_set_draw_order_308, METH_O, (const char *)Dtool_EggRenderMode_set_draw_order_308_comment},
  {"setDrawOrder", &Dtool_EggRenderMode_set_draw_order_308, METH_O, (const char *)Dtool_EggRenderMode_set_draw_order_308_comment},
  {"get_draw_order", &Dtool_EggRenderMode_get_draw_order_309, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_draw_order_309_comment},
  {"getDrawOrder", &Dtool_EggRenderMode_get_draw_order_309, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_draw_order_309_comment},
  {"has_draw_order", &Dtool_EggRenderMode_has_draw_order_310, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_draw_order_310_comment},
  {"hasDrawOrder", &Dtool_EggRenderMode_has_draw_order_310, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_draw_order_310_comment},
  {"clear_draw_order", &Dtool_EggRenderMode_clear_draw_order_311, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_draw_order_311_comment},
  {"clearDrawOrder", &Dtool_EggRenderMode_clear_draw_order_311, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_draw_order_311_comment},
  {"set_bin", &Dtool_EggRenderMode_set_bin_312, METH_O, (const char *)Dtool_EggRenderMode_set_bin_312_comment},
  {"setBin", &Dtool_EggRenderMode_set_bin_312, METH_O, (const char *)Dtool_EggRenderMode_set_bin_312_comment},
  {"get_bin", &Dtool_EggRenderMode_get_bin_313, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_bin_313_comment},
  {"getBin", &Dtool_EggRenderMode_get_bin_313, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_bin_313_comment},
  {"has_bin", &Dtool_EggRenderMode_has_bin_314, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_bin_314_comment},
  {"hasBin", &Dtool_EggRenderMode_has_bin_314, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_bin_314_comment},
  {"clear_bin", &Dtool_EggRenderMode_clear_bin_315, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_bin_315_comment},
  {"clearBin", &Dtool_EggRenderMode_clear_bin_315, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_bin_315_comment},
  {"string_alpha_mode", &Dtool_EggRenderMode_string_alpha_mode_319, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_alpha_mode_319_comment},
  {"stringAlphaMode", &Dtool_EggRenderMode_string_alpha_mode_319, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_alpha_mode_319_comment},
  {"string_depth_write_mode", &Dtool_EggRenderMode_string_depth_write_mode_320, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_depth_write_mode_320_comment},
  {"stringDepthWriteMode", &Dtool_EggRenderMode_string_depth_write_mode_320, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_depth_write_mode_320_comment},
  {"string_depth_test_mode", &Dtool_EggRenderMode_string_depth_test_mode_321, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_depth_test_mode_321_comment},
  {"stringDepthTestMode", &Dtool_EggRenderMode_string_depth_test_mode_321, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_depth_test_mode_321_comment},
  {"string_visibility_mode", &Dtool_EggRenderMode_string_visibility_mode_322, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_visibility_mode_322_comment},
  {"stringVisibilityMode", &Dtool_EggRenderMode_string_visibility_mode_322, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_visibility_mode_322_comment},
  {"get_class_type", &Dtool_EggRenderMode_get_class_type_323, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggRenderMode_get_class_type_323_comment},
  {"getClassType", &Dtool_EggRenderMode_get_class_type_323, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggRenderMode_get_class_type_323_comment},
  {"downcast_to_EggGroup", &Dtool_EggRenderMode_downcast_to_EggGroup_373, METH_NOARGS, (const char *)Dtool_EggRenderMode_downcast_to_EggGroup_373_comment},
  {"downcastToEggGroup", &Dtool_EggRenderMode_downcast_to_EggGroup_373, METH_NOARGS, (const char *)Dtool_EggRenderMode_downcast_to_EggGroup_373_comment},
  {"downcast_to_EggTexture", &Dtool_EggRenderMode_downcast_to_EggTexture_612, METH_NOARGS, (const char *)Dtool_EggRenderMode_downcast_to_EggTexture_612_comment},
  {"downcastToEggTexture", &Dtool_EggRenderMode_downcast_to_EggTexture_612, METH_NOARGS, (const char *)Dtool_EggRenderMode_downcast_to_EggTexture_612_comment},
  {"downcast_to_EggPrimitive", &Dtool_EggRenderMode_downcast_to_EggPrimitive_846, METH_NOARGS, (const char *)Dtool_EggRenderMode_downcast_to_EggPrimitive_846_comment},
  {"downcastToEggPrimitive", &Dtool_EggRenderMode_downcast_to_EggPrimitive_846, METH_NOARGS, (const char *)Dtool_EggRenderMode_downcast_to_EggPrimitive_846_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     EggRenderMode
//////////////////
static PyObject *Dtool_Str_EggRenderMode(PyObject *self) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     EggRenderMode
//////////////////
static PyObject *Dtool_RichCompare_EggRenderMode(PyObject *self, PyObject *arg, int op) {
  EggRenderMode *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-bool EggRenderMode::operator ==(EggRenderMode const &other) const
      EggRenderMode const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggRenderMode, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const EggRenderMode*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool EggRenderMode::operator !=(EggRenderMode const &other) const
      EggRenderMode const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggRenderMode, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const EggRenderMode*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-bool EggRenderMode::operator <(EggRenderMode const &other) const
      EggRenderMode const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_EggRenderMode, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const EggRenderMode*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_EggRenderMode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_EggRenderMode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggRenderMode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggRenderMode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggRenderMode,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_EggRenderMode,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class stores miscellaneous rendering properties that is associated\n"
    " * with geometry, and which may be set on the geometry primitive level, on the\n"
    " * group above it, or indirectly via a texture.  It's intended to be a base\n"
    " * class for egg objects that can have these properties set.\n"
    " *\n"
    " * This class cannot inherit from EggObject, because it causes problems at the\n"
    " * EggPolygon level with multiple appearances of the EggObject base class.\n"
    " * And making EggObject a virtual base class is just no fun.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_EggRenderMode,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggRenderMode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggRenderMode,
    PyType_GenericAlloc,
    Dtool_new_EggRenderMode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggRenderMode,
  Dtool_UpcastInterface_EggRenderMode,
  Dtool_DowncastInterface_EggRenderMode,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggRenderMode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EggRenderMode._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(39);
    Dtool_EggRenderMode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggRenderMode::AlphaMode;
    PyDict_SetItemString(dict, "AM_unspecified", Dtool_WrapValue(EggRenderMode::AM_unspecified));
    PyDict_SetItemString(dict, "AMUnspecified", Dtool_WrapValue(EggRenderMode::AM_unspecified));
    PyDict_SetItemString(dict, "AM_off", Dtool_WrapValue(EggRenderMode::AM_off));
    PyDict_SetItemString(dict, "AMOff", Dtool_WrapValue(EggRenderMode::AM_off));
    PyDict_SetItemString(dict, "AM_on", Dtool_WrapValue(EggRenderMode::AM_on));
    PyDict_SetItemString(dict, "AMOn", Dtool_WrapValue(EggRenderMode::AM_on));
    PyDict_SetItemString(dict, "AM_blend", Dtool_WrapValue(EggRenderMode::AM_blend));
    PyDict_SetItemString(dict, "AMBlend", Dtool_WrapValue(EggRenderMode::AM_blend));
    PyDict_SetItemString(dict, "AM_blend_no_occlude", Dtool_WrapValue(EggRenderMode::AM_blend_no_occlude));
    PyDict_SetItemString(dict, "AMBlendNoOcclude", Dtool_WrapValue(EggRenderMode::AM_blend_no_occlude));
    PyDict_SetItemString(dict, "AM_ms", Dtool_WrapValue(EggRenderMode::AM_ms));
    PyDict_SetItemString(dict, "AMMs", Dtool_WrapValue(EggRenderMode::AM_ms));
    PyDict_SetItemString(dict, "AM_ms_mask", Dtool_WrapValue(EggRenderMode::AM_ms_mask));
    PyDict_SetItemString(dict, "AMMsMask", Dtool_WrapValue(EggRenderMode::AM_ms_mask));
    PyDict_SetItemString(dict, "AM_binary", Dtool_WrapValue(EggRenderMode::AM_binary));
    PyDict_SetItemString(dict, "AMBinary", Dtool_WrapValue(EggRenderMode::AM_binary));
    PyDict_SetItemString(dict, "AM_dual", Dtool_WrapValue(EggRenderMode::AM_dual));
    PyDict_SetItemString(dict, "AMDual", Dtool_WrapValue(EggRenderMode::AM_dual));
    PyDict_SetItemString(dict, "AM_premultiplied", Dtool_WrapValue(EggRenderMode::AM_premultiplied));
    PyDict_SetItemString(dict, "AMPremultiplied", Dtool_WrapValue(EggRenderMode::AM_premultiplied));
    // enum EggRenderMode::DepthWriteMode;
    PyDict_SetItemString(dict, "DWM_unspecified", Dtool_WrapValue(EggRenderMode::DWM_unspecified));
    PyDict_SetItemString(dict, "DWMUnspecified", Dtool_WrapValue(EggRenderMode::DWM_unspecified));
    PyDict_SetItemString(dict, "DWM_off", Dtool_WrapValue(EggRenderMode::DWM_off));
    PyDict_SetItemString(dict, "DWMOff", Dtool_WrapValue(EggRenderMode::DWM_off));
    PyDict_SetItemString(dict, "DWM_on", Dtool_WrapValue(EggRenderMode::DWM_on));
    PyDict_SetItemString(dict, "DWMOn", Dtool_WrapValue(EggRenderMode::DWM_on));
    // enum EggRenderMode::DepthTestMode;
    PyDict_SetItemString(dict, "DTM_unspecified", Dtool_WrapValue(EggRenderMode::DTM_unspecified));
    PyDict_SetItemString(dict, "DTMUnspecified", Dtool_WrapValue(EggRenderMode::DTM_unspecified));
    PyDict_SetItemString(dict, "DTM_off", Dtool_WrapValue(EggRenderMode::DTM_off));
    PyDict_SetItemString(dict, "DTMOff", Dtool_WrapValue(EggRenderMode::DTM_off));
    PyDict_SetItemString(dict, "DTM_on", Dtool_WrapValue(EggRenderMode::DTM_on));
    PyDict_SetItemString(dict, "DTMOn", Dtool_WrapValue(EggRenderMode::DTM_on));
    // enum EggRenderMode::VisibilityMode;
    PyDict_SetItemString(dict, "VM_unspecified", Dtool_WrapValue(EggRenderMode::VM_unspecified));
    PyDict_SetItemString(dict, "VMUnspecified", Dtool_WrapValue(EggRenderMode::VM_unspecified));
    PyDict_SetItemString(dict, "VM_hidden", Dtool_WrapValue(EggRenderMode::VM_hidden));
    PyDict_SetItemString(dict, "VMHidden", Dtool_WrapValue(EggRenderMode::VM_hidden));
    PyDict_SetItemString(dict, "VM_normal", Dtool_WrapValue(EggRenderMode::VM_normal));
    PyDict_SetItemString(dict, "VMNormal", Dtool_WrapValue(EggRenderMode::VM_normal));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggRenderMode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggRenderMode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggRenderMode);
  }
}

/**
 * Python method tables for EggTransform (EggTransform)
 */
static PyMethodDef Dtool_Methods_EggTransform[] = {
  {"assign", &Dtool_EggTransform_operator_327, METH_O, (const char *)Dtool_EggTransform_operator_327_comment},
  {"clear_transform", &Dtool_EggTransform_clear_transform_329, METH_NOARGS, (const char *)Dtool_EggTransform_clear_transform_329_comment},
  {"clearTransform", &Dtool_EggTransform_clear_transform_329, METH_NOARGS, (const char *)Dtool_EggTransform_clear_transform_329_comment},
  {"add_translate2d", &Dtool_EggTransform_add_translate2d_330, METH_O, (const char *)Dtool_EggTransform_add_translate2d_330_comment},
  {"addTranslate2d", &Dtool_EggTransform_add_translate2d_330, METH_O, (const char *)Dtool_EggTransform_add_translate2d_330_comment},
  {"add_translate3d", &Dtool_EggTransform_add_translate3d_331, METH_O, (const char *)Dtool_EggTransform_add_translate3d_331_comment},
  {"addTranslate3d", &Dtool_EggTransform_add_translate3d_331, METH_O, (const char *)Dtool_EggTransform_add_translate3d_331_comment},
  {"add_rotate2d", &Dtool_EggTransform_add_rotate2d_332, METH_O, (const char *)Dtool_EggTransform_add_rotate2d_332_comment},
  {"addRotate2d", &Dtool_EggTransform_add_rotate2d_332, METH_O, (const char *)Dtool_EggTransform_add_rotate2d_332_comment},
  {"add_rotx", &Dtool_EggTransform_add_rotx_333, METH_O, (const char *)Dtool_EggTransform_add_rotx_333_comment},
  {"addRotx", &Dtool_EggTransform_add_rotx_333, METH_O, (const char *)Dtool_EggTransform_add_rotx_333_comment},
  {"add_roty", &Dtool_EggTransform_add_roty_334, METH_O, (const char *)Dtool_EggTransform_add_roty_334_comment},
  {"addRoty", &Dtool_EggTransform_add_roty_334, METH_O, (const char *)Dtool_EggTransform_add_roty_334_comment},
  {"add_rotz", &Dtool_EggTransform_add_rotz_335, METH_O, (const char *)Dtool_EggTransform_add_rotz_335_comment},
  {"addRotz", &Dtool_EggTransform_add_rotz_335, METH_O, (const char *)Dtool_EggTransform_add_rotz_335_comment},
  {"add_rotate3d", (PyCFunction) &Dtool_EggTransform_add_rotate3d_336, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTransform_add_rotate3d_336_comment},
  {"addRotate3d", (PyCFunction) &Dtool_EggTransform_add_rotate3d_336, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTransform_add_rotate3d_336_comment},
  {"add_scale2d", &Dtool_EggTransform_add_scale2d_337, METH_O, (const char *)Dtool_EggTransform_add_scale2d_337_comment},
  {"addScale2d", &Dtool_EggTransform_add_scale2d_337, METH_O, (const char *)Dtool_EggTransform_add_scale2d_337_comment},
  {"add_scale3d", &Dtool_EggTransform_add_scale3d_338, METH_O, (const char *)Dtool_EggTransform_add_scale3d_338_comment},
  {"addScale3d", &Dtool_EggTransform_add_scale3d_338, METH_O, (const char *)Dtool_EggTransform_add_scale3d_338_comment},
  {"add_uniform_scale", &Dtool_EggTransform_add_uniform_scale_339, METH_O, (const char *)Dtool_EggTransform_add_uniform_scale_339_comment},
  {"addUniformScale", &Dtool_EggTransform_add_uniform_scale_339, METH_O, (const char *)Dtool_EggTransform_add_uniform_scale_339_comment},
  {"add_matrix3", &Dtool_EggTransform_add_matrix3_340, METH_O, (const char *)Dtool_EggTransform_add_matrix3_340_comment},
  {"addMatrix3", &Dtool_EggTransform_add_matrix3_340, METH_O, (const char *)Dtool_EggTransform_add_matrix3_340_comment},
  {"add_matrix4", &Dtool_EggTransform_add_matrix4_341, METH_O, (const char *)Dtool_EggTransform_add_matrix4_341_comment},
  {"addMatrix4", &Dtool_EggTransform_add_matrix4_341, METH_O, (const char *)Dtool_EggTransform_add_matrix4_341_comment},
  {"has_transform", &Dtool_EggTransform_has_transform_342, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform_342_comment},
  {"hasTransform", &Dtool_EggTransform_has_transform_342, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform_342_comment},
  {"has_transform2d", &Dtool_EggTransform_has_transform2d_343, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform2d_343_comment},
  {"hasTransform2d", &Dtool_EggTransform_has_transform2d_343, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform2d_343_comment},
  {"set_transform2d", &Dtool_EggTransform_set_transform2d_344, METH_O, (const char *)Dtool_EggTransform_set_transform2d_344_comment},
  {"setTransform2d", &Dtool_EggTransform_set_transform2d_344, METH_O, (const char *)Dtool_EggTransform_set_transform2d_344_comment},
  {"has_transform3d", &Dtool_EggTransform_has_transform3d_345, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform3d_345_comment},
  {"hasTransform3d", &Dtool_EggTransform_has_transform3d_345, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform3d_345_comment},
  {"set_transform3d", &Dtool_EggTransform_set_transform3d_346, METH_O, (const char *)Dtool_EggTransform_set_transform3d_346_comment},
  {"setTransform3d", &Dtool_EggTransform_set_transform3d_346, METH_O, (const char *)Dtool_EggTransform_set_transform3d_346_comment},
  {"get_transform2d", &Dtool_EggTransform_get_transform2d_347, METH_NOARGS, (const char *)Dtool_EggTransform_get_transform2d_347_comment},
  {"getTransform2d", &Dtool_EggTransform_get_transform2d_347, METH_NOARGS, (const char *)Dtool_EggTransform_get_transform2d_347_comment},
  {"get_transform3d", &Dtool_EggTransform_get_transform3d_348, METH_NOARGS, (const char *)Dtool_EggTransform_get_transform3d_348_comment},
  {"getTransform3d", &Dtool_EggTransform_get_transform3d_348, METH_NOARGS, (const char *)Dtool_EggTransform_get_transform3d_348_comment},
  {"transform_is_identity", &Dtool_EggTransform_transform_is_identity_349, METH_NOARGS, (const char *)Dtool_EggTransform_transform_is_identity_349_comment},
  {"transformIsIdentity", &Dtool_EggTransform_transform_is_identity_349, METH_NOARGS, (const char *)Dtool_EggTransform_transform_is_identity_349_comment},
  {"get_num_components", &Dtool_EggTransform_get_num_components_351, METH_NOARGS, (const char *)Dtool_EggTransform_get_num_components_351_comment},
  {"getNumComponents", &Dtool_EggTransform_get_num_components_351, METH_NOARGS, (const char *)Dtool_EggTransform_get_num_components_351_comment},
  {"get_component_type", &Dtool_EggTransform_get_component_type_352, METH_O, (const char *)Dtool_EggTransform_get_component_type_352_comment},
  {"getComponentType", &Dtool_EggTransform_get_component_type_352, METH_O, (const char *)Dtool_EggTransform_get_component_type_352_comment},
  {"get_component_number", &Dtool_EggTransform_get_component_number_353, METH_O, (const char *)Dtool_EggTransform_get_component_number_353_comment},
  {"getComponentNumber", &Dtool_EggTransform_get_component_number_353, METH_O, (const char *)Dtool_EggTransform_get_component_number_353_comment},
  {"get_component_vec2", &Dtool_EggTransform_get_component_vec2_354, METH_O, (const char *)Dtool_EggTransform_get_component_vec2_354_comment},
  {"getComponentVec2", &Dtool_EggTransform_get_component_vec2_354, METH_O, (const char *)Dtool_EggTransform_get_component_vec2_354_comment},
  {"get_component_vec3", &Dtool_EggTransform_get_component_vec3_355, METH_O, (const char *)Dtool_EggTransform_get_component_vec3_355_comment},
  {"getComponentVec3", &Dtool_EggTransform_get_component_vec3_355, METH_O, (const char *)Dtool_EggTransform_get_component_vec3_355_comment},
  {"get_component_mat3", &Dtool_EggTransform_get_component_mat3_356, METH_O, (const char *)Dtool_EggTransform_get_component_mat3_356_comment},
  {"getComponentMat3", &Dtool_EggTransform_get_component_mat3_356, METH_O, (const char *)Dtool_EggTransform_get_component_mat3_356_comment},
  {"get_component_mat4", &Dtool_EggTransform_get_component_mat4_357, METH_O, (const char *)Dtool_EggTransform_get_component_mat4_357_comment},
  {"getComponentMat4", &Dtool_EggTransform_get_component_mat4_357, METH_O, (const char *)Dtool_EggTransform_get_component_mat4_357_comment},
  {"write", (PyCFunction) &Dtool_EggTransform_write_358, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTransform_write_358_comment},
  {"downcast_to_EggGroup", &Dtool_EggTransform_downcast_to_EggGroup_375, METH_NOARGS, (const char *)Dtool_EggTransform_downcast_to_EggGroup_375_comment},
  {"downcastToEggGroup", &Dtool_EggTransform_downcast_to_EggGroup_375, METH_NOARGS, (const char *)Dtool_EggTransform_downcast_to_EggGroup_375_comment},
  {"downcast_to_EggTexture", &Dtool_EggTransform_downcast_to_EggTexture_614, METH_NOARGS, (const char *)Dtool_EggTransform_downcast_to_EggTexture_614_comment},
  {"downcastToEggTexture", &Dtool_EggTransform_downcast_to_EggTexture_614, METH_NOARGS, (const char *)Dtool_EggTransform_downcast_to_EggTexture_614_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggTransform = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_EggTransform = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggTransform",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTransform,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggTransform,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents the <Transform> entry of a group or texture node: a list of\n"
    " * component transform operations, applied in order, that describe a net\n"
    " * transform matrix.\n"
    " *\n"
    " * This may be either a 3-d transform, and therefore described by a 4x4\n"
    " * matrix, or a 2-d transform, described by a 3x3 matrix.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggTransform,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggTransform,
    PyType_GenericAlloc,
    Dtool_new_EggTransform,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTransform,
  Dtool_UpcastInterface_EggTransform,
  Dtool_DowncastInterface_EggTransform,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggTransform(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EggTransform._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(27);
    Dtool_EggTransform._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggTransform::ComponentType;
    PyDict_SetItemString(dict, "CT_invalid", Dtool_WrapValue(EggTransform::CT_invalid));
    PyDict_SetItemString(dict, "CTInvalid", Dtool_WrapValue(EggTransform::CT_invalid));
    PyDict_SetItemString(dict, "CT_translate2d", Dtool_WrapValue(EggTransform::CT_translate2d));
    PyDict_SetItemString(dict, "CTTranslate2d", Dtool_WrapValue(EggTransform::CT_translate2d));
    PyDict_SetItemString(dict, "CT_translate3d", Dtool_WrapValue(EggTransform::CT_translate3d));
    PyDict_SetItemString(dict, "CTTranslate3d", Dtool_WrapValue(EggTransform::CT_translate3d));
    PyDict_SetItemString(dict, "CT_rotate2d", Dtool_WrapValue(EggTransform::CT_rotate2d));
    PyDict_SetItemString(dict, "CTRotate2d", Dtool_WrapValue(EggTransform::CT_rotate2d));
    PyDict_SetItemString(dict, "CT_rotx", Dtool_WrapValue(EggTransform::CT_rotx));
    PyDict_SetItemString(dict, "CTRotx", Dtool_WrapValue(EggTransform::CT_rotx));
    PyDict_SetItemString(dict, "CT_roty", Dtool_WrapValue(EggTransform::CT_roty));
    PyDict_SetItemString(dict, "CTRoty", Dtool_WrapValue(EggTransform::CT_roty));
    PyDict_SetItemString(dict, "CT_rotz", Dtool_WrapValue(EggTransform::CT_rotz));
    PyDict_SetItemString(dict, "CTRotz", Dtool_WrapValue(EggTransform::CT_rotz));
    PyDict_SetItemString(dict, "CT_rotate3d", Dtool_WrapValue(EggTransform::CT_rotate3d));
    PyDict_SetItemString(dict, "CTRotate3d", Dtool_WrapValue(EggTransform::CT_rotate3d));
    PyDict_SetItemString(dict, "CT_scale2d", Dtool_WrapValue(EggTransform::CT_scale2d));
    PyDict_SetItemString(dict, "CTScale2d", Dtool_WrapValue(EggTransform::CT_scale2d));
    PyDict_SetItemString(dict, "CT_scale3d", Dtool_WrapValue(EggTransform::CT_scale3d));
    PyDict_SetItemString(dict, "CTScale3d", Dtool_WrapValue(EggTransform::CT_scale3d));
    PyDict_SetItemString(dict, "CT_uniform_scale", Dtool_WrapValue(EggTransform::CT_uniform_scale));
    PyDict_SetItemString(dict, "CTUniformScale", Dtool_WrapValue(EggTransform::CT_uniform_scale));
    PyDict_SetItemString(dict, "CT_matrix3", Dtool_WrapValue(EggTransform::CT_matrix3));
    PyDict_SetItemString(dict, "CTMatrix3", Dtool_WrapValue(EggTransform::CT_matrix3));
    PyDict_SetItemString(dict, "CT_matrix4", Dtool_WrapValue(EggTransform::CT_matrix4));
    PyDict_SetItemString(dict, "CTMatrix4", Dtool_WrapValue(EggTransform::CT_matrix4));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTransform) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTransform)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTransform);
  }
}

/**
 * Python method tables for EggSwitchCondition (EggSwitchCondition)
 */
static PyMethodDef Dtool_Methods_EggSwitchCondition[] = {
  {"make_copy", &Dtool_EggSwitchCondition_make_copy_360, METH_NOARGS, (const char *)Dtool_EggSwitchCondition_make_copy_360_comment},
  {"makeCopy", &Dtool_EggSwitchCondition_make_copy_360, METH_NOARGS, (const char *)Dtool_EggSwitchCondition_make_copy_360_comment},
  {"write", (PyCFunction) &Dtool_EggSwitchCondition_write_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggSwitchCondition_write_361_comment},
  {"transform", &Dtool_EggSwitchCondition_transform_362, METH_O, (const char *)Dtool_EggSwitchCondition_transform_362_comment},
  {"get_class_type", &Dtool_EggSwitchCondition_get_class_type_363, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSwitchCondition_get_class_type_363_comment},
  {"getClassType", &Dtool_EggSwitchCondition_get_class_type_363, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSwitchCondition_get_class_type_363_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     EggSwitchCondition
//////////////////
static PyObject *Dtool_Str_EggSwitchCondition(PyObject *self) {
  EggSwitchCondition *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggSwitchCondition, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EggSwitchCondition = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggSwitchCondition = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggSwitchCondition = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggSwitchCondition = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggSwitchCondition = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggSwitchCondition",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggSwitchCondition,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggSwitchCondition,
    &Dtool_SequenceMethods_EggSwitchCondition,
    &Dtool_MappingMethods_EggSwitchCondition,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_EggSwitchCondition,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggSwitchCondition,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This corresponds to a <SwitchCondition> entry within a group.  It indicates\n"
    " * the condition at which a level-of-detail is switched in or out.  This is\n"
    " * actually an abstract base class for potentially any number of specific\n"
    " * different kinds of switching conditions; presently, only a <Distance> type\n"
    " * is actually supported.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggSwitchCondition,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggSwitchCondition,
    PyType_GenericAlloc,
    Dtool_new_EggSwitchCondition,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggSwitchCondition,
  Dtool_UpcastInterface_EggSwitchCondition,
  Dtool_DowncastInterface_EggSwitchCondition,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggSwitchCondition(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggObject(NULL);
    Dtool_EggSwitchCondition._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggObject);
    PyObject *dict = PyDict_New();
    Dtool_EggSwitchCondition._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggSwitchCondition) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggSwitchCondition)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggSwitchCondition);
  }
}

/**
 * Python method tables for EggSwitchConditionDistance (EggSwitchConditionDistance)
 */
static PyMethodDef Dtool_Methods_EggSwitchConditionDistance[] = {
  {"get_class_type", &Dtool_EggSwitchConditionDistance_get_class_type_367, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSwitchConditionDistance_get_class_type_367_comment},
  {"getClassType", &Dtool_EggSwitchConditionDistance_get_class_type_367, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSwitchConditionDistance_get_class_type_367_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggSwitchConditionDistance = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggSwitchConditionDistance = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggSwitchConditionDistance = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggSwitchConditionDistance = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggSwitchConditionDistance = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggSwitchConditionDistance",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggSwitchConditionDistance,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggSwitchConditionDistance,
    &Dtool_SequenceMethods_EggSwitchConditionDistance,
    &Dtool_MappingMethods_EggSwitchConditionDistance,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggSwitchConditionDistance,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A SwitchCondition that switches the levels-of-detail based on distance from\n"
    " * the camera's eyepoint.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggSwitchConditionDistance,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggSwitchConditionDistance,
    PyType_GenericAlloc,
    Dtool_new_EggSwitchConditionDistance,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggSwitchConditionDistance,
  Dtool_UpcastInterface_EggSwitchConditionDistance,
  Dtool_DowncastInterface_EggSwitchConditionDistance,
  (CoerceFunction)Dtool_ConstCoerce_EggSwitchConditionDistance,
  (CoerceFunction)Dtool_Coerce_EggSwitchConditionDistance,
};

static void Dtool_PyModuleClassInit_EggSwitchConditionDistance(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggSwitchCondition(NULL);
    Dtool_EggSwitchConditionDistance._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggSwitchCondition);
    PyObject *dict = PyDict_New();
    Dtool_EggSwitchConditionDistance._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggSwitchConditionDistance) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggSwitchConditionDistance)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggSwitchConditionDistance);
  }
}

/**
 * Python method tables for EggGroup (EggGroup)
 */
static PyMethodDef Dtool_Methods_EggGroup[] = {
  {"assign", &Dtool_EggGroup_operator_389, METH_O, (const char *)Dtool_EggGroup_operator_389_comment},
  {"write", (PyCFunction) &Dtool_EggGroup_write_391, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_391_comment},
  {"write_billboard_flags", (PyCFunction) &Dtool_EggGroup_write_billboard_flags_392, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_billboard_flags_392_comment},
  {"writeBillboardFlags", (PyCFunction) &Dtool_EggGroup_write_billboard_flags_392, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_billboard_flags_392_comment},
  {"write_collide_flags", (PyCFunction) &Dtool_EggGroup_write_collide_flags_393, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_collide_flags_393_comment},
  {"writeCollideFlags", (PyCFunction) &Dtool_EggGroup_write_collide_flags_393, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_collide_flags_393_comment},
  {"write_model_flags", (PyCFunction) &Dtool_EggGroup_write_model_flags_394, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_model_flags_394_comment},
  {"writeModelFlags", (PyCFunction) &Dtool_EggGroup_write_model_flags_394, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_model_flags_394_comment},
  {"write_switch_flags", (PyCFunction) &Dtool_EggGroup_write_switch_flags_395, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_switch_flags_395_comment},
  {"writeSwitchFlags", (PyCFunction) &Dtool_EggGroup_write_switch_flags_395, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_switch_flags_395_comment},
  {"write_object_types", (PyCFunction) &Dtool_EggGroup_write_object_types_396, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_object_types_396_comment},
  {"writeObjectTypes", (PyCFunction) &Dtool_EggGroup_write_object_types_396, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_object_types_396_comment},
  {"write_decal_flags", (PyCFunction) &Dtool_EggGroup_write_decal_flags_397, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_decal_flags_397_comment},
  {"writeDecalFlags", (PyCFunction) &Dtool_EggGroup_write_decal_flags_397, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_decal_flags_397_comment},
  {"write_tags", (PyCFunction) &Dtool_EggGroup_write_tags_398, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_tags_398_comment},
  {"writeTags", (PyCFunction) &Dtool_EggGroup_write_tags_398, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_tags_398_comment},
  {"write_render_mode", (PyCFunction) &Dtool_EggGroup_write_render_mode_399, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_render_mode_399_comment},
  {"writeRenderMode", (PyCFunction) &Dtool_EggGroup_write_render_mode_399, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_render_mode_399_comment},
  {"is_joint", &Dtool_EggGroup_is_joint_400, METH_NOARGS, (const char *)Dtool_EggGroup_is_joint_400_comment},
  {"isJoint", &Dtool_EggGroup_is_joint_400, METH_NOARGS, (const char *)Dtool_EggGroup_is_joint_400_comment},
  {"determine_alpha_mode", &Dtool_EggGroup_determine_alpha_mode_401, METH_NOARGS, (const char *)Dtool_EggGroup_determine_alpha_mode_401_comment},
  {"determineAlphaMode", &Dtool_EggGroup_determine_alpha_mode_401, METH_NOARGS, (const char *)Dtool_EggGroup_determine_alpha_mode_401_comment},
  {"determine_depth_write_mode", &Dtool_EggGroup_determine_depth_write_mode_402, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_write_mode_402_comment},
  {"determineDepthWriteMode", &Dtool_EggGroup_determine_depth_write_mode_402, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_write_mode_402_comment},
  {"determine_depth_test_mode", &Dtool_EggGroup_determine_depth_test_mode_403, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_test_mode_403_comment},
  {"determineDepthTestMode", &Dtool_EggGroup_determine_depth_test_mode_403, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_test_mode_403_comment},
  {"determine_visibility_mode", &Dtool_EggGroup_determine_visibility_mode_404, METH_NOARGS, (const char *)Dtool_EggGroup_determine_visibility_mode_404_comment},
  {"determineVisibilityMode", &Dtool_EggGroup_determine_visibility_mode_404, METH_NOARGS, (const char *)Dtool_EggGroup_determine_visibility_mode_404_comment},
  {"determine_depth_offset", &Dtool_EggGroup_determine_depth_offset_405, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_offset_405_comment},
  {"determineDepthOffset", &Dtool_EggGroup_determine_depth_offset_405, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_offset_405_comment},
  {"determine_draw_order", &Dtool_EggGroup_determine_draw_order_406, METH_NOARGS, (const char *)Dtool_EggGroup_determine_draw_order_406_comment},
  {"determineDrawOrder", &Dtool_EggGroup_determine_draw_order_406, METH_NOARGS, (const char *)Dtool_EggGroup_determine_draw_order_406_comment},
  {"determine_bin", &Dtool_EggGroup_determine_bin_407, METH_NOARGS, (const char *)Dtool_EggGroup_determine_bin_407_comment},
  {"determineBin", &Dtool_EggGroup_determine_bin_407, METH_NOARGS, (const char *)Dtool_EggGroup_determine_bin_407_comment},
  {"determine_indexed", &Dtool_EggGroup_determine_indexed_408, METH_NOARGS, (const char *)Dtool_EggGroup_determine_indexed_408_comment},
  {"determineIndexed", &Dtool_EggGroup_determine_indexed_408, METH_NOARGS, (const char *)Dtool_EggGroup_determine_indexed_408_comment},
  {"determine_decal", &Dtool_EggGroup_determine_decal_409, METH_NOARGS, (const char *)Dtool_EggGroup_determine_decal_409_comment},
  {"determineDecal", &Dtool_EggGroup_determine_decal_409, METH_NOARGS, (const char *)Dtool_EggGroup_determine_decal_409_comment},
  {"set_group_type", &Dtool_EggGroup_set_group_type_410, METH_O, (const char *)Dtool_EggGroup_set_group_type_410_comment},
  {"setGroupType", &Dtool_EggGroup_set_group_type_410, METH_O, (const char *)Dtool_EggGroup_set_group_type_410_comment},
  {"get_group_type", &Dtool_EggGroup_get_group_type_411, METH_NOARGS, (const char *)Dtool_EggGroup_get_group_type_411_comment},
  {"getGroupType", &Dtool_EggGroup_get_group_type_411, METH_NOARGS, (const char *)Dtool_EggGroup_get_group_type_411_comment},
  {"is_instance_type", &Dtool_EggGroup_is_instance_type_412, METH_NOARGS, (const char *)Dtool_EggGroup_is_instance_type_412_comment},
  {"isInstanceType", &Dtool_EggGroup_is_instance_type_412, METH_NOARGS, (const char *)Dtool_EggGroup_is_instance_type_412_comment},
  {"set_billboard_type", &Dtool_EggGroup_set_billboard_type_413, METH_O, (const char *)Dtool_EggGroup_set_billboard_type_413_comment},
  {"setBillboardType", &Dtool_EggGroup_set_billboard_type_413, METH_O, (const char *)Dtool_EggGroup_set_billboard_type_413_comment},
  {"get_billboard_type", &Dtool_EggGroup_get_billboard_type_414, METH_NOARGS, (const char *)Dtool_EggGroup_get_billboard_type_414_comment},
  {"getBillboardType", &Dtool_EggGroup_get_billboard_type_414, METH_NOARGS, (const char *)Dtool_EggGroup_get_billboard_type_414_comment},
  {"set_billboard_center", &Dtool_EggGroup_set_billboard_center_415, METH_O, (const char *)Dtool_EggGroup_set_billboard_center_415_comment},
  {"setBillboardCenter", &Dtool_EggGroup_set_billboard_center_415, METH_O, (const char *)Dtool_EggGroup_set_billboard_center_415_comment},
  {"clear_billboard_center", &Dtool_EggGroup_clear_billboard_center_416, METH_NOARGS, (const char *)Dtool_EggGroup_clear_billboard_center_416_comment},
  {"clearBillboardCenter", &Dtool_EggGroup_clear_billboard_center_416, METH_NOARGS, (const char *)Dtool_EggGroup_clear_billboard_center_416_comment},
  {"has_billboard_center", &Dtool_EggGroup_has_billboard_center_417, METH_NOARGS, (const char *)Dtool_EggGroup_has_billboard_center_417_comment},
  {"hasBillboardCenter", &Dtool_EggGroup_has_billboard_center_417, METH_NOARGS, (const char *)Dtool_EggGroup_has_billboard_center_417_comment},
  {"get_billboard_center", &Dtool_EggGroup_get_billboard_center_418, METH_NOARGS, (const char *)Dtool_EggGroup_get_billboard_center_418_comment},
  {"getBillboardCenter", &Dtool_EggGroup_get_billboard_center_418, METH_NOARGS, (const char *)Dtool_EggGroup_get_billboard_center_418_comment},
  {"set_cs_type", &Dtool_EggGroup_set_cs_type_419, METH_O, (const char *)Dtool_EggGroup_set_cs_type_419_comment},
  {"setCsType", &Dtool_EggGroup_set_cs_type_419, METH_O, (const char *)Dtool_EggGroup_set_cs_type_419_comment},
  {"get_cs_type", &Dtool_EggGroup_get_cs_type_420, METH_NOARGS, (const char *)Dtool_EggGroup_get_cs_type_420_comment},
  {"getCsType", &Dtool_EggGroup_get_cs_type_420, METH_NOARGS, (const char *)Dtool_EggGroup_get_cs_type_420_comment},
  {"set_collide_flags", &Dtool_EggGroup_set_collide_flags_421, METH_O, (const char *)Dtool_EggGroup_set_collide_flags_421_comment},
  {"setCollideFlags", &Dtool_EggGroup_set_collide_flags_421, METH_O, (const char *)Dtool_EggGroup_set_collide_flags_421_comment},
  {"get_collide_flags", &Dtool_EggGroup_get_collide_flags_422, METH_NOARGS, (const char *)Dtool_EggGroup_get_collide_flags_422_comment},
  {"getCollideFlags", &Dtool_EggGroup_get_collide_flags_422, METH_NOARGS, (const char *)Dtool_EggGroup_get_collide_flags_422_comment},
  {"set_collision_name", &Dtool_EggGroup_set_collision_name_423, METH_O, (const char *)Dtool_EggGroup_set_collision_name_423_comment},
  {"setCollisionName", &Dtool_EggGroup_set_collision_name_423, METH_O, (const char *)Dtool_EggGroup_set_collision_name_423_comment},
  {"clear_collision_name", &Dtool_EggGroup_clear_collision_name_424, METH_NOARGS, (const char *)Dtool_EggGroup_clear_collision_name_424_comment},
  {"clearCollisionName", &Dtool_EggGroup_clear_collision_name_424, METH_NOARGS, (const char *)Dtool_EggGroup_clear_collision_name_424_comment},
  {"has_collision_name", &Dtool_EggGroup_has_collision_name_425, METH_NOARGS, (const char *)Dtool_EggGroup_has_collision_name_425_comment},
  {"hasCollisionName", &Dtool_EggGroup_has_collision_name_425, METH_NOARGS, (const char *)Dtool_EggGroup_has_collision_name_425_comment},
  {"get_collision_name", &Dtool_EggGroup_get_collision_name_426, METH_NOARGS, (const char *)Dtool_EggGroup_get_collision_name_426_comment},
  {"getCollisionName", &Dtool_EggGroup_get_collision_name_426, METH_NOARGS, (const char *)Dtool_EggGroup_get_collision_name_426_comment},
  {"set_dcs_type", &Dtool_EggGroup_set_dcs_type_427, METH_O, (const char *)Dtool_EggGroup_set_dcs_type_427_comment},
  {"setDcsType", &Dtool_EggGroup_set_dcs_type_427, METH_O, (const char *)Dtool_EggGroup_set_dcs_type_427_comment},
  {"get_dcs_type", &Dtool_EggGroup_get_dcs_type_428, METH_NOARGS, (const char *)Dtool_EggGroup_get_dcs_type_428_comment},
  {"getDcsType", &Dtool_EggGroup_get_dcs_type_428, METH_NOARGS, (const char *)Dtool_EggGroup_get_dcs_type_428_comment},
  {"has_dcs_type", &Dtool_EggGroup_has_dcs_type_429, METH_NOARGS, (const char *)Dtool_EggGroup_has_dcs_type_429_comment},
  {"hasDcsType", &Dtool_EggGroup_has_dcs_type_429, METH_NOARGS, (const char *)Dtool_EggGroup_has_dcs_type_429_comment},
  {"set_dart_type", &Dtool_EggGroup_set_dart_type_430, METH_O, (const char *)Dtool_EggGroup_set_dart_type_430_comment},
  {"setDartType", &Dtool_EggGroup_set_dart_type_430, METH_O, (const char *)Dtool_EggGroup_set_dart_type_430_comment},
  {"get_dart_type", &Dtool_EggGroup_get_dart_type_431, METH_NOARGS, (const char *)Dtool_EggGroup_get_dart_type_431_comment},
  {"getDartType", &Dtool_EggGroup_get_dart_type_431, METH_NOARGS, (const char *)Dtool_EggGroup_get_dart_type_431_comment},
  {"set_switch_flag", &Dtool_EggGroup_set_switch_flag_432, METH_O, (const char *)Dtool_EggGroup_set_switch_flag_432_comment},
  {"setSwitchFlag", &Dtool_EggGroup_set_switch_flag_432, METH_O, (const char *)Dtool_EggGroup_set_switch_flag_432_comment},
  {"get_switch_flag", &Dtool_EggGroup_get_switch_flag_433, METH_NOARGS, (const char *)Dtool_EggGroup_get_switch_flag_433_comment},
  {"getSwitchFlag", &Dtool_EggGroup_get_switch_flag_433, METH_NOARGS, (const char *)Dtool_EggGroup_get_switch_flag_433_comment},
  {"set_switch_fps", &Dtool_EggGroup_set_switch_fps_434, METH_O, (const char *)Dtool_EggGroup_set_switch_fps_434_comment},
  {"setSwitchFps", &Dtool_EggGroup_set_switch_fps_434, METH_O, (const char *)Dtool_EggGroup_set_switch_fps_434_comment},
  {"get_switch_fps", &Dtool_EggGroup_get_switch_fps_435, METH_NOARGS, (const char *)Dtool_EggGroup_get_switch_fps_435_comment},
  {"getSwitchFps", &Dtool_EggGroup_get_switch_fps_435, METH_NOARGS, (const char *)Dtool_EggGroup_get_switch_fps_435_comment},
  {"add_object_type", &Dtool_EggGroup_add_object_type_436, METH_O, (const char *)Dtool_EggGroup_add_object_type_436_comment},
  {"addObjectType", &Dtool_EggGroup_add_object_type_436, METH_O, (const char *)Dtool_EggGroup_add_object_type_436_comment},
  {"clear_object_types", &Dtool_EggGroup_clear_object_types_437, METH_NOARGS, (const char *)Dtool_EggGroup_clear_object_types_437_comment},
  {"clearObjectTypes", &Dtool_EggGroup_clear_object_types_437, METH_NOARGS, (const char *)Dtool_EggGroup_clear_object_types_437_comment},
  {"get_num_object_types", &Dtool_EggGroup_get_num_object_types_438, METH_NOARGS, (const char *)Dtool_EggGroup_get_num_object_types_438_comment},
  {"getNumObjectTypes", &Dtool_EggGroup_get_num_object_types_438, METH_NOARGS, (const char *)Dtool_EggGroup_get_num_object_types_438_comment},
  {"get_object_type", &Dtool_EggGroup_get_object_type_439, METH_O, (const char *)Dtool_EggGroup_get_object_type_439_comment},
  {"getObjectType", &Dtool_EggGroup_get_object_type_439, METH_O, (const char *)Dtool_EggGroup_get_object_type_439_comment},
  {"has_object_type", &Dtool_EggGroup_has_object_type_441, METH_O, (const char *)Dtool_EggGroup_has_object_type_441_comment},
  {"hasObjectType", &Dtool_EggGroup_has_object_type_441, METH_O, (const char *)Dtool_EggGroup_has_object_type_441_comment},
  {"remove_object_type", &Dtool_EggGroup_remove_object_type_442, METH_O, (const char *)Dtool_EggGroup_remove_object_type_442_comment},
  {"removeObjectType", &Dtool_EggGroup_remove_object_type_442, METH_O, (const char *)Dtool_EggGroup_remove_object_type_442_comment},
  {"set_model_flag", &Dtool_EggGroup_set_model_flag_443, METH_O, (const char *)Dtool_EggGroup_set_model_flag_443_comment},
  {"setModelFlag", &Dtool_EggGroup_set_model_flag_443, METH_O, (const char *)Dtool_EggGroup_set_model_flag_443_comment},
  {"get_model_flag", &Dtool_EggGroup_get_model_flag_444, METH_NOARGS, (const char *)Dtool_EggGroup_get_model_flag_444_comment},
  {"getModelFlag", &Dtool_EggGroup_get_model_flag_444, METH_NOARGS, (const char *)Dtool_EggGroup_get_model_flag_444_comment},
  {"set_texlist_flag", &Dtool_EggGroup_set_texlist_flag_445, METH_O, (const char *)Dtool_EggGroup_set_texlist_flag_445_comment},
  {"setTexlistFlag", &Dtool_EggGroup_set_texlist_flag_445, METH_O, (const char *)Dtool_EggGroup_set_texlist_flag_445_comment},
  {"get_texlist_flag", &Dtool_EggGroup_get_texlist_flag_446, METH_NOARGS, (const char *)Dtool_EggGroup_get_texlist_flag_446_comment},
  {"getTexlistFlag", &Dtool_EggGroup_get_texlist_flag_446, METH_NOARGS, (const char *)Dtool_EggGroup_get_texlist_flag_446_comment},
  {"set_nofog_flag", &Dtool_EggGroup_set_nofog_flag_447, METH_O, (const char *)Dtool_EggGroup_set_nofog_flag_447_comment},
  {"setNofogFlag", &Dtool_EggGroup_set_nofog_flag_447, METH_O, (const char *)Dtool_EggGroup_set_nofog_flag_447_comment},
  {"get_nofog_flag", &Dtool_EggGroup_get_nofog_flag_448, METH_NOARGS, (const char *)Dtool_EggGroup_get_nofog_flag_448_comment},
  {"getNofogFlag", &Dtool_EggGroup_get_nofog_flag_448, METH_NOARGS, (const char *)Dtool_EggGroup_get_nofog_flag_448_comment},
  {"set_decal_flag", &Dtool_EggGroup_set_decal_flag_449, METH_O, (const char *)Dtool_EggGroup_set_decal_flag_449_comment},
  {"setDecalFlag", &Dtool_EggGroup_set_decal_flag_449, METH_O, (const char *)Dtool_EggGroup_set_decal_flag_449_comment},
  {"get_decal_flag", &Dtool_EggGroup_get_decal_flag_450, METH_NOARGS, (const char *)Dtool_EggGroup_get_decal_flag_450_comment},
  {"getDecalFlag", &Dtool_EggGroup_get_decal_flag_450, METH_NOARGS, (const char *)Dtool_EggGroup_get_decal_flag_450_comment},
  {"set_direct_flag", &Dtool_EggGroup_set_direct_flag_451, METH_O, (const char *)Dtool_EggGroup_set_direct_flag_451_comment},
  {"setDirectFlag", &Dtool_EggGroup_set_direct_flag_451, METH_O, (const char *)Dtool_EggGroup_set_direct_flag_451_comment},
  {"get_direct_flag", &Dtool_EggGroup_get_direct_flag_452, METH_NOARGS, (const char *)Dtool_EggGroup_get_direct_flag_452_comment},
  {"getDirectFlag", &Dtool_EggGroup_get_direct_flag_452, METH_NOARGS, (const char *)Dtool_EggGroup_get_direct_flag_452_comment},
  {"set_portal_flag", &Dtool_EggGroup_set_portal_flag_453, METH_O, (const char *)Dtool_EggGroup_set_portal_flag_453_comment},
  {"setPortalFlag", &Dtool_EggGroup_set_portal_flag_453, METH_O, (const char *)Dtool_EggGroup_set_portal_flag_453_comment},
  {"get_portal_flag", &Dtool_EggGroup_get_portal_flag_454, METH_NOARGS, (const char *)Dtool_EggGroup_get_portal_flag_454_comment},
  {"getPortalFlag", &Dtool_EggGroup_get_portal_flag_454, METH_NOARGS, (const char *)Dtool_EggGroup_get_portal_flag_454_comment},
  {"set_occluder_flag", &Dtool_EggGroup_set_occluder_flag_455, METH_O, (const char *)Dtool_EggGroup_set_occluder_flag_455_comment},
  {"setOccluderFlag", &Dtool_EggGroup_set_occluder_flag_455, METH_O, (const char *)Dtool_EggGroup_set_occluder_flag_455_comment},
  {"get_occluder_flag", &Dtool_EggGroup_get_occluder_flag_456, METH_NOARGS, (const char *)Dtool_EggGroup_get_occluder_flag_456_comment},
  {"getOccluderFlag", &Dtool_EggGroup_get_occluder_flag_456, METH_NOARGS, (const char *)Dtool_EggGroup_get_occluder_flag_456_comment},
  {"set_polylight_flag", &Dtool_EggGroup_set_polylight_flag_457, METH_O, (const char *)Dtool_EggGroup_set_polylight_flag_457_comment},
  {"setPolylightFlag", &Dtool_EggGroup_set_polylight_flag_457, METH_O, (const char *)Dtool_EggGroup_set_polylight_flag_457_comment},
  {"get_polylight_flag", &Dtool_EggGroup_get_polylight_flag_458, METH_NOARGS, (const char *)Dtool_EggGroup_get_polylight_flag_458_comment},
  {"getPolylightFlag", &Dtool_EggGroup_get_polylight_flag_458, METH_NOARGS, (const char *)Dtool_EggGroup_get_polylight_flag_458_comment},
  {"set_indexed_flag", &Dtool_EggGroup_set_indexed_flag_459, METH_O, (const char *)Dtool_EggGroup_set_indexed_flag_459_comment},
  {"setIndexedFlag", &Dtool_EggGroup_set_indexed_flag_459, METH_O, (const char *)Dtool_EggGroup_set_indexed_flag_459_comment},
  {"clear_indexed_flag", &Dtool_EggGroup_clear_indexed_flag_460, METH_NOARGS, (const char *)Dtool_EggGroup_clear_indexed_flag_460_comment},
  {"clearIndexedFlag", &Dtool_EggGroup_clear_indexed_flag_460, METH_NOARGS, (const char *)Dtool_EggGroup_clear_indexed_flag_460_comment},
  {"has_indexed_flag", &Dtool_EggGroup_has_indexed_flag_461, METH_NOARGS, (const char *)Dtool_EggGroup_has_indexed_flag_461_comment},
  {"hasIndexedFlag", &Dtool_EggGroup_has_indexed_flag_461, METH_NOARGS, (const char *)Dtool_EggGroup_has_indexed_flag_461_comment},
  {"get_indexed_flag", &Dtool_EggGroup_get_indexed_flag_462, METH_NOARGS, (const char *)Dtool_EggGroup_get_indexed_flag_462_comment},
  {"getIndexedFlag", &Dtool_EggGroup_get_indexed_flag_462, METH_NOARGS, (const char *)Dtool_EggGroup_get_indexed_flag_462_comment},
  {"set_collide_mask", &Dtool_EggGroup_set_collide_mask_463, METH_O, (const char *)Dtool_EggGroup_set_collide_mask_463_comment},
  {"setCollideMask", &Dtool_EggGroup_set_collide_mask_463, METH_O, (const char *)Dtool_EggGroup_set_collide_mask_463_comment},
  {"clear_collide_mask", &Dtool_EggGroup_clear_collide_mask_464, METH_NOARGS, (const char *)Dtool_EggGroup_clear_collide_mask_464_comment},
  {"clearCollideMask", &Dtool_EggGroup_clear_collide_mask_464, METH_NOARGS, (const char *)Dtool_EggGroup_clear_collide_mask_464_comment},
  {"has_collide_mask", &Dtool_EggGroup_has_collide_mask_465, METH_NOARGS, (const char *)Dtool_EggGroup_has_collide_mask_465_comment},
  {"hasCollideMask", &Dtool_EggGroup_has_collide_mask_465, METH_NOARGS, (const char *)Dtool_EggGroup_has_collide_mask_465_comment},
  {"get_collide_mask", &Dtool_EggGroup_get_collide_mask_466, METH_NOARGS, (const char *)Dtool_EggGroup_get_collide_mask_466_comment},
  {"getCollideMask", &Dtool_EggGroup_get_collide_mask_466, METH_NOARGS, (const char *)Dtool_EggGroup_get_collide_mask_466_comment},
  {"set_from_collide_mask", &Dtool_EggGroup_set_from_collide_mask_467, METH_O, (const char *)Dtool_EggGroup_set_from_collide_mask_467_comment},
  {"setFromCollideMask", &Dtool_EggGroup_set_from_collide_mask_467, METH_O, (const char *)Dtool_EggGroup_set_from_collide_mask_467_comment},
  {"clear_from_collide_mask", &Dtool_EggGroup_clear_from_collide_mask_468, METH_NOARGS, (const char *)Dtool_EggGroup_clear_from_collide_mask_468_comment},
  {"clearFromCollideMask", &Dtool_EggGroup_clear_from_collide_mask_468, METH_NOARGS, (const char *)Dtool_EggGroup_clear_from_collide_mask_468_comment},
  {"has_from_collide_mask", &Dtool_EggGroup_has_from_collide_mask_469, METH_NOARGS, (const char *)Dtool_EggGroup_has_from_collide_mask_469_comment},
  {"hasFromCollideMask", &Dtool_EggGroup_has_from_collide_mask_469, METH_NOARGS, (const char *)Dtool_EggGroup_has_from_collide_mask_469_comment},
  {"get_from_collide_mask", &Dtool_EggGroup_get_from_collide_mask_470, METH_NOARGS, (const char *)Dtool_EggGroup_get_from_collide_mask_470_comment},
  {"getFromCollideMask", &Dtool_EggGroup_get_from_collide_mask_470, METH_NOARGS, (const char *)Dtool_EggGroup_get_from_collide_mask_470_comment},
  {"set_into_collide_mask", &Dtool_EggGroup_set_into_collide_mask_471, METH_O, (const char *)Dtool_EggGroup_set_into_collide_mask_471_comment},
  {"setIntoCollideMask", &Dtool_EggGroup_set_into_collide_mask_471, METH_O, (const char *)Dtool_EggGroup_set_into_collide_mask_471_comment},
  {"clear_into_collide_mask", &Dtool_EggGroup_clear_into_collide_mask_472, METH_NOARGS, (const char *)Dtool_EggGroup_clear_into_collide_mask_472_comment},
  {"clearIntoCollideMask", &Dtool_EggGroup_clear_into_collide_mask_472, METH_NOARGS, (const char *)Dtool_EggGroup_clear_into_collide_mask_472_comment},
  {"has_into_collide_mask", &Dtool_EggGroup_has_into_collide_mask_473, METH_NOARGS, (const char *)Dtool_EggGroup_has_into_collide_mask_473_comment},
  {"hasIntoCollideMask", &Dtool_EggGroup_has_into_collide_mask_473, METH_NOARGS, (const char *)Dtool_EggGroup_has_into_collide_mask_473_comment},
  {"get_into_collide_mask", &Dtool_EggGroup_get_into_collide_mask_474, METH_NOARGS, (const char *)Dtool_EggGroup_get_into_collide_mask_474_comment},
  {"getIntoCollideMask", &Dtool_EggGroup_get_into_collide_mask_474, METH_NOARGS, (const char *)Dtool_EggGroup_get_into_collide_mask_474_comment},
  {"set_blend_mode", &Dtool_EggGroup_set_blend_mode_475, METH_O, (const char *)Dtool_EggGroup_set_blend_mode_475_comment},
  {"setBlendMode", &Dtool_EggGroup_set_blend_mode_475, METH_O, (const char *)Dtool_EggGroup_set_blend_mode_475_comment},
  {"get_blend_mode", &Dtool_EggGroup_get_blend_mode_476, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_mode_476_comment},
  {"getBlendMode", &Dtool_EggGroup_get_blend_mode_476, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_mode_476_comment},
  {"set_blend_operand_a", &Dtool_EggGroup_set_blend_operand_a_477, METH_O, (const char *)Dtool_EggGroup_set_blend_operand_a_477_comment},
  {"setBlendOperandA", &Dtool_EggGroup_set_blend_operand_a_477, METH_O, (const char *)Dtool_EggGroup_set_blend_operand_a_477_comment},
  {"get_blend_operand_a", &Dtool_EggGroup_get_blend_operand_a_478, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_operand_a_478_comment},
  {"getBlendOperandA", &Dtool_EggGroup_get_blend_operand_a_478, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_operand_a_478_comment},
  {"set_blend_operand_b", &Dtool_EggGroup_set_blend_operand_b_479, METH_O, (const char *)Dtool_EggGroup_set_blend_operand_b_479_comment},
  {"setBlendOperandB", &Dtool_EggGroup_set_blend_operand_b_479, METH_O, (const char *)Dtool_EggGroup_set_blend_operand_b_479_comment},
  {"get_blend_operand_b", &Dtool_EggGroup_get_blend_operand_b_480, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_operand_b_480_comment},
  {"getBlendOperandB", &Dtool_EggGroup_get_blend_operand_b_480, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_operand_b_480_comment},
  {"set_blend_color", &Dtool_EggGroup_set_blend_color_481, METH_O, (const char *)Dtool_EggGroup_set_blend_color_481_comment},
  {"setBlendColor", &Dtool_EggGroup_set_blend_color_481, METH_O, (const char *)Dtool_EggGroup_set_blend_color_481_comment},
  {"clear_blend_color", &Dtool_EggGroup_clear_blend_color_482, METH_NOARGS, (const char *)Dtool_EggGroup_clear_blend_color_482_comment},
  {"clearBlendColor", &Dtool_EggGroup_clear_blend_color_482, METH_NOARGS, (const char *)Dtool_EggGroup_clear_blend_color_482_comment},
  {"has_blend_color", &Dtool_EggGroup_has_blend_color_483, METH_NOARGS, (const char *)Dtool_EggGroup_has_blend_color_483_comment},
  {"hasBlendColor", &Dtool_EggGroup_has_blend_color_483, METH_NOARGS, (const char *)Dtool_EggGroup_has_blend_color_483_comment},
  {"get_blend_color", &Dtool_EggGroup_get_blend_color_484, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_color_484_comment},
  {"getBlendColor", &Dtool_EggGroup_get_blend_color_484, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_color_484_comment},
  {"set_lod", &Dtool_EggGroup_set_lod_485, METH_O, (const char *)Dtool_EggGroup_set_lod_485_comment},
  {"setLod", &Dtool_EggGroup_set_lod_485, METH_O, (const char *)Dtool_EggGroup_set_lod_485_comment},
  {"clear_lod", &Dtool_EggGroup_clear_lod_486, METH_NOARGS, (const char *)Dtool_EggGroup_clear_lod_486_comment},
  {"clearLod", &Dtool_EggGroup_clear_lod_486, METH_NOARGS, (const char *)Dtool_EggGroup_clear_lod_486_comment},
  {"has_lod", &Dtool_EggGroup_has_lod_487, METH_NOARGS, (const char *)Dtool_EggGroup_has_lod_487_comment},
  {"hasLod", &Dtool_EggGroup_has_lod_487, METH_NOARGS, (const char *)Dtool_EggGroup_has_lod_487_comment},
  {"get_lod", &Dtool_EggGroup_get_lod_488, METH_NOARGS, (const char *)Dtool_EggGroup_get_lod_488_comment},
  {"getLod", &Dtool_EggGroup_get_lod_488, METH_NOARGS, (const char *)Dtool_EggGroup_get_lod_488_comment},
  {"set_tag", (PyCFunction) &Dtool_EggGroup_set_tag_489, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_set_tag_489_comment},
  {"setTag", (PyCFunction) &Dtool_EggGroup_set_tag_489, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_set_tag_489_comment},
  {"get_tag", &Dtool_EggGroup_get_tag_490, METH_O, (const char *)Dtool_EggGroup_get_tag_490_comment},
  {"getTag", &Dtool_EggGroup_get_tag_490, METH_O, (const char *)Dtool_EggGroup_get_tag_490_comment},
  {"has_tag", &Dtool_EggGroup_has_tag_491, METH_O, (const char *)Dtool_EggGroup_has_tag_491_comment},
  {"hasTag", &Dtool_EggGroup_has_tag_491, METH_O, (const char *)Dtool_EggGroup_has_tag_491_comment},
  {"clear_tag", &Dtool_EggGroup_clear_tag_492, METH_O, (const char *)Dtool_EggGroup_clear_tag_492_comment},
  {"clearTag", &Dtool_EggGroup_clear_tag_492, METH_O, (const char *)Dtool_EggGroup_clear_tag_492_comment},
  {"get_default_pose", &Dtool_EggGroup_get_default_pose_493, METH_NOARGS, (const char *)Dtool_EggGroup_get_default_pose_493_comment},
  {"getDefaultPose", &Dtool_EggGroup_get_default_pose_493, METH_NOARGS, (const char *)Dtool_EggGroup_get_default_pose_493_comment},
  {"modify_default_pose", &Dtool_EggGroup_modify_default_pose_494, METH_NOARGS, (const char *)Dtool_EggGroup_modify_default_pose_494_comment},
  {"modifyDefaultPose", &Dtool_EggGroup_modify_default_pose_494, METH_NOARGS, (const char *)Dtool_EggGroup_modify_default_pose_494_comment},
  {"set_default_pose", &Dtool_EggGroup_set_default_pose_495, METH_O, (const char *)Dtool_EggGroup_set_default_pose_495_comment},
  {"setDefaultPose", &Dtool_EggGroup_set_default_pose_495, METH_O, (const char *)Dtool_EggGroup_set_default_pose_495_comment},
  {"clear_default_pose", &Dtool_EggGroup_clear_default_pose_496, METH_NOARGS, (const char *)Dtool_EggGroup_clear_default_pose_496_comment},
  {"clearDefaultPose", &Dtool_EggGroup_clear_default_pose_496, METH_NOARGS, (const char *)Dtool_EggGroup_clear_default_pose_496_comment},
  {"set_scroll_u", &Dtool_EggGroup_set_scroll_u_497, METH_O, (const char *)Dtool_EggGroup_set_scroll_u_497_comment},
  {"setScrollU", &Dtool_EggGroup_set_scroll_u_497, METH_O, (const char *)Dtool_EggGroup_set_scroll_u_497_comment},
  {"set_scroll_v", &Dtool_EggGroup_set_scroll_v_498, METH_O, (const char *)Dtool_EggGroup_set_scroll_v_498_comment},
  {"setScrollV", &Dtool_EggGroup_set_scroll_v_498, METH_O, (const char *)Dtool_EggGroup_set_scroll_v_498_comment},
  {"set_scroll_w", &Dtool_EggGroup_set_scroll_w_499, METH_O, (const char *)Dtool_EggGroup_set_scroll_w_499_comment},
  {"setScrollW", &Dtool_EggGroup_set_scroll_w_499, METH_O, (const char *)Dtool_EggGroup_set_scroll_w_499_comment},
  {"set_scroll_r", &Dtool_EggGroup_set_scroll_r_500, METH_O, (const char *)Dtool_EggGroup_set_scroll_r_500_comment},
  {"setScrollR", &Dtool_EggGroup_set_scroll_r_500, METH_O, (const char *)Dtool_EggGroup_set_scroll_r_500_comment},
  {"get_scroll_u", &Dtool_EggGroup_get_scroll_u_501, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_u_501_comment},
  {"getScrollU", &Dtool_EggGroup_get_scroll_u_501, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_u_501_comment},
  {"get_scroll_v", &Dtool_EggGroup_get_scroll_v_502, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_v_502_comment},
  {"getScrollV", &Dtool_EggGroup_get_scroll_v_502, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_v_502_comment},
  {"get_scroll_w", &Dtool_EggGroup_get_scroll_w_503, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_w_503_comment},
  {"getScrollW", &Dtool_EggGroup_get_scroll_w_503, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_w_503_comment},
  {"get_scroll_r", &Dtool_EggGroup_get_scroll_r_504, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_r_504_comment},
  {"getScrollR", &Dtool_EggGroup_get_scroll_r_504, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_r_504_comment},
  {"has_scrolling_uvs", &Dtool_EggGroup_has_scrolling_uvs_505, METH_NOARGS, (const char *)Dtool_EggGroup_has_scrolling_uvs_505_comment},
  {"hasScrollingUvs", &Dtool_EggGroup_has_scrolling_uvs_505, METH_NOARGS, (const char *)Dtool_EggGroup_has_scrolling_uvs_505_comment},
  {"ref_vertex", (PyCFunction) &Dtool_EggGroup_ref_vertex_554, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_ref_vertex_554_comment},
  {"refVertex", (PyCFunction) &Dtool_EggGroup_ref_vertex_554, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_ref_vertex_554_comment},
  {"unref_vertex", &Dtool_EggGroup_unref_vertex_555, METH_O, (const char *)Dtool_EggGroup_unref_vertex_555_comment},
  {"unrefVertex", &Dtool_EggGroup_unref_vertex_555, METH_O, (const char *)Dtool_EggGroup_unref_vertex_555_comment},
  {"unref_all_vertices", &Dtool_EggGroup_unref_all_vertices_556, METH_NOARGS, (const char *)Dtool_EggGroup_unref_all_vertices_556_comment},
  {"unrefAllVertices", &Dtool_EggGroup_unref_all_vertices_556, METH_NOARGS, (const char *)Dtool_EggGroup_unref_all_vertices_556_comment},
  {"get_vertex_membership", &Dtool_EggGroup_get_vertex_membership_557, METH_O, (const char *)Dtool_EggGroup_get_vertex_membership_557_comment},
  {"getVertexMembership", &Dtool_EggGroup_get_vertex_membership_557, METH_O, (const char *)Dtool_EggGroup_get_vertex_membership_557_comment},
  {"set_vertex_membership", (PyCFunction) &Dtool_EggGroup_set_vertex_membership_558, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_set_vertex_membership_558_comment},
  {"setVertexMembership", (PyCFunction) &Dtool_EggGroup_set_vertex_membership_558, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_set_vertex_membership_558_comment},
  {"steal_vrefs", &Dtool_EggGroup_steal_vrefs_559, METH_O, (const char *)Dtool_EggGroup_steal_vrefs_559_comment},
  {"stealVrefs", &Dtool_EggGroup_steal_vrefs_559, METH_O, (const char *)Dtool_EggGroup_steal_vrefs_559_comment},
  {"test_vref_integrity", &Dtool_EggGroup_test_vref_integrity_560, METH_NOARGS, (const char *)Dtool_EggGroup_test_vref_integrity_560_comment},
  {"testVrefIntegrity", &Dtool_EggGroup_test_vref_integrity_560, METH_NOARGS, (const char *)Dtool_EggGroup_test_vref_integrity_560_comment},
  {"add_group_ref", &Dtool_EggGroup_add_group_ref_561, METH_O, (const char *)Dtool_EggGroup_add_group_ref_561_comment},
  {"addGroupRef", &Dtool_EggGroup_add_group_ref_561, METH_O, (const char *)Dtool_EggGroup_add_group_ref_561_comment},
  {"get_num_group_refs", &Dtool_EggGroup_get_num_group_refs_562, METH_NOARGS, (const char *)Dtool_EggGroup_get_num_group_refs_562_comment},
  {"getNumGroupRefs", &Dtool_EggGroup_get_num_group_refs_562, METH_NOARGS, (const char *)Dtool_EggGroup_get_num_group_refs_562_comment},
  {"get_group_ref", &Dtool_EggGroup_get_group_ref_563, METH_O, (const char *)Dtool_EggGroup_get_group_ref_563_comment},
  {"getGroupRef", &Dtool_EggGroup_get_group_ref_563, METH_O, (const char *)Dtool_EggGroup_get_group_ref_563_comment},
  {"remove_group_ref", &Dtool_EggGroup_remove_group_ref_565, METH_O, (const char *)Dtool_EggGroup_remove_group_ref_565_comment},
  {"removeGroupRef", &Dtool_EggGroup_remove_group_ref_565, METH_O, (const char *)Dtool_EggGroup_remove_group_ref_565_comment},
  {"clear_group_refs", &Dtool_EggGroup_clear_group_refs_566, METH_NOARGS, (const char *)Dtool_EggGroup_clear_group_refs_566_comment},
  {"clearGroupRefs", &Dtool_EggGroup_clear_group_refs_566, METH_NOARGS, (const char *)Dtool_EggGroup_clear_group_refs_566_comment},
  {"string_group_type", &Dtool_EggGroup_string_group_type_567, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_group_type_567_comment},
  {"stringGroupType", &Dtool_EggGroup_string_group_type_567, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_group_type_567_comment},
  {"string_dart_type", &Dtool_EggGroup_string_dart_type_568, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_dart_type_568_comment},
  {"stringDartType", &Dtool_EggGroup_string_dart_type_568, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_dart_type_568_comment},
  {"string_dcs_type", &Dtool_EggGroup_string_dcs_type_569, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_dcs_type_569_comment},
  {"stringDcsType", &Dtool_EggGroup_string_dcs_type_569, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_dcs_type_569_comment},
  {"string_billboard_type", &Dtool_EggGroup_string_billboard_type_570, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_billboard_type_570_comment},
  {"stringBillboardType", &Dtool_EggGroup_string_billboard_type_570, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_billboard_type_570_comment},
  {"string_cs_type", &Dtool_EggGroup_string_cs_type_571, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_cs_type_571_comment},
  {"stringCsType", &Dtool_EggGroup_string_cs_type_571, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_cs_type_571_comment},
  {"string_collide_flags", &Dtool_EggGroup_string_collide_flags_572, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_collide_flags_572_comment},
  {"stringCollideFlags", &Dtool_EggGroup_string_collide_flags_572, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_collide_flags_572_comment},
  {"string_blend_mode", &Dtool_EggGroup_string_blend_mode_573, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_blend_mode_573_comment},
  {"stringBlendMode", &Dtool_EggGroup_string_blend_mode_573, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_blend_mode_573_comment},
  {"string_blend_operand", &Dtool_EggGroup_string_blend_operand_574, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_blend_operand_574_comment},
  {"stringBlendOperand", &Dtool_EggGroup_string_blend_operand_574, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_blend_operand_574_comment},
  {"get_class_type", &Dtool_EggGroup_get_class_type_575, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroup_get_class_type_575_comment},
  {"getClassType", &Dtool_EggGroup_get_class_type_575, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroup_get_class_type_575_comment},
  {"upcast_to_EggGroupNode", &Dtool_EggGroup_upcast_to_EggGroupNode_370, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggGroupNode_370_comment},
  {"upcastToEggGroupNode", &Dtool_EggGroup_upcast_to_EggGroupNode_370, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggGroupNode_370_comment},
  {"upcast_to_EggRenderMode", &Dtool_EggGroup_upcast_to_EggRenderMode_372, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggRenderMode_372_comment},
  {"upcastToEggRenderMode", &Dtool_EggGroup_upcast_to_EggRenderMode_372, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggRenderMode_372_comment},
  {"upcast_to_EggTransform", &Dtool_EggGroup_upcast_to_EggTransform_374, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggTransform_374_comment},
  {"upcastToEggTransform", &Dtool_EggGroup_upcast_to_EggTransform_374, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggTransform_374_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_object_types", (PyCFunction) &MakeSeq_EggGroup_get_object_types, METH_NOARGS, NULL},
  { "getObjectTypes", (PyCFunction) &MakeSeq_EggGroup_get_object_types, METH_NOARGS, NULL},
  {"get_group_refs", (PyCFunction) &MakeSeq_EggGroup_get_group_refs, METH_NOARGS, NULL},
  { "getGroupRefs", (PyCFunction) &MakeSeq_EggGroup_get_group_refs, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     EggGroup
//////////////////
static PyObject *Dtool_Str_EggGroup(PyObject *self) {
  EggGroup *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_EggGroup[] = {
  {(char *)"group_type", &Dtool_EggGroup_group_type_Getter, &Dtool_EggGroup_group_type_Setter, NULL, NULL},
  {(char *)"billboard_type", &Dtool_EggGroup_billboard_type_Getter, &Dtool_EggGroup_billboard_type_Setter, NULL, NULL},
  {(char *)"billboard_center", &Dtool_EggGroup_billboard_center_Getter, &Dtool_EggGroup_billboard_center_Setter, NULL, NULL},
  {(char *)"cs_type", &Dtool_EggGroup_cs_type_Getter, &Dtool_EggGroup_cs_type_Setter, NULL, NULL},
  {(char *)"collide_flags", &Dtool_EggGroup_collide_flags_Getter, &Dtool_EggGroup_collide_flags_Setter, NULL, NULL},
  {(char *)"collision_name", &Dtool_EggGroup_collision_name_Getter, &Dtool_EggGroup_collision_name_Setter, NULL, NULL},
  {(char *)"dcs_type", &Dtool_EggGroup_dcs_type_Getter, &Dtool_EggGroup_dcs_type_Setter, NULL, NULL},
  {(char *)"dart_type", &Dtool_EggGroup_dart_type_Getter, &Dtool_EggGroup_dart_type_Setter, NULL, NULL},
  {(char *)"switch_flag", &Dtool_EggGroup_switch_flag_Getter, &Dtool_EggGroup_switch_flag_Setter, NULL, NULL},
  {(char *)"switch_fps", &Dtool_EggGroup_switch_fps_Getter, &Dtool_EggGroup_switch_fps_Setter, NULL, NULL},
  {(char *)"object_types", &Dtool_EggGroup_object_types_Getter, NULL, NULL, NULL},
  {(char *)"model_flag", &Dtool_EggGroup_model_flag_Getter, &Dtool_EggGroup_model_flag_Setter, NULL, NULL},
  {(char *)"texlist_flag", &Dtool_EggGroup_texlist_flag_Getter, &Dtool_EggGroup_texlist_flag_Setter, NULL, NULL},
  {(char *)"nofog_flag", &Dtool_EggGroup_nofog_flag_Getter, &Dtool_EggGroup_nofog_flag_Setter, NULL, NULL},
  {(char *)"decal_flag", &Dtool_EggGroup_decal_flag_Getter, &Dtool_EggGroup_decal_flag_Setter, NULL, NULL},
  {(char *)"direct_flag", &Dtool_EggGroup_direct_flag_Getter, &Dtool_EggGroup_direct_flag_Setter, NULL, NULL},
  {(char *)"portal_flag", &Dtool_EggGroup_portal_flag_Getter, &Dtool_EggGroup_portal_flag_Setter, NULL, NULL},
  {(char *)"occluder_flag", &Dtool_EggGroup_occluder_flag_Getter, &Dtool_EggGroup_occluder_flag_Setter, NULL, NULL},
  {(char *)"indexed_flag", &Dtool_EggGroup_indexed_flag_Getter, &Dtool_EggGroup_indexed_flag_Setter, NULL, NULL},
  {(char *)"collide_mask", &Dtool_EggGroup_collide_mask_Getter, &Dtool_EggGroup_collide_mask_Setter, NULL, NULL},
  {(char *)"from_collide_mask", &Dtool_EggGroup_from_collide_mask_Getter, &Dtool_EggGroup_from_collide_mask_Setter, NULL, NULL},
  {(char *)"into_collide_mask", &Dtool_EggGroup_into_collide_mask_Getter, &Dtool_EggGroup_into_collide_mask_Setter, NULL, NULL},
  {(char *)"blend_mode", &Dtool_EggGroup_blend_mode_Getter, &Dtool_EggGroup_blend_mode_Setter, NULL, NULL},
  {(char *)"blend_operand_a", &Dtool_EggGroup_blend_operand_a_Getter, &Dtool_EggGroup_blend_operand_a_Setter, NULL, NULL},
  {(char *)"blend_operand_b", &Dtool_EggGroup_blend_operand_b_Getter, &Dtool_EggGroup_blend_operand_b_Setter, NULL, NULL},
  {(char *)"blend_color", &Dtool_EggGroup_blend_color_Getter, &Dtool_EggGroup_blend_color_Setter, NULL, NULL},
  {(char *)"lod", &Dtool_EggGroup_lod_Getter, &Dtool_EggGroup_lod_Setter, NULL, NULL},
  {(char *)"default_pose", &Dtool_EggGroup_default_pose_Getter, &Dtool_EggGroup_default_pose_Setter, NULL, NULL},
  {(char *)"scroll_u", &Dtool_EggGroup_scroll_u_Getter, &Dtool_EggGroup_scroll_u_Setter, NULL, NULL},
  {(char *)"scroll_v", &Dtool_EggGroup_scroll_v_Getter, &Dtool_EggGroup_scroll_v_Setter, NULL, NULL},
  {(char *)"scroll_w", &Dtool_EggGroup_scroll_w_Getter, &Dtool_EggGroup_scroll_w_Setter, NULL, NULL},
  {(char *)"scroll_r", &Dtool_EggGroup_scroll_r_Getter, &Dtool_EggGroup_scroll_r_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_EggGroup = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggGroup = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggGroup = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggGroup = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggGroup = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggGroup",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggGroup,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggGroup,
    &Dtool_SequenceMethods_EggGroup,
    &Dtool_MappingMethods_EggGroup,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_EggGroup,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggGroup,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The main glue of the egg hierarchy, this corresponds to the <Group>,\n"
    " * <Instance>, and <Joint> type nodes.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggGroup,
    0, // tp_members
    Dtool_Properties_EggGroup,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggGroup,
    PyType_GenericAlloc,
    Dtool_new_EggGroup,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggGroup,
  Dtool_UpcastInterface_EggGroup,
  Dtool_DowncastInterface_EggGroup,
  (CoerceFunction)Dtool_ConstCoerce_EggGroup,
  (CoerceFunction)Dtool_Coerce_EggGroup,
};

static void Dtool_PyModuleClassInit_EggGroup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggGroupNode(NULL);
    Dtool_PyModuleClassInit_EggRenderMode(NULL);
    Dtool_PyModuleClassInit_EggTransform(NULL);
    Dtool_EggGroup._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)&Dtool_EggGroupNode, (PyTypeObject *)&Dtool_EggRenderMode, (PyTypeObject *)&Dtool_EggTransform);
    PyObject *dict = _PyDict_NewPresized(129);
    Dtool_EggGroup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggGroup::GroupType;
    PyDict_SetItemString(dict, "GT_invalid", Dtool_WrapValue(EggGroup::GT_invalid));
    PyDict_SetItemString(dict, "GTInvalid", Dtool_WrapValue(EggGroup::GT_invalid));
    PyDict_SetItemString(dict, "GT_group", Dtool_WrapValue(EggGroup::GT_group));
    PyDict_SetItemString(dict, "GTGroup", Dtool_WrapValue(EggGroup::GT_group));
    PyDict_SetItemString(dict, "GT_instance", Dtool_WrapValue(EggGroup::GT_instance));
    PyDict_SetItemString(dict, "GTInstance", Dtool_WrapValue(EggGroup::GT_instance));
    PyDict_SetItemString(dict, "GT_joint", Dtool_WrapValue(EggGroup::GT_joint));
    PyDict_SetItemString(dict, "GTJoint", Dtool_WrapValue(EggGroup::GT_joint));
    // enum EggGroup::DCSType;
    PyDict_SetItemString(dict, "DC_unspecified", Dtool_WrapValue(EggGroup::DC_unspecified));
    PyDict_SetItemString(dict, "DCUnspecified", Dtool_WrapValue(EggGroup::DC_unspecified));
    PyDict_SetItemString(dict, "DC_none", Dtool_WrapValue(EggGroup::DC_none));
    PyDict_SetItemString(dict, "DCNone", Dtool_WrapValue(EggGroup::DC_none));
    PyDict_SetItemString(dict, "DC_local", Dtool_WrapValue(EggGroup::DC_local));
    PyDict_SetItemString(dict, "DCLocal", Dtool_WrapValue(EggGroup::DC_local));
    PyDict_SetItemString(dict, "DC_net", Dtool_WrapValue(EggGroup::DC_net));
    PyDict_SetItemString(dict, "DCNet", Dtool_WrapValue(EggGroup::DC_net));
    PyDict_SetItemString(dict, "DC_no_touch", Dtool_WrapValue(EggGroup::DC_no_touch));
    PyDict_SetItemString(dict, "DCNoTouch", Dtool_WrapValue(EggGroup::DC_no_touch));
    PyDict_SetItemString(dict, "DC_default", Dtool_WrapValue(EggGroup::DC_default));
    PyDict_SetItemString(dict, "DCDefault", Dtool_WrapValue(EggGroup::DC_default));
    // enum EggGroup::BillboardType;
    PyDict_SetItemString(dict, "BT_none", Dtool_WrapValue(EggGroup::BT_none));
    PyDict_SetItemString(dict, "BTNone", Dtool_WrapValue(EggGroup::BT_none));
    PyDict_SetItemString(dict, "BT_axis", Dtool_WrapValue(EggGroup::BT_axis));
    PyDict_SetItemString(dict, "BTAxis", Dtool_WrapValue(EggGroup::BT_axis));
    PyDict_SetItemString(dict, "BT_point_camera_relative", Dtool_WrapValue(EggGroup::BT_point_camera_relative));
    PyDict_SetItemString(dict, "BTPointCameraRelative", Dtool_WrapValue(EggGroup::BT_point_camera_relative));
    PyDict_SetItemString(dict, "BT_point_world_relative", Dtool_WrapValue(EggGroup::BT_point_world_relative));
    PyDict_SetItemString(dict, "BTPointWorldRelative", Dtool_WrapValue(EggGroup::BT_point_world_relative));
    // enum EggGroup::CollisionSolidType;
    PyDict_SetItemString(dict, "CST_none", Dtool_WrapValue(EggGroup::CST_none));
    PyDict_SetItemString(dict, "CSTNone", Dtool_WrapValue(EggGroup::CST_none));
    PyDict_SetItemString(dict, "CST_plane", Dtool_WrapValue(EggGroup::CST_plane));
    PyDict_SetItemString(dict, "CSTPlane", Dtool_WrapValue(EggGroup::CST_plane));
    PyDict_SetItemString(dict, "CST_polygon", Dtool_WrapValue(EggGroup::CST_polygon));
    PyDict_SetItemString(dict, "CSTPolygon", Dtool_WrapValue(EggGroup::CST_polygon));
    PyDict_SetItemString(dict, "CST_polyset", Dtool_WrapValue(EggGroup::CST_polyset));
    PyDict_SetItemString(dict, "CSTPolyset", Dtool_WrapValue(EggGroup::CST_polyset));
    PyDict_SetItemString(dict, "CST_sphere", Dtool_WrapValue(EggGroup::CST_sphere));
    PyDict_SetItemString(dict, "CSTSphere", Dtool_WrapValue(EggGroup::CST_sphere));
    PyDict_SetItemString(dict, "CST_tube", Dtool_WrapValue(EggGroup::CST_tube));
    PyDict_SetItemString(dict, "CSTTube", Dtool_WrapValue(EggGroup::CST_tube));
    PyDict_SetItemString(dict, "CST_inv_sphere", Dtool_WrapValue(EggGroup::CST_inv_sphere));
    PyDict_SetItemString(dict, "CSTInvSphere", Dtool_WrapValue(EggGroup::CST_inv_sphere));
    PyDict_SetItemString(dict, "CST_box", Dtool_WrapValue(EggGroup::CST_box));
    PyDict_SetItemString(dict, "CSTBox", Dtool_WrapValue(EggGroup::CST_box));
    PyDict_SetItemString(dict, "CST_floor_mesh", Dtool_WrapValue(EggGroup::CST_floor_mesh));
    PyDict_SetItemString(dict, "CSTFloorMesh", Dtool_WrapValue(EggGroup::CST_floor_mesh));
    // enum EggGroup::CollideFlags;
    PyDict_SetItemString(dict, "CF_none", Dtool_WrapValue(EggGroup::CF_none));
    PyDict_SetItemString(dict, "CFNone", Dtool_WrapValue(EggGroup::CF_none));
    PyDict_SetItemString(dict, "CF_descend", Dtool_WrapValue(EggGroup::CF_descend));
    PyDict_SetItemString(dict, "CFDescend", Dtool_WrapValue(EggGroup::CF_descend));
    PyDict_SetItemString(dict, "CF_event", Dtool_WrapValue(EggGroup::CF_event));
    PyDict_SetItemString(dict, "CFEvent", Dtool_WrapValue(EggGroup::CF_event));
    PyDict_SetItemString(dict, "CF_keep", Dtool_WrapValue(EggGroup::CF_keep));
    PyDict_SetItemString(dict, "CFKeep", Dtool_WrapValue(EggGroup::CF_keep));
    PyDict_SetItemString(dict, "CF_solid", Dtool_WrapValue(EggGroup::CF_solid));
    PyDict_SetItemString(dict, "CFSolid", Dtool_WrapValue(EggGroup::CF_solid));
    PyDict_SetItemString(dict, "CF_center", Dtool_WrapValue(EggGroup::CF_center));
    PyDict_SetItemString(dict, "CFCenter", Dtool_WrapValue(EggGroup::CF_center));
    PyDict_SetItemString(dict, "CF_turnstile", Dtool_WrapValue(EggGroup::CF_turnstile));
    PyDict_SetItemString(dict, "CFTurnstile", Dtool_WrapValue(EggGroup::CF_turnstile));
    PyDict_SetItemString(dict, "CF_level", Dtool_WrapValue(EggGroup::CF_level));
    PyDict_SetItemString(dict, "CFLevel", Dtool_WrapValue(EggGroup::CF_level));
    PyDict_SetItemString(dict, "CF_intangible", Dtool_WrapValue(EggGroup::CF_intangible));
    PyDict_SetItemString(dict, "CFIntangible", Dtool_WrapValue(EggGroup::CF_intangible));
    // enum EggGroup::DartType;
    PyDict_SetItemString(dict, "DT_none", Dtool_WrapValue(EggGroup::DT_none));
    PyDict_SetItemString(dict, "DTNone", Dtool_WrapValue(EggGroup::DT_none));
    PyDict_SetItemString(dict, "DT_structured", Dtool_WrapValue(EggGroup::DT_structured));
    PyDict_SetItemString(dict, "DTStructured", Dtool_WrapValue(EggGroup::DT_structured));
    PyDict_SetItemString(dict, "DT_sync", Dtool_WrapValue(EggGroup::DT_sync));
    PyDict_SetItemString(dict, "DTSync", Dtool_WrapValue(EggGroup::DT_sync));
    PyDict_SetItemString(dict, "DT_nosync", Dtool_WrapValue(EggGroup::DT_nosync));
    PyDict_SetItemString(dict, "DTNosync", Dtool_WrapValue(EggGroup::DT_nosync));
    PyDict_SetItemString(dict, "DT_default", Dtool_WrapValue(EggGroup::DT_default));
    PyDict_SetItemString(dict, "DTDefault", Dtool_WrapValue(EggGroup::DT_default));
    // enum EggGroup::BlendMode;
    PyDict_SetItemString(dict, "BM_unspecified", Dtool_WrapValue(EggGroup::BM_unspecified));
    PyDict_SetItemString(dict, "BMUnspecified", Dtool_WrapValue(EggGroup::BM_unspecified));
    PyDict_SetItemString(dict, "BM_none", Dtool_WrapValue(EggGroup::BM_none));
    PyDict_SetItemString(dict, "BMNone", Dtool_WrapValue(EggGroup::BM_none));
    PyDict_SetItemString(dict, "BM_add", Dtool_WrapValue(EggGroup::BM_add));
    PyDict_SetItemString(dict, "BMAdd", Dtool_WrapValue(EggGroup::BM_add));
    PyDict_SetItemString(dict, "BM_subtract", Dtool_WrapValue(EggGroup::BM_subtract));
    PyDict_SetItemString(dict, "BMSubtract", Dtool_WrapValue(EggGroup::BM_subtract));
    PyDict_SetItemString(dict, "BM_inv_subtract", Dtool_WrapValue(EggGroup::BM_inv_subtract));
    PyDict_SetItemString(dict, "BMInvSubtract", Dtool_WrapValue(EggGroup::BM_inv_subtract));
    PyDict_SetItemString(dict, "BM_min", Dtool_WrapValue(EggGroup::BM_min));
    PyDict_SetItemString(dict, "BMMin", Dtool_WrapValue(EggGroup::BM_min));
    PyDict_SetItemString(dict, "BM_max", Dtool_WrapValue(EggGroup::BM_max));
    PyDict_SetItemString(dict, "BMMax", Dtool_WrapValue(EggGroup::BM_max));
    // enum EggGroup::BlendOperand;
    PyDict_SetItemString(dict, "BO_unspecified", Dtool_WrapValue(EggGroup::BO_unspecified));
    PyDict_SetItemString(dict, "BOUnspecified", Dtool_WrapValue(EggGroup::BO_unspecified));
    PyDict_SetItemString(dict, "BO_zero", Dtool_WrapValue(EggGroup::BO_zero));
    PyDict_SetItemString(dict, "BOZero", Dtool_WrapValue(EggGroup::BO_zero));
    PyDict_SetItemString(dict, "BO_one", Dtool_WrapValue(EggGroup::BO_one));
    PyDict_SetItemString(dict, "BOOne", Dtool_WrapValue(EggGroup::BO_one));
    PyDict_SetItemString(dict, "BO_incoming_color", Dtool_WrapValue(EggGroup::BO_incoming_color));
    PyDict_SetItemString(dict, "BOIncomingColor", Dtool_WrapValue(EggGroup::BO_incoming_color));
    PyDict_SetItemString(dict, "BO_one_minus_incoming_color", Dtool_WrapValue(EggGroup::BO_one_minus_incoming_color));
    PyDict_SetItemString(dict, "BOOneMinusIncomingColor", Dtool_WrapValue(EggGroup::BO_one_minus_incoming_color));
    PyDict_SetItemString(dict, "BO_fbuffer_color", Dtool_WrapValue(EggGroup::BO_fbuffer_color));
    PyDict_SetItemString(dict, "BOFbufferColor", Dtool_WrapValue(EggGroup::BO_fbuffer_color));
    PyDict_SetItemString(dict, "BO_one_minus_fbuffer_color", Dtool_WrapValue(EggGroup::BO_one_minus_fbuffer_color));
    PyDict_SetItemString(dict, "BOOneMinusFbufferColor", Dtool_WrapValue(EggGroup::BO_one_minus_fbuffer_color));
    PyDict_SetItemString(dict, "BO_incoming_alpha", Dtool_WrapValue(EggGroup::BO_incoming_alpha));
    PyDict_SetItemString(dict, "BOIncomingAlpha", Dtool_WrapValue(EggGroup::BO_incoming_alpha));
    PyDict_SetItemString(dict, "BO_one_minus_incoming_alpha", Dtool_WrapValue(EggGroup::BO_one_minus_incoming_alpha));
    PyDict_SetItemString(dict, "BOOneMinusIncomingAlpha", Dtool_WrapValue(EggGroup::BO_one_minus_incoming_alpha));
    PyDict_SetItemString(dict, "BO_fbuffer_alpha", Dtool_WrapValue(EggGroup::BO_fbuffer_alpha));
    PyDict_SetItemString(dict, "BOFbufferAlpha", Dtool_WrapValue(EggGroup::BO_fbuffer_alpha));
    PyDict_SetItemString(dict, "BO_one_minus_fbuffer_alpha", Dtool_WrapValue(EggGroup::BO_one_minus_fbuffer_alpha));
    PyDict_SetItemString(dict, "BOOneMinusFbufferAlpha", Dtool_WrapValue(EggGroup::BO_one_minus_fbuffer_alpha));
    PyDict_SetItemString(dict, "BO_constant_color", Dtool_WrapValue(EggGroup::BO_constant_color));
    PyDict_SetItemString(dict, "BOConstantColor", Dtool_WrapValue(EggGroup::BO_constant_color));
    PyDict_SetItemString(dict, "BO_one_minus_constant_color", Dtool_WrapValue(EggGroup::BO_one_minus_constant_color));
    PyDict_SetItemString(dict, "BOOneMinusConstantColor", Dtool_WrapValue(EggGroup::BO_one_minus_constant_color));
    PyDict_SetItemString(dict, "BO_constant_alpha", Dtool_WrapValue(EggGroup::BO_constant_alpha));
    PyDict_SetItemString(dict, "BOConstantAlpha", Dtool_WrapValue(EggGroup::BO_constant_alpha));
    PyDict_SetItemString(dict, "BO_one_minus_constant_alpha", Dtool_WrapValue(EggGroup::BO_one_minus_constant_alpha));
    PyDict_SetItemString(dict, "BOOneMinusConstantAlpha", Dtool_WrapValue(EggGroup::BO_one_minus_constant_alpha));
    PyDict_SetItemString(dict, "BO_incoming_color_saturate", Dtool_WrapValue(EggGroup::BO_incoming_color_saturate));
    PyDict_SetItemString(dict, "BOIncomingColorSaturate", Dtool_WrapValue(EggGroup::BO_incoming_color_saturate));
    PyDict_SetItemString(dict, "BO_color_scale", Dtool_WrapValue(EggGroup::BO_color_scale));
    PyDict_SetItemString(dict, "BOColorScale", Dtool_WrapValue(EggGroup::BO_color_scale));
    PyDict_SetItemString(dict, "BO_one_minus_color_scale", Dtool_WrapValue(EggGroup::BO_one_minus_color_scale));
    PyDict_SetItemString(dict, "BOOneMinusColorScale", Dtool_WrapValue(EggGroup::BO_one_minus_color_scale));
    PyDict_SetItemString(dict, "BO_alpha_scale", Dtool_WrapValue(EggGroup::BO_alpha_scale));
    PyDict_SetItemString(dict, "BOAlphaScale", Dtool_WrapValue(EggGroup::BO_alpha_scale));
    PyDict_SetItemString(dict, "BO_one_minus_alpha_scale", Dtool_WrapValue(EggGroup::BO_one_minus_alpha_scale));
    PyDict_SetItemString(dict, "BOOneMinusAlphaScale", Dtool_WrapValue(EggGroup::BO_one_minus_alpha_scale));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggGroup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggGroup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggGroup);
  }
}

/**
 * Python method tables for EggBin (EggBin)
 */
static PyMethodDef Dtool_Methods_EggBin[] = {
  {"set_bin_number", &Dtool_EggBin_set_bin_number_578, METH_O, (const char *)Dtool_EggBin_set_bin_number_578_comment},
  {"setBinNumber", &Dtool_EggBin_set_bin_number_578, METH_O, (const char *)Dtool_EggBin_set_bin_number_578_comment},
  {"get_bin_number", &Dtool_EggBin_get_bin_number_579, METH_NOARGS, (const char *)Dtool_EggBin_get_bin_number_579_comment},
  {"getBinNumber", &Dtool_EggBin_get_bin_number_579, METH_NOARGS, (const char *)Dtool_EggBin_get_bin_number_579_comment},
  {"get_class_type", &Dtool_EggBin_get_class_type_580, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggBin_get_class_type_580_comment},
  {"getClassType", &Dtool_EggBin_get_class_type_580, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggBin_get_class_type_580_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggBin = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggBin = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggBin = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggBin = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggBin = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggBin",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggBin,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggBin,
    &Dtool_SequenceMethods_EggBin,
    &Dtool_MappingMethods_EggBin,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggBin,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A type of group node that holds related subnodes.  This is a special kind\n"
    " * of node that will never be read in from an egg file, but can only exist in\n"
    " * the egg scene graph if it is created via the use of an EggBinMaker.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggBin,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggBin,
    PyType_GenericAlloc,
    Dtool_new_EggBin,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggBin,
  Dtool_UpcastInterface_EggBin,
  Dtool_DowncastInterface_EggBin,
  (CoerceFunction)Dtool_ConstCoerce_EggBin,
  (CoerceFunction)Dtool_Coerce_EggBin,
};

static void Dtool_PyModuleClassInit_EggBin(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggGroup(NULL);
    Dtool_EggBin._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggGroup);
    PyObject *dict = PyDict_New();
    Dtool_EggBin._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggBin) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggBin)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggBin);
  }
}

/**
 * Python method tables for EggBinMaker (EggBinMaker)
 */
static PyMethodDef Dtool_Methods_EggBinMaker[] = {
  {"make_bins", &Dtool_EggBinMaker_make_bins_583, METH_O, (const char *)Dtool_EggBinMaker_make_bins_583_comment},
  {"makeBins", &Dtool_EggBinMaker_make_bins_583, METH_O, (const char *)Dtool_EggBinMaker_make_bins_583_comment},
  {"prepare_node", &Dtool_EggBinMaker_prepare_node_584, METH_O, (const char *)Dtool_EggBinMaker_prepare_node_584_comment},
  {"prepareNode", &Dtool_EggBinMaker_prepare_node_584, METH_O, (const char *)Dtool_EggBinMaker_prepare_node_584_comment},
  {"get_bin_number", &Dtool_EggBinMaker_get_bin_number_585, METH_O, (const char *)Dtool_EggBinMaker_get_bin_number_585_comment},
  {"getBinNumber", &Dtool_EggBinMaker_get_bin_number_585, METH_O, (const char *)Dtool_EggBinMaker_get_bin_number_585_comment},
  {"sorts_less", (PyCFunction) &Dtool_EggBinMaker_sorts_less_586, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_sorts_less_586_comment},
  {"sortsLess", (PyCFunction) &Dtool_EggBinMaker_sorts_less_586, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_sorts_less_586_comment},
  {"collapse_group", (PyCFunction) &Dtool_EggBinMaker_collapse_group_587, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_collapse_group_587_comment},
  {"collapseGroup", (PyCFunction) &Dtool_EggBinMaker_collapse_group_587, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_collapse_group_587_comment},
  {"get_bin_name", (PyCFunction) &Dtool_EggBinMaker_get_bin_name_588, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_get_bin_name_588_comment},
  {"getBinName", (PyCFunction) &Dtool_EggBinMaker_get_bin_name_588, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_get_bin_name_588_comment},
  {"make_bin", (PyCFunction) &Dtool_EggBinMaker_make_bin_589, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_make_bin_589_comment},
  {"makeBin", (PyCFunction) &Dtool_EggBinMaker_make_bin_589, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_make_bin_589_comment},
  {"get_class_type", &Dtool_EggBinMaker_get_class_type_590, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggBinMaker_get_class_type_590_comment},
  {"getClassType", &Dtool_EggBinMaker_get_class_type_590, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggBinMaker_get_class_type_590_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggBinMaker = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggBinMaker = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggBinMaker = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggBinMaker = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggBinMaker = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggBinMaker",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggBinMaker,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggBinMaker,
    &Dtool_SequenceMethods_EggBinMaker,
    &Dtool_MappingMethods_EggBinMaker,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggBinMaker,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a handy class for collecting related nodes together.  It is an\n"
    " * abstract class; to use it you must subclass off of it.  See the somewhat\n"
    " * lengthy comment above.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggBinMaker,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggBinMaker,
    PyType_GenericAlloc,
    Dtool_new_EggBinMaker,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggBinMaker,
  Dtool_UpcastInterface_EggBinMaker,
  Dtool_DowncastInterface_EggBinMaker,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggBinMaker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggObject(NULL);
    Dtool_EggBinMaker._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggObject);
    PyObject *dict = PyDict_New();
    Dtool_EggBinMaker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggBinMaker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggBinMaker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggBinMaker);
  }
}

/**
 * Python method tables for EggComment (EggComment)
 */
static PyMethodDef Dtool_Methods_EggComment[] = {
  {"assign", &Dtool_EggComment_operator_593, METH_O, (const char *)Dtool_EggComment_operator_593_comment},
  {"set_comment", &Dtool_EggComment_set_comment_595, METH_O, (const char *)Dtool_EggComment_set_comment_595_comment},
  {"setComment", &Dtool_EggComment_set_comment_595, METH_O, (const char *)Dtool_EggComment_set_comment_595_comment},
  {"get_comment", &Dtool_EggComment_get_comment_596, METH_NOARGS, (const char *)Dtool_EggComment_get_comment_596_comment},
  {"getComment", &Dtool_EggComment_get_comment_596, METH_NOARGS, (const char *)Dtool_EggComment_get_comment_596_comment},
  {"get_class_type", &Dtool_EggComment_get_class_type_597, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggComment_get_class_type_597_comment},
  {"getClassType", &Dtool_EggComment_get_class_type_597, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggComment_get_class_type_597_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggComment slot tp_str -> operator typecast
//////////////////
static PyObject *Dtool_EggComment_operator_typecast_594_tp_str(PyObject *self) {
  EggComment *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggComment, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &EggComment::operator typecast(void) const
  std::string const &return_value = (std::string const &)*(const EggComment*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast(EggComment self)\n");
  }
  return NULL;
}

static PyNumberMethods Dtool_NumberMethods_EggComment = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggComment = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggComment = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggComment = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggComment = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggComment",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggComment,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggComment,
    &Dtool_SequenceMethods_EggComment,
    &Dtool_MappingMethods_EggComment,
    0, // tp_hash
    0, // tp_call
    &Dtool_EggComment_operator_typecast_594_tp_str,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggComment,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A comment that appears in an egg file within a <Comment> entry.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggComment,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggComment,
    PyType_GenericAlloc,
    Dtool_new_EggComment,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggComment,
  Dtool_UpcastInterface_EggComment,
  Dtool_DowncastInterface_EggComment,
  (CoerceFunction)Dtool_ConstCoerce_EggComment,
  (CoerceFunction)Dtool_Coerce_EggComment,
};

static void Dtool_PyModuleClassInit_EggComment(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(NULL);
    Dtool_EggComment._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    PyObject *dict = PyDict_New();
    Dtool_EggComment._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggComment) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggComment)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggComment);
  }
}

/**
 * Python method tables for EggFilenameNode (EggFilenameNode)
 */
static PyMethodDef Dtool_Methods_EggFilenameNode[] = {
  {"assign", &Dtool_EggFilenameNode_operator_600, METH_O, (const char *)Dtool_EggFilenameNode_operator_600_comment},
  {"get_default_extension", &Dtool_EggFilenameNode_get_default_extension_601, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_default_extension_601_comment},
  {"getDefaultExtension", &Dtool_EggFilenameNode_get_default_extension_601, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_default_extension_601_comment},
  {"get_filename", &Dtool_EggFilenameNode_get_filename_602, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_filename_602_comment},
  {"getFilename", &Dtool_EggFilenameNode_get_filename_602, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_filename_602_comment},
  {"set_filename", &Dtool_EggFilenameNode_set_filename_603, METH_O, (const char *)Dtool_EggFilenameNode_set_filename_603_comment},
  {"setFilename", &Dtool_EggFilenameNode_set_filename_603, METH_O, (const char *)Dtool_EggFilenameNode_set_filename_603_comment},
  {"get_fullpath", &Dtool_EggFilenameNode_get_fullpath_604, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_fullpath_604_comment},
  {"getFullpath", &Dtool_EggFilenameNode_get_fullpath_604, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_fullpath_604_comment},
  {"set_fullpath", &Dtool_EggFilenameNode_set_fullpath_605, METH_O, (const char *)Dtool_EggFilenameNode_set_fullpath_605_comment},
  {"setFullpath", &Dtool_EggFilenameNode_set_fullpath_605, METH_O, (const char *)Dtool_EggFilenameNode_set_fullpath_605_comment},
  {"get_class_type", &Dtool_EggFilenameNode_get_class_type_606, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggFilenameNode_get_class_type_606_comment},
  {"getClassType", &Dtool_EggFilenameNode_get_class_type_606, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggFilenameNode_get_class_type_606_comment},
  {"downcast_to_EggTexture", &Dtool_EggFilenameNode_downcast_to_EggTexture_610, METH_NOARGS, (const char *)Dtool_EggFilenameNode_downcast_to_EggTexture_610_comment},
  {"downcastToEggTexture", &Dtool_EggFilenameNode_downcast_to_EggTexture_610, METH_NOARGS, (const char *)Dtool_EggFilenameNode_downcast_to_EggTexture_610_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggFilenameNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggFilenameNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggFilenameNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggFilenameNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggFilenameNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggFilenameNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggFilenameNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggFilenameNode,
    &Dtool_SequenceMethods_EggFilenameNode,
    &Dtool_MappingMethods_EggFilenameNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggFilenameNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an egg node that contains a filename.  It references a physical\n"
    " * file relative to the directory the egg file was loaded in.  It is a base\n"
    " * class for EggTexture and EggExternalReference.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggFilenameNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggFilenameNode,
    PyType_GenericAlloc,
    Dtool_new_EggFilenameNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggFilenameNode,
  Dtool_UpcastInterface_EggFilenameNode,
  Dtool_DowncastInterface_EggFilenameNode,
  (CoerceFunction)Dtool_ConstCoerce_EggFilenameNode,
  (CoerceFunction)Dtool_Coerce_EggFilenameNode,
};

static void Dtool_PyModuleClassInit_EggFilenameNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(NULL);
    Dtool_EggFilenameNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    PyObject *dict = PyDict_New();
    Dtool_EggFilenameNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggFilenameNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggFilenameNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggFilenameNode);
  }
}

/**
 * Python method tables for EggTexture (EggTexture)
 */
static PyMethodDef Dtool_Methods_EggTexture[] = {
  {"assign", &Dtool_EggTexture_operator_616, METH_O, (const char *)Dtool_EggTexture_operator_616_comment},
  {"write", (PyCFunction) &Dtool_EggTexture_write_618, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_write_618_comment},
  {"is_equivalent_to", (PyCFunction) &Dtool_EggTexture_is_equivalent_to_620, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_is_equivalent_to_620_comment},
  {"isEquivalentTo", (PyCFunction) &Dtool_EggTexture_is_equivalent_to_620, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_is_equivalent_to_620_comment},
  {"sorts_less_than", (PyCFunction) &Dtool_EggTexture_sorts_less_than_621, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_sorts_less_than_621_comment},
  {"sortsLessThan", (PyCFunction) &Dtool_EggTexture_sorts_less_than_621, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_sorts_less_than_621_comment},
  {"has_alpha_channel", &Dtool_EggTexture_has_alpha_channel_622, METH_O, (const char *)Dtool_EggTexture_has_alpha_channel_622_comment},
  {"hasAlphaChannel", &Dtool_EggTexture_has_alpha_channel_622, METH_O, (const char *)Dtool_EggTexture_has_alpha_channel_622_comment},
  {"set_texture_type", &Dtool_EggTexture_set_texture_type_636, METH_O, (const char *)Dtool_EggTexture_set_texture_type_636_comment},
  {"setTextureType", &Dtool_EggTexture_set_texture_type_636, METH_O, (const char *)Dtool_EggTexture_set_texture_type_636_comment},
  {"get_texture_type", &Dtool_EggTexture_get_texture_type_637, METH_NOARGS, (const char *)Dtool_EggTexture_get_texture_type_637_comment},
  {"getTextureType", &Dtool_EggTexture_get_texture_type_637, METH_NOARGS, (const char *)Dtool_EggTexture_get_texture_type_637_comment},
  {"set_format", &Dtool_EggTexture_set_format_638, METH_O, (const char *)Dtool_EggTexture_set_format_638_comment},
  {"setFormat", &Dtool_EggTexture_set_format_638, METH_O, (const char *)Dtool_EggTexture_set_format_638_comment},
  {"get_format", &Dtool_EggTexture_get_format_639, METH_NOARGS, (const char *)Dtool_EggTexture_get_format_639_comment},
  {"getFormat", &Dtool_EggTexture_get_format_639, METH_NOARGS, (const char *)Dtool_EggTexture_get_format_639_comment},
  {"set_compression_mode", &Dtool_EggTexture_set_compression_mode_640, METH_O, (const char *)Dtool_EggTexture_set_compression_mode_640_comment},
  {"setCompressionMode", &Dtool_EggTexture_set_compression_mode_640, METH_O, (const char *)Dtool_EggTexture_set_compression_mode_640_comment},
  {"get_compression_mode", &Dtool_EggTexture_get_compression_mode_641, METH_NOARGS, (const char *)Dtool_EggTexture_get_compression_mode_641_comment},
  {"getCompressionMode", &Dtool_EggTexture_get_compression_mode_641, METH_NOARGS, (const char *)Dtool_EggTexture_get_compression_mode_641_comment},
  {"set_wrap_mode", &Dtool_EggTexture_set_wrap_mode_642, METH_O, (const char *)Dtool_EggTexture_set_wrap_mode_642_comment},
  {"setWrapMode", &Dtool_EggTexture_set_wrap_mode_642, METH_O, (const char *)Dtool_EggTexture_set_wrap_mode_642_comment},
  {"get_wrap_mode", &Dtool_EggTexture_get_wrap_mode_643, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_mode_643_comment},
  {"getWrapMode", &Dtool_EggTexture_get_wrap_mode_643, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_mode_643_comment},
  {"set_wrap_u", &Dtool_EggTexture_set_wrap_u_644, METH_O, (const char *)Dtool_EggTexture_set_wrap_u_644_comment},
  {"setWrapU", &Dtool_EggTexture_set_wrap_u_644, METH_O, (const char *)Dtool_EggTexture_set_wrap_u_644_comment},
  {"get_wrap_u", &Dtool_EggTexture_get_wrap_u_645, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_u_645_comment},
  {"getWrapU", &Dtool_EggTexture_get_wrap_u_645, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_u_645_comment},
  {"determine_wrap_u", &Dtool_EggTexture_determine_wrap_u_646, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_u_646_comment},
  {"determineWrapU", &Dtool_EggTexture_determine_wrap_u_646, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_u_646_comment},
  {"set_wrap_v", &Dtool_EggTexture_set_wrap_v_647, METH_O, (const char *)Dtool_EggTexture_set_wrap_v_647_comment},
  {"setWrapV", &Dtool_EggTexture_set_wrap_v_647, METH_O, (const char *)Dtool_EggTexture_set_wrap_v_647_comment},
  {"get_wrap_v", &Dtool_EggTexture_get_wrap_v_648, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_v_648_comment},
  {"getWrapV", &Dtool_EggTexture_get_wrap_v_648, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_v_648_comment},
  {"determine_wrap_v", &Dtool_EggTexture_determine_wrap_v_649, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_v_649_comment},
  {"determineWrapV", &Dtool_EggTexture_determine_wrap_v_649, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_v_649_comment},
  {"set_wrap_w", &Dtool_EggTexture_set_wrap_w_650, METH_O, (const char *)Dtool_EggTexture_set_wrap_w_650_comment},
  {"setWrapW", &Dtool_EggTexture_set_wrap_w_650, METH_O, (const char *)Dtool_EggTexture_set_wrap_w_650_comment},
  {"get_wrap_w", &Dtool_EggTexture_get_wrap_w_651, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_w_651_comment},
  {"getWrapW", &Dtool_EggTexture_get_wrap_w_651, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_w_651_comment},
  {"determine_wrap_w", &Dtool_EggTexture_determine_wrap_w_652, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_w_652_comment},
  {"determineWrapW", &Dtool_EggTexture_determine_wrap_w_652, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_w_652_comment},
  {"set_minfilter", &Dtool_EggTexture_set_minfilter_653, METH_O, (const char *)Dtool_EggTexture_set_minfilter_653_comment},
  {"setMinfilter", &Dtool_EggTexture_set_minfilter_653, METH_O, (const char *)Dtool_EggTexture_set_minfilter_653_comment},
  {"get_minfilter", &Dtool_EggTexture_get_minfilter_654, METH_NOARGS, (const char *)Dtool_EggTexture_get_minfilter_654_comment},
  {"getMinfilter", &Dtool_EggTexture_get_minfilter_654, METH_NOARGS, (const char *)Dtool_EggTexture_get_minfilter_654_comment},
  {"set_magfilter", &Dtool_EggTexture_set_magfilter_655, METH_O, (const char *)Dtool_EggTexture_set_magfilter_655_comment},
  {"setMagfilter", &Dtool_EggTexture_set_magfilter_655, METH_O, (const char *)Dtool_EggTexture_set_magfilter_655_comment},
  {"get_magfilter", &Dtool_EggTexture_get_magfilter_656, METH_NOARGS, (const char *)Dtool_EggTexture_get_magfilter_656_comment},
  {"getMagfilter", &Dtool_EggTexture_get_magfilter_656, METH_NOARGS, (const char *)Dtool_EggTexture_get_magfilter_656_comment},
  {"set_anisotropic_degree", &Dtool_EggTexture_set_anisotropic_degree_657, METH_O, (const char *)Dtool_EggTexture_set_anisotropic_degree_657_comment},
  {"setAnisotropicDegree", &Dtool_EggTexture_set_anisotropic_degree_657, METH_O, (const char *)Dtool_EggTexture_set_anisotropic_degree_657_comment},
  {"clear_anisotropic_degree", &Dtool_EggTexture_clear_anisotropic_degree_658, METH_NOARGS, (const char *)Dtool_EggTexture_clear_anisotropic_degree_658_comment},
  {"clearAnisotropicDegree", &Dtool_EggTexture_clear_anisotropic_degree_658, METH_NOARGS, (const char *)Dtool_EggTexture_clear_anisotropic_degree_658_comment},
  {"has_anisotropic_degree", &Dtool_EggTexture_has_anisotropic_degree_659, METH_NOARGS, (const char *)Dtool_EggTexture_has_anisotropic_degree_659_comment},
  {"hasAnisotropicDegree", &Dtool_EggTexture_has_anisotropic_degree_659, METH_NOARGS, (const char *)Dtool_EggTexture_has_anisotropic_degree_659_comment},
  {"get_anisotropic_degree", &Dtool_EggTexture_get_anisotropic_degree_660, METH_NOARGS, (const char *)Dtool_EggTexture_get_anisotropic_degree_660_comment},
  {"getAnisotropicDegree", &Dtool_EggTexture_get_anisotropic_degree_660, METH_NOARGS, (const char *)Dtool_EggTexture_get_anisotropic_degree_660_comment},
  {"set_env_type", &Dtool_EggTexture_set_env_type_661, METH_O, (const char *)Dtool_EggTexture_set_env_type_661_comment},
  {"setEnvType", &Dtool_EggTexture_set_env_type_661, METH_O, (const char *)Dtool_EggTexture_set_env_type_661_comment},
  {"get_env_type", &Dtool_EggTexture_get_env_type_662, METH_NOARGS, (const char *)Dtool_EggTexture_get_env_type_662_comment},
  {"getEnvType", &Dtool_EggTexture_get_env_type_662, METH_NOARGS, (const char *)Dtool_EggTexture_get_env_type_662_comment},
  {"affects_polygon_alpha", &Dtool_EggTexture_affects_polygon_alpha_663, METH_NOARGS, (const char *)Dtool_EggTexture_affects_polygon_alpha_663_comment},
  {"affectsPolygonAlpha", &Dtool_EggTexture_affects_polygon_alpha_663, METH_NOARGS, (const char *)Dtool_EggTexture_affects_polygon_alpha_663_comment},
  {"set_combine_mode", (PyCFunction) &Dtool_EggTexture_set_combine_mode_664, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_mode_664_comment},
  {"setCombineMode", (PyCFunction) &Dtool_EggTexture_set_combine_mode_664, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_mode_664_comment},
  {"get_combine_mode", &Dtool_EggTexture_get_combine_mode_665, METH_O, (const char *)Dtool_EggTexture_get_combine_mode_665_comment},
  {"getCombineMode", &Dtool_EggTexture_get_combine_mode_665, METH_O, (const char *)Dtool_EggTexture_get_combine_mode_665_comment},
  {"set_combine_source", (PyCFunction) &Dtool_EggTexture_set_combine_source_666, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_source_666_comment},
  {"setCombineSource", (PyCFunction) &Dtool_EggTexture_set_combine_source_666, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_source_666_comment},
  {"get_combine_source", (PyCFunction) &Dtool_EggTexture_get_combine_source_667, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_get_combine_source_667_comment},
  {"getCombineSource", (PyCFunction) &Dtool_EggTexture_get_combine_source_667, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_get_combine_source_667_comment},
  {"set_combine_operand", (PyCFunction) &Dtool_EggTexture_set_combine_operand_668, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_operand_668_comment},
  {"setCombineOperand", (PyCFunction) &Dtool_EggTexture_set_combine_operand_668, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_operand_668_comment},
  {"get_combine_operand", (PyCFunction) &Dtool_EggTexture_get_combine_operand_669, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_get_combine_operand_669_comment},
  {"getCombineOperand", (PyCFunction) &Dtool_EggTexture_get_combine_operand_669, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_get_combine_operand_669_comment},
  {"set_saved_result", &Dtool_EggTexture_set_saved_result_670, METH_O, (const char *)Dtool_EggTexture_set_saved_result_670_comment},
  {"setSavedResult", &Dtool_EggTexture_set_saved_result_670, METH_O, (const char *)Dtool_EggTexture_set_saved_result_670_comment},
  {"get_saved_result", &Dtool_EggTexture_get_saved_result_671, METH_NOARGS, (const char *)Dtool_EggTexture_get_saved_result_671_comment},
  {"getSavedResult", &Dtool_EggTexture_get_saved_result_671, METH_NOARGS, (const char *)Dtool_EggTexture_get_saved_result_671_comment},
  {"set_tex_gen", &Dtool_EggTexture_set_tex_gen_672, METH_O, (const char *)Dtool_EggTexture_set_tex_gen_672_comment},
  {"setTexGen", &Dtool_EggTexture_set_tex_gen_672, METH_O, (const char *)Dtool_EggTexture_set_tex_gen_672_comment},
  {"get_tex_gen", &Dtool_EggTexture_get_tex_gen_673, METH_NOARGS, (const char *)Dtool_EggTexture_get_tex_gen_673_comment},
  {"getTexGen", &Dtool_EggTexture_get_tex_gen_673, METH_NOARGS, (const char *)Dtool_EggTexture_get_tex_gen_673_comment},
  {"set_quality_level", &Dtool_EggTexture_set_quality_level_674, METH_O, (const char *)Dtool_EggTexture_set_quality_level_674_comment},
  {"setQualityLevel", &Dtool_EggTexture_set_quality_level_674, METH_O, (const char *)Dtool_EggTexture_set_quality_level_674_comment},
  {"get_quality_level", &Dtool_EggTexture_get_quality_level_675, METH_NOARGS, (const char *)Dtool_EggTexture_get_quality_level_675_comment},
  {"getQualityLevel", &Dtool_EggTexture_get_quality_level_675, METH_NOARGS, (const char *)Dtool_EggTexture_get_quality_level_675_comment},
  {"set_stage_name", &Dtool_EggTexture_set_stage_name_676, METH_O, (const char *)Dtool_EggTexture_set_stage_name_676_comment},
  {"setStageName", &Dtool_EggTexture_set_stage_name_676, METH_O, (const char *)Dtool_EggTexture_set_stage_name_676_comment},
  {"clear_stage_name", &Dtool_EggTexture_clear_stage_name_677, METH_NOARGS, (const char *)Dtool_EggTexture_clear_stage_name_677_comment},
  {"clearStageName", &Dtool_EggTexture_clear_stage_name_677, METH_NOARGS, (const char *)Dtool_EggTexture_clear_stage_name_677_comment},
  {"has_stage_name", &Dtool_EggTexture_has_stage_name_678, METH_NOARGS, (const char *)Dtool_EggTexture_has_stage_name_678_comment},
  {"hasStageName", &Dtool_EggTexture_has_stage_name_678, METH_NOARGS, (const char *)Dtool_EggTexture_has_stage_name_678_comment},
  {"get_stage_name", &Dtool_EggTexture_get_stage_name_679, METH_NOARGS, (const char *)Dtool_EggTexture_get_stage_name_679_comment},
  {"getStageName", &Dtool_EggTexture_get_stage_name_679, METH_NOARGS, (const char *)Dtool_EggTexture_get_stage_name_679_comment},
  {"set_priority", &Dtool_EggTexture_set_priority_680, METH_O, (const char *)Dtool_EggTexture_set_priority_680_comment},
  {"setPriority", &Dtool_EggTexture_set_priority_680, METH_O, (const char *)Dtool_EggTexture_set_priority_680_comment},
  {"clear_priority", &Dtool_EggTexture_clear_priority_681, METH_NOARGS, (const char *)Dtool_EggTexture_clear_priority_681_comment},
  {"clearPriority", &Dtool_EggTexture_clear_priority_681, METH_NOARGS, (const char *)Dtool_EggTexture_clear_priority_681_comment},
  {"has_priority", &Dtool_EggTexture_has_priority_682, METH_NOARGS, (const char *)Dtool_EggTexture_has_priority_682_comment},
  {"hasPriority", &Dtool_EggTexture_has_priority_682, METH_NOARGS, (const char *)Dtool_EggTexture_has_priority_682_comment},
  {"get_priority", &Dtool_EggTexture_get_priority_683, METH_NOARGS, (const char *)Dtool_EggTexture_get_priority_683_comment},
  {"getPriority", &Dtool_EggTexture_get_priority_683, METH_NOARGS, (const char *)Dtool_EggTexture_get_priority_683_comment},
  {"set_color", &Dtool_EggTexture_set_color_684, METH_O, (const char *)Dtool_EggTexture_set_color_684_comment},
  {"setColor", &Dtool_EggTexture_set_color_684, METH_O, (const char *)Dtool_EggTexture_set_color_684_comment},
  {"clear_color", &Dtool_EggTexture_clear_color_685, METH_NOARGS, (const char *)Dtool_EggTexture_clear_color_685_comment},
  {"clearColor", &Dtool_EggTexture_clear_color_685, METH_NOARGS, (const char *)Dtool_EggTexture_clear_color_685_comment},
  {"has_color", &Dtool_EggTexture_has_color_686, METH_NOARGS, (const char *)Dtool_EggTexture_has_color_686_comment},
  {"hasColor", &Dtool_EggTexture_has_color_686, METH_NOARGS, (const char *)Dtool_EggTexture_has_color_686_comment},
  {"get_color", &Dtool_EggTexture_get_color_687, METH_NOARGS, (const char *)Dtool_EggTexture_get_color_687_comment},
  {"getColor", &Dtool_EggTexture_get_color_687, METH_NOARGS, (const char *)Dtool_EggTexture_get_color_687_comment},
  {"set_border_color", &Dtool_EggTexture_set_border_color_688, METH_O, (const char *)Dtool_EggTexture_set_border_color_688_comment},
  {"setBorderColor", &Dtool_EggTexture_set_border_color_688, METH_O, (const char *)Dtool_EggTexture_set_border_color_688_comment},
  {"clear_border_color", &Dtool_EggTexture_clear_border_color_689, METH_NOARGS, (const char *)Dtool_EggTexture_clear_border_color_689_comment},
  {"clearBorderColor", &Dtool_EggTexture_clear_border_color_689, METH_NOARGS, (const char *)Dtool_EggTexture_clear_border_color_689_comment},
  {"has_border_color", &Dtool_EggTexture_has_border_color_690, METH_NOARGS, (const char *)Dtool_EggTexture_has_border_color_690_comment},
  {"hasBorderColor", &Dtool_EggTexture_has_border_color_690, METH_NOARGS, (const char *)Dtool_EggTexture_has_border_color_690_comment},
  {"get_border_color", &Dtool_EggTexture_get_border_color_691, METH_NOARGS, (const char *)Dtool_EggTexture_get_border_color_691_comment},
  {"getBorderColor", &Dtool_EggTexture_get_border_color_691, METH_NOARGS, (const char *)Dtool_EggTexture_get_border_color_691_comment},
  {"set_uv_name", &Dtool_EggTexture_set_uv_name_692, METH_O, (const char *)Dtool_EggTexture_set_uv_name_692_comment},
  {"setUvName", &Dtool_EggTexture_set_uv_name_692, METH_O, (const char *)Dtool_EggTexture_set_uv_name_692_comment},
  {"clear_uv_name", &Dtool_EggTexture_clear_uv_name_693, METH_NOARGS, (const char *)Dtool_EggTexture_clear_uv_name_693_comment},
  {"clearUvName", &Dtool_EggTexture_clear_uv_name_693, METH_NOARGS, (const char *)Dtool_EggTexture_clear_uv_name_693_comment},
  {"has_uv_name", &Dtool_EggTexture_has_uv_name_694, METH_NOARGS, (const char *)Dtool_EggTexture_has_uv_name_694_comment},
  {"hasUvName", &Dtool_EggTexture_has_uv_name_694, METH_NOARGS, (const char *)Dtool_EggTexture_has_uv_name_694_comment},
  {"get_uv_name", &Dtool_EggTexture_get_uv_name_695, METH_NOARGS, (const char *)Dtool_EggTexture_get_uv_name_695_comment},
  {"getUvName", &Dtool_EggTexture_get_uv_name_695, METH_NOARGS, (const char *)Dtool_EggTexture_get_uv_name_695_comment},
  {"set_rgb_scale", &Dtool_EggTexture_set_rgb_scale_696, METH_O, (const char *)Dtool_EggTexture_set_rgb_scale_696_comment},
  {"setRgbScale", &Dtool_EggTexture_set_rgb_scale_696, METH_O, (const char *)Dtool_EggTexture_set_rgb_scale_696_comment},
  {"clear_rgb_scale", &Dtool_EggTexture_clear_rgb_scale_697, METH_NOARGS, (const char *)Dtool_EggTexture_clear_rgb_scale_697_comment},
  {"clearRgbScale", &Dtool_EggTexture_clear_rgb_scale_697, METH_NOARGS, (const char *)Dtool_EggTexture_clear_rgb_scale_697_comment},
  {"has_rgb_scale", &Dtool_EggTexture_has_rgb_scale_698, METH_NOARGS, (const char *)Dtool_EggTexture_has_rgb_scale_698_comment},
  {"hasRgbScale", &Dtool_EggTexture_has_rgb_scale_698, METH_NOARGS, (const char *)Dtool_EggTexture_has_rgb_scale_698_comment},
  {"get_rgb_scale", &Dtool_EggTexture_get_rgb_scale_699, METH_NOARGS, (const char *)Dtool_EggTexture_get_rgb_scale_699_comment},
  {"getRgbScale", &Dtool_EggTexture_get_rgb_scale_699, METH_NOARGS, (const char *)Dtool_EggTexture_get_rgb_scale_699_comment},
  {"set_alpha_scale", &Dtool_EggTexture_set_alpha_scale_700, METH_O, (const char *)Dtool_EggTexture_set_alpha_scale_700_comment},
  {"setAlphaScale", &Dtool_EggTexture_set_alpha_scale_700, METH_O, (const char *)Dtool_EggTexture_set_alpha_scale_700_comment},
  {"clear_alpha_scale", &Dtool_EggTexture_clear_alpha_scale_701, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_scale_701_comment},
  {"clearAlphaScale", &Dtool_EggTexture_clear_alpha_scale_701, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_scale_701_comment},
  {"has_alpha_scale", &Dtool_EggTexture_has_alpha_scale_702, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_scale_702_comment},
  {"hasAlphaScale", &Dtool_EggTexture_has_alpha_scale_702, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_scale_702_comment},
  {"get_alpha_scale", &Dtool_EggTexture_get_alpha_scale_703, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_scale_703_comment},
  {"getAlphaScale", &Dtool_EggTexture_get_alpha_scale_703, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_scale_703_comment},
  {"set_alpha_filename", &Dtool_EggTexture_set_alpha_filename_704, METH_O, (const char *)Dtool_EggTexture_set_alpha_filename_704_comment},
  {"setAlphaFilename", &Dtool_EggTexture_set_alpha_filename_704, METH_O, (const char *)Dtool_EggTexture_set_alpha_filename_704_comment},
  {"clear_alpha_filename", &Dtool_EggTexture_clear_alpha_filename_705, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_filename_705_comment},
  {"clearAlphaFilename", &Dtool_EggTexture_clear_alpha_filename_705, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_filename_705_comment},
  {"has_alpha_filename", &Dtool_EggTexture_has_alpha_filename_706, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_filename_706_comment},
  {"hasAlphaFilename", &Dtool_EggTexture_has_alpha_filename_706, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_filename_706_comment},
  {"get_alpha_filename", &Dtool_EggTexture_get_alpha_filename_707, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_filename_707_comment},
  {"getAlphaFilename", &Dtool_EggTexture_get_alpha_filename_707, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_filename_707_comment},
  {"set_alpha_fullpath", &Dtool_EggTexture_set_alpha_fullpath_708, METH_O, (const char *)Dtool_EggTexture_set_alpha_fullpath_708_comment},
  {"setAlphaFullpath", &Dtool_EggTexture_set_alpha_fullpath_708, METH_O, (const char *)Dtool_EggTexture_set_alpha_fullpath_708_comment},
  {"get_alpha_fullpath", &Dtool_EggTexture_get_alpha_fullpath_709, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_fullpath_709_comment},
  {"getAlphaFullpath", &Dtool_EggTexture_get_alpha_fullpath_709, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_fullpath_709_comment},
  {"set_alpha_file_channel", &Dtool_EggTexture_set_alpha_file_channel_710, METH_O, (const char *)Dtool_EggTexture_set_alpha_file_channel_710_comment},
  {"setAlphaFileChannel", &Dtool_EggTexture_set_alpha_file_channel_710, METH_O, (const char *)Dtool_EggTexture_set_alpha_file_channel_710_comment},
  {"clear_alpha_file_channel", &Dtool_EggTexture_clear_alpha_file_channel_711, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_file_channel_711_comment},
  {"clearAlphaFileChannel", &Dtool_EggTexture_clear_alpha_file_channel_711, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_file_channel_711_comment},
  {"has_alpha_file_channel", &Dtool_EggTexture_has_alpha_file_channel_712, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_file_channel_712_comment},
  {"hasAlphaFileChannel", &Dtool_EggTexture_has_alpha_file_channel_712, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_file_channel_712_comment},
  {"get_alpha_file_channel", &Dtool_EggTexture_get_alpha_file_channel_713, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_file_channel_713_comment},
  {"getAlphaFileChannel", &Dtool_EggTexture_get_alpha_file_channel_713, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_file_channel_713_comment},
  {"set_multiview", &Dtool_EggTexture_set_multiview_714, METH_O, (const char *)Dtool_EggTexture_set_multiview_714_comment},
  {"setMultiview", &Dtool_EggTexture_set_multiview_714, METH_O, (const char *)Dtool_EggTexture_set_multiview_714_comment},
  {"get_multiview", &Dtool_EggTexture_get_multiview_715, METH_NOARGS, (const char *)Dtool_EggTexture_get_multiview_715_comment},
  {"getMultiview", &Dtool_EggTexture_get_multiview_715, METH_NOARGS, (const char *)Dtool_EggTexture_get_multiview_715_comment},
  {"set_num_views", &Dtool_EggTexture_set_num_views_716, METH_O, (const char *)Dtool_EggTexture_set_num_views_716_comment},
  {"setNumViews", &Dtool_EggTexture_set_num_views_716, METH_O, (const char *)Dtool_EggTexture_set_num_views_716_comment},
  {"clear_num_views", &Dtool_EggTexture_clear_num_views_717, METH_NOARGS, (const char *)Dtool_EggTexture_clear_num_views_717_comment},
  {"clearNumViews", &Dtool_EggTexture_clear_num_views_717, METH_NOARGS, (const char *)Dtool_EggTexture_clear_num_views_717_comment},
  {"has_num_views", &Dtool_EggTexture_has_num_views_718, METH_NOARGS, (const char *)Dtool_EggTexture_has_num_views_718_comment},
  {"hasNumViews", &Dtool_EggTexture_has_num_views_718, METH_NOARGS, (const char *)Dtool_EggTexture_has_num_views_718_comment},
  {"get_num_views", &Dtool_EggTexture_get_num_views_719, METH_NOARGS, (const char *)Dtool_EggTexture_get_num_views_719_comment},
  {"getNumViews", &Dtool_EggTexture_get_num_views_719, METH_NOARGS, (const char *)Dtool_EggTexture_get_num_views_719_comment},
  {"set_read_mipmaps", &Dtool_EggTexture_set_read_mipmaps_720, METH_O, (const char *)Dtool_EggTexture_set_read_mipmaps_720_comment},
  {"setReadMipmaps", &Dtool_EggTexture_set_read_mipmaps_720, METH_O, (const char *)Dtool_EggTexture_set_read_mipmaps_720_comment},
  {"get_read_mipmaps", &Dtool_EggTexture_get_read_mipmaps_721, METH_NOARGS, (const char *)Dtool_EggTexture_get_read_mipmaps_721_comment},
  {"getReadMipmaps", &Dtool_EggTexture_get_read_mipmaps_721, METH_NOARGS, (const char *)Dtool_EggTexture_get_read_mipmaps_721_comment},
  {"set_min_lod", &Dtool_EggTexture_set_min_lod_722, METH_O, (const char *)Dtool_EggTexture_set_min_lod_722_comment},
  {"setMinLod", &Dtool_EggTexture_set_min_lod_722, METH_O, (const char *)Dtool_EggTexture_set_min_lod_722_comment},
  {"clear_min_lod", &Dtool_EggTexture_clear_min_lod_723, METH_NOARGS, (const char *)Dtool_EggTexture_clear_min_lod_723_comment},
  {"clearMinLod", &Dtool_EggTexture_clear_min_lod_723, METH_NOARGS, (const char *)Dtool_EggTexture_clear_min_lod_723_comment},
  {"has_min_lod", &Dtool_EggTexture_has_min_lod_724, METH_NOARGS, (const char *)Dtool_EggTexture_has_min_lod_724_comment},
  {"hasMinLod", &Dtool_EggTexture_has_min_lod_724, METH_NOARGS, (const char *)Dtool_EggTexture_has_min_lod_724_comment},
  {"get_min_lod", &Dtool_EggTexture_get_min_lod_725, METH_NOARGS, (const char *)Dtool_EggTexture_get_min_lod_725_comment},
  {"getMinLod", &Dtool_EggTexture_get_min_lod_725, METH_NOARGS, (const char *)Dtool_EggTexture_get_min_lod_725_comment},
  {"set_max_lod", &Dtool_EggTexture_set_max_lod_726, METH_O, (const char *)Dtool_EggTexture_set_max_lod_726_comment},
  {"setMaxLod", &Dtool_EggTexture_set_max_lod_726, METH_O, (const char *)Dtool_EggTexture_set_max_lod_726_comment},
  {"clear_max_lod", &Dtool_EggTexture_clear_max_lod_727, METH_NOARGS, (const char *)Dtool_EggTexture_clear_max_lod_727_comment},
  {"clearMaxLod", &Dtool_EggTexture_clear_max_lod_727, METH_NOARGS, (const char *)Dtool_EggTexture_clear_max_lod_727_comment},
  {"has_max_lod", &Dtool_EggTexture_has_max_lod_728, METH_NOARGS, (const char *)Dtool_EggTexture_has_max_lod_728_comment},
  {"hasMaxLod", &Dtool_EggTexture_has_max_lod_728, METH_NOARGS, (const char *)Dtool_EggTexture_has_max_lod_728_comment},
  {"get_max_lod", &Dtool_EggTexture_get_max_lod_729, METH_NOARGS, (const char *)Dtool_EggTexture_get_max_lod_729_comment},
  {"getMaxLod", &Dtool_EggTexture_get_max_lod_729, METH_NOARGS, (const char *)Dtool_EggTexture_get_max_lod_729_comment},
  {"set_lod_bias", &Dtool_EggTexture_set_lod_bias_730, METH_O, (const char *)Dtool_EggTexture_set_lod_bias_730_comment},
  {"setLodBias", &Dtool_EggTexture_set_lod_bias_730, METH_O, (const char *)Dtool_EggTexture_set_lod_bias_730_comment},
  {"clear_lod_bias", &Dtool_EggTexture_clear_lod_bias_731, METH_NOARGS, (const char *)Dtool_EggTexture_clear_lod_bias_731_comment},
  {"clearLodBias", &Dtool_EggTexture_clear_lod_bias_731, METH_NOARGS, (const char *)Dtool_EggTexture_clear_lod_bias_731_comment},
  {"has_lod_bias", &Dtool_EggTexture_has_lod_bias_732, METH_NOARGS, (const char *)Dtool_EggTexture_has_lod_bias_732_comment},
  {"hasLodBias", &Dtool_EggTexture_has_lod_bias_732, METH_NOARGS, (const char *)Dtool_EggTexture_has_lod_bias_732_comment},
  {"get_lod_bias", &Dtool_EggTexture_get_lod_bias_733, METH_NOARGS, (const char *)Dtool_EggTexture_get_lod_bias_733_comment},
  {"getLodBias", &Dtool_EggTexture_get_lod_bias_733, METH_NOARGS, (const char *)Dtool_EggTexture_get_lod_bias_733_comment},
  {"clear_multitexture", &Dtool_EggTexture_clear_multitexture_734, METH_NOARGS, (const char *)Dtool_EggTexture_clear_multitexture_734_comment},
  {"clearMultitexture", &Dtool_EggTexture_clear_multitexture_734, METH_NOARGS, (const char *)Dtool_EggTexture_clear_multitexture_734_comment},
  {"multitexture_over", &Dtool_EggTexture_multitexture_over_735, METH_O, (const char *)Dtool_EggTexture_multitexture_over_735_comment},
  {"multitextureOver", &Dtool_EggTexture_multitexture_over_735, METH_O, (const char *)Dtool_EggTexture_multitexture_over_735_comment},
  {"get_multitexture_sort", &Dtool_EggTexture_get_multitexture_sort_736, METH_NOARGS, (const char *)Dtool_EggTexture_get_multitexture_sort_736_comment},
  {"getMultitextureSort", &Dtool_EggTexture_get_multitexture_sort_736, METH_NOARGS, (const char *)Dtool_EggTexture_get_multitexture_sort_736_comment},
  {"string_texture_type", &Dtool_EggTexture_string_texture_type_737, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_texture_type_737_comment},
  {"stringTextureType", &Dtool_EggTexture_string_texture_type_737, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_texture_type_737_comment},
  {"string_format", &Dtool_EggTexture_string_format_738, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_format_738_comment},
  {"stringFormat", &Dtool_EggTexture_string_format_738, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_format_738_comment},
  {"string_compression_mode", &Dtool_EggTexture_string_compression_mode_739, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_compression_mode_739_comment},
  {"stringCompressionMode", &Dtool_EggTexture_string_compression_mode_739, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_compression_mode_739_comment},
  {"string_wrap_mode", &Dtool_EggTexture_string_wrap_mode_740, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_wrap_mode_740_comment},
  {"stringWrapMode", &Dtool_EggTexture_string_wrap_mode_740, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_wrap_mode_740_comment},
  {"string_filter_type", &Dtool_EggTexture_string_filter_type_741, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_filter_type_741_comment},
  {"stringFilterType", &Dtool_EggTexture_string_filter_type_741, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_filter_type_741_comment},
  {"string_env_type", &Dtool_EggTexture_string_env_type_742, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_env_type_742_comment},
  {"stringEnvType", &Dtool_EggTexture_string_env_type_742, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_env_type_742_comment},
  {"string_combine_mode", &Dtool_EggTexture_string_combine_mode_743, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_mode_743_comment},
  {"stringCombineMode", &Dtool_EggTexture_string_combine_mode_743, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_mode_743_comment},
  {"string_combine_source", &Dtool_EggTexture_string_combine_source_744, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_source_744_comment},
  {"stringCombineSource", &Dtool_EggTexture_string_combine_source_744, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_source_744_comment},
  {"string_combine_operand", &Dtool_EggTexture_string_combine_operand_745, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_operand_745_comment},
  {"stringCombineOperand", &Dtool_EggTexture_string_combine_operand_745, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_operand_745_comment},
  {"string_tex_gen", &Dtool_EggTexture_string_tex_gen_746, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_tex_gen_746_comment},
  {"stringTexGen", &Dtool_EggTexture_string_tex_gen_746, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_tex_gen_746_comment},
  {"string_quality_level", &Dtool_EggTexture_string_quality_level_747, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_quality_level_747_comment},
  {"stringQualityLevel", &Dtool_EggTexture_string_quality_level_747, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_quality_level_747_comment},
  {"get_class_type", &Dtool_EggTexture_get_class_type_782, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTexture_get_class_type_782_comment},
  {"getClassType", &Dtool_EggTexture_get_class_type_782, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTexture_get_class_type_782_comment},
  {"upcast_to_EggFilenameNode", &Dtool_EggTexture_upcast_to_EggFilenameNode_609, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggFilenameNode_609_comment},
  {"upcastToEggFilenameNode", &Dtool_EggTexture_upcast_to_EggFilenameNode_609, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggFilenameNode_609_comment},
  {"upcast_to_EggRenderMode", &Dtool_EggTexture_upcast_to_EggRenderMode_611, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggRenderMode_611_comment},
  {"upcastToEggRenderMode", &Dtool_EggTexture_upcast_to_EggRenderMode_611, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggRenderMode_611_comment},
  {"upcast_to_EggTransform", &Dtool_EggTexture_upcast_to_EggTransform_613, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggTransform_613_comment},
  {"upcastToEggTransform", &Dtool_EggTexture_upcast_to_EggTransform_613, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggTransform_613_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     EggTexture
//////////////////
static PyObject *Dtool_Str_EggTexture(PyObject *self) {
  EggTexture *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_EggTexture[] = {
  {(char *)"texture_type", &Dtool_EggTexture_texture_type_Getter, &Dtool_EggTexture_texture_type_Setter, NULL, NULL},
  {(char *)"format", &Dtool_EggTexture_format_Getter, &Dtool_EggTexture_format_Setter, NULL, NULL},
  {(char *)"compression_mode", &Dtool_EggTexture_compression_mode_Getter, &Dtool_EggTexture_compression_mode_Setter, NULL, NULL},
  {(char *)"wrap_mode", &Dtool_EggTexture_wrap_mode_Getter, &Dtool_EggTexture_wrap_mode_Setter, NULL, NULL},
  {(char *)"wrap_u", &Dtool_EggTexture_wrap_u_Getter, &Dtool_EggTexture_wrap_u_Setter, NULL, NULL},
  {(char *)"wrap_v", &Dtool_EggTexture_wrap_v_Getter, &Dtool_EggTexture_wrap_v_Setter, NULL, NULL},
  {(char *)"wrap_w", &Dtool_EggTexture_wrap_w_Getter, &Dtool_EggTexture_wrap_w_Setter, NULL, NULL},
  {(char *)"minfilter", &Dtool_EggTexture_minfilter_Getter, &Dtool_EggTexture_minfilter_Setter, NULL, NULL},
  {(char *)"magfilter", &Dtool_EggTexture_magfilter_Getter, &Dtool_EggTexture_magfilter_Setter, NULL, NULL},
  {(char *)"anisotropic_degree", &Dtool_EggTexture_anisotropic_degree_Getter, &Dtool_EggTexture_anisotropic_degree_Setter, NULL, NULL},
  {(char *)"env_type", &Dtool_EggTexture_env_type_Getter, &Dtool_EggTexture_env_type_Setter, NULL, NULL},
  {(char *)"saved_result", &Dtool_EggTexture_saved_result_Getter, &Dtool_EggTexture_saved_result_Setter, NULL, NULL},
  {(char *)"tex_gen", &Dtool_EggTexture_tex_gen_Getter, &Dtool_EggTexture_tex_gen_Setter, NULL, NULL},
  {(char *)"quality_level", &Dtool_EggTexture_quality_level_Getter, &Dtool_EggTexture_quality_level_Setter, NULL, NULL},
  {(char *)"stage_name", &Dtool_EggTexture_stage_name_Getter, &Dtool_EggTexture_stage_name_Setter, NULL, NULL},
  {(char *)"priority", &Dtool_EggTexture_priority_Getter, &Dtool_EggTexture_priority_Setter, NULL, NULL},
  {(char *)"color", &Dtool_EggTexture_color_Getter, &Dtool_EggTexture_color_Setter, NULL, NULL},
  {(char *)"border_color", &Dtool_EggTexture_border_color_Getter, &Dtool_EggTexture_border_color_Setter, NULL, NULL},
  {(char *)"uv_name", &Dtool_EggTexture_uv_name_Getter, &Dtool_EggTexture_uv_name_Setter, NULL, NULL},
  {(char *)"rgb_scale", &Dtool_EggTexture_rgb_scale_Getter, &Dtool_EggTexture_rgb_scale_Setter, NULL, NULL},
  {(char *)"alpha_scale", &Dtool_EggTexture_alpha_scale_Getter, &Dtool_EggTexture_alpha_scale_Setter, NULL, NULL},
  {(char *)"alpha_filename", &Dtool_EggTexture_alpha_filename_Getter, &Dtool_EggTexture_alpha_filename_Setter, NULL, NULL},
  {(char *)"alpha_fullpath", &Dtool_EggTexture_alpha_fullpath_Getter, &Dtool_EggTexture_alpha_fullpath_Setter, NULL, NULL},
  {(char *)"alpha_file_channel", &Dtool_EggTexture_alpha_file_channel_Getter, &Dtool_EggTexture_alpha_file_channel_Setter, NULL, NULL},
  {(char *)"multiview", &Dtool_EggTexture_multiview_Getter, &Dtool_EggTexture_multiview_Setter, NULL, NULL},
  {(char *)"num_views", &Dtool_EggTexture_num_views_Getter, &Dtool_EggTexture_num_views_Setter, NULL, NULL},
  {(char *)"read_mipmaps", &Dtool_EggTexture_read_mipmaps_Getter, &Dtool_EggTexture_read_mipmaps_Setter, NULL, NULL},
  {(char *)"min_lod", &Dtool_EggTexture_min_lod_Getter, &Dtool_EggTexture_min_lod_Setter, NULL, NULL},
  {(char *)"max_lod", &Dtool_EggTexture_max_lod_Getter, &Dtool_EggTexture_max_lod_Setter, NULL, NULL},
  {(char *)"lod_bias", &Dtool_EggTexture_lod_bias_Getter, &Dtool_EggTexture_lod_bias_Setter, NULL, NULL},
  {(char *)"multitexture_sort", &Dtool_EggTexture_multitexture_sort_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_EggTexture = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggTexture = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggTexture = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggTexture = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggTexture = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggTexture",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTexture,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggTexture,
    &Dtool_SequenceMethods_EggTexture,
    &Dtool_MappingMethods_EggTexture,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_EggTexture,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggTexture,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a texture map that may be applied to geometry.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggTexture,
    0, // tp_members
    Dtool_Properties_EggTexture,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggTexture,
    PyType_GenericAlloc,
    Dtool_new_EggTexture,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTexture,
  Dtool_UpcastInterface_EggTexture,
  Dtool_DowncastInterface_EggTexture,
  (CoerceFunction)Dtool_ConstCoerce_EggTexture,
  (CoerceFunction)Dtool_Coerce_EggTexture,
};

static void Dtool_PyModuleClassInit_EggTexture(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggFilenameNode(NULL);
    Dtool_PyModuleClassInit_EggRenderMode(NULL);
    Dtool_PyModuleClassInit_EggTransform(NULL);
    Dtool_EggTexture._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)&Dtool_EggFilenameNode, (PyTypeObject *)&Dtool_EggRenderMode, (PyTypeObject *)&Dtool_EggTransform);
    PyObject *dict = _PyDict_NewPresized(217);
    Dtool_EggTexture._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggTexture::Equivalence;
    PyDict_SetItemString(dict, "E_basename", Dtool_WrapValue(EggTexture::E_basename));
    PyDict_SetItemString(dict, "EBasename", Dtool_WrapValue(EggTexture::E_basename));
    PyDict_SetItemString(dict, "E_extension", Dtool_WrapValue(EggTexture::E_extension));
    PyDict_SetItemString(dict, "EExtension", Dtool_WrapValue(EggTexture::E_extension));
    PyDict_SetItemString(dict, "E_dirname", Dtool_WrapValue(EggTexture::E_dirname));
    PyDict_SetItemString(dict, "EDirname", Dtool_WrapValue(EggTexture::E_dirname));
    PyDict_SetItemString(dict, "E_complete_filename", Dtool_WrapValue(EggTexture::E_complete_filename));
    PyDict_SetItemString(dict, "ECompleteFilename", Dtool_WrapValue(EggTexture::E_complete_filename));
    PyDict_SetItemString(dict, "E_transform", Dtool_WrapValue(EggTexture::E_transform));
    PyDict_SetItemString(dict, "ETransform", Dtool_WrapValue(EggTexture::E_transform));
    PyDict_SetItemString(dict, "E_attributes", Dtool_WrapValue(EggTexture::E_attributes));
    PyDict_SetItemString(dict, "EAttributes", Dtool_WrapValue(EggTexture::E_attributes));
    PyDict_SetItemString(dict, "E_tref_name", Dtool_WrapValue(EggTexture::E_tref_name));
    PyDict_SetItemString(dict, "ETrefName", Dtool_WrapValue(EggTexture::E_tref_name));
    // enum EggTexture::TextureType;
    PyDict_SetItemString(dict, "TT_unspecified", Dtool_WrapValue(EggTexture::TT_unspecified));
    PyDict_SetItemString(dict, "TTUnspecified", Dtool_WrapValue(EggTexture::TT_unspecified));
    PyDict_SetItemString(dict, "TT_1d_texture", Dtool_WrapValue(EggTexture::TT_1d_texture));
    PyDict_SetItemString(dict, "TT1dTexture", Dtool_WrapValue(EggTexture::TT_1d_texture));
    PyDict_SetItemString(dict, "TT_2d_texture", Dtool_WrapValue(EggTexture::TT_2d_texture));
    PyDict_SetItemString(dict, "TT2dTexture", Dtool_WrapValue(EggTexture::TT_2d_texture));
    PyDict_SetItemString(dict, "TT_3d_texture", Dtool_WrapValue(EggTexture::TT_3d_texture));
    PyDict_SetItemString(dict, "TT3dTexture", Dtool_WrapValue(EggTexture::TT_3d_texture));
    PyDict_SetItemString(dict, "TT_cube_map", Dtool_WrapValue(EggTexture::TT_cube_map));
    PyDict_SetItemString(dict, "TTCubeMap", Dtool_WrapValue(EggTexture::TT_cube_map));
    // enum EggTexture::Format;
    PyDict_SetItemString(dict, "F_unspecified", Dtool_WrapValue(EggTexture::F_unspecified));
    PyDict_SetItemString(dict, "FUnspecified", Dtool_WrapValue(EggTexture::F_unspecified));
    PyDict_SetItemString(dict, "F_rgba", Dtool_WrapValue(EggTexture::F_rgba));
    PyDict_SetItemString(dict, "FRgba", Dtool_WrapValue(EggTexture::F_rgba));
    PyDict_SetItemString(dict, "F_rgbm", Dtool_WrapValue(EggTexture::F_rgbm));
    PyDict_SetItemString(dict, "FRgbm", Dtool_WrapValue(EggTexture::F_rgbm));
    PyDict_SetItemString(dict, "F_rgba12", Dtool_WrapValue(EggTexture::F_rgba12));
    PyDict_SetItemString(dict, "FRgba12", Dtool_WrapValue(EggTexture::F_rgba12));
    PyDict_SetItemString(dict, "F_rgba8", Dtool_WrapValue(EggTexture::F_rgba8));
    PyDict_SetItemString(dict, "FRgba8", Dtool_WrapValue(EggTexture::F_rgba8));
    PyDict_SetItemString(dict, "F_rgba4", Dtool_WrapValue(EggTexture::F_rgba4));
    PyDict_SetItemString(dict, "FRgba4", Dtool_WrapValue(EggTexture::F_rgba4));
    PyDict_SetItemString(dict, "F_rgba5", Dtool_WrapValue(EggTexture::F_rgba5));
    PyDict_SetItemString(dict, "FRgba5", Dtool_WrapValue(EggTexture::F_rgba5));
    PyDict_SetItemString(dict, "F_rgb", Dtool_WrapValue(EggTexture::F_rgb));
    PyDict_SetItemString(dict, "FRgb", Dtool_WrapValue(EggTexture::F_rgb));
    PyDict_SetItemString(dict, "F_rgb12", Dtool_WrapValue(EggTexture::F_rgb12));
    PyDict_SetItemString(dict, "FRgb12", Dtool_WrapValue(EggTexture::F_rgb12));
    PyDict_SetItemString(dict, "F_rgb8", Dtool_WrapValue(EggTexture::F_rgb8));
    PyDict_SetItemString(dict, "FRgb8", Dtool_WrapValue(EggTexture::F_rgb8));
    PyDict_SetItemString(dict, "F_rgb5", Dtool_WrapValue(EggTexture::F_rgb5));
    PyDict_SetItemString(dict, "FRgb5", Dtool_WrapValue(EggTexture::F_rgb5));
    PyDict_SetItemString(dict, "F_rgb332", Dtool_WrapValue(EggTexture::F_rgb332));
    PyDict_SetItemString(dict, "FRgb332", Dtool_WrapValue(EggTexture::F_rgb332));
    PyDict_SetItemString(dict, "F_red", Dtool_WrapValue(EggTexture::F_red));
    PyDict_SetItemString(dict, "FRed", Dtool_WrapValue(EggTexture::F_red));
    PyDict_SetItemString(dict, "F_green", Dtool_WrapValue(EggTexture::F_green));
    PyDict_SetItemString(dict, "FGreen", Dtool_WrapValue(EggTexture::F_green));
    PyDict_SetItemString(dict, "F_blue", Dtool_WrapValue(EggTexture::F_blue));
    PyDict_SetItemString(dict, "FBlue", Dtool_WrapValue(EggTexture::F_blue));
    PyDict_SetItemString(dict, "F_alpha", Dtool_WrapValue(EggTexture::F_alpha));
    PyDict_SetItemString(dict, "FAlpha", Dtool_WrapValue(EggTexture::F_alpha));
    PyDict_SetItemString(dict, "F_luminance", Dtool_WrapValue(EggTexture::F_luminance));
    PyDict_SetItemString(dict, "FLuminance", Dtool_WrapValue(EggTexture::F_luminance));
    PyDict_SetItemString(dict, "F_luminance_alpha", Dtool_WrapValue(EggTexture::F_luminance_alpha));
    PyDict_SetItemString(dict, "FLuminanceAlpha", Dtool_WrapValue(EggTexture::F_luminance_alpha));
    PyDict_SetItemString(dict, "F_luminance_alphamask", Dtool_WrapValue(EggTexture::F_luminance_alphamask));
    PyDict_SetItemString(dict, "FLuminanceAlphamask", Dtool_WrapValue(EggTexture::F_luminance_alphamask));
    // enum EggTexture::CompressionMode;
    PyDict_SetItemString(dict, "CM_default", Dtool_WrapValue(EggTexture::CM_default));
    PyDict_SetItemString(dict, "CMDefault", Dtool_WrapValue(EggTexture::CM_default));
    PyDict_SetItemString(dict, "CM_off", Dtool_WrapValue(EggTexture::CM_off));
    PyDict_SetItemString(dict, "CMOff", Dtool_WrapValue(EggTexture::CM_off));
    PyDict_SetItemString(dict, "CM_on", Dtool_WrapValue(EggTexture::CM_on));
    PyDict_SetItemString(dict, "CMOn", Dtool_WrapValue(EggTexture::CM_on));
    PyDict_SetItemString(dict, "CM_fxt1", Dtool_WrapValue(EggTexture::CM_fxt1));
    PyDict_SetItemString(dict, "CMFxt1", Dtool_WrapValue(EggTexture::CM_fxt1));
    PyDict_SetItemString(dict, "CM_dxt1", Dtool_WrapValue(EggTexture::CM_dxt1));
    PyDict_SetItemString(dict, "CMDxt1", Dtool_WrapValue(EggTexture::CM_dxt1));
    PyDict_SetItemString(dict, "CM_dxt2", Dtool_WrapValue(EggTexture::CM_dxt2));
    PyDict_SetItemString(dict, "CMDxt2", Dtool_WrapValue(EggTexture::CM_dxt2));
    PyDict_SetItemString(dict, "CM_dxt3", Dtool_WrapValue(EggTexture::CM_dxt3));
    PyDict_SetItemString(dict, "CMDxt3", Dtool_WrapValue(EggTexture::CM_dxt3));
    PyDict_SetItemString(dict, "CM_dxt4", Dtool_WrapValue(EggTexture::CM_dxt4));
    PyDict_SetItemString(dict, "CMDxt4", Dtool_WrapValue(EggTexture::CM_dxt4));
    PyDict_SetItemString(dict, "CM_dxt5", Dtool_WrapValue(EggTexture::CM_dxt5));
    PyDict_SetItemString(dict, "CMDxt5", Dtool_WrapValue(EggTexture::CM_dxt5));
    // enum EggTexture::WrapMode;
    PyDict_SetItemString(dict, "WM_unspecified", Dtool_WrapValue(EggTexture::WM_unspecified));
    PyDict_SetItemString(dict, "WMUnspecified", Dtool_WrapValue(EggTexture::WM_unspecified));
    PyDict_SetItemString(dict, "WM_clamp", Dtool_WrapValue(EggTexture::WM_clamp));
    PyDict_SetItemString(dict, "WMClamp", Dtool_WrapValue(EggTexture::WM_clamp));
    PyDict_SetItemString(dict, "WM_repeat", Dtool_WrapValue(EggTexture::WM_repeat));
    PyDict_SetItemString(dict, "WMRepeat", Dtool_WrapValue(EggTexture::WM_repeat));
    PyDict_SetItemString(dict, "WM_mirror", Dtool_WrapValue(EggTexture::WM_mirror));
    PyDict_SetItemString(dict, "WMMirror", Dtool_WrapValue(EggTexture::WM_mirror));
    PyDict_SetItemString(dict, "WM_mirror_once", Dtool_WrapValue(EggTexture::WM_mirror_once));
    PyDict_SetItemString(dict, "WMMirrorOnce", Dtool_WrapValue(EggTexture::WM_mirror_once));
    PyDict_SetItemString(dict, "WM_border_color", Dtool_WrapValue(EggTexture::WM_border_color));
    PyDict_SetItemString(dict, "WMBorderColor", Dtool_WrapValue(EggTexture::WM_border_color));
    // enum EggTexture::FilterType;
    PyDict_SetItemString(dict, "FT_unspecified", Dtool_WrapValue(EggTexture::FT_unspecified));
    PyDict_SetItemString(dict, "FTUnspecified", Dtool_WrapValue(EggTexture::FT_unspecified));
    PyDict_SetItemString(dict, "FT_nearest", Dtool_WrapValue(EggTexture::FT_nearest));
    PyDict_SetItemString(dict, "FTNearest", Dtool_WrapValue(EggTexture::FT_nearest));
    PyDict_SetItemString(dict, "FT_linear", Dtool_WrapValue(EggTexture::FT_linear));
    PyDict_SetItemString(dict, "FTLinear", Dtool_WrapValue(EggTexture::FT_linear));
    PyDict_SetItemString(dict, "FT_nearest_mipmap_nearest", Dtool_WrapValue(EggTexture::FT_nearest_mipmap_nearest));
    PyDict_SetItemString(dict, "FTNearestMipmapNearest", Dtool_WrapValue(EggTexture::FT_nearest_mipmap_nearest));
    PyDict_SetItemString(dict, "FT_linear_mipmap_nearest", Dtool_WrapValue(EggTexture::FT_linear_mipmap_nearest));
    PyDict_SetItemString(dict, "FTLinearMipmapNearest", Dtool_WrapValue(EggTexture::FT_linear_mipmap_nearest));
    PyDict_SetItemString(dict, "FT_nearest_mipmap_linear", Dtool_WrapValue(EggTexture::FT_nearest_mipmap_linear));
    PyDict_SetItemString(dict, "FTNearestMipmapLinear", Dtool_WrapValue(EggTexture::FT_nearest_mipmap_linear));
    PyDict_SetItemString(dict, "FT_linear_mipmap_linear", Dtool_WrapValue(EggTexture::FT_linear_mipmap_linear));
    PyDict_SetItemString(dict, "FTLinearMipmapLinear", Dtool_WrapValue(EggTexture::FT_linear_mipmap_linear));
    // enum EggTexture::EnvType;
    PyDict_SetItemString(dict, "ET_unspecified", Dtool_WrapValue(EggTexture::ET_unspecified));
    PyDict_SetItemString(dict, "ETUnspecified", Dtool_WrapValue(EggTexture::ET_unspecified));
    PyDict_SetItemString(dict, "ET_modulate", Dtool_WrapValue(EggTexture::ET_modulate));
    PyDict_SetItemString(dict, "ETModulate", Dtool_WrapValue(EggTexture::ET_modulate));
    PyDict_SetItemString(dict, "ET_decal", Dtool_WrapValue(EggTexture::ET_decal));
    PyDict_SetItemString(dict, "ETDecal", Dtool_WrapValue(EggTexture::ET_decal));
    PyDict_SetItemString(dict, "ET_blend", Dtool_WrapValue(EggTexture::ET_blend));
    PyDict_SetItemString(dict, "ETBlend", Dtool_WrapValue(EggTexture::ET_blend));
    PyDict_SetItemString(dict, "ET_replace", Dtool_WrapValue(EggTexture::ET_replace));
    PyDict_SetItemString(dict, "ETReplace", Dtool_WrapValue(EggTexture::ET_replace));
    PyDict_SetItemString(dict, "ET_add", Dtool_WrapValue(EggTexture::ET_add));
    PyDict_SetItemString(dict, "ETAdd", Dtool_WrapValue(EggTexture::ET_add));
    PyDict_SetItemString(dict, "ET_blend_color_scale", Dtool_WrapValue(EggTexture::ET_blend_color_scale));
    PyDict_SetItemString(dict, "ETBlendColorScale", Dtool_WrapValue(EggTexture::ET_blend_color_scale));
    PyDict_SetItemString(dict, "ET_modulate_glow", Dtool_WrapValue(EggTexture::ET_modulate_glow));
    PyDict_SetItemString(dict, "ETModulateGlow", Dtool_WrapValue(EggTexture::ET_modulate_glow));
    PyDict_SetItemString(dict, "ET_modulate_gloss", Dtool_WrapValue(EggTexture::ET_modulate_gloss));
    PyDict_SetItemString(dict, "ETModulateGloss", Dtool_WrapValue(EggTexture::ET_modulate_gloss));
    PyDict_SetItemString(dict, "ET_normal", Dtool_WrapValue(EggTexture::ET_normal));
    PyDict_SetItemString(dict, "ETNormal", Dtool_WrapValue(EggTexture::ET_normal));
    PyDict_SetItemString(dict, "ET_normal_height", Dtool_WrapValue(EggTexture::ET_normal_height));
    PyDict_SetItemString(dict, "ETNormalHeight", Dtool_WrapValue(EggTexture::ET_normal_height));
    PyDict_SetItemString(dict, "ET_glow", Dtool_WrapValue(EggTexture::ET_glow));
    PyDict_SetItemString(dict, "ETGlow", Dtool_WrapValue(EggTexture::ET_glow));
    PyDict_SetItemString(dict, "ET_gloss", Dtool_WrapValue(EggTexture::ET_gloss));
    PyDict_SetItemString(dict, "ETGloss", Dtool_WrapValue(EggTexture::ET_gloss));
    PyDict_SetItemString(dict, "ET_height", Dtool_WrapValue(EggTexture::ET_height));
    PyDict_SetItemString(dict, "ETHeight", Dtool_WrapValue(EggTexture::ET_height));
    PyDict_SetItemString(dict, "ET_selector", Dtool_WrapValue(EggTexture::ET_selector));
    PyDict_SetItemString(dict, "ETSelector", Dtool_WrapValue(EggTexture::ET_selector));
    PyDict_SetItemString(dict, "ET_normal_gloss", Dtool_WrapValue(EggTexture::ET_normal_gloss));
    PyDict_SetItemString(dict, "ETNormalGloss", Dtool_WrapValue(EggTexture::ET_normal_gloss));
    // enum EggTexture::CombineMode;
    PyDict_SetItemString(dict, "CM_unspecified", Dtool_WrapValue(EggTexture::CM_unspecified));
    PyDict_SetItemString(dict, "CMUnspecified", Dtool_WrapValue(EggTexture::CM_unspecified));
    PyDict_SetItemString(dict, "CM_replace", Dtool_WrapValue(EggTexture::CM_replace));
    PyDict_SetItemString(dict, "CMReplace", Dtool_WrapValue(EggTexture::CM_replace));
    PyDict_SetItemString(dict, "CM_modulate", Dtool_WrapValue(EggTexture::CM_modulate));
    PyDict_SetItemString(dict, "CMModulate", Dtool_WrapValue(EggTexture::CM_modulate));
    PyDict_SetItemString(dict, "CM_add", Dtool_WrapValue(EggTexture::CM_add));
    PyDict_SetItemString(dict, "CMAdd", Dtool_WrapValue(EggTexture::CM_add));
    PyDict_SetItemString(dict, "CM_add_signed", Dtool_WrapValue(EggTexture::CM_add_signed));
    PyDict_SetItemString(dict, "CMAddSigned", Dtool_WrapValue(EggTexture::CM_add_signed));
    PyDict_SetItemString(dict, "CM_interpolate", Dtool_WrapValue(EggTexture::CM_interpolate));
    PyDict_SetItemString(dict, "CMInterpolate", Dtool_WrapValue(EggTexture::CM_interpolate));
    PyDict_SetItemString(dict, "CM_subtract", Dtool_WrapValue(EggTexture::CM_subtract));
    PyDict_SetItemString(dict, "CMSubtract", Dtool_WrapValue(EggTexture::CM_subtract));
    PyDict_SetItemString(dict, "CM_dot3_rgb", Dtool_WrapValue(EggTexture::CM_dot3_rgb));
    PyDict_SetItemString(dict, "CMDot3Rgb", Dtool_WrapValue(EggTexture::CM_dot3_rgb));
    PyDict_SetItemString(dict, "CM_dot3_rgba", Dtool_WrapValue(EggTexture::CM_dot3_rgba));
    PyDict_SetItemString(dict, "CMDot3Rgba", Dtool_WrapValue(EggTexture::CM_dot3_rgba));
    // enum EggTexture::CombineChannel;
    PyDict_SetItemString(dict, "CC_rgb", Dtool_WrapValue(EggTexture::CC_rgb));
    PyDict_SetItemString(dict, "CCRgb", Dtool_WrapValue(EggTexture::CC_rgb));
    PyDict_SetItemString(dict, "CC_alpha", Dtool_WrapValue(EggTexture::CC_alpha));
    PyDict_SetItemString(dict, "CCAlpha", Dtool_WrapValue(EggTexture::CC_alpha));
    PyDict_SetItemString(dict, "CC_num_channels", Dtool_WrapValue(EggTexture::CC_num_channels));
    PyDict_SetItemString(dict, "CCNumChannels", Dtool_WrapValue(EggTexture::CC_num_channels));
    // enum EggTexture::CombineIndex;
    PyDict_SetItemString(dict, "CI_num_indices", Dtool_WrapValue(EggTexture::CI_num_indices));
    PyDict_SetItemString(dict, "CINumIndices", Dtool_WrapValue(EggTexture::CI_num_indices));
    // enum EggTexture::CombineSource;
    PyDict_SetItemString(dict, "CS_unspecified", Dtool_WrapValue(EggTexture::CS_unspecified));
    PyDict_SetItemString(dict, "CSUnspecified", Dtool_WrapValue(EggTexture::CS_unspecified));
    PyDict_SetItemString(dict, "CS_texture", Dtool_WrapValue(EggTexture::CS_texture));
    PyDict_SetItemString(dict, "CSTexture", Dtool_WrapValue(EggTexture::CS_texture));
    PyDict_SetItemString(dict, "CS_constant", Dtool_WrapValue(EggTexture::CS_constant));
    PyDict_SetItemString(dict, "CSConstant", Dtool_WrapValue(EggTexture::CS_constant));
    PyDict_SetItemString(dict, "CS_primary_color", Dtool_WrapValue(EggTexture::CS_primary_color));
    PyDict_SetItemString(dict, "CSPrimaryColor", Dtool_WrapValue(EggTexture::CS_primary_color));
    PyDict_SetItemString(dict, "CS_previous", Dtool_WrapValue(EggTexture::CS_previous));
    PyDict_SetItemString(dict, "CSPrevious", Dtool_WrapValue(EggTexture::CS_previous));
    PyDict_SetItemString(dict, "CS_constant_color_scale", Dtool_WrapValue(EggTexture::CS_constant_color_scale));
    PyDict_SetItemString(dict, "CSConstantColorScale", Dtool_WrapValue(EggTexture::CS_constant_color_scale));
    PyDict_SetItemString(dict, "CS_last_saved_result", Dtool_WrapValue(EggTexture::CS_last_saved_result));
    PyDict_SetItemString(dict, "CSLastSavedResult", Dtool_WrapValue(EggTexture::CS_last_saved_result));
    // enum EggTexture::CombineOperand;
    PyDict_SetItemString(dict, "CO_unspecified", Dtool_WrapValue(EggTexture::CO_unspecified));
    PyDict_SetItemString(dict, "COUnspecified", Dtool_WrapValue(EggTexture::CO_unspecified));
    PyDict_SetItemString(dict, "CO_src_color", Dtool_WrapValue(EggTexture::CO_src_color));
    PyDict_SetItemString(dict, "COSrcColor", Dtool_WrapValue(EggTexture::CO_src_color));
    PyDict_SetItemString(dict, "CO_one_minus_src_color", Dtool_WrapValue(EggTexture::CO_one_minus_src_color));
    PyDict_SetItemString(dict, "COOneMinusSrcColor", Dtool_WrapValue(EggTexture::CO_one_minus_src_color));
    PyDict_SetItemString(dict, "CO_src_alpha", Dtool_WrapValue(EggTexture::CO_src_alpha));
    PyDict_SetItemString(dict, "COSrcAlpha", Dtool_WrapValue(EggTexture::CO_src_alpha));
    PyDict_SetItemString(dict, "CO_one_minus_src_alpha", Dtool_WrapValue(EggTexture::CO_one_minus_src_alpha));
    PyDict_SetItemString(dict, "COOneMinusSrcAlpha", Dtool_WrapValue(EggTexture::CO_one_minus_src_alpha));
    // enum EggTexture::TexGen;
    PyDict_SetItemString(dict, "TG_unspecified", Dtool_WrapValue(EggTexture::TG_unspecified));
    PyDict_SetItemString(dict, "TGUnspecified", Dtool_WrapValue(EggTexture::TG_unspecified));
    PyDict_SetItemString(dict, "TG_eye_sphere_map", Dtool_WrapValue(EggTexture::TG_eye_sphere_map));
    PyDict_SetItemString(dict, "TGEyeSphereMap", Dtool_WrapValue(EggTexture::TG_eye_sphere_map));
    PyDict_SetItemString(dict, "TG_world_cube_map", Dtool_WrapValue(EggTexture::TG_world_cube_map));
    PyDict_SetItemString(dict, "TGWorldCubeMap", Dtool_WrapValue(EggTexture::TG_world_cube_map));
    PyDict_SetItemString(dict, "TG_eye_cube_map", Dtool_WrapValue(EggTexture::TG_eye_cube_map));
    PyDict_SetItemString(dict, "TGEyeCubeMap", Dtool_WrapValue(EggTexture::TG_eye_cube_map));
    PyDict_SetItemString(dict, "TG_world_normal", Dtool_WrapValue(EggTexture::TG_world_normal));
    PyDict_SetItemString(dict, "TGWorldNormal", Dtool_WrapValue(EggTexture::TG_world_normal));
    PyDict_SetItemString(dict, "TG_eye_normal", Dtool_WrapValue(EggTexture::TG_eye_normal));
    PyDict_SetItemString(dict, "TGEyeNormal", Dtool_WrapValue(EggTexture::TG_eye_normal));
    PyDict_SetItemString(dict, "TG_world_position", Dtool_WrapValue(EggTexture::TG_world_position));
    PyDict_SetItemString(dict, "TGWorldPosition", Dtool_WrapValue(EggTexture::TG_world_position));
    PyDict_SetItemString(dict, "TG_eye_position", Dtool_WrapValue(EggTexture::TG_eye_position));
    PyDict_SetItemString(dict, "TGEyePosition", Dtool_WrapValue(EggTexture::TG_eye_position));
    PyDict_SetItemString(dict, "TG_point_sprite", Dtool_WrapValue(EggTexture::TG_point_sprite));
    PyDict_SetItemString(dict, "TGPointSprite", Dtool_WrapValue(EggTexture::TG_point_sprite));
    // enum EggTexture::QualityLevel;
    PyDict_SetItemString(dict, "QL_unspecified", Dtool_WrapValue(EggTexture::QL_unspecified));
    PyDict_SetItemString(dict, "QLUnspecified", Dtool_WrapValue(EggTexture::QL_unspecified));
    PyDict_SetItemString(dict, "QL_default", Dtool_WrapValue(EggTexture::QL_default));
    PyDict_SetItemString(dict, "QLDefault", Dtool_WrapValue(EggTexture::QL_default));
    PyDict_SetItemString(dict, "QL_fastest", Dtool_WrapValue(EggTexture::QL_fastest));
    PyDict_SetItemString(dict, "QLFastest", Dtool_WrapValue(EggTexture::QL_fastest));
    PyDict_SetItemString(dict, "QL_normal", Dtool_WrapValue(EggTexture::QL_normal));
    PyDict_SetItemString(dict, "QLNormal", Dtool_WrapValue(EggTexture::QL_normal));
    PyDict_SetItemString(dict, "QL_best", Dtool_WrapValue(EggTexture::QL_best));
    PyDict_SetItemString(dict, "QLBest", Dtool_WrapValue(EggTexture::QL_best));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTexture) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTexture)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTexture);
  }
}

/**
 * Python method tables for EggMaterial (EggMaterial)
 */
static PyMethodDef Dtool_Methods_EggMaterial[] = {
  {"is_equivalent_to", (PyCFunction) &Dtool_EggMaterial_is_equivalent_to_786, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterial_is_equivalent_to_786_comment},
  {"isEquivalentTo", (PyCFunction) &Dtool_EggMaterial_is_equivalent_to_786, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterial_is_equivalent_to_786_comment},
  {"sorts_less_than", (PyCFunction) &Dtool_EggMaterial_sorts_less_than_787, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterial_sorts_less_than_787_comment},
  {"sortsLessThan", (PyCFunction) &Dtool_EggMaterial_sorts_less_than_787, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterial_sorts_less_than_787_comment},
  {"set_base", &Dtool_EggMaterial_set_base_788, METH_O, (const char *)Dtool_EggMaterial_set_base_788_comment},
  {"setBase", &Dtool_EggMaterial_set_base_788, METH_O, (const char *)Dtool_EggMaterial_set_base_788_comment},
  {"clear_base", &Dtool_EggMaterial_clear_base_789, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_base_789_comment},
  {"clearBase", &Dtool_EggMaterial_clear_base_789, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_base_789_comment},
  {"has_base", &Dtool_EggMaterial_has_base_790, METH_NOARGS, (const char *)Dtool_EggMaterial_has_base_790_comment},
  {"hasBase", &Dtool_EggMaterial_has_base_790, METH_NOARGS, (const char *)Dtool_EggMaterial_has_base_790_comment},
  {"get_base", &Dtool_EggMaterial_get_base_791, METH_NOARGS, (const char *)Dtool_EggMaterial_get_base_791_comment},
  {"getBase", &Dtool_EggMaterial_get_base_791, METH_NOARGS, (const char *)Dtool_EggMaterial_get_base_791_comment},
  {"set_diff", &Dtool_EggMaterial_set_diff_792, METH_O, (const char *)Dtool_EggMaterial_set_diff_792_comment},
  {"setDiff", &Dtool_EggMaterial_set_diff_792, METH_O, (const char *)Dtool_EggMaterial_set_diff_792_comment},
  {"clear_diff", &Dtool_EggMaterial_clear_diff_793, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_diff_793_comment},
  {"clearDiff", &Dtool_EggMaterial_clear_diff_793, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_diff_793_comment},
  {"has_diff", &Dtool_EggMaterial_has_diff_794, METH_NOARGS, (const char *)Dtool_EggMaterial_has_diff_794_comment},
  {"hasDiff", &Dtool_EggMaterial_has_diff_794, METH_NOARGS, (const char *)Dtool_EggMaterial_has_diff_794_comment},
  {"get_diff", &Dtool_EggMaterial_get_diff_795, METH_NOARGS, (const char *)Dtool_EggMaterial_get_diff_795_comment},
  {"getDiff", &Dtool_EggMaterial_get_diff_795, METH_NOARGS, (const char *)Dtool_EggMaterial_get_diff_795_comment},
  {"set_amb", &Dtool_EggMaterial_set_amb_796, METH_O, (const char *)Dtool_EggMaterial_set_amb_796_comment},
  {"setAmb", &Dtool_EggMaterial_set_amb_796, METH_O, (const char *)Dtool_EggMaterial_set_amb_796_comment},
  {"clear_amb", &Dtool_EggMaterial_clear_amb_797, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_amb_797_comment},
  {"clearAmb", &Dtool_EggMaterial_clear_amb_797, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_amb_797_comment},
  {"has_amb", &Dtool_EggMaterial_has_amb_798, METH_NOARGS, (const char *)Dtool_EggMaterial_has_amb_798_comment},
  {"hasAmb", &Dtool_EggMaterial_has_amb_798, METH_NOARGS, (const char *)Dtool_EggMaterial_has_amb_798_comment},
  {"get_amb", &Dtool_EggMaterial_get_amb_799, METH_NOARGS, (const char *)Dtool_EggMaterial_get_amb_799_comment},
  {"getAmb", &Dtool_EggMaterial_get_amb_799, METH_NOARGS, (const char *)Dtool_EggMaterial_get_amb_799_comment},
  {"set_emit", &Dtool_EggMaterial_set_emit_800, METH_O, (const char *)Dtool_EggMaterial_set_emit_800_comment},
  {"setEmit", &Dtool_EggMaterial_set_emit_800, METH_O, (const char *)Dtool_EggMaterial_set_emit_800_comment},
  {"clear_emit", &Dtool_EggMaterial_clear_emit_801, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_emit_801_comment},
  {"clearEmit", &Dtool_EggMaterial_clear_emit_801, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_emit_801_comment},
  {"has_emit", &Dtool_EggMaterial_has_emit_802, METH_NOARGS, (const char *)Dtool_EggMaterial_has_emit_802_comment},
  {"hasEmit", &Dtool_EggMaterial_has_emit_802, METH_NOARGS, (const char *)Dtool_EggMaterial_has_emit_802_comment},
  {"get_emit", &Dtool_EggMaterial_get_emit_803, METH_NOARGS, (const char *)Dtool_EggMaterial_get_emit_803_comment},
  {"getEmit", &Dtool_EggMaterial_get_emit_803, METH_NOARGS, (const char *)Dtool_EggMaterial_get_emit_803_comment},
  {"set_spec", &Dtool_EggMaterial_set_spec_804, METH_O, (const char *)Dtool_EggMaterial_set_spec_804_comment},
  {"setSpec", &Dtool_EggMaterial_set_spec_804, METH_O, (const char *)Dtool_EggMaterial_set_spec_804_comment},
  {"clear_spec", &Dtool_EggMaterial_clear_spec_805, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_spec_805_comment},
  {"clearSpec", &Dtool_EggMaterial_clear_spec_805, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_spec_805_comment},
  {"has_spec", &Dtool_EggMaterial_has_spec_806, METH_NOARGS, (const char *)Dtool_EggMaterial_has_spec_806_comment},
  {"hasSpec", &Dtool_EggMaterial_has_spec_806, METH_NOARGS, (const char *)Dtool_EggMaterial_has_spec_806_comment},
  {"get_spec", &Dtool_EggMaterial_get_spec_807, METH_NOARGS, (const char *)Dtool_EggMaterial_get_spec_807_comment},
  {"getSpec", &Dtool_EggMaterial_get_spec_807, METH_NOARGS, (const char *)Dtool_EggMaterial_get_spec_807_comment},
  {"set_shininess", &Dtool_EggMaterial_set_shininess_808, METH_O, (const char *)Dtool_EggMaterial_set_shininess_808_comment},
  {"setShininess", &Dtool_EggMaterial_set_shininess_808, METH_O, (const char *)Dtool_EggMaterial_set_shininess_808_comment},
  {"clear_shininess", &Dtool_EggMaterial_clear_shininess_809, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_shininess_809_comment},
  {"clearShininess", &Dtool_EggMaterial_clear_shininess_809, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_shininess_809_comment},
  {"has_shininess", &Dtool_EggMaterial_has_shininess_810, METH_NOARGS, (const char *)Dtool_EggMaterial_has_shininess_810_comment},
  {"hasShininess", &Dtool_EggMaterial_has_shininess_810, METH_NOARGS, (const char *)Dtool_EggMaterial_has_shininess_810_comment},
  {"get_shininess", &Dtool_EggMaterial_get_shininess_811, METH_NOARGS, (const char *)Dtool_EggMaterial_get_shininess_811_comment},
  {"getShininess", &Dtool_EggMaterial_get_shininess_811, METH_NOARGS, (const char *)Dtool_EggMaterial_get_shininess_811_comment},
  {"set_roughness", &Dtool_EggMaterial_set_roughness_812, METH_O, (const char *)Dtool_EggMaterial_set_roughness_812_comment},
  {"setRoughness", &Dtool_EggMaterial_set_roughness_812, METH_O, (const char *)Dtool_EggMaterial_set_roughness_812_comment},
  {"clear_roughness", &Dtool_EggMaterial_clear_roughness_813, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_roughness_813_comment},
  {"clearRoughness", &Dtool_EggMaterial_clear_roughness_813, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_roughness_813_comment},
  {"has_roughness", &Dtool_EggMaterial_has_roughness_814, METH_NOARGS, (const char *)Dtool_EggMaterial_has_roughness_814_comment},
  {"hasRoughness", &Dtool_EggMaterial_has_roughness_814, METH_NOARGS, (const char *)Dtool_EggMaterial_has_roughness_814_comment},
  {"get_roughness", &Dtool_EggMaterial_get_roughness_815, METH_NOARGS, (const char *)Dtool_EggMaterial_get_roughness_815_comment},
  {"getRoughness", &Dtool_EggMaterial_get_roughness_815, METH_NOARGS, (const char *)Dtool_EggMaterial_get_roughness_815_comment},
  {"set_metallic", &Dtool_EggMaterial_set_metallic_816, METH_O, (const char *)Dtool_EggMaterial_set_metallic_816_comment},
  {"setMetallic", &Dtool_EggMaterial_set_metallic_816, METH_O, (const char *)Dtool_EggMaterial_set_metallic_816_comment},
  {"clear_metallic", &Dtool_EggMaterial_clear_metallic_817, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_metallic_817_comment},
  {"clearMetallic", &Dtool_EggMaterial_clear_metallic_817, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_metallic_817_comment},
  {"has_metallic", &Dtool_EggMaterial_has_metallic_818, METH_NOARGS, (const char *)Dtool_EggMaterial_has_metallic_818_comment},
  {"hasMetallic", &Dtool_EggMaterial_has_metallic_818, METH_NOARGS, (const char *)Dtool_EggMaterial_has_metallic_818_comment},
  {"get_metallic", &Dtool_EggMaterial_get_metallic_819, METH_NOARGS, (const char *)Dtool_EggMaterial_get_metallic_819_comment},
  {"getMetallic", &Dtool_EggMaterial_get_metallic_819, METH_NOARGS, (const char *)Dtool_EggMaterial_get_metallic_819_comment},
  {"set_ior", &Dtool_EggMaterial_set_ior_820, METH_O, (const char *)Dtool_EggMaterial_set_ior_820_comment},
  {"setIor", &Dtool_EggMaterial_set_ior_820, METH_O, (const char *)Dtool_EggMaterial_set_ior_820_comment},
  {"clear_ior", &Dtool_EggMaterial_clear_ior_821, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_ior_821_comment},
  {"clearIor", &Dtool_EggMaterial_clear_ior_821, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_ior_821_comment},
  {"has_ior", &Dtool_EggMaterial_has_ior_822, METH_NOARGS, (const char *)Dtool_EggMaterial_has_ior_822_comment},
  {"hasIor", &Dtool_EggMaterial_has_ior_822, METH_NOARGS, (const char *)Dtool_EggMaterial_has_ior_822_comment},
  {"get_ior", &Dtool_EggMaterial_get_ior_823, METH_NOARGS, (const char *)Dtool_EggMaterial_get_ior_823_comment},
  {"getIor", &Dtool_EggMaterial_get_ior_823, METH_NOARGS, (const char *)Dtool_EggMaterial_get_ior_823_comment},
  {"set_local", &Dtool_EggMaterial_set_local_824, METH_O, (const char *)Dtool_EggMaterial_set_local_824_comment},
  {"setLocal", &Dtool_EggMaterial_set_local_824, METH_O, (const char *)Dtool_EggMaterial_set_local_824_comment},
  {"clear_local", &Dtool_EggMaterial_clear_local_825, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_local_825_comment},
  {"clearLocal", &Dtool_EggMaterial_clear_local_825, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_local_825_comment},
  {"has_local", &Dtool_EggMaterial_has_local_826, METH_NOARGS, (const char *)Dtool_EggMaterial_has_local_826_comment},
  {"hasLocal", &Dtool_EggMaterial_has_local_826, METH_NOARGS, (const char *)Dtool_EggMaterial_has_local_826_comment},
  {"get_local", &Dtool_EggMaterial_get_local_827, METH_NOARGS, (const char *)Dtool_EggMaterial_get_local_827_comment},
  {"getLocal", &Dtool_EggMaterial_get_local_827, METH_NOARGS, (const char *)Dtool_EggMaterial_get_local_827_comment},
  {"get_class_type", &Dtool_EggMaterial_get_class_type_838, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggMaterial_get_class_type_838_comment},
  {"getClassType", &Dtool_EggMaterial_get_class_type_838, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggMaterial_get_class_type_838_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_EggMaterial[] = {
  {(char *)"base", &Dtool_EggMaterial_base_Getter, &Dtool_EggMaterial_base_Setter, NULL, NULL},
  {(char *)"diff", &Dtool_EggMaterial_diff_Getter, &Dtool_EggMaterial_diff_Setter, NULL, NULL},
  {(char *)"amb", &Dtool_EggMaterial_amb_Getter, &Dtool_EggMaterial_amb_Setter, NULL, NULL},
  {(char *)"emit", &Dtool_EggMaterial_emit_Getter, &Dtool_EggMaterial_emit_Setter, NULL, NULL},
  {(char *)"spec", &Dtool_EggMaterial_spec_Getter, &Dtool_EggMaterial_spec_Setter, NULL, NULL},
  {(char *)"shininess", &Dtool_EggMaterial_shininess_Getter, &Dtool_EggMaterial_shininess_Setter, NULL, NULL},
  {(char *)"roughness", &Dtool_EggMaterial_roughness_Getter, &Dtool_EggMaterial_roughness_Setter, NULL, NULL},
  {(char *)"metallic", &Dtool_EggMaterial_metallic_Getter, &Dtool_EggMaterial_metallic_Setter, NULL, NULL},
  {(char *)"ior", &Dtool_EggMaterial_ior_Getter, &Dtool_EggMaterial_ior_Setter, NULL, NULL},
  {(char *)"local", &Dtool_EggMaterial_local_Getter, &Dtool_EggMaterial_local_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_EggMaterial = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggMaterial = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggMaterial = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggMaterial = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggMaterial = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggMaterial",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggMaterial,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggMaterial,
    &Dtool_SequenceMethods_EggMaterial,
    &Dtool_MappingMethods_EggMaterial,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggMaterial,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggMaterial,
    0, // tp_members
    Dtool_Properties_EggMaterial,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggMaterial,
    PyType_GenericAlloc,
    Dtool_new_EggMaterial,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggMaterial,
  Dtool_UpcastInterface_EggMaterial,
  Dtool_DowncastInterface_EggMaterial,
  (CoerceFunction)Dtool_ConstCoerce_EggMaterial,
  (CoerceFunction)Dtool_Coerce_EggMaterial,
};

static void Dtool_PyModuleClassInit_EggMaterial(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(NULL);
    Dtool_EggMaterial._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    PyObject *dict = PyDict_New();
    Dtool_EggMaterial._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggMaterial::Equivalence;
    PyDict_SetItemString(dict, "E_attributes", Dtool_WrapValue(EggMaterial::E_attributes));
    PyDict_SetItemString(dict, "EAttributes", Dtool_WrapValue(EggMaterial::E_attributes));
    PyDict_SetItemString(dict, "E_mref_name", Dtool_WrapValue(EggMaterial::E_mref_name));
    PyDict_SetItemString(dict, "EMrefName", Dtool_WrapValue(EggMaterial::E_mref_name));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggMaterial) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggMaterial)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggMaterial);
  }
}

/**
 * Python method tables for EggPrimitive (EggPrimitive)
 */
static PyMethodDef Dtool_Methods_EggPrimitive[] = {
  {"assign", &Dtool_EggPrimitive_operator_848, METH_O, (const char *)Dtool_EggPrimitive_operator_848_comment},
  {"make_copy", &Dtool_EggPrimitive_make_copy_850, METH_NOARGS, (const char *)Dtool_EggPrimitive_make_copy_850_comment},
  {"makeCopy", &Dtool_EggPrimitive_make_copy_850, METH_NOARGS, (const char *)Dtool_EggPrimitive_make_copy_850_comment},
  {"determine_alpha_mode", &Dtool_EggPrimitive_determine_alpha_mode_851, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_alpha_mode_851_comment},
  {"determineAlphaMode", &Dtool_EggPrimitive_determine_alpha_mode_851, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_alpha_mode_851_comment},
  {"determine_depth_write_mode", &Dtool_EggPrimitive_determine_depth_write_mode_852, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_write_mode_852_comment},
  {"determineDepthWriteMode", &Dtool_EggPrimitive_determine_depth_write_mode_852, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_write_mode_852_comment},
  {"determine_depth_test_mode", &Dtool_EggPrimitive_determine_depth_test_mode_853, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_test_mode_853_comment},
  {"determineDepthTestMode", &Dtool_EggPrimitive_determine_depth_test_mode_853, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_test_mode_853_comment},
  {"determine_visibility_mode", &Dtool_EggPrimitive_determine_visibility_mode_854, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_visibility_mode_854_comment},
  {"determineVisibilityMode", &Dtool_EggPrimitive_determine_visibility_mode_854, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_visibility_mode_854_comment},
  {"determine_depth_offset", &Dtool_EggPrimitive_determine_depth_offset_855, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_offset_855_comment},
  {"determineDepthOffset", &Dtool_EggPrimitive_determine_depth_offset_855, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_offset_855_comment},
  {"determine_draw_order", &Dtool_EggPrimitive_determine_draw_order_856, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_draw_order_856_comment},
  {"determineDrawOrder", &Dtool_EggPrimitive_determine_draw_order_856, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_draw_order_856_comment},
  {"determine_bin", &Dtool_EggPrimitive_determine_bin_857, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_bin_857_comment},
  {"determineBin", &Dtool_EggPrimitive_determine_bin_857, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_bin_857_comment},
  {"get_sort_name", &Dtool_EggPrimitive_get_sort_name_858, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_sort_name_858_comment},
  {"getSortName", &Dtool_EggPrimitive_get_sort_name_858, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_sort_name_858_comment},
  {"get_shading", &Dtool_EggPrimitive_get_shading_859, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_shading_859_comment},
  {"getShading", &Dtool_EggPrimitive_get_shading_859, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_shading_859_comment},
  {"clear_connected_shading", &Dtool_EggPrimitive_clear_connected_shading_860, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_connected_shading_860_comment},
  {"clearConnectedShading", &Dtool_EggPrimitive_clear_connected_shading_860, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_connected_shading_860_comment},
  {"get_connected_shading", &Dtool_EggPrimitive_get_connected_shading_861, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_connected_shading_861_comment},
  {"getConnectedShading", &Dtool_EggPrimitive_get_connected_shading_861, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_connected_shading_861_comment},
  {"set_texture", &Dtool_EggPrimitive_set_texture_862, METH_O, (const char *)Dtool_EggPrimitive_set_texture_862_comment},
  {"setTexture", &Dtool_EggPrimitive_set_texture_862, METH_O, (const char *)Dtool_EggPrimitive_set_texture_862_comment},
  {"has_texture", &Dtool_EggPrimitive_has_texture_863, METH_VARARGS, (const char *)Dtool_EggPrimitive_has_texture_863_comment},
  {"hasTexture", &Dtool_EggPrimitive_has_texture_863, METH_VARARGS, (const char *)Dtool_EggPrimitive_has_texture_863_comment},
  {"get_texture", &Dtool_EggPrimitive_get_texture_864, METH_VARARGS, (const char *)Dtool_EggPrimitive_get_texture_864_comment},
  {"getTexture", &Dtool_EggPrimitive_get_texture_864, METH_VARARGS, (const char *)Dtool_EggPrimitive_get_texture_864_comment},
  {"add_texture", &Dtool_EggPrimitive_add_texture_865, METH_O, (const char *)Dtool_EggPrimitive_add_texture_865_comment},
  {"addTexture", &Dtool_EggPrimitive_add_texture_865, METH_O, (const char *)Dtool_EggPrimitive_add_texture_865_comment},
  {"clear_texture", &Dtool_EggPrimitive_clear_texture_866, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_texture_866_comment},
  {"clearTexture", &Dtool_EggPrimitive_clear_texture_866, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_texture_866_comment},
  {"get_num_textures", &Dtool_EggPrimitive_get_num_textures_867, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_num_textures_867_comment},
  {"getNumTextures", &Dtool_EggPrimitive_get_num_textures_867, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_num_textures_867_comment},
  {"set_material", &Dtool_EggPrimitive_set_material_869, METH_O, (const char *)Dtool_EggPrimitive_set_material_869_comment},
  {"setMaterial", &Dtool_EggPrimitive_set_material_869, METH_O, (const char *)Dtool_EggPrimitive_set_material_869_comment},
  {"clear_material", &Dtool_EggPrimitive_clear_material_870, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_material_870_comment},
  {"clearMaterial", &Dtool_EggPrimitive_clear_material_870, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_material_870_comment},
  {"get_material", &Dtool_EggPrimitive_get_material_871, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_material_871_comment},
  {"getMaterial", &Dtool_EggPrimitive_get_material_871, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_material_871_comment},
  {"has_material", &Dtool_EggPrimitive_has_material_872, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_material_872_comment},
  {"hasMaterial", &Dtool_EggPrimitive_has_material_872, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_material_872_comment},
  {"set_bface_flag", &Dtool_EggPrimitive_set_bface_flag_873, METH_O, (const char *)Dtool_EggPrimitive_set_bface_flag_873_comment},
  {"setBfaceFlag", &Dtool_EggPrimitive_set_bface_flag_873, METH_O, (const char *)Dtool_EggPrimitive_set_bface_flag_873_comment},
  {"get_bface_flag", &Dtool_EggPrimitive_get_bface_flag_874, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_bface_flag_874_comment},
  {"getBfaceFlag", &Dtool_EggPrimitive_get_bface_flag_874, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_bface_flag_874_comment},
  {"copy_attributes", &Dtool_EggPrimitive_copy_attributes_883, METH_O, (const char *)Dtool_EggPrimitive_copy_attributes_883_comment},
  {"copyAttributes", &Dtool_EggPrimitive_copy_attributes_883, METH_O, (const char *)Dtool_EggPrimitive_copy_attributes_883_comment},
  {"has_vertex_normal", &Dtool_EggPrimitive_has_vertex_normal_884, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_vertex_normal_884_comment},
  {"hasVertexNormal", &Dtool_EggPrimitive_has_vertex_normal_884, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_vertex_normal_884_comment},
  {"has_vertex_color", &Dtool_EggPrimitive_has_vertex_color_885, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_vertex_color_885_comment},
  {"hasVertexColor", &Dtool_EggPrimitive_has_vertex_color_885, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_vertex_color_885_comment},
  {"unify_attributes", &Dtool_EggPrimitive_unify_attributes_886, METH_O, (const char *)Dtool_EggPrimitive_unify_attributes_886_comment},
  {"unifyAttributes", &Dtool_EggPrimitive_unify_attributes_886, METH_O, (const char *)Dtool_EggPrimitive_unify_attributes_886_comment},
  {"apply_last_attribute", &Dtool_EggPrimitive_apply_last_attribute_887, METH_NOARGS, (const char *)Dtool_EggPrimitive_apply_last_attribute_887_comment},
  {"applyLastAttribute", &Dtool_EggPrimitive_apply_last_attribute_887, METH_NOARGS, (const char *)Dtool_EggPrimitive_apply_last_attribute_887_comment},
  {"apply_first_attribute", &Dtool_EggPrimitive_apply_first_attribute_888, METH_NOARGS, (const char *)Dtool_EggPrimitive_apply_first_attribute_888_comment},
  {"applyFirstAttribute", &Dtool_EggPrimitive_apply_first_attribute_888, METH_NOARGS, (const char *)Dtool_EggPrimitive_apply_first_attribute_888_comment},
  {"post_apply_flat_attribute", &Dtool_EggPrimitive_post_apply_flat_attribute_889, METH_NOARGS, (const char *)Dtool_EggPrimitive_post_apply_flat_attribute_889_comment},
  {"postApplyFlatAttribute", &Dtool_EggPrimitive_post_apply_flat_attribute_889, METH_NOARGS, (const char *)Dtool_EggPrimitive_post_apply_flat_attribute_889_comment},
  {"reverse_vertex_ordering", &Dtool_EggPrimitive_reverse_vertex_ordering_890, METH_NOARGS, (const char *)Dtool_EggPrimitive_reverse_vertex_ordering_890_comment},
  {"reverseVertexOrdering", &Dtool_EggPrimitive_reverse_vertex_ordering_890, METH_NOARGS, (const char *)Dtool_EggPrimitive_reverse_vertex_ordering_890_comment},
  {"cleanup", &Dtool_EggPrimitive_cleanup_891, METH_NOARGS, (const char *)Dtool_EggPrimitive_cleanup_891_comment},
  {"remove_doubled_verts", &Dtool_EggPrimitive_remove_doubled_verts_892, METH_O, (const char *)Dtool_EggPrimitive_remove_doubled_verts_892_comment},
  {"removeDoubledVerts", &Dtool_EggPrimitive_remove_doubled_verts_892, METH_O, (const char *)Dtool_EggPrimitive_remove_doubled_verts_892_comment},
  {"remove_nonunique_verts", &Dtool_EggPrimitive_remove_nonunique_verts_893, METH_NOARGS, (const char *)Dtool_EggPrimitive_remove_nonunique_verts_893_comment},
  {"removeNonuniqueVerts", &Dtool_EggPrimitive_remove_nonunique_verts_893, METH_NOARGS, (const char *)Dtool_EggPrimitive_remove_nonunique_verts_893_comment},
  {"has_primitives", &Dtool_EggPrimitive_has_primitives_894, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_primitives_894_comment},
  {"hasPrimitives", &Dtool_EggPrimitive_has_primitives_894, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_primitives_894_comment},
  {"joint_has_primitives", &Dtool_EggPrimitive_joint_has_primitives_895, METH_NOARGS, (const char *)Dtool_EggPrimitive_joint_has_primitives_895_comment},
  {"jointHasPrimitives", &Dtool_EggPrimitive_joint_has_primitives_895, METH_NOARGS, (const char *)Dtool_EggPrimitive_joint_has_primitives_895_comment},
  {"has_normals", &Dtool_EggPrimitive_has_normals_896, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_normals_896_comment},
  {"hasNormals", &Dtool_EggPrimitive_has_normals_896, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_normals_896_comment},
  {"clear", &Dtool_EggPrimitive_clear_897, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_897_comment},
  {"add_vertex", &Dtool_EggPrimitive_add_vertex_898, METH_O, (const char *)Dtool_EggPrimitive_add_vertex_898_comment},
  {"addVertex", &Dtool_EggPrimitive_add_vertex_898, METH_O, (const char *)Dtool_EggPrimitive_add_vertex_898_comment},
  {"remove_vertex", &Dtool_EggPrimitive_remove_vertex_899, METH_O, (const char *)Dtool_EggPrimitive_remove_vertex_899_comment},
  {"removeVertex", &Dtool_EggPrimitive_remove_vertex_899, METH_O, (const char *)Dtool_EggPrimitive_remove_vertex_899_comment},
  {"copy_vertices", &Dtool_EggPrimitive_copy_vertices_900, METH_O, (const char *)Dtool_EggPrimitive_copy_vertices_900_comment},
  {"copyVertices", &Dtool_EggPrimitive_copy_vertices_900, METH_O, (const char *)Dtool_EggPrimitive_copy_vertices_900_comment},
  {"get_num_vertices", &Dtool_EggPrimitive_get_num_vertices_901, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_num_vertices_901_comment},
  {"getNumVertices", &Dtool_EggPrimitive_get_num_vertices_901, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_num_vertices_901_comment},
  {"set_vertex", (PyCFunction) &Dtool_EggPrimitive_set_vertex_902, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPrimitive_set_vertex_902_comment},
  {"setVertex", (PyCFunction) &Dtool_EggPrimitive_set_vertex_902, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPrimitive_set_vertex_902_comment},
  {"get_vertex", &Dtool_EggPrimitive_get_vertex_903, METH_O, (const char *)Dtool_EggPrimitive_get_vertex_903_comment},
  {"getVertex", &Dtool_EggPrimitive_get_vertex_903, METH_O, (const char *)Dtool_EggPrimitive_get_vertex_903_comment},
  {"get_pool", &Dtool_EggPrimitive_get_pool_905, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_pool_905_comment},
  {"getPool", &Dtool_EggPrimitive_get_pool_905, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_pool_905_comment},
  {"write", (PyCFunction) &Dtool_EggPrimitive_write_910, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPrimitive_write_910_comment},
  {"test_vref_integrity", &Dtool_EggPrimitive_test_vref_integrity_911, METH_NOARGS, (const char *)Dtool_EggPrimitive_test_vref_integrity_911_comment},
  {"testVrefIntegrity", &Dtool_EggPrimitive_test_vref_integrity_911, METH_NOARGS, (const char *)Dtool_EggPrimitive_test_vref_integrity_911_comment},
  {"get_class_type", &Dtool_EggPrimitive_get_class_type_912, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPrimitive_get_class_type_912_comment},
  {"getClassType", &Dtool_EggPrimitive_get_class_type_912, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPrimitive_get_class_type_912_comment},
  {"upcast_to_EggNode", &Dtool_EggPrimitive_upcast_to_EggNode_841, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggNode_841_comment},
  {"upcastToEggNode", &Dtool_EggPrimitive_upcast_to_EggNode_841, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggNode_841_comment},
  {"upcast_to_EggAttributes", &Dtool_EggPrimitive_upcast_to_EggAttributes_843, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggAttributes_843_comment},
  {"upcastToEggAttributes", &Dtool_EggPrimitive_upcast_to_EggAttributes_843, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggAttributes_843_comment},
  {"upcast_to_EggRenderMode", &Dtool_EggPrimitive_upcast_to_EggRenderMode_845, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggRenderMode_845_comment},
  {"upcastToEggRenderMode", &Dtool_EggPrimitive_upcast_to_EggRenderMode_845, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggRenderMode_845_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_textures", (PyCFunction) &MakeSeq_EggPrimitive_get_textures, METH_NOARGS, NULL},
  { "getTextures", (PyCFunction) &MakeSeq_EggPrimitive_get_textures, METH_NOARGS, NULL},
  {"get_vertices", (PyCFunction) &MakeSeq_EggPrimitive_get_vertices, METH_NOARGS, NULL},
  { "getVertices", (PyCFunction) &MakeSeq_EggPrimitive_get_vertices, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     EggPrimitive
//////////////////
static PyObject *Dtool_Str_EggPrimitive(PyObject *self) {
  EggPrimitive *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_EggPrimitive[] = {
  {(char *)"sort_name", &Dtool_EggPrimitive_sort_name_Getter, NULL, NULL, NULL},
  {(char *)"shading", &Dtool_EggPrimitive_shading_Getter, NULL, NULL, NULL},
  {(char *)"connected_shading", &Dtool_EggPrimitive_connected_shading_Getter, NULL, NULL, NULL},
  {(char *)"textures", &Dtool_EggPrimitive_textures_Getter, NULL, NULL, NULL},
  {(char *)"material", &Dtool_EggPrimitive_material_Getter, &Dtool_EggPrimitive_material_Setter, NULL, NULL},
  {(char *)"bface_flag", &Dtool_EggPrimitive_bface_flag_Getter, &Dtool_EggPrimitive_bface_flag_Setter, NULL, NULL},
  {(char *)"vertices", &Dtool_EggPrimitive_vertices_Getter, NULL, NULL, NULL},
  {(char *)"pool", &Dtool_EggPrimitive_pool_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_EggPrimitive = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPrimitive = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggPrimitive = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggPrimitive = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggPrimitive = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggPrimitive",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPrimitive,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggPrimitive,
    &Dtool_SequenceMethods_EggPrimitive,
    &Dtool_MappingMethods_EggPrimitive,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_EggPrimitive,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggPrimitive,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for any of a number of kinds of geometry primitives: polygons,\n"
    " * point lights, nurbs patches, parametrics curves, etc.  Things with a set of\n"
    " * vertices and some rendering properties like color.\n"
    " *\n"
    " * An EggPrimitive is an STL-style container of pointers to EggVertex's.  In\n"
    " * fact, it IS a vector, and can be manipulated in all the ways that vectors\n"
    " * can.  However, it is necessary that all vertices belong to the same vertex\n"
    " * pool.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggPrimitive,
    0, // tp_members
    Dtool_Properties_EggPrimitive,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggPrimitive,
    PyType_GenericAlloc,
    Dtool_new_EggPrimitive,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPrimitive,
  Dtool_UpcastInterface_EggPrimitive,
  Dtool_DowncastInterface_EggPrimitive,
  (CoerceFunction)Dtool_ConstCoerce_EggPrimitive,
  (CoerceFunction)Dtool_Coerce_EggPrimitive,
};

static void Dtool_PyModuleClassInit_EggPrimitive(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(NULL);
    Dtool_PyModuleClassInit_EggAttributes(NULL);
    Dtool_PyModuleClassInit_EggRenderMode(NULL);
    Dtool_EggPrimitive._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)&Dtool_EggNode, (PyTypeObject *)&Dtool_EggAttributes, (PyTypeObject *)&Dtool_EggRenderMode);
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_EggPrimitive._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggPrimitive::Shading;
    PyDict_SetItemString(dict, "S_unknown", Dtool_WrapValue(EggPrimitive::S_unknown));
    PyDict_SetItemString(dict, "SUnknown", Dtool_WrapValue(EggPrimitive::S_unknown));
    PyDict_SetItemString(dict, "S_overall", Dtool_WrapValue(EggPrimitive::S_overall));
    PyDict_SetItemString(dict, "SOverall", Dtool_WrapValue(EggPrimitive::S_overall));
    PyDict_SetItemString(dict, "S_per_face", Dtool_WrapValue(EggPrimitive::S_per_face));
    PyDict_SetItemString(dict, "SPerFace", Dtool_WrapValue(EggPrimitive::S_per_face));
    PyDict_SetItemString(dict, "S_per_vertex", Dtool_WrapValue(EggPrimitive::S_per_vertex));
    PyDict_SetItemString(dict, "SPerVertex", Dtool_WrapValue(EggPrimitive::S_per_vertex));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPrimitive) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPrimitive)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPrimitive);
  }
}

/**
 * Python method tables for EggCompositePrimitive (EggCompositePrimitive)
 */
static PyMethodDef Dtool_Methods_EggCompositePrimitive[] = {
  {"assign", &Dtool_EggCompositePrimitive_operator_914, METH_O, (const char *)Dtool_EggCompositePrimitive_operator_914_comment},
  {"get_num_components", &Dtool_EggCompositePrimitive_get_num_components_915, METH_NOARGS, (const char *)Dtool_EggCompositePrimitive_get_num_components_915_comment},
  {"getNumComponents", &Dtool_EggCompositePrimitive_get_num_components_915, METH_NOARGS, (const char *)Dtool_EggCompositePrimitive_get_num_components_915_comment},
  {"get_component", &Dtool_EggCompositePrimitive_get_component_916, METH_O, (const char *)Dtool_EggCompositePrimitive_get_component_916_comment},
  {"getComponent", &Dtool_EggCompositePrimitive_get_component_916, METH_O, (const char *)Dtool_EggCompositePrimitive_get_component_916_comment},
  {"set_component", (PyCFunction) &Dtool_EggCompositePrimitive_set_component_918, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggCompositePrimitive_set_component_918_comment},
  {"setComponent", (PyCFunction) &Dtool_EggCompositePrimitive_set_component_918, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggCompositePrimitive_set_component_918_comment},
  {"triangulate_into", &Dtool_EggCompositePrimitive_triangulate_into_921, METH_O, (const char *)Dtool_EggCompositePrimitive_triangulate_into_921_comment},
  {"triangulateInto", &Dtool_EggCompositePrimitive_triangulate_into_921, METH_O, (const char *)Dtool_EggCompositePrimitive_triangulate_into_921_comment},
  {"triangulate_in_place", &Dtool_EggCompositePrimitive_triangulate_in_place_922, METH_NOARGS, (const char *)Dtool_EggCompositePrimitive_triangulate_in_place_922_comment},
  {"triangulateInPlace", &Dtool_EggCompositePrimitive_triangulate_in_place_922, METH_NOARGS, (const char *)Dtool_EggCompositePrimitive_triangulate_in_place_922_comment},
  {"get_class_type", &Dtool_EggCompositePrimitive_get_class_type_923, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCompositePrimitive_get_class_type_923_comment},
  {"getClassType", &Dtool_EggCompositePrimitive_get_class_type_923, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCompositePrimitive_get_class_type_923_comment},
  {"get_components", (PyCFunction) &MakeSeq_EggCompositePrimitive_get_components, METH_NOARGS, NULL},
  { "getComponents", (PyCFunction) &MakeSeq_EggCompositePrimitive_get_components, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_EggCompositePrimitive[] = {
  {(char *)"components", &Dtool_EggCompositePrimitive_components_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_EggCompositePrimitive = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggCompositePrimitive = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggCompositePrimitive = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggCompositePrimitive = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggCompositePrimitive = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggCompositePrimitive",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggCompositePrimitive,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggCompositePrimitive,
    &Dtool_SequenceMethods_EggCompositePrimitive,
    &Dtool_MappingMethods_EggCompositePrimitive,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggCompositePrimitive,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The base class for primitives such as triangle strips and triangle fans,\n"
    " * which include several component triangles, each of which might have its own\n"
    " * color and/or normal.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggCompositePrimitive,
    0, // tp_members
    Dtool_Properties_EggCompositePrimitive,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggCompositePrimitive,
    PyType_GenericAlloc,
    Dtool_new_EggCompositePrimitive,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggCompositePrimitive,
  Dtool_UpcastInterface_EggCompositePrimitive,
  Dtool_DowncastInterface_EggCompositePrimitive,
  (CoerceFunction)Dtool_ConstCoerce_EggCompositePrimitive,
  (CoerceFunction)Dtool_Coerce_EggCompositePrimitive,
};

static void Dtool_PyModuleClassInit_EggCompositePrimitive(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(NULL);
    Dtool_EggCompositePrimitive._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    PyObject *dict = PyDict_New();
    Dtool_EggCompositePrimitive._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggCompositePrimitive) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggCompositePrimitive)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggCompositePrimitive);
  }
}

/**
 * Python method tables for EggData (EggData)
 */
static PyMethodDef Dtool_Methods_EggData[] = {
  {"assign", &Dtool_EggData_operator_926, METH_O, (const char *)Dtool_EggData_operator_926_comment},
  {"resolve_egg_filename", (PyCFunction) &Dtool_EggData_resolve_egg_filename_927, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggData_resolve_egg_filename_927_comment},
  {"resolveEggFilename", (PyCFunction) &Dtool_EggData_resolve_egg_filename_927, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggData_resolve_egg_filename_927_comment},
  {"read", (PyCFunction) &Dtool_EggData_read_928, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggData_read_928_comment},
  {"merge", &Dtool_EggData_merge_929, METH_O, (const char *)Dtool_EggData_merge_929_comment},
  {"load_externals", (PyCFunction) &Dtool_EggData_load_externals_930, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggData_load_externals_930_comment},
  {"loadExternals", (PyCFunction) &Dtool_EggData_load_externals_930, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggData_load_externals_930_comment},
  {"collapse_equivalent_textures", &Dtool_EggData_collapse_equivalent_textures_931, METH_NOARGS, (const char *)Dtool_EggData_collapse_equivalent_textures_931_comment},
  {"collapseEquivalentTextures", &Dtool_EggData_collapse_equivalent_textures_931, METH_NOARGS, (const char *)Dtool_EggData_collapse_equivalent_textures_931_comment},
  {"collapse_equivalent_materials", &Dtool_EggData_collapse_equivalent_materials_932, METH_NOARGS, (const char *)Dtool_EggData_collapse_equivalent_materials_932_comment},
  {"collapseEquivalentMaterials", &Dtool_EggData_collapse_equivalent_materials_932, METH_NOARGS, (const char *)Dtool_EggData_collapse_equivalent_materials_932_comment},
  {"write_egg", &Dtool_EggData_write_egg_933, METH_O, (const char *)Dtool_EggData_write_egg_933_comment},
  {"writeEgg", &Dtool_EggData_write_egg_933, METH_O, (const char *)Dtool_EggData_write_egg_933_comment},
  {"set_auto_resolve_externals", &Dtool_EggData_set_auto_resolve_externals_934, METH_O, (const char *)Dtool_EggData_set_auto_resolve_externals_934_comment},
  {"setAutoResolveExternals", &Dtool_EggData_set_auto_resolve_externals_934, METH_O, (const char *)Dtool_EggData_set_auto_resolve_externals_934_comment},
  {"get_auto_resolve_externals", &Dtool_EggData_get_auto_resolve_externals_935, METH_NOARGS, (const char *)Dtool_EggData_get_auto_resolve_externals_935_comment},
  {"getAutoResolveExternals", &Dtool_EggData_get_auto_resolve_externals_935, METH_NOARGS, (const char *)Dtool_EggData_get_auto_resolve_externals_935_comment},
  {"original_had_absolute_pathnames", &Dtool_EggData_original_had_absolute_pathnames_936, METH_NOARGS, (const char *)Dtool_EggData_original_had_absolute_pathnames_936_comment},
  {"originalHadAbsolutePathnames", &Dtool_EggData_original_had_absolute_pathnames_936, METH_NOARGS, (const char *)Dtool_EggData_original_had_absolute_pathnames_936_comment},
  {"set_coordinate_system", &Dtool_EggData_set_coordinate_system_937, METH_O, (const char *)Dtool_EggData_set_coordinate_system_937_comment},
  {"setCoordinateSystem", &Dtool_EggData_set_coordinate_system_937, METH_O, (const char *)Dtool_EggData_set_coordinate_system_937_comment},
  {"get_coordinate_system", &Dtool_EggData_get_coordinate_system_938, METH_NOARGS, (const char *)Dtool_EggData_get_coordinate_system_938_comment},
  {"getCoordinateSystem", &Dtool_EggData_get_coordinate_system_938, METH_NOARGS, (const char *)Dtool_EggData_get_coordinate_system_938_comment},
  {"set_egg_filename", &Dtool_EggData_set_egg_filename_939, METH_O, (const char *)Dtool_EggData_set_egg_filename_939_comment},
  {"setEggFilename", &Dtool_EggData_set_egg_filename_939, METH_O, (const char *)Dtool_EggData_set_egg_filename_939_comment},
  {"get_egg_filename", &Dtool_EggData_get_egg_filename_940, METH_NOARGS, (const char *)Dtool_EggData_get_egg_filename_940_comment},
  {"getEggFilename", &Dtool_EggData_get_egg_filename_940, METH_NOARGS, (const char *)Dtool_EggData_get_egg_filename_940_comment},
  {"set_egg_timestamp", &Dtool_EggData_set_egg_timestamp_941, METH_O, (const char *)Dtool_EggData_set_egg_timestamp_941_comment},
  {"setEggTimestamp", &Dtool_EggData_set_egg_timestamp_941, METH_O, (const char *)Dtool_EggData_set_egg_timestamp_941_comment},
  {"get_egg_timestamp", &Dtool_EggData_get_egg_timestamp_942, METH_NOARGS, (const char *)Dtool_EggData_get_egg_timestamp_942_comment},
  {"getEggTimestamp", &Dtool_EggData_get_egg_timestamp_942, METH_NOARGS, (const char *)Dtool_EggData_get_egg_timestamp_942_comment},
  {"recompute_vertex_normals", &Dtool_EggData_recompute_vertex_normals_943, METH_O, (const char *)Dtool_EggData_recompute_vertex_normals_943_comment},
  {"recomputeVertexNormals", &Dtool_EggData_recompute_vertex_normals_943, METH_O, (const char *)Dtool_EggData_recompute_vertex_normals_943_comment},
  {"recompute_polygon_normals", &Dtool_EggData_recompute_polygon_normals_944, METH_NOARGS, (const char *)Dtool_EggData_recompute_polygon_normals_944_comment},
  {"recomputePolygonNormals", &Dtool_EggData_recompute_polygon_normals_944, METH_NOARGS, (const char *)Dtool_EggData_recompute_polygon_normals_944_comment},
  {"strip_normals", &Dtool_EggData_strip_normals_945, METH_NOARGS, (const char *)Dtool_EggData_strip_normals_945_comment},
  {"stripNormals", &Dtool_EggData_strip_normals_945, METH_NOARGS, (const char *)Dtool_EggData_strip_normals_945_comment},
  {"get_class_type", &Dtool_EggData_get_class_type_946, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggData_get_class_type_946_comment},
  {"getClassType", &Dtool_EggData_get_class_type_946, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggData_get_class_type_946_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggData = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggData = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggData = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggData,
    &Dtool_SequenceMethods_EggData,
    &Dtool_MappingMethods_EggData,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the primary interface into all the egg data, and the root of the\n"
    " * egg file structure.  An EggData structure corresponds exactly with an egg\n"
    " * file on the disk.\n"
    " *\n"
    " * The EggData class inherits from EggGroupNode its collection of children,\n"
    " * which are accessed by using the EggData itself as an STL container with\n"
    " * begin() and end() calls.  The children of the EggData class are the\n"
    " * toplevel nodes in the egg file.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggData,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggData,
    PyType_GenericAlloc,
    Dtool_new_EggData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggData,
  Dtool_UpcastInterface_EggData,
  Dtool_DowncastInterface_EggData,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggGroupNode(NULL);
    Dtool_EggData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggGroupNode);
    PyObject *dict = PyDict_New();
    Dtool_EggData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggData);
  }
}

/**
 * Python method tables for EggCoordinateSystem (EggCoordinateSystem)
 */
static PyMethodDef Dtool_Methods_EggCoordinateSystem[] = {
  {"set_value", &Dtool_EggCoordinateSystem_set_value_950, METH_O, (const char *)Dtool_EggCoordinateSystem_set_value_950_comment},
  {"setValue", &Dtool_EggCoordinateSystem_set_value_950, METH_O, (const char *)Dtool_EggCoordinateSystem_set_value_950_comment},
  {"get_value", &Dtool_EggCoordinateSystem_get_value_951, METH_NOARGS, (const char *)Dtool_EggCoordinateSystem_get_value_951_comment},
  {"getValue", &Dtool_EggCoordinateSystem_get_value_951, METH_NOARGS, (const char *)Dtool_EggCoordinateSystem_get_value_951_comment},
  {"get_class_type", &Dtool_EggCoordinateSystem_get_class_type_952, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCoordinateSystem_get_class_type_952_comment},
  {"getClassType", &Dtool_EggCoordinateSystem_get_class_type_952, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCoordinateSystem_get_class_type_952_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggCoordinateSystem = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggCoordinateSystem = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggCoordinateSystem = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggCoordinateSystem = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggCoordinateSystem = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggCoordinateSystem",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggCoordinateSystem,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggCoordinateSystem,
    &Dtool_SequenceMethods_EggCoordinateSystem,
    &Dtool_MappingMethods_EggCoordinateSystem,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggCoordinateSystem,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The <CoordinateSystem> entry at the top of an egg file.  Don't confuse this\n"
    " * with the enum EggData::CoordinateSystem, which is the value contained by\n"
    " * this entry.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggCoordinateSystem,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggCoordinateSystem,
    PyType_GenericAlloc,
    Dtool_new_EggCoordinateSystem,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggCoordinateSystem,
  Dtool_UpcastInterface_EggCoordinateSystem,
  Dtool_DowncastInterface_EggCoordinateSystem,
  (CoerceFunction)Dtool_ConstCoerce_EggCoordinateSystem,
  (CoerceFunction)Dtool_Coerce_EggCoordinateSystem,
};

static void Dtool_PyModuleClassInit_EggCoordinateSystem(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(NULL);
    Dtool_EggCoordinateSystem._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    PyObject *dict = PyDict_New();
    Dtool_EggCoordinateSystem._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggCoordinateSystem) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggCoordinateSystem)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggCoordinateSystem);
  }
}

/**
 * Python method tables for EggCurve (EggCurve)
 */
static PyMethodDef Dtool_Methods_EggCurve[] = {
  {"assign", &Dtool_EggCurve_operator_955, METH_O, (const char *)Dtool_EggCurve_operator_955_comment},
  {"set_subdiv", &Dtool_EggCurve_set_subdiv_957, METH_O, (const char *)Dtool_EggCurve_set_subdiv_957_comment},
  {"setSubdiv", &Dtool_EggCurve_set_subdiv_957, METH_O, (const char *)Dtool_EggCurve_set_subdiv_957_comment},
  {"get_subdiv", &Dtool_EggCurve_get_subdiv_958, METH_NOARGS, (const char *)Dtool_EggCurve_get_subdiv_958_comment},
  {"getSubdiv", &Dtool_EggCurve_get_subdiv_958, METH_NOARGS, (const char *)Dtool_EggCurve_get_subdiv_958_comment},
  {"set_curve_type", &Dtool_EggCurve_set_curve_type_959, METH_O, (const char *)Dtool_EggCurve_set_curve_type_959_comment},
  {"setCurveType", &Dtool_EggCurve_set_curve_type_959, METH_O, (const char *)Dtool_EggCurve_set_curve_type_959_comment},
  {"get_curve_type", &Dtool_EggCurve_get_curve_type_960, METH_NOARGS, (const char *)Dtool_EggCurve_get_curve_type_960_comment},
  {"getCurveType", &Dtool_EggCurve_get_curve_type_960, METH_NOARGS, (const char *)Dtool_EggCurve_get_curve_type_960_comment},
  {"string_curve_type", &Dtool_EggCurve_string_curve_type_961, METH_O | METH_STATIC, (const char *)Dtool_EggCurve_string_curve_type_961_comment},
  {"stringCurveType", &Dtool_EggCurve_string_curve_type_961, METH_O | METH_STATIC, (const char *)Dtool_EggCurve_string_curve_type_961_comment},
  {"get_class_type", &Dtool_EggCurve_get_class_type_962, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCurve_get_class_type_962_comment},
  {"getClassType", &Dtool_EggCurve_get_class_type_962, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCurve_get_class_type_962_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggCurve = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggCurve = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggCurve = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggCurve = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggCurve = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggCurve",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggCurve,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggCurve,
    &Dtool_SequenceMethods_EggCurve,
    &Dtool_MappingMethods_EggCurve,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A parametric curve of some kind.  See EggNurbsCurve.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggCurve,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggCurve,
    PyType_GenericAlloc,
    Dtool_new_EggCurve,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggCurve,
  Dtool_UpcastInterface_EggCurve,
  Dtool_DowncastInterface_EggCurve,
  (CoerceFunction)Dtool_ConstCoerce_EggCurve,
  (CoerceFunction)Dtool_Coerce_EggCurve,
};

static void Dtool_PyModuleClassInit_EggCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(NULL);
    Dtool_EggCurve._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_EggCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggCurve::CurveType;
    PyDict_SetItemString(dict, "CT_none", Dtool_WrapValue(EggCurve::CT_none));
    PyDict_SetItemString(dict, "CTNone", Dtool_WrapValue(EggCurve::CT_none));
    PyDict_SetItemString(dict, "CT_xyz", Dtool_WrapValue(EggCurve::CT_xyz));
    PyDict_SetItemString(dict, "CTXyz", Dtool_WrapValue(EggCurve::CT_xyz));
    PyDict_SetItemString(dict, "CT_hpr", Dtool_WrapValue(EggCurve::CT_hpr));
    PyDict_SetItemString(dict, "CTHpr", Dtool_WrapValue(EggCurve::CT_hpr));
    PyDict_SetItemString(dict, "CT_t", Dtool_WrapValue(EggCurve::CT_t));
    PyDict_SetItemString(dict, "CTT", Dtool_WrapValue(EggCurve::CT_t));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggCurve);
  }
}

/**
 * Python method tables for EggExternalReference (EggExternalReference)
 */
static PyMethodDef Dtool_Methods_EggExternalReference[] = {
  {"assign", &Dtool_EggExternalReference_operator_966, METH_O, (const char *)Dtool_EggExternalReference_operator_966_comment},
  {"get_class_type", &Dtool_EggExternalReference_get_class_type_967, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggExternalReference_get_class_type_967_comment},
  {"getClassType", &Dtool_EggExternalReference_get_class_type_967, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggExternalReference_get_class_type_967_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggExternalReference = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggExternalReference = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggExternalReference = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggExternalReference = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggExternalReference = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggExternalReference",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggExternalReference,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggExternalReference,
    &Dtool_SequenceMethods_EggExternalReference,
    &Dtool_MappingMethods_EggExternalReference,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggExternalReference,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a reference to another egg file which should be inserted at this\n"
    " * point.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggExternalReference,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggExternalReference,
    PyType_GenericAlloc,
    Dtool_new_EggExternalReference,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggExternalReference,
  Dtool_UpcastInterface_EggExternalReference,
  Dtool_DowncastInterface_EggExternalReference,
  (CoerceFunction)Dtool_ConstCoerce_EggExternalReference,
  (CoerceFunction)Dtool_Coerce_EggExternalReference,
};

static void Dtool_PyModuleClassInit_EggExternalReference(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggFilenameNode(NULL);
    Dtool_EggExternalReference._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggFilenameNode);
    PyObject *dict = PyDict_New();
    Dtool_EggExternalReference._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggExternalReference) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggExternalReference)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggExternalReference);
  }
}

/**
 * Python method tables for EggNameUniquifier (EggNameUniquifier)
 */
static PyMethodDef Dtool_Methods_EggNameUniquifier[] = {
  {"clear", &Dtool_EggNameUniquifier_clear_970, METH_NOARGS, (const char *)Dtool_EggNameUniquifier_clear_970_comment},
  {"uniquify", &Dtool_EggNameUniquifier_uniquify_971, METH_O, (const char *)Dtool_EggNameUniquifier_uniquify_971_comment},
  {"get_node", (PyCFunction) &Dtool_EggNameUniquifier_get_node_972, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_get_node_972_comment},
  {"getNode", (PyCFunction) &Dtool_EggNameUniquifier_get_node_972, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_get_node_972_comment},
  {"has_name", (PyCFunction) &Dtool_EggNameUniquifier_has_name_973, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_has_name_973_comment},
  {"hasName", (PyCFunction) &Dtool_EggNameUniquifier_has_name_973, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_has_name_973_comment},
  {"add_name", (PyCFunction) &Dtool_EggNameUniquifier_add_name_974, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_add_name_974_comment},
  {"addName", (PyCFunction) &Dtool_EggNameUniquifier_add_name_974, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_add_name_974_comment},
  {"get_category", &Dtool_EggNameUniquifier_get_category_975, METH_O, (const char *)Dtool_EggNameUniquifier_get_category_975_comment},
  {"getCategory", &Dtool_EggNameUniquifier_get_category_975, METH_O, (const char *)Dtool_EggNameUniquifier_get_category_975_comment},
  {"filter_name", &Dtool_EggNameUniquifier_filter_name_976, METH_O, (const char *)Dtool_EggNameUniquifier_filter_name_976_comment},
  {"filterName", &Dtool_EggNameUniquifier_filter_name_976, METH_O, (const char *)Dtool_EggNameUniquifier_filter_name_976_comment},
  {"generate_name", (PyCFunction) &Dtool_EggNameUniquifier_generate_name_977, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_generate_name_977_comment},
  {"generateName", (PyCFunction) &Dtool_EggNameUniquifier_generate_name_977, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_generate_name_977_comment},
  {"get_class_type", &Dtool_EggNameUniquifier_get_class_type_978, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNameUniquifier_get_class_type_978_comment},
  {"getClassType", &Dtool_EggNameUniquifier_get_class_type_978, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNameUniquifier_get_class_type_978_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggNameUniquifier = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggNameUniquifier = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggNameUniquifier = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggNameUniquifier = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggNameUniquifier = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggNameUniquifier",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggNameUniquifier,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggNameUniquifier,
    &Dtool_SequenceMethods_EggNameUniquifier,
    &Dtool_MappingMethods_EggNameUniquifier,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggNameUniquifier,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a handy class for guaranteeing unique node names in an egg\n"
    " * hierarchy.  It is an abstract class; to use it you must subclass off of it.\n"
    " * See the comment above.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggNameUniquifier,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggNameUniquifier,
    PyType_GenericAlloc,
    Dtool_new_EggNameUniquifier,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggNameUniquifier,
  Dtool_UpcastInterface_EggNameUniquifier,
  Dtool_DowncastInterface_EggNameUniquifier,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggNameUniquifier(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggObject(NULL);
    Dtool_EggNameUniquifier._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggObject);
    PyObject *dict = PyDict_New();
    Dtool_EggNameUniquifier._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggNameUniquifier) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggNameUniquifier)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggNameUniquifier);
  }
}

/**
 * Python method tables for EggGroupUniquifier (EggGroupUniquifier)
 */
static PyMethodDef Dtool_Methods_EggGroupUniquifier[] = {
  {"get_class_type", &Dtool_EggGroupUniquifier_get_class_type_981, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroupUniquifier_get_class_type_981_comment},
  {"getClassType", &Dtool_EggGroupUniquifier_get_class_type_981, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroupUniquifier_get_class_type_981_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggGroupUniquifier = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggGroupUniquifier = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggGroupUniquifier = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggGroupUniquifier = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggGroupUniquifier = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggGroupUniquifier",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggGroupUniquifier,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggGroupUniquifier,
    &Dtool_SequenceMethods_EggGroupUniquifier,
    &Dtool_MappingMethods_EggGroupUniquifier,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggGroupUniquifier,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization of EggNameUniquifier to generate unique names for\n"
    " * EggGroup nodes.  It's not called automatically; you must invoke it yourself\n"
    " * if you want it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggGroupUniquifier,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggGroupUniquifier,
    PyType_GenericAlloc,
    Dtool_new_EggGroupUniquifier,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggGroupUniquifier,
  Dtool_UpcastInterface_EggGroupUniquifier,
  Dtool_DowncastInterface_EggGroupUniquifier,
  (CoerceFunction)Dtool_ConstCoerce_EggGroupUniquifier,
  (CoerceFunction)Dtool_Coerce_EggGroupUniquifier,
};

static void Dtool_PyModuleClassInit_EggGroupUniquifier(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNameUniquifier(NULL);
    Dtool_EggGroupUniquifier._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNameUniquifier);
    PyObject *dict = PyDict_New();
    Dtool_EggGroupUniquifier._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggGroupUniquifier) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggGroupUniquifier)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggGroupUniquifier);
  }
}

/**
 * Python method tables for EggLine (EggLine)
 */
static PyMethodDef Dtool_Methods_EggLine[] = {
  {"assign", &Dtool_EggLine_operator_984, METH_O, (const char *)Dtool_EggLine_operator_984_comment},
  {"make_copy", &Dtool_EggLine_make_copy_985, METH_NOARGS, (const char *)Dtool_EggLine_make_copy_985_comment},
  {"makeCopy", &Dtool_EggLine_make_copy_985, METH_NOARGS, (const char *)Dtool_EggLine_make_copy_985_comment},
  {"has_thick", &Dtool_EggLine_has_thick_986, METH_NOARGS, (const char *)Dtool_EggLine_has_thick_986_comment},
  {"hasThick", &Dtool_EggLine_has_thick_986, METH_NOARGS, (const char *)Dtool_EggLine_has_thick_986_comment},
  {"get_thick", &Dtool_EggLine_get_thick_987, METH_NOARGS, (const char *)Dtool_EggLine_get_thick_987_comment},
  {"getThick", &Dtool_EggLine_get_thick_987, METH_NOARGS, (const char *)Dtool_EggLine_get_thick_987_comment},
  {"set_thick", &Dtool_EggLine_set_thick_988, METH_O, (const char *)Dtool_EggLine_set_thick_988_comment},
  {"setThick", &Dtool_EggLine_set_thick_988, METH_O, (const char *)Dtool_EggLine_set_thick_988_comment},
  {"clear_thick", &Dtool_EggLine_clear_thick_989, METH_NOARGS, (const char *)Dtool_EggLine_clear_thick_989_comment},
  {"clearThick", &Dtool_EggLine_clear_thick_989, METH_NOARGS, (const char *)Dtool_EggLine_clear_thick_989_comment},
  {"get_class_type", &Dtool_EggLine_get_class_type_990, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggLine_get_class_type_990_comment},
  {"getClassType", &Dtool_EggLine_get_class_type_990, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggLine_get_class_type_990_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggLine = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggLine = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggLine = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggLine = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggLine = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggLine",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggLine,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggLine,
    &Dtool_SequenceMethods_EggLine,
    &Dtool_MappingMethods_EggLine,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggLine,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A line segment, or a series of connected line segments, defined by a <Line>\n"
    " * entry.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggLine,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggLine,
    PyType_GenericAlloc,
    Dtool_new_EggLine,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggLine,
  Dtool_UpcastInterface_EggLine,
  Dtool_DowncastInterface_EggLine,
  (CoerceFunction)Dtool_ConstCoerce_EggLine,
  (CoerceFunction)Dtool_Coerce_EggLine,
};

static void Dtool_PyModuleClassInit_EggLine(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggCompositePrimitive(NULL);
    Dtool_EggLine._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggCompositePrimitive);
    PyObject *dict = PyDict_New();
    Dtool_EggLine._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggLine) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggLine)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggLine);
  }
}

/**
 * Python method tables for EggMaterialCollection (EggMaterialCollection)
 */
static PyMethodDef Dtool_Methods_EggMaterialCollection[] = {
  {"assign", &Dtool_EggMaterialCollection_operator_993, METH_O, (const char *)Dtool_EggMaterialCollection_operator_993_comment},
  {"clear", &Dtool_EggMaterialCollection_clear_995, METH_NOARGS, (const char *)Dtool_EggMaterialCollection_clear_995_comment},
  {"extract_materials", &Dtool_EggMaterialCollection_extract_materials_996, METH_O, (const char *)Dtool_EggMaterialCollection_extract_materials_996_comment},
  {"extractMaterials", &Dtool_EggMaterialCollection_extract_materials_996, METH_O, (const char *)Dtool_EggMaterialCollection_extract_materials_996_comment},
  {"find_used_materials", &Dtool_EggMaterialCollection_find_used_materials_997, METH_O, (const char *)Dtool_EggMaterialCollection_find_used_materials_997_comment},
  {"findUsedMaterials", &Dtool_EggMaterialCollection_find_used_materials_997, METH_O, (const char *)Dtool_EggMaterialCollection_find_used_materials_997_comment},
  {"remove_unused_materials", &Dtool_EggMaterialCollection_remove_unused_materials_998, METH_O, (const char *)Dtool_EggMaterialCollection_remove_unused_materials_998_comment},
  {"removeUnusedMaterials", &Dtool_EggMaterialCollection_remove_unused_materials_998, METH_O, (const char *)Dtool_EggMaterialCollection_remove_unused_materials_998_comment},
  {"collapse_equivalent_materials", (PyCFunction) &Dtool_EggMaterialCollection_collapse_equivalent_materials_999, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterialCollection_collapse_equivalent_materials_999_comment},
  {"collapseEquivalentMaterials", (PyCFunction) &Dtool_EggMaterialCollection_collapse_equivalent_materials_999, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterialCollection_collapse_equivalent_materials_999_comment},
  {"uniquify_mrefs", &Dtool_EggMaterialCollection_uniquify_mrefs_1001, METH_NOARGS, (const char *)Dtool_EggMaterialCollection_uniquify_mrefs_1001_comment},
  {"uniquifyMrefs", &Dtool_EggMaterialCollection_uniquify_mrefs_1001, METH_NOARGS, (const char *)Dtool_EggMaterialCollection_uniquify_mrefs_1001_comment},
  {"sort_by_mref", &Dtool_EggMaterialCollection_sort_by_mref_1002, METH_NOARGS, (const char *)Dtool_EggMaterialCollection_sort_by_mref_1002_comment},
  {"sortByMref", &Dtool_EggMaterialCollection_sort_by_mref_1002, METH_NOARGS, (const char *)Dtool_EggMaterialCollection_sort_by_mref_1002_comment},
  {"add_material", &Dtool_EggMaterialCollection_add_material_1003, METH_O, (const char *)Dtool_EggMaterialCollection_add_material_1003_comment},
  {"addMaterial", &Dtool_EggMaterialCollection_add_material_1003, METH_O, (const char *)Dtool_EggMaterialCollection_add_material_1003_comment},
  {"remove_material", &Dtool_EggMaterialCollection_remove_material_1004, METH_O, (const char *)Dtool_EggMaterialCollection_remove_material_1004_comment},
  {"removeMaterial", &Dtool_EggMaterialCollection_remove_material_1004, METH_O, (const char *)Dtool_EggMaterialCollection_remove_material_1004_comment},
  {"create_unique_material", (PyCFunction) &Dtool_EggMaterialCollection_create_unique_material_1005, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterialCollection_create_unique_material_1005_comment},
  {"createUniqueMaterial", (PyCFunction) &Dtool_EggMaterialCollection_create_unique_material_1005, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterialCollection_create_unique_material_1005_comment},
  {"find_mref", &Dtool_EggMaterialCollection_find_mref_1006, METH_O, (const char *)Dtool_EggMaterialCollection_find_mref_1006_comment},
  {"findMref", &Dtool_EggMaterialCollection_find_mref_1006, METH_O, (const char *)Dtool_EggMaterialCollection_find_mref_1006_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggMaterialCollection = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_EggMaterialCollection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggMaterialCollection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggMaterialCollection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggMaterialCollection,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a collection of materials by MRef name.  It can extract the\n"
    " * materials from an egg file and sort them all together; it can also manage\n"
    " * the creation of unique materials and the assignment of unique MRef names.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggMaterialCollection,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggMaterialCollection,
    PyType_GenericAlloc,
    Dtool_new_EggMaterialCollection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggMaterialCollection,
  Dtool_UpcastInterface_EggMaterialCollection,
  Dtool_DowncastInterface_EggMaterialCollection,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggMaterialCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EggMaterialCollection._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_EggMaterialCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggMaterialCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggMaterialCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggMaterialCollection);
  }
}

/**
 * Python method tables for EggPolygon (EggPolygon)
 */
static PyMethodDef Dtool_Methods_EggPolygon[] = {
  {"assign", &Dtool_EggPolygon_operator_1008, METH_O, (const char *)Dtool_EggPolygon_operator_1008_comment},
  {"make_copy", &Dtool_EggPolygon_make_copy_1009, METH_NOARGS, (const char *)Dtool_EggPolygon_make_copy_1009_comment},
  {"makeCopy", &Dtool_EggPolygon_make_copy_1009, METH_NOARGS, (const char *)Dtool_EggPolygon_make_copy_1009_comment},
  {"calculate_normal", (PyCFunction) &Dtool_EggPolygon_calculate_normal_1010, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_calculate_normal_1010_comment},
  {"calculateNormal", (PyCFunction) &Dtool_EggPolygon_calculate_normal_1010, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_calculate_normal_1010_comment},
  {"is_planar", &Dtool_EggPolygon_is_planar_1011, METH_NOARGS, (const char *)Dtool_EggPolygon_is_planar_1011_comment},
  {"isPlanar", &Dtool_EggPolygon_is_planar_1011, METH_NOARGS, (const char *)Dtool_EggPolygon_is_planar_1011_comment},
  {"recompute_polygon_normal", (PyCFunction) &Dtool_EggPolygon_recompute_polygon_normal_1012, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_recompute_polygon_normal_1012_comment},
  {"recomputePolygonNormal", (PyCFunction) &Dtool_EggPolygon_recompute_polygon_normal_1012, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_recompute_polygon_normal_1012_comment},
  {"triangulate_into", (PyCFunction) &Dtool_EggPolygon_triangulate_into_1013, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_triangulate_into_1013_comment},
  {"triangulateInto", (PyCFunction) &Dtool_EggPolygon_triangulate_into_1013, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_triangulate_into_1013_comment},
  {"triangulate_in_place", &Dtool_EggPolygon_triangulate_in_place_1014, METH_O, (const char *)Dtool_EggPolygon_triangulate_in_place_1014_comment},
  {"triangulateInPlace", &Dtool_EggPolygon_triangulate_in_place_1014, METH_O, (const char *)Dtool_EggPolygon_triangulate_in_place_1014_comment},
  {"get_class_type", &Dtool_EggPolygon_get_class_type_1015, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPolygon_get_class_type_1015_comment},
  {"getClassType", &Dtool_EggPolygon_get_class_type_1015, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPolygon_get_class_type_1015_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggPolygon = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPolygon = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggPolygon = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggPolygon = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggPolygon = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggPolygon",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPolygon,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggPolygon,
    &Dtool_SequenceMethods_EggPolygon,
    &Dtool_MappingMethods_EggPolygon,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggPolygon,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single polygon.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggPolygon,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggPolygon,
    PyType_GenericAlloc,
    Dtool_new_EggPolygon,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPolygon,
  Dtool_UpcastInterface_EggPolygon,
  Dtool_DowncastInterface_EggPolygon,
  (CoerceFunction)Dtool_ConstCoerce_EggPolygon,
  (CoerceFunction)Dtool_Coerce_EggPolygon,
};

static void Dtool_PyModuleClassInit_EggPolygon(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(NULL);
    Dtool_EggPolygon._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    PyObject *dict = PyDict_New();
    Dtool_EggPolygon._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPolygon) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPolygon)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPolygon);
  }
}

/**
 * Python method tables for EggNurbsCurve (EggNurbsCurve)
 */
static PyMethodDef Dtool_Methods_EggNurbsCurve[] = {
  {"assign", &Dtool_EggNurbsCurve_operator_1018, METH_O, (const char *)Dtool_EggNurbsCurve_operator_1018_comment},
  {"make_copy", &Dtool_EggNurbsCurve_make_copy_1019, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_make_copy_1019_comment},
  {"makeCopy", &Dtool_EggNurbsCurve_make_copy_1019, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_make_copy_1019_comment},
  {"setup", (PyCFunction) &Dtool_EggNurbsCurve_setup_1020, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsCurve_setup_1020_comment},
  {"set_order", &Dtool_EggNurbsCurve_set_order_1021, METH_O, (const char *)Dtool_EggNurbsCurve_set_order_1021_comment},
  {"setOrder", &Dtool_EggNurbsCurve_set_order_1021, METH_O, (const char *)Dtool_EggNurbsCurve_set_order_1021_comment},
  {"set_num_knots", &Dtool_EggNurbsCurve_set_num_knots_1022, METH_O, (const char *)Dtool_EggNurbsCurve_set_num_knots_1022_comment},
  {"setNumKnots", &Dtool_EggNurbsCurve_set_num_knots_1022, METH_O, (const char *)Dtool_EggNurbsCurve_set_num_knots_1022_comment},
  {"set_knot", (PyCFunction) &Dtool_EggNurbsCurve_set_knot_1023, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsCurve_set_knot_1023_comment},
  {"setKnot", (PyCFunction) &Dtool_EggNurbsCurve_set_knot_1023, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsCurve_set_knot_1023_comment},
  {"is_valid", &Dtool_EggNurbsCurve_is_valid_1024, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_is_valid_1024_comment},
  {"isValid", &Dtool_EggNurbsCurve_is_valid_1024, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_is_valid_1024_comment},
  {"get_order", &Dtool_EggNurbsCurve_get_order_1025, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_order_1025_comment},
  {"getOrder", &Dtool_EggNurbsCurve_get_order_1025, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_order_1025_comment},
  {"get_degree", &Dtool_EggNurbsCurve_get_degree_1026, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_degree_1026_comment},
  {"getDegree", &Dtool_EggNurbsCurve_get_degree_1026, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_degree_1026_comment},
  {"get_num_knots", &Dtool_EggNurbsCurve_get_num_knots_1027, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_num_knots_1027_comment},
  {"getNumKnots", &Dtool_EggNurbsCurve_get_num_knots_1027, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_num_knots_1027_comment},
  {"get_num_cvs", &Dtool_EggNurbsCurve_get_num_cvs_1028, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_num_cvs_1028_comment},
  {"getNumCvs", &Dtool_EggNurbsCurve_get_num_cvs_1028, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_num_cvs_1028_comment},
  {"is_closed", &Dtool_EggNurbsCurve_is_closed_1029, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_is_closed_1029_comment},
  {"isClosed", &Dtool_EggNurbsCurve_is_closed_1029, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_is_closed_1029_comment},
  {"get_knot", &Dtool_EggNurbsCurve_get_knot_1030, METH_O, (const char *)Dtool_EggNurbsCurve_get_knot_1030_comment},
  {"getKnot", &Dtool_EggNurbsCurve_get_knot_1030, METH_O, (const char *)Dtool_EggNurbsCurve_get_knot_1030_comment},
  {"get_class_type", &Dtool_EggNurbsCurve_get_class_type_1036, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNurbsCurve_get_class_type_1036_comment},
  {"getClassType", &Dtool_EggNurbsCurve_get_class_type_1036, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNurbsCurve_get_class_type_1036_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_knots", (PyCFunction) &MakeSeq_EggNurbsCurve_get_knots, METH_NOARGS, NULL},
  { "getKnots", (PyCFunction) &MakeSeq_EggNurbsCurve_get_knots, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_EggNurbsCurve[] = {
  {(char *)"order", &Dtool_EggNurbsCurve_order_Getter, &Dtool_EggNurbsCurve_order_Setter, NULL, NULL},
  {(char *)"degree", &Dtool_EggNurbsCurve_degree_Getter, NULL, NULL, NULL},
  {(char *)"closed", &Dtool_EggNurbsCurve_closed_Getter, NULL, NULL, NULL},
  {(char *)"knots", &Dtool_EggNurbsCurve_knots_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_EggNurbsCurve = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggNurbsCurve = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggNurbsCurve = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggNurbsCurve = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggNurbsCurve = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggNurbsCurve",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggNurbsCurve,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggNurbsCurve,
    &Dtool_SequenceMethods_EggNurbsCurve,
    &Dtool_MappingMethods_EggNurbsCurve,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggNurbsCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A parametric NURBS curve.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggNurbsCurve,
    0, // tp_members
    Dtool_Properties_EggNurbsCurve,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggNurbsCurve,
    PyType_GenericAlloc,
    Dtool_new_EggNurbsCurve,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggNurbsCurve,
  Dtool_UpcastInterface_EggNurbsCurve,
  Dtool_DowncastInterface_EggNurbsCurve,
  (CoerceFunction)Dtool_ConstCoerce_EggNurbsCurve,
  (CoerceFunction)Dtool_Coerce_EggNurbsCurve,
};

static void Dtool_PyModuleClassInit_EggNurbsCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggCurve(NULL);
    Dtool_EggNurbsCurve._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggCurve);
    PyObject *dict = PyDict_New();
    Dtool_EggNurbsCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggNurbsCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggNurbsCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggNurbsCurve);
  }
}

/**
 * Python method tables for EggSurface (EggSurface)
 */
static PyMethodDef Dtool_Methods_EggSurface[] = {
  {"assign", &Dtool_EggSurface_operator_1039, METH_O, (const char *)Dtool_EggSurface_operator_1039_comment},
  {"set_u_subdiv", &Dtool_EggSurface_set_u_subdiv_1040, METH_O, (const char *)Dtool_EggSurface_set_u_subdiv_1040_comment},
  {"setUSubdiv", &Dtool_EggSurface_set_u_subdiv_1040, METH_O, (const char *)Dtool_EggSurface_set_u_subdiv_1040_comment},
  {"get_u_subdiv", &Dtool_EggSurface_get_u_subdiv_1041, METH_NOARGS, (const char *)Dtool_EggSurface_get_u_subdiv_1041_comment},
  {"getUSubdiv", &Dtool_EggSurface_get_u_subdiv_1041, METH_NOARGS, (const char *)Dtool_EggSurface_get_u_subdiv_1041_comment},
  {"set_v_subdiv", &Dtool_EggSurface_set_v_subdiv_1042, METH_O, (const char *)Dtool_EggSurface_set_v_subdiv_1042_comment},
  {"setVSubdiv", &Dtool_EggSurface_set_v_subdiv_1042, METH_O, (const char *)Dtool_EggSurface_set_v_subdiv_1042_comment},
  {"get_v_subdiv", &Dtool_EggSurface_get_v_subdiv_1043, METH_NOARGS, (const char *)Dtool_EggSurface_get_v_subdiv_1043_comment},
  {"getVSubdiv", &Dtool_EggSurface_get_v_subdiv_1043, METH_NOARGS, (const char *)Dtool_EggSurface_get_v_subdiv_1043_comment},
  {"get_class_type", &Dtool_EggSurface_get_class_type_1044, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSurface_get_class_type_1044_comment},
  {"getClassType", &Dtool_EggSurface_get_class_type_1044, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSurface_get_class_type_1044_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggSurface = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggSurface = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggSurface = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggSurface = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggSurface = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggSurface",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggSurface,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggSurface,
    &Dtool_SequenceMethods_EggSurface,
    &Dtool_MappingMethods_EggSurface,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggSurface,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A parametric surface of some kind.  See EggNurbsSurface.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggSurface,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggSurface,
    PyType_GenericAlloc,
    Dtool_new_EggSurface,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggSurface,
  Dtool_UpcastInterface_EggSurface,
  Dtool_DowncastInterface_EggSurface,
  (CoerceFunction)Dtool_ConstCoerce_EggSurface,
  (CoerceFunction)Dtool_Coerce_EggSurface,
};

static void Dtool_PyModuleClassInit_EggSurface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(NULL);
    Dtool_EggSurface._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    PyObject *dict = PyDict_New();
    Dtool_EggSurface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggSurface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggSurface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggSurface);
  }
}

/**
 * Python method tables for EggNurbsSurface (EggNurbsSurface)
 */
static PyMethodDef Dtool_Methods_EggNurbsSurface[] = {
  {"assign", &Dtool_EggNurbsSurface_operator_1055, METH_O, (const char *)Dtool_EggNurbsSurface_operator_1055_comment},
  {"make_copy", &Dtool_EggNurbsSurface_make_copy_1056, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_make_copy_1056_comment},
  {"makeCopy", &Dtool_EggNurbsSurface_make_copy_1056, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_make_copy_1056_comment},
  {"setup", (PyCFunction) &Dtool_EggNurbsSurface_setup_1057, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_setup_1057_comment},
  {"set_u_order", &Dtool_EggNurbsSurface_set_u_order_1058, METH_O, (const char *)Dtool_EggNurbsSurface_set_u_order_1058_comment},
  {"setUOrder", &Dtool_EggNurbsSurface_set_u_order_1058, METH_O, (const char *)Dtool_EggNurbsSurface_set_u_order_1058_comment},
  {"set_v_order", &Dtool_EggNurbsSurface_set_v_order_1059, METH_O, (const char *)Dtool_EggNurbsSurface_set_v_order_1059_comment},
  {"setVOrder", &Dtool_EggNurbsSurface_set_v_order_1059, METH_O, (const char *)Dtool_EggNurbsSurface_set_v_order_1059_comment},
  {"set_num_u_knots", &Dtool_EggNurbsSurface_set_num_u_knots_1060, METH_O, (const char *)Dtool_EggNurbsSurface_set_num_u_knots_1060_comment},
  {"setNumUKnots", &Dtool_EggNurbsSurface_set_num_u_knots_1060, METH_O, (const char *)Dtool_EggNurbsSurface_set_num_u_knots_1060_comment},
  {"set_num_v_knots", &Dtool_EggNurbsSurface_set_num_v_knots_1061, METH_O, (const char *)Dtool_EggNurbsSurface_set_num_v_knots_1061_comment},
  {"setNumVKnots", &Dtool_EggNurbsSurface_set_num_v_knots_1061, METH_O, (const char *)Dtool_EggNurbsSurface_set_num_v_knots_1061_comment},
  {"set_u_knot", (PyCFunction) &Dtool_EggNurbsSurface_set_u_knot_1062, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_u_knot_1062_comment},
  {"setUKnot", (PyCFunction) &Dtool_EggNurbsSurface_set_u_knot_1062, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_u_knot_1062_comment},
  {"set_v_knot", (PyCFunction) &Dtool_EggNurbsSurface_set_v_knot_1063, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_v_knot_1063_comment},
  {"setVKnot", (PyCFunction) &Dtool_EggNurbsSurface_set_v_knot_1063, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_v_knot_1063_comment},
  {"set_cv", (PyCFunction) &Dtool_EggNurbsSurface_set_cv_1064, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_cv_1064_comment},
  {"setCv", (PyCFunction) &Dtool_EggNurbsSurface_set_cv_1064, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_cv_1064_comment},
  {"is_valid", &Dtool_EggNurbsSurface_is_valid_1065, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_valid_1065_comment},
  {"isValid", &Dtool_EggNurbsSurface_is_valid_1065, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_valid_1065_comment},
  {"get_u_order", &Dtool_EggNurbsSurface_get_u_order_1066, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_u_order_1066_comment},
  {"getUOrder", &Dtool_EggNurbsSurface_get_u_order_1066, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_u_order_1066_comment},
  {"get_v_order", &Dtool_EggNurbsSurface_get_v_order_1067, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_v_order_1067_comment},
  {"getVOrder", &Dtool_EggNurbsSurface_get_v_order_1067, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_v_order_1067_comment},
  {"get_u_degree", &Dtool_EggNurbsSurface_get_u_degree_1068, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_u_degree_1068_comment},
  {"getUDegree", &Dtool_EggNurbsSurface_get_u_degree_1068, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_u_degree_1068_comment},
  {"get_v_degree", &Dtool_EggNurbsSurface_get_v_degree_1069, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_v_degree_1069_comment},
  {"getVDegree", &Dtool_EggNurbsSurface_get_v_degree_1069, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_v_degree_1069_comment},
  {"get_num_u_knots", &Dtool_EggNurbsSurface_get_num_u_knots_1070, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_u_knots_1070_comment},
  {"getNumUKnots", &Dtool_EggNurbsSurface_get_num_u_knots_1070, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_u_knots_1070_comment},
  {"get_num_v_knots", &Dtool_EggNurbsSurface_get_num_v_knots_1071, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_v_knots_1071_comment},
  {"getNumVKnots", &Dtool_EggNurbsSurface_get_num_v_knots_1071, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_v_knots_1071_comment},
  {"get_num_u_cvs", &Dtool_EggNurbsSurface_get_num_u_cvs_1072, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_u_cvs_1072_comment},
  {"getNumUCvs", &Dtool_EggNurbsSurface_get_num_u_cvs_1072, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_u_cvs_1072_comment},
  {"get_num_v_cvs", &Dtool_EggNurbsSurface_get_num_v_cvs_1073, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_v_cvs_1073_comment},
  {"getNumVCvs", &Dtool_EggNurbsSurface_get_num_v_cvs_1073, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_v_cvs_1073_comment},
  {"get_num_cvs", &Dtool_EggNurbsSurface_get_num_cvs_1074, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_cvs_1074_comment},
  {"getNumCvs", &Dtool_EggNurbsSurface_get_num_cvs_1074, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_cvs_1074_comment},
  {"get_u_index", &Dtool_EggNurbsSurface_get_u_index_1075, METH_O, (const char *)Dtool_EggNurbsSurface_get_u_index_1075_comment},
  {"getUIndex", &Dtool_EggNurbsSurface_get_u_index_1075, METH_O, (const char *)Dtool_EggNurbsSurface_get_u_index_1075_comment},
  {"get_v_index", &Dtool_EggNurbsSurface_get_v_index_1076, METH_O, (const char *)Dtool_EggNurbsSurface_get_v_index_1076_comment},
  {"getVIndex", &Dtool_EggNurbsSurface_get_v_index_1076, METH_O, (const char *)Dtool_EggNurbsSurface_get_v_index_1076_comment},
  {"get_vertex_index", (PyCFunction) &Dtool_EggNurbsSurface_get_vertex_index_1077, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_get_vertex_index_1077_comment},
  {"getVertexIndex", (PyCFunction) &Dtool_EggNurbsSurface_get_vertex_index_1077, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_get_vertex_index_1077_comment},
  {"is_closed_u", &Dtool_EggNurbsSurface_is_closed_u_1078, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_closed_u_1078_comment},
  {"isClosedU", &Dtool_EggNurbsSurface_is_closed_u_1078, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_closed_u_1078_comment},
  {"is_closed_v", &Dtool_EggNurbsSurface_is_closed_v_1079, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_closed_v_1079_comment},
  {"isClosedV", &Dtool_EggNurbsSurface_is_closed_v_1079, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_closed_v_1079_comment},
  {"get_u_knot", &Dtool_EggNurbsSurface_get_u_knot_1080, METH_O, (const char *)Dtool_EggNurbsSurface_get_u_knot_1080_comment},
  {"getUKnot", &Dtool_EggNurbsSurface_get_u_knot_1080, METH_O, (const char *)Dtool_EggNurbsSurface_get_u_knot_1080_comment},
  {"get_v_knot", &Dtool_EggNurbsSurface_get_v_knot_1082, METH_O, (const char *)Dtool_EggNurbsSurface_get_v_knot_1082_comment},
  {"getVKnot", &Dtool_EggNurbsSurface_get_v_knot_1082, METH_O, (const char *)Dtool_EggNurbsSurface_get_v_knot_1082_comment},
  {"get_cv", (PyCFunction) &Dtool_EggNurbsSurface_get_cv_1084, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_get_cv_1084_comment},
  {"getCv", (PyCFunction) &Dtool_EggNurbsSurface_get_cv_1084, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_get_cv_1084_comment},
  {"get_class_type", &Dtool_EggNurbsSurface_get_class_type_1085, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNurbsSurface_get_class_type_1085_comment},
  {"getClassType", &Dtool_EggNurbsSurface_get_class_type_1085, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNurbsSurface_get_class_type_1085_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_u_knots", (PyCFunction) &MakeSeq_EggNurbsSurface_get_u_knots, METH_NOARGS, NULL},
  { "getUKnots", (PyCFunction) &MakeSeq_EggNurbsSurface_get_u_knots, METH_NOARGS, NULL},
  {"get_v_knots", (PyCFunction) &MakeSeq_EggNurbsSurface_get_v_knots, METH_NOARGS, NULL},
  { "getVKnots", (PyCFunction) &MakeSeq_EggNurbsSurface_get_v_knots, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggNurbsSurface = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggNurbsSurface = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggNurbsSurface = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggNurbsSurface = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggNurbsSurface = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggNurbsSurface",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggNurbsSurface,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggNurbsSurface,
    &Dtool_SequenceMethods_EggNurbsSurface,
    &Dtool_MappingMethods_EggNurbsSurface,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggNurbsSurface,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A parametric NURBS surface.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggNurbsSurface,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggNurbsSurface,
    PyType_GenericAlloc,
    Dtool_new_EggNurbsSurface,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggNurbsSurface,
  Dtool_UpcastInterface_EggNurbsSurface,
  Dtool_DowncastInterface_EggNurbsSurface,
  (CoerceFunction)Dtool_ConstCoerce_EggNurbsSurface,
  (CoerceFunction)Dtool_Coerce_EggNurbsSurface,
};

static void Dtool_PyModuleClassInit_EggNurbsSurface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggSurface(NULL);
    Dtool_EggNurbsSurface._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggSurface);
    PyObject *dict = PyDict_New();
    Dtool_EggNurbsSurface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggNurbsSurface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggNurbsSurface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggNurbsSurface);
  }
}

/**
 * Python method tables for EggPatch (EggPatch)
 */
static PyMethodDef Dtool_Methods_EggPatch[] = {
  {"assign", &Dtool_EggPatch_operator_1088, METH_O, (const char *)Dtool_EggPatch_operator_1088_comment},
  {"make_copy", &Dtool_EggPatch_make_copy_1089, METH_NOARGS, (const char *)Dtool_EggPatch_make_copy_1089_comment},
  {"makeCopy", &Dtool_EggPatch_make_copy_1089, METH_NOARGS, (const char *)Dtool_EggPatch_make_copy_1089_comment},
  {"get_class_type", &Dtool_EggPatch_get_class_type_1090, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPatch_get_class_type_1090_comment},
  {"getClassType", &Dtool_EggPatch_get_class_type_1090, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPatch_get_class_type_1090_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggPatch = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPatch = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggPatch = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggPatch = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggPatch = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggPatch",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPatch,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggPatch,
    &Dtool_SequenceMethods_EggPatch,
    &Dtool_MappingMethods_EggPatch,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggPatch,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single \"patch\", a special primitive to be rendered only with a\n"
    " * tessellation shader.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggPatch,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggPatch,
    PyType_GenericAlloc,
    Dtool_new_EggPatch,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPatch,
  Dtool_UpcastInterface_EggPatch,
  Dtool_DowncastInterface_EggPatch,
  (CoerceFunction)Dtool_ConstCoerce_EggPatch,
  (CoerceFunction)Dtool_Coerce_EggPatch,
};

static void Dtool_PyModuleClassInit_EggPatch(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(NULL);
    Dtool_EggPatch._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    PyObject *dict = PyDict_New();
    Dtool_EggPatch._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPatch) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPatch)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPatch);
  }
}

/**
 * Python method tables for EggPoint (EggPoint)
 */
static PyMethodDef Dtool_Methods_EggPoint[] = {
  {"assign", &Dtool_EggPoint_operator_1093, METH_O, (const char *)Dtool_EggPoint_operator_1093_comment},
  {"make_copy", &Dtool_EggPoint_make_copy_1094, METH_NOARGS, (const char *)Dtool_EggPoint_make_copy_1094_comment},
  {"makeCopy", &Dtool_EggPoint_make_copy_1094, METH_NOARGS, (const char *)Dtool_EggPoint_make_copy_1094_comment},
  {"has_thick", &Dtool_EggPoint_has_thick_1095, METH_NOARGS, (const char *)Dtool_EggPoint_has_thick_1095_comment},
  {"hasThick", &Dtool_EggPoint_has_thick_1095, METH_NOARGS, (const char *)Dtool_EggPoint_has_thick_1095_comment},
  {"get_thick", &Dtool_EggPoint_get_thick_1096, METH_NOARGS, (const char *)Dtool_EggPoint_get_thick_1096_comment},
  {"getThick", &Dtool_EggPoint_get_thick_1096, METH_NOARGS, (const char *)Dtool_EggPoint_get_thick_1096_comment},
  {"set_thick", &Dtool_EggPoint_set_thick_1097, METH_O, (const char *)Dtool_EggPoint_set_thick_1097_comment},
  {"setThick", &Dtool_EggPoint_set_thick_1097, METH_O, (const char *)Dtool_EggPoint_set_thick_1097_comment},
  {"clear_thick", &Dtool_EggPoint_clear_thick_1098, METH_NOARGS, (const char *)Dtool_EggPoint_clear_thick_1098_comment},
  {"clearThick", &Dtool_EggPoint_clear_thick_1098, METH_NOARGS, (const char *)Dtool_EggPoint_clear_thick_1098_comment},
  {"has_perspective", &Dtool_EggPoint_has_perspective_1099, METH_NOARGS, (const char *)Dtool_EggPoint_has_perspective_1099_comment},
  {"hasPerspective", &Dtool_EggPoint_has_perspective_1099, METH_NOARGS, (const char *)Dtool_EggPoint_has_perspective_1099_comment},
  {"get_perspective", &Dtool_EggPoint_get_perspective_1100, METH_NOARGS, (const char *)Dtool_EggPoint_get_perspective_1100_comment},
  {"getPerspective", &Dtool_EggPoint_get_perspective_1100, METH_NOARGS, (const char *)Dtool_EggPoint_get_perspective_1100_comment},
  {"set_perspective", &Dtool_EggPoint_set_perspective_1101, METH_O, (const char *)Dtool_EggPoint_set_perspective_1101_comment},
  {"setPerspective", &Dtool_EggPoint_set_perspective_1101, METH_O, (const char *)Dtool_EggPoint_set_perspective_1101_comment},
  {"clear_perspective", &Dtool_EggPoint_clear_perspective_1102, METH_NOARGS, (const char *)Dtool_EggPoint_clear_perspective_1102_comment},
  {"clearPerspective", &Dtool_EggPoint_clear_perspective_1102, METH_NOARGS, (const char *)Dtool_EggPoint_clear_perspective_1102_comment},
  {"get_class_type", &Dtool_EggPoint_get_class_type_1103, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPoint_get_class_type_1103_comment},
  {"getClassType", &Dtool_EggPoint_get_class_type_1103, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPoint_get_class_type_1103_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggPoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggPoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggPoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggPoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggPoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggPoint,
    &Dtool_SequenceMethods_EggPoint,
    &Dtool_MappingMethods_EggPoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggPoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single point, or a collection of points as defined by a single\n"
    " * <PointLight> entry.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggPoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggPoint,
    PyType_GenericAlloc,
    Dtool_new_EggPoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPoint,
  Dtool_UpcastInterface_EggPoint,
  Dtool_DowncastInterface_EggPoint,
  (CoerceFunction)Dtool_ConstCoerce_EggPoint,
  (CoerceFunction)Dtool_Coerce_EggPoint,
};

static void Dtool_PyModuleClassInit_EggPoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(NULL);
    Dtool_EggPoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    PyObject *dict = PyDict_New();
    Dtool_EggPoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPoint);
  }
}

/**
 * Python method tables for EggPolysetMaker (EggPolysetMaker)
 */
static PyMethodDef Dtool_Methods_EggPolysetMaker[] = {
  {"set_properties", &Dtool_EggPolysetMaker_set_properties_1109, METH_O, (const char *)Dtool_EggPolysetMaker_set_properties_1109_comment},
  {"setProperties", &Dtool_EggPolysetMaker_set_properties_1109, METH_O, (const char *)Dtool_EggPolysetMaker_set_properties_1109_comment},
  {"get_class_type", &Dtool_EggPolysetMaker_get_class_type_1110, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPolysetMaker_get_class_type_1110_comment},
  {"getClassType", &Dtool_EggPolysetMaker_get_class_type_1110, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPolysetMaker_get_class_type_1110_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggPolysetMaker = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPolysetMaker = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggPolysetMaker = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggPolysetMaker = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggPolysetMaker = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggPolysetMaker",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPolysetMaker,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggPolysetMaker,
    &Dtool_SequenceMethods_EggPolysetMaker,
    &Dtool_MappingMethods_EggPolysetMaker,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggPolysetMaker,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialization on EggBinMaker for making polysets that share the same\n"
    " * basic rendering characteristic.  This really just defines the example\n"
    " * functions described in the leading comment to EggBinMaker.\n"
    " *\n"
    " * It makes some common assumptions about how polysets should be grouped; if\n"
    " * these are not sufficient, you can always rederive your own further\n"
    " * specialization of this class.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggPolysetMaker,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggPolysetMaker,
    PyType_GenericAlloc,
    Dtool_new_EggPolysetMaker,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPolysetMaker,
  Dtool_UpcastInterface_EggPolysetMaker,
  Dtool_DowncastInterface_EggPolysetMaker,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggPolysetMaker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggBinMaker(NULL);
    Dtool_EggPolysetMaker._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggBinMaker);
    PyObject *dict = _PyDict_NewPresized(25);
    Dtool_EggPolysetMaker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggPolysetMaker::BinNumber;
    PyDict_SetItemString(dict, "BN_none", Dtool_WrapValue(EggPolysetMaker::BN_none));
    PyDict_SetItemString(dict, "BNNone", Dtool_WrapValue(EggPolysetMaker::BN_none));
    PyDict_SetItemString(dict, "BN_polyset", Dtool_WrapValue(EggPolysetMaker::BN_polyset));
    PyDict_SetItemString(dict, "BNPolyset", Dtool_WrapValue(EggPolysetMaker::BN_polyset));
    // enum EggPolysetMaker::Properties;
    PyDict_SetItemString(dict, "P_has_texture", Dtool_WrapValue(EggPolysetMaker::P_has_texture));
    PyDict_SetItemString(dict, "PHasTexture", Dtool_WrapValue(EggPolysetMaker::P_has_texture));
    PyDict_SetItemString(dict, "P_texture", Dtool_WrapValue(EggPolysetMaker::P_texture));
    PyDict_SetItemString(dict, "PTexture", Dtool_WrapValue(EggPolysetMaker::P_texture));
    PyDict_SetItemString(dict, "P_has_material", Dtool_WrapValue(EggPolysetMaker::P_has_material));
    PyDict_SetItemString(dict, "PHasMaterial", Dtool_WrapValue(EggPolysetMaker::P_has_material));
    PyDict_SetItemString(dict, "P_material", Dtool_WrapValue(EggPolysetMaker::P_material));
    PyDict_SetItemString(dict, "PMaterial", Dtool_WrapValue(EggPolysetMaker::P_material));
    PyDict_SetItemString(dict, "P_has_poly_color", Dtool_WrapValue(EggPolysetMaker::P_has_poly_color));
    PyDict_SetItemString(dict, "PHasPolyColor", Dtool_WrapValue(EggPolysetMaker::P_has_poly_color));
    PyDict_SetItemString(dict, "P_poly_color", Dtool_WrapValue(EggPolysetMaker::P_poly_color));
    PyDict_SetItemString(dict, "PPolyColor", Dtool_WrapValue(EggPolysetMaker::P_poly_color));
    PyDict_SetItemString(dict, "P_has_poly_normal", Dtool_WrapValue(EggPolysetMaker::P_has_poly_normal));
    PyDict_SetItemString(dict, "PHasPolyNormal", Dtool_WrapValue(EggPolysetMaker::P_has_poly_normal));
    PyDict_SetItemString(dict, "P_has_vertex_normal", Dtool_WrapValue(EggPolysetMaker::P_has_vertex_normal));
    PyDict_SetItemString(dict, "PHasVertexNormal", Dtool_WrapValue(EggPolysetMaker::P_has_vertex_normal));
    PyDict_SetItemString(dict, "P_has_vertex_color", Dtool_WrapValue(EggPolysetMaker::P_has_vertex_color));
    PyDict_SetItemString(dict, "PHasVertexColor", Dtool_WrapValue(EggPolysetMaker::P_has_vertex_color));
    PyDict_SetItemString(dict, "P_bface", Dtool_WrapValue(EggPolysetMaker::P_bface));
    PyDict_SetItemString(dict, "PBface", Dtool_WrapValue(EggPolysetMaker::P_bface));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPolysetMaker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPolysetMaker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPolysetMaker);
  }
}

/**
 * Python method tables for EggPoolUniquifier (EggPoolUniquifier)
 */
static PyMethodDef Dtool_Methods_EggPoolUniquifier[] = {
  {"get_class_type", &Dtool_EggPoolUniquifier_get_class_type_1114, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPoolUniquifier_get_class_type_1114_comment},
  {"getClassType", &Dtool_EggPoolUniquifier_get_class_type_1114, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPoolUniquifier_get_class_type_1114_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggPoolUniquifier = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPoolUniquifier = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggPoolUniquifier = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggPoolUniquifier = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggPoolUniquifier = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggPoolUniquifier",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPoolUniquifier,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggPoolUniquifier,
    &Dtool_SequenceMethods_EggPoolUniquifier,
    &Dtool_MappingMethods_EggPoolUniquifier,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggPoolUniquifier,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization of EggNameUniquifier to generate unique names for\n"
    " * textures, materials, and vertex pools prior to writing out an egg file.\n"
    " * It's automatically called by EggData prior to writing out an egg file.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggPoolUniquifier,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggPoolUniquifier,
    PyType_GenericAlloc,
    Dtool_new_EggPoolUniquifier,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPoolUniquifier,
  Dtool_UpcastInterface_EggPoolUniquifier,
  Dtool_DowncastInterface_EggPoolUniquifier,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggPoolUniquifier(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNameUniquifier(NULL);
    Dtool_EggPoolUniquifier._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNameUniquifier);
    PyObject *dict = PyDict_New();
    Dtool_EggPoolUniquifier._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPoolUniquifier) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPoolUniquifier)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPoolUniquifier);
  }
}

/**
 * Python method tables for EggSAnimData (EggSAnimData)
 */
static PyMethodDef Dtool_Methods_EggSAnimData[] = {
  {"assign", &Dtool_EggSAnimData_operator_1118, METH_O, (const char *)Dtool_EggSAnimData_operator_1118_comment},
  {"get_num_rows", &Dtool_EggSAnimData_get_num_rows_1119, METH_NOARGS, (const char *)Dtool_EggSAnimData_get_num_rows_1119_comment},
  {"getNumRows", &Dtool_EggSAnimData_get_num_rows_1119, METH_NOARGS, (const char *)Dtool_EggSAnimData_get_num_rows_1119_comment},
  {"get_value", &Dtool_EggSAnimData_get_value_1120, METH_O, (const char *)Dtool_EggSAnimData_get_value_1120_comment},
  {"getValue", &Dtool_EggSAnimData_get_value_1120, METH_O, (const char *)Dtool_EggSAnimData_get_value_1120_comment},
  {"set_value", (PyCFunction) &Dtool_EggSAnimData_set_value_1121, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggSAnimData_set_value_1121_comment},
  {"setValue", (PyCFunction) &Dtool_EggSAnimData_set_value_1121, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggSAnimData_set_value_1121_comment},
  {"optimize", &Dtool_EggSAnimData_optimize_1122, METH_NOARGS, (const char *)Dtool_EggSAnimData_optimize_1122_comment},
  {"get_class_type", &Dtool_EggSAnimData_get_class_type_1123, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSAnimData_get_class_type_1123_comment},
  {"getClassType", &Dtool_EggSAnimData_get_class_type_1123, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSAnimData_get_class_type_1123_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggSAnimData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggSAnimData = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggSAnimData = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggSAnimData = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggSAnimData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggSAnimData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggSAnimData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggSAnimData,
    &Dtool_SequenceMethods_EggSAnimData,
    &Dtool_MappingMethods_EggSAnimData,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggSAnimData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Corresponding to an <S$Anim> entry, this stores a single column of numbers,\n"
    " * for instance for a morph target, or as one column in an EggXfmSAnim.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggSAnimData,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggSAnimData,
    PyType_GenericAlloc,
    Dtool_new_EggSAnimData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggSAnimData,
  Dtool_UpcastInterface_EggSAnimData,
  Dtool_DowncastInterface_EggSAnimData,
  (CoerceFunction)Dtool_ConstCoerce_EggSAnimData,
  (CoerceFunction)Dtool_Coerce_EggSAnimData,
};

static void Dtool_PyModuleClassInit_EggSAnimData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggAnimData(NULL);
    Dtool_EggSAnimData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggAnimData);
    PyObject *dict = PyDict_New();
    Dtool_EggSAnimData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggSAnimData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggSAnimData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggSAnimData);
  }
}

/**
 * Python method tables for EggTable (EggTable)
 */
static PyMethodDef Dtool_Methods_EggTable[] = {
  {"assign", &Dtool_EggTable_operator_1128, METH_O, (const char *)Dtool_EggTable_operator_1128_comment},
  {"set_table_type", &Dtool_EggTable_set_table_type_1129, METH_O, (const char *)Dtool_EggTable_set_table_type_1129_comment},
  {"setTableType", &Dtool_EggTable_set_table_type_1129, METH_O, (const char *)Dtool_EggTable_set_table_type_1129_comment},
  {"get_table_type", &Dtool_EggTable_get_table_type_1130, METH_NOARGS, (const char *)Dtool_EggTable_get_table_type_1130_comment},
  {"getTableType", &Dtool_EggTable_get_table_type_1130, METH_NOARGS, (const char *)Dtool_EggTable_get_table_type_1130_comment},
  {"has_transform", &Dtool_EggTable_has_transform_1131, METH_NOARGS, (const char *)Dtool_EggTable_has_transform_1131_comment},
  {"hasTransform", &Dtool_EggTable_has_transform_1131, METH_NOARGS, (const char *)Dtool_EggTable_has_transform_1131_comment},
  {"string_table_type", &Dtool_EggTable_string_table_type_1132, METH_O | METH_STATIC, (const char *)Dtool_EggTable_string_table_type_1132_comment},
  {"stringTableType", &Dtool_EggTable_string_table_type_1132, METH_O | METH_STATIC, (const char *)Dtool_EggTable_string_table_type_1132_comment},
  {"get_class_type", &Dtool_EggTable_get_class_type_1133, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTable_get_class_type_1133_comment},
  {"getClassType", &Dtool_EggTable_get_class_type_1133, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTable_get_class_type_1133_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggTable = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggTable = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggTable = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggTable = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggTable = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggTable",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTable,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggTable,
    &Dtool_SequenceMethods_EggTable,
    &Dtool_MappingMethods_EggTable,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggTable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This corresponds to a <Table> or a <Bundle> entry.  As such, it doesn't\n"
    " * actually contain a table of numbers, but it may be a parent to an\n"
    " * EggSAnimData or an EggXfmAnimData, which do.  It may also be a parent to\n"
    " * another <Table> or <Bundle>, establishing a hierarchy of tables.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggTable,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggTable,
    PyType_GenericAlloc,
    Dtool_new_EggTable,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTable,
  Dtool_UpcastInterface_EggTable,
  Dtool_DowncastInterface_EggTable,
  (CoerceFunction)Dtool_ConstCoerce_EggTable,
  (CoerceFunction)Dtool_Coerce_EggTable,
};

static void Dtool_PyModuleClassInit_EggTable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggGroupNode(NULL);
    Dtool_EggTable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggGroupNode);
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_EggTable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggTable::TableType;
    PyDict_SetItemString(dict, "TT_invalid", Dtool_WrapValue(EggTable::TT_invalid));
    PyDict_SetItemString(dict, "TTInvalid", Dtool_WrapValue(EggTable::TT_invalid));
    PyDict_SetItemString(dict, "TT_table", Dtool_WrapValue(EggTable::TT_table));
    PyDict_SetItemString(dict, "TTTable", Dtool_WrapValue(EggTable::TT_table));
    PyDict_SetItemString(dict, "TT_bundle", Dtool_WrapValue(EggTable::TT_bundle));
    PyDict_SetItemString(dict, "TTBundle", Dtool_WrapValue(EggTable::TT_bundle));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTable);
  }
}

/**
 * Python method tables for EggTextureCollection (EggTextureCollection)
 */
static PyMethodDef Dtool_Methods_EggTextureCollection[] = {
  {"assign", &Dtool_EggTextureCollection_operator_1137, METH_O, (const char *)Dtool_EggTextureCollection_operator_1137_comment},
  {"clear", &Dtool_EggTextureCollection_clear_1139, METH_NOARGS, (const char *)Dtool_EggTextureCollection_clear_1139_comment},
  {"extract_textures", &Dtool_EggTextureCollection_extract_textures_1140, METH_O, (const char *)Dtool_EggTextureCollection_extract_textures_1140_comment},
  {"extractTextures", &Dtool_EggTextureCollection_extract_textures_1140, METH_O, (const char *)Dtool_EggTextureCollection_extract_textures_1140_comment},
  {"is_empty", &Dtool_EggTextureCollection_is_empty_1141, METH_NOARGS, (const char *)Dtool_EggTextureCollection_is_empty_1141_comment},
  {"isEmpty", &Dtool_EggTextureCollection_is_empty_1141, METH_NOARGS, (const char *)Dtool_EggTextureCollection_is_empty_1141_comment},
  {"get_num_textures", &Dtool_EggTextureCollection_get_num_textures_1142, METH_NOARGS, (const char *)Dtool_EggTextureCollection_get_num_textures_1142_comment},
  {"getNumTextures", &Dtool_EggTextureCollection_get_num_textures_1142, METH_NOARGS, (const char *)Dtool_EggTextureCollection_get_num_textures_1142_comment},
  {"get_texture", &Dtool_EggTextureCollection_get_texture_1143, METH_O, (const char *)Dtool_EggTextureCollection_get_texture_1143_comment},
  {"getTexture", &Dtool_EggTextureCollection_get_texture_1143, METH_O, (const char *)Dtool_EggTextureCollection_get_texture_1143_comment},
  {"find_used_textures", &Dtool_EggTextureCollection_find_used_textures_1145, METH_O, (const char *)Dtool_EggTextureCollection_find_used_textures_1145_comment},
  {"findUsedTextures", &Dtool_EggTextureCollection_find_used_textures_1145, METH_O, (const char *)Dtool_EggTextureCollection_find_used_textures_1145_comment},
  {"remove_unused_textures", &Dtool_EggTextureCollection_remove_unused_textures_1146, METH_O, (const char *)Dtool_EggTextureCollection_remove_unused_textures_1146_comment},
  {"removeUnusedTextures", &Dtool_EggTextureCollection_remove_unused_textures_1146, METH_O, (const char *)Dtool_EggTextureCollection_remove_unused_textures_1146_comment},
  {"collapse_equivalent_textures", (PyCFunction) &Dtool_EggTextureCollection_collapse_equivalent_textures_1147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTextureCollection_collapse_equivalent_textures_1147_comment},
  {"collapseEquivalentTextures", (PyCFunction) &Dtool_EggTextureCollection_collapse_equivalent_textures_1147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTextureCollection_collapse_equivalent_textures_1147_comment},
  {"uniquify_trefs", &Dtool_EggTextureCollection_uniquify_trefs_1149, METH_NOARGS, (const char *)Dtool_EggTextureCollection_uniquify_trefs_1149_comment},
  {"uniquifyTrefs", &Dtool_EggTextureCollection_uniquify_trefs_1149, METH_NOARGS, (const char *)Dtool_EggTextureCollection_uniquify_trefs_1149_comment},
  {"sort_by_tref", &Dtool_EggTextureCollection_sort_by_tref_1150, METH_NOARGS, (const char *)Dtool_EggTextureCollection_sort_by_tref_1150_comment},
  {"sortByTref", &Dtool_EggTextureCollection_sort_by_tref_1150, METH_NOARGS, (const char *)Dtool_EggTextureCollection_sort_by_tref_1150_comment},
  {"sort_by_basename", &Dtool_EggTextureCollection_sort_by_basename_1151, METH_NOARGS, (const char *)Dtool_EggTextureCollection_sort_by_basename_1151_comment},
  {"sortByBasename", &Dtool_EggTextureCollection_sort_by_basename_1151, METH_NOARGS, (const char *)Dtool_EggTextureCollection_sort_by_basename_1151_comment},
  {"add_texture", &Dtool_EggTextureCollection_add_texture_1154, METH_O, (const char *)Dtool_EggTextureCollection_add_texture_1154_comment},
  {"addTexture", &Dtool_EggTextureCollection_add_texture_1154, METH_O, (const char *)Dtool_EggTextureCollection_add_texture_1154_comment},
  {"remove_texture", &Dtool_EggTextureCollection_remove_texture_1155, METH_O, (const char *)Dtool_EggTextureCollection_remove_texture_1155_comment},
  {"removeTexture", &Dtool_EggTextureCollection_remove_texture_1155, METH_O, (const char *)Dtool_EggTextureCollection_remove_texture_1155_comment},
  {"create_unique_texture", (PyCFunction) &Dtool_EggTextureCollection_create_unique_texture_1156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTextureCollection_create_unique_texture_1156_comment},
  {"createUniqueTexture", (PyCFunction) &Dtool_EggTextureCollection_create_unique_texture_1156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTextureCollection_create_unique_texture_1156_comment},
  {"find_tref", &Dtool_EggTextureCollection_find_tref_1157, METH_O, (const char *)Dtool_EggTextureCollection_find_tref_1157_comment},
  {"findTref", &Dtool_EggTextureCollection_find_tref_1157, METH_O, (const char *)Dtool_EggTextureCollection_find_tref_1157_comment},
  {"find_filename", &Dtool_EggTextureCollection_find_filename_1158, METH_O, (const char *)Dtool_EggTextureCollection_find_filename_1158_comment},
  {"findFilename", &Dtool_EggTextureCollection_find_filename_1158, METH_O, (const char *)Dtool_EggTextureCollection_find_filename_1158_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_textures", (PyCFunction) &MakeSeq_EggTextureCollection_get_textures, METH_NOARGS, NULL},
  { "getTextures", (PyCFunction) &MakeSeq_EggTextureCollection_get_textures, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggTextureCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_EggTextureCollection_operator_1152_sq_item(PyObject *self, Py_ssize_t index) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTextureCollection, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "EggTextureCollection index out of range");
    return NULL;
  }
  // 1-inline EggTexture *EggTextureCollection::operator [](EggTextureCollection::size_type n) const
  EggTexture *return_value = (*(const EggTextureCollection*)local_this).operator [](index);
  if (return_value != (EggTexture *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (EggTexture *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(EggTextureCollection self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggTextureCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_EggTextureCollection_size_1153_sq_length(PyObject *self) {
  EggTextureCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTextureCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_EggTextureCollection = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggTextureCollection = {
  &Dtool_EggTextureCollection_size_1153_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_EggTextureCollection_operator_1152_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_EggTextureCollection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggTextureCollection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTextureCollection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggTextureCollection,
    &Dtool_SequenceMethods_EggTextureCollection,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a collection of textures by TRef name.  It can extract the textures\n"
    " * from an egg file and sort them all together; it can also manage the\n"
    " * creation of unique textures and the assignment of unique TRef names.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggTextureCollection,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggTextureCollection,
    PyType_GenericAlloc,
    Dtool_new_EggTextureCollection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTextureCollection,
  Dtool_UpcastInterface_EggTextureCollection,
  Dtool_DowncastInterface_EggTextureCollection,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EggTextureCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EggTextureCollection._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_EggTextureCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTextureCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTextureCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTextureCollection);
  }
}

/**
 * Python method tables for EggTriangleFan (EggTriangleFan)
 */
static PyMethodDef Dtool_Methods_EggTriangleFan[] = {
  {"assign", &Dtool_EggTriangleFan_operator_1160, METH_O, (const char *)Dtool_EggTriangleFan_operator_1160_comment},
  {"make_copy", &Dtool_EggTriangleFan_make_copy_1161, METH_NOARGS, (const char *)Dtool_EggTriangleFan_make_copy_1161_comment},
  {"makeCopy", &Dtool_EggTriangleFan_make_copy_1161, METH_NOARGS, (const char *)Dtool_EggTriangleFan_make_copy_1161_comment},
  {"get_class_type", &Dtool_EggTriangleFan_get_class_type_1162, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTriangleFan_get_class_type_1162_comment},
  {"getClassType", &Dtool_EggTriangleFan_get_class_type_1162, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTriangleFan_get_class_type_1162_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggTriangleFan = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggTriangleFan = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggTriangleFan = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggTriangleFan = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggTriangleFan = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggTriangleFan",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTriangleFan,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggTriangleFan,
    &Dtool_SequenceMethods_EggTriangleFan,
    &Dtool_MappingMethods_EggTriangleFan,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggTriangleFan,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A connected fan of triangles.  This does not normally appear in an egg\n"
    " * file; it is typically generated as a result of meshing.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggTriangleFan,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggTriangleFan,
    PyType_GenericAlloc,
    Dtool_new_EggTriangleFan,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTriangleFan,
  Dtool_UpcastInterface_EggTriangleFan,
  Dtool_DowncastInterface_EggTriangleFan,
  (CoerceFunction)Dtool_ConstCoerce_EggTriangleFan,
  (CoerceFunction)Dtool_Coerce_EggTriangleFan,
};

static void Dtool_PyModuleClassInit_EggTriangleFan(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggCompositePrimitive(NULL);
    Dtool_EggTriangleFan._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggCompositePrimitive);
    PyObject *dict = PyDict_New();
    Dtool_EggTriangleFan._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTriangleFan) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTriangleFan)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTriangleFan);
  }
}

/**
 * Python method tables for EggTriangleStrip (EggTriangleStrip)
 */
static PyMethodDef Dtool_Methods_EggTriangleStrip[] = {
  {"assign", &Dtool_EggTriangleStrip_operator_1164, METH_O, (const char *)Dtool_EggTriangleStrip_operator_1164_comment},
  {"make_copy", &Dtool_EggTriangleStrip_make_copy_1165, METH_NOARGS, (const char *)Dtool_EggTriangleStrip_make_copy_1165_comment},
  {"makeCopy", &Dtool_EggTriangleStrip_make_copy_1165, METH_NOARGS, (const char *)Dtool_EggTriangleStrip_make_copy_1165_comment},
  {"get_class_type", &Dtool_EggTriangleStrip_get_class_type_1166, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTriangleStrip_get_class_type_1166_comment},
  {"getClassType", &Dtool_EggTriangleStrip_get_class_type_1166, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTriangleStrip_get_class_type_1166_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggTriangleStrip = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggTriangleStrip = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggTriangleStrip = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggTriangleStrip = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggTriangleStrip = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggTriangleStrip",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTriangleStrip,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggTriangleStrip,
    &Dtool_SequenceMethods_EggTriangleStrip,
    &Dtool_MappingMethods_EggTriangleStrip,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggTriangleStrip,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A connected strip of triangles.  This does not normally appear in an egg\n"
    " * file; it is typically generated as a result of meshing.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggTriangleStrip,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggTriangleStrip,
    PyType_GenericAlloc,
    Dtool_new_EggTriangleStrip,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTriangleStrip,
  Dtool_UpcastInterface_EggTriangleStrip,
  Dtool_DowncastInterface_EggTriangleStrip,
  (CoerceFunction)Dtool_ConstCoerce_EggTriangleStrip,
  (CoerceFunction)Dtool_Coerce_EggTriangleStrip,
};

static void Dtool_PyModuleClassInit_EggTriangleStrip(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggCompositePrimitive(NULL);
    Dtool_EggTriangleStrip._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggCompositePrimitive);
    PyObject *dict = PyDict_New();
    Dtool_EggTriangleStrip._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTriangleStrip) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTriangleStrip)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTriangleStrip);
  }
}

/**
 * Python method tables for EggXfmSAnim (EggXfmSAnim)
 */
static PyMethodDef Dtool_Methods_EggXfmSAnim[] = {
  {"assign", &Dtool_EggXfmSAnim_operator_1169, METH_O, (const char *)Dtool_EggXfmSAnim_operator_1169_comment},
  {"set_fps", &Dtool_EggXfmSAnim_set_fps_1170, METH_O, (const char *)Dtool_EggXfmSAnim_set_fps_1170_comment},
  {"setFps", &Dtool_EggXfmSAnim_set_fps_1170, METH_O, (const char *)Dtool_EggXfmSAnim_set_fps_1170_comment},
  {"clear_fps", &Dtool_EggXfmSAnim_clear_fps_1171, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_fps_1171_comment},
  {"clearFps", &Dtool_EggXfmSAnim_clear_fps_1171, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_fps_1171_comment},
  {"has_fps", &Dtool_EggXfmSAnim_has_fps_1172, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_has_fps_1172_comment},
  {"hasFps", &Dtool_EggXfmSAnim_has_fps_1172, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_has_fps_1172_comment},
  {"get_fps", &Dtool_EggXfmSAnim_get_fps_1173, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_fps_1173_comment},
  {"getFps", &Dtool_EggXfmSAnim_get_fps_1173, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_fps_1173_comment},
  {"set_order", &Dtool_EggXfmSAnim_set_order_1174, METH_O, (const char *)Dtool_EggXfmSAnim_set_order_1174_comment},
  {"setOrder", &Dtool_EggXfmSAnim_set_order_1174, METH_O, (const char *)Dtool_EggXfmSAnim_set_order_1174_comment},
  {"clear_order", &Dtool_EggXfmSAnim_clear_order_1175, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_order_1175_comment},
  {"clearOrder", &Dtool_EggXfmSAnim_clear_order_1175, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_order_1175_comment},
  {"has_order", &Dtool_EggXfmSAnim_has_order_1176, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_has_order_1176_comment},
  {"hasOrder", &Dtool_EggXfmSAnim_has_order_1176, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_has_order_1176_comment},
  {"get_order", &Dtool_EggXfmSAnim_get_order_1177, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_order_1177_comment},
  {"getOrder", &Dtool_EggXfmSAnim_get_order_1177, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_order_1177_comment},
  {"get_standard_order", &Dtool_EggXfmSAnim_get_standard_order_1178, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_get_standard_order_1178_comment},
  {"getStandardOrder", &Dtool_EggXfmSAnim_get_standard_order_1178, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_get_standard_order_1178_comment},
  {"get_coordinate_system", &Dtool_EggXfmSAnim_get_coordinate_system_1179, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_coordinate_system_1179_comment},
  {"getCoordinateSystem", &Dtool_EggXfmSAnim_get_coordinate_system_1179, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_coordinate_system_1179_comment},
  {"optimize", &Dtool_EggXfmSAnim_optimize_1180, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_optimize_1180_comment},
  {"optimize_to_standard_order", &Dtool_EggXfmSAnim_optimize_to_standard_order_1181, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_optimize_to_standard_order_1181_comment},
  {"optimizeToStandardOrder", &Dtool_EggXfmSAnim_optimize_to_standard_order_1181, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_optimize_to_standard_order_1181_comment},
  {"normalize", &Dtool_EggXfmSAnim_normalize_1182, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_normalize_1182_comment},
  {"get_num_rows", &Dtool_EggXfmSAnim_get_num_rows_1183, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_num_rows_1183_comment},
  {"getNumRows", &Dtool_EggXfmSAnim_get_num_rows_1183, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_num_rows_1183_comment},
  {"get_value", (PyCFunction) &Dtool_EggXfmSAnim_get_value_1184, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_get_value_1184_comment},
  {"getValue", (PyCFunction) &Dtool_EggXfmSAnim_get_value_1184, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_get_value_1184_comment},
  {"set_value", (PyCFunction) &Dtool_EggXfmSAnim_set_value_1185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_set_value_1185_comment},
  {"setValue", (PyCFunction) &Dtool_EggXfmSAnim_set_value_1185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_set_value_1185_comment},
  {"clear_data", &Dtool_EggXfmSAnim_clear_data_1186, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_data_1186_comment},
  {"clearData", &Dtool_EggXfmSAnim_clear_data_1186, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_data_1186_comment},
  {"add_data", &Dtool_EggXfmSAnim_add_data_1187, METH_O, (const char *)Dtool_EggXfmSAnim_add_data_1187_comment},
  {"addData", &Dtool_EggXfmSAnim_add_data_1187, METH_O, (const char *)Dtool_EggXfmSAnim_add_data_1187_comment},
  {"add_component_data", (PyCFunction) &Dtool_EggXfmSAnim_add_component_data_1188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_add_component_data_1188_comment},
  {"addComponentData", (PyCFunction) &Dtool_EggXfmSAnim_add_component_data_1188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_add_component_data_1188_comment},
  {"compose_with_order", (PyCFunction) &Dtool_EggXfmSAnim_compose_with_order_1189, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_compose_with_order_1189_comment},
  {"composeWithOrder", (PyCFunction) &Dtool_EggXfmSAnim_compose_with_order_1189, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_compose_with_order_1189_comment},
  {"get_class_type", &Dtool_EggXfmSAnim_get_class_type_1190, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_get_class_type_1190_comment},
  {"getClassType", &Dtool_EggXfmSAnim_get_class_type_1190, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_get_class_type_1190_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggXfmSAnim = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggXfmSAnim = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggXfmSAnim = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggXfmSAnim = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggXfmSAnim = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggXfmSAnim",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggXfmSAnim,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggXfmSAnim,
    &Dtool_SequenceMethods_EggXfmSAnim,
    &Dtool_MappingMethods_EggXfmSAnim,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggXfmSAnim,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This corresponds to an <Xfm$Anim_S$> entry, which is a collection of up to\n"
    " * nine <S$Anim> entries that specify the nine components of a transformation.\n"
    " * It's implemented as a group that can contain any number of EggSAnimData\n"
    " * children.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggXfmSAnim,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggXfmSAnim,
    PyType_GenericAlloc,
    Dtool_new_EggXfmSAnim,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggXfmSAnim,
  Dtool_UpcastInterface_EggXfmSAnim,
  Dtool_DowncastInterface_EggXfmSAnim,
  (CoerceFunction)Dtool_ConstCoerce_EggXfmSAnim,
  (CoerceFunction)Dtool_Coerce_EggXfmSAnim,
};

static void Dtool_PyModuleClassInit_EggXfmSAnim(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggGroupNode(NULL);
    Dtool_EggXfmSAnim._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggGroupNode);
    PyObject *dict = PyDict_New();
    Dtool_EggXfmSAnim._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggXfmSAnim) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggXfmSAnim)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggXfmSAnim);
  }
}

/**
 * Python method tables for EggXfmAnimData (EggXfmAnimData)
 */
static PyMethodDef Dtool_Methods_EggXfmAnimData[] = {
  {"assign", &Dtool_EggXfmAnimData_operator_1194, METH_O, (const char *)Dtool_EggXfmAnimData_operator_1194_comment},
  {"set_order", &Dtool_EggXfmAnimData_set_order_1195, METH_O, (const char *)Dtool_EggXfmAnimData_set_order_1195_comment},
  {"setOrder", &Dtool_EggXfmAnimData_set_order_1195, METH_O, (const char *)Dtool_EggXfmAnimData_set_order_1195_comment},
  {"clear_order", &Dtool_EggXfmAnimData_clear_order_1196, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_clear_order_1196_comment},
  {"clearOrder", &Dtool_EggXfmAnimData_clear_order_1196, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_clear_order_1196_comment},
  {"has_order", &Dtool_EggXfmAnimData_has_order_1197, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_has_order_1197_comment},
  {"hasOrder", &Dtool_EggXfmAnimData_has_order_1197, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_has_order_1197_comment},
  {"get_order", &Dtool_EggXfmAnimData_get_order_1198, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_order_1198_comment},
  {"getOrder", &Dtool_EggXfmAnimData_get_order_1198, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_order_1198_comment},
  {"get_standard_order", &Dtool_EggXfmAnimData_get_standard_order_1199, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmAnimData_get_standard_order_1199_comment},
  {"getStandardOrder", &Dtool_EggXfmAnimData_get_standard_order_1199, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmAnimData_get_standard_order_1199_comment},
  {"set_contents", &Dtool_EggXfmAnimData_set_contents_1200, METH_O, (const char *)Dtool_EggXfmAnimData_set_contents_1200_comment},
  {"setContents", &Dtool_EggXfmAnimData_set_contents_1200, METH_O, (const char *)Dtool_EggXfmAnimData_set_contents_1200_comment},
  {"clear_contents", &Dtool_EggXfmAnimData_clear_contents_1201, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_clear_contents_1201_comment},
  {"clearContents", &Dtool_EggXfmAnimData_clear_contents_1201, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_clear_contents_1201_comment},
  {"has_contents", &Dtool_EggXfmAnimData_has_contents_1202, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_has_contents_1202_comment},
  {"hasContents", &Dtool_EggXfmAnimData_has_contents_1202, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_has_contents_1202_comment},
  {"get_contents", &Dtool_EggXfmAnimData_get_contents_1203, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_contents_1203_comment},
  {"getContents", &Dtool_EggXfmAnimData_get_contents_1203, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_contents_1203_comment},
  {"get_coordinate_system", &Dtool_EggXfmAnimData_get_coordinate_system_1204, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_coordinate_system_1204_comment},
  {"getCoordinateSystem", &Dtool_EggXfmAnimData_get_coordinate_system_1204, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_coordinate_system_1204_comment},
  {"get_num_rows", &Dtool_EggXfmAnimData_get_num_rows_1205, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_num_rows_1205_comment},
  {"getNumRows", &Dtool_EggXfmAnimData_get_num_rows_1205, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_num_rows_1205_comment},
  {"get_num_cols", &Dtool_EggXfmAnimData_get_num_cols_1206, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_num_cols_1206_comment},
  {"getNumCols", &Dtool_EggXfmAnimData_get_num_cols_1206, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_num_cols_1206_comment},
  {"get_value", (PyCFunction) &Dtool_EggXfmAnimData_get_value_1207, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmAnimData_get_value_1207_comment},
  {"getValue", (PyCFunction) &Dtool_EggXfmAnimData_get_value_1207, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmAnimData_get_value_1207_comment},
  {"get_class_type", &Dtool_EggXfmAnimData_get_class_type_1208, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmAnimData_get_class_type_1208_comment},
  {"getClassType", &Dtool_EggXfmAnimData_get_class_type_1208, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmAnimData_get_class_type_1208_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EggXfmAnimData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggXfmAnimData = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EggXfmAnimData = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EggXfmAnimData = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EggXfmAnimData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.egg.EggXfmAnimData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EggXfmAnimData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EggXfmAnimData,
    &Dtool_SequenceMethods_EggXfmAnimData,
    &Dtool_MappingMethods_EggXfmAnimData,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EggXfmAnimData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Corresponding to an <Xfm$Anim> entry, this stores a two-dimensional table\n"
    " * with up to nine columns, one for each component of a transformation.  This\n"
    " * is an older syntax of egg anim table, not often used currently--it's\n"
    " * replaced by EggXfmSAnim.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EggXfmAnimData,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EggXfmAnimData,
    PyType_GenericAlloc,
    Dtool_new_EggXfmAnimData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggXfmAnimData,
  Dtool_UpcastInterface_EggXfmAnimData,
  Dtool_DowncastInterface_EggXfmAnimData,
  (CoerceFunction)Dtool_ConstCoerce_EggXfmAnimData,
  (CoerceFunction)Dtool_Coerce_EggXfmAnimData,
};

static void Dtool_PyModuleClassInit_EggXfmAnimData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggAnimData(NULL);
    Dtool_EggXfmAnimData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggAnimData);
    PyObject *dict = PyDict_New();
    Dtool_EggXfmAnimData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggXfmAnimData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggXfmAnimData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggXfmAnimData);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3egg_RegisterTypes() {
  Dtool_EggUserData._type = EggUserData::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggUserData);
  Dtool_EggObject._type = EggObject::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggObject);
  Dtool_EggNamedObject._type = EggNamedObject::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggNamedObject);
  Dtool_EggNode._type = EggNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggNode);
  Dtool_EggAnimData._type = EggAnimData::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggAnimData);
  Dtool_EggAnimPreload._type = EggAnimPreload::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggAnimPreload);
  Dtool_EggAttributes._type = EggAttributes::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggAttributes);
  Dtool_EggVertexUV._type = EggVertexUV::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggVertexUV);
  Dtool_EggVertexAux._type = EggVertexAux::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggVertexAux);
  Dtool_EggVertex._type = EggVertex::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggVertex);
  Dtool_EggVertexPool._type = EggVertexPool::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggVertexPool);
  Dtool_EggGroupNode._type = EggGroupNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggGroupNode);
  Dtool_EggRenderMode._type = EggRenderMode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggRenderMode);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("EggTransform", Dtool_EggTransform);
#endif
  Dtool_EggSwitchCondition._type = EggSwitchCondition::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggSwitchCondition);
  Dtool_EggSwitchConditionDistance._type = EggSwitchConditionDistance::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggSwitchConditionDistance);
  Dtool_EggGroup._type = EggGroup::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggGroup);
  Dtool_EggBin._type = EggBin::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggBin);
  Dtool_EggBinMaker._type = EggBinMaker::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggBinMaker);
  Dtool_EggComment._type = EggComment::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggComment);
  Dtool_EggFilenameNode._type = EggFilenameNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggFilenameNode);
  Dtool_EggTexture._type = EggTexture::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggTexture);
  Dtool_EggMaterial._type = EggMaterial::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggMaterial);
  Dtool_EggPrimitive._type = EggPrimitive::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggPrimitive);
  Dtool_EggCompositePrimitive._type = EggCompositePrimitive::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggCompositePrimitive);
  Dtool_EggData._type = EggData::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggData);
  Dtool_EggCoordinateSystem._type = EggCoordinateSystem::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggCoordinateSystem);
  Dtool_EggCurve._type = EggCurve::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggCurve);
  Dtool_EggExternalReference._type = EggExternalReference::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggExternalReference);
  Dtool_EggNameUniquifier._type = EggNameUniquifier::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggNameUniquifier);
  Dtool_EggGroupUniquifier._type = EggGroupUniquifier::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggGroupUniquifier);
  Dtool_EggLine._type = EggLine::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggLine);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("EggMaterialCollection", Dtool_EggMaterialCollection);
#endif
  Dtool_EggPolygon._type = EggPolygon::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggPolygon);
  Dtool_EggNurbsCurve._type = EggNurbsCurve::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggNurbsCurve);
  Dtool_EggSurface._type = EggSurface::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggSurface);
  Dtool_EggNurbsSurface._type = EggNurbsSurface::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggNurbsSurface);
  Dtool_EggPatch._type = EggPatch::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggPatch);
  Dtool_EggPoint._type = EggPoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggPoint);
  Dtool_EggPolysetMaker._type = EggPolysetMaker::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggPolysetMaker);
  Dtool_EggPoolUniquifier._type = EggPoolUniquifier::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggPoolUniquifier);
  Dtool_EggSAnimData._type = EggSAnimData::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggSAnimData);
  Dtool_EggTable._type = EggTable::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggTable);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("EggTextureCollection", Dtool_EggTextureCollection);
#endif
  Dtool_EggTriangleFan._type = EggTriangleFan::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggTriangleFan);
  Dtool_EggTriangleStrip._type = EggTriangleStrip::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggTriangleStrip);
  Dtool_EggXfmSAnim._type = EggXfmSAnim::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggXfmSAnim);
  Dtool_EggXfmAnimData._type = EggXfmAnimData::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EggXfmAnimData);
}

void Dtool_libp3egg_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_istream = LookupNamedClass("istream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_GlobPattern = LookupNamedClass("GlobPattern");
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_DSearchPath = LookupNamedClass("DSearchPath");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_LVecBase4d = LookupRuntimeTypedClass(LVecBase4d::get_class_type());
  Dtool_Ptr_LPoint3d = LookupRuntimeTypedClass(LPoint3d::get_class_type());
  Dtool_Ptr_LMatrix3d = LookupRuntimeTypedClass(LMatrix3d::get_class_type());
  Dtool_Ptr_LMatrix4d = LookupRuntimeTypedClass(LMatrix4d::get_class_type());
  Dtool_Ptr_LVecBase2d = LookupRuntimeTypedClass(LVecBase2d::get_class_type());
  Dtool_Ptr_LVecBase3d = LookupRuntimeTypedClass(LVecBase3d::get_class_type());
  Dtool_Ptr_LVector2d = LookupRuntimeTypedClass(LVector2d::get_class_type());
  Dtool_Ptr_LVector3d = LookupRuntimeTypedClass(LVector3d::get_class_type());
  Dtool_Ptr_LPoint2d = LookupRuntimeTypedClass(LPoint2d::get_class_type());
  Dtool_Ptr_LQuaterniond = LookupRuntimeTypedClass(LQuaterniond::get_class_type());
  Dtool_Ptr_LPoint4d = LookupRuntimeTypedClass(LPoint4d::get_class_type());
  Dtool_Ptr_BamCacheRecord = LookupRuntimeTypedClass(BamCacheRecord::get_class_type());
  Dtool_Ptr_BitMask_uint32_t_32 = LookupRuntimeTypedClass(BitMask< uint32_t, 32 >::get_class_type());
#endif
}

void Dtool_libp3egg_BuildInstants(PyObject *module) {
  (void) module;
  // EggUserData
  Dtool_PyModuleClassInit_EggUserData(module);
  PyModule_AddObject(module, "EggUserData", (PyObject *)&Dtool_EggUserData);
  // EggObject
  Dtool_PyModuleClassInit_EggObject(module);
  PyModule_AddObject(module, "EggObject", (PyObject *)&Dtool_EggObject);
  // EggNamedObject
  Dtool_PyModuleClassInit_EggNamedObject(module);
  PyModule_AddObject(module, "EggNamedObject", (PyObject *)&Dtool_EggNamedObject);
  // EggNode
  Dtool_PyModuleClassInit_EggNode(module);
  PyModule_AddObject(module, "EggNode", (PyObject *)&Dtool_EggNode);
  // EggAnimData
  Dtool_PyModuleClassInit_EggAnimData(module);
  PyModule_AddObject(module, "EggAnimData", (PyObject *)&Dtool_EggAnimData);
  // EggAnimPreload
  Dtool_PyModuleClassInit_EggAnimPreload(module);
  PyModule_AddObject(module, "EggAnimPreload", (PyObject *)&Dtool_EggAnimPreload);
  // EggAttributes
  Dtool_PyModuleClassInit_EggAttributes(module);
  PyModule_AddObject(module, "EggAttributes", (PyObject *)&Dtool_EggAttributes);
  // EggVertexUV
  Dtool_PyModuleClassInit_EggVertexUV(module);
  PyModule_AddObject(module, "EggVertexUV", (PyObject *)&Dtool_EggVertexUV);
  // EggVertexAux
  Dtool_PyModuleClassInit_EggVertexAux(module);
  PyModule_AddObject(module, "EggVertexAux", (PyObject *)&Dtool_EggVertexAux);
  // EggVertex
  Dtool_PyModuleClassInit_EggVertex(module);
  PyModule_AddObject(module, "EggVertex", (PyObject *)&Dtool_EggVertex);
  // EggVertexPool
  Dtool_PyModuleClassInit_EggVertexPool(module);
  PyModule_AddObject(module, "EggVertexPool", (PyObject *)&Dtool_EggVertexPool);
  // EggGroupNode
  Dtool_PyModuleClassInit_EggGroupNode(module);
  PyModule_AddObject(module, "EggGroupNode", (PyObject *)&Dtool_EggGroupNode);
  // EggRenderMode
  Dtool_PyModuleClassInit_EggRenderMode(module);
  PyModule_AddObject(module, "EggRenderMode", (PyObject *)&Dtool_EggRenderMode);
  // EggTransform
  Dtool_PyModuleClassInit_EggTransform(module);
  PyModule_AddObject(module, "EggTransform", (PyObject *)&Dtool_EggTransform);
  // EggSwitchCondition
  Dtool_PyModuleClassInit_EggSwitchCondition(module);
  PyModule_AddObject(module, "EggSwitchCondition", (PyObject *)&Dtool_EggSwitchCondition);
  // EggSwitchConditionDistance
  Dtool_PyModuleClassInit_EggSwitchConditionDistance(module);
  PyModule_AddObject(module, "EggSwitchConditionDistance", (PyObject *)&Dtool_EggSwitchConditionDistance);
  // EggGroup
  Dtool_PyModuleClassInit_EggGroup(module);
  PyModule_AddObject(module, "EggGroup", (PyObject *)&Dtool_EggGroup);
  // EggBin
  Dtool_PyModuleClassInit_EggBin(module);
  PyModule_AddObject(module, "EggBin", (PyObject *)&Dtool_EggBin);
  // EggBinMaker
  Dtool_PyModuleClassInit_EggBinMaker(module);
  PyModule_AddObject(module, "EggBinMaker", (PyObject *)&Dtool_EggBinMaker);
  // EggComment
  Dtool_PyModuleClassInit_EggComment(module);
  PyModule_AddObject(module, "EggComment", (PyObject *)&Dtool_EggComment);
  // EggFilenameNode
  Dtool_PyModuleClassInit_EggFilenameNode(module);
  PyModule_AddObject(module, "EggFilenameNode", (PyObject *)&Dtool_EggFilenameNode);
  // EggTexture
  Dtool_PyModuleClassInit_EggTexture(module);
  PyModule_AddObject(module, "EggTexture", (PyObject *)&Dtool_EggTexture);
  // EggMaterial
  Dtool_PyModuleClassInit_EggMaterial(module);
  PyModule_AddObject(module, "EggMaterial", (PyObject *)&Dtool_EggMaterial);
  // EggPrimitive
  Dtool_PyModuleClassInit_EggPrimitive(module);
  PyModule_AddObject(module, "EggPrimitive", (PyObject *)&Dtool_EggPrimitive);
  // EggCompositePrimitive
  Dtool_PyModuleClassInit_EggCompositePrimitive(module);
  PyModule_AddObject(module, "EggCompositePrimitive", (PyObject *)&Dtool_EggCompositePrimitive);
  // EggData
  Dtool_PyModuleClassInit_EggData(module);
  PyModule_AddObject(module, "EggData", (PyObject *)&Dtool_EggData);
  // EggCoordinateSystem
  Dtool_PyModuleClassInit_EggCoordinateSystem(module);
  PyModule_AddObject(module, "EggCoordinateSystem", (PyObject *)&Dtool_EggCoordinateSystem);
  // EggCurve
  Dtool_PyModuleClassInit_EggCurve(module);
  PyModule_AddObject(module, "EggCurve", (PyObject *)&Dtool_EggCurve);
  // EggExternalReference
  Dtool_PyModuleClassInit_EggExternalReference(module);
  PyModule_AddObject(module, "EggExternalReference", (PyObject *)&Dtool_EggExternalReference);
  // EggNameUniquifier
  Dtool_PyModuleClassInit_EggNameUniquifier(module);
  PyModule_AddObject(module, "EggNameUniquifier", (PyObject *)&Dtool_EggNameUniquifier);
  // EggGroupUniquifier
  Dtool_PyModuleClassInit_EggGroupUniquifier(module);
  PyModule_AddObject(module, "EggGroupUniquifier", (PyObject *)&Dtool_EggGroupUniquifier);
  // EggLine
  Dtool_PyModuleClassInit_EggLine(module);
  PyModule_AddObject(module, "EggLine", (PyObject *)&Dtool_EggLine);
  // EggMaterialCollection
  Dtool_PyModuleClassInit_EggMaterialCollection(module);
  PyModule_AddObject(module, "EggMaterialCollection", (PyObject *)&Dtool_EggMaterialCollection);
  // EggPolygon
  Dtool_PyModuleClassInit_EggPolygon(module);
  PyModule_AddObject(module, "EggPolygon", (PyObject *)&Dtool_EggPolygon);
  // EggNurbsCurve
  Dtool_PyModuleClassInit_EggNurbsCurve(module);
  PyModule_AddObject(module, "EggNurbsCurve", (PyObject *)&Dtool_EggNurbsCurve);
  // EggSurface
  Dtool_PyModuleClassInit_EggSurface(module);
  PyModule_AddObject(module, "EggSurface", (PyObject *)&Dtool_EggSurface);
  // EggNurbsSurface
  Dtool_PyModuleClassInit_EggNurbsSurface(module);
  PyModule_AddObject(module, "EggNurbsSurface", (PyObject *)&Dtool_EggNurbsSurface);
  // EggPatch
  Dtool_PyModuleClassInit_EggPatch(module);
  PyModule_AddObject(module, "EggPatch", (PyObject *)&Dtool_EggPatch);
  // EggPoint
  Dtool_PyModuleClassInit_EggPoint(module);
  PyModule_AddObject(module, "EggPoint", (PyObject *)&Dtool_EggPoint);
  // EggPolysetMaker
  Dtool_PyModuleClassInit_EggPolysetMaker(module);
  PyModule_AddObject(module, "EggPolysetMaker", (PyObject *)&Dtool_EggPolysetMaker);
  // EggPoolUniquifier
  Dtool_PyModuleClassInit_EggPoolUniquifier(module);
  PyModule_AddObject(module, "EggPoolUniquifier", (PyObject *)&Dtool_EggPoolUniquifier);
  // EggSAnimData
  Dtool_PyModuleClassInit_EggSAnimData(module);
  PyModule_AddObject(module, "EggSAnimData", (PyObject *)&Dtool_EggSAnimData);
  // EggTable
  Dtool_PyModuleClassInit_EggTable(module);
  PyModule_AddObject(module, "EggTable", (PyObject *)&Dtool_EggTable);
  // EggTextureCollection
  Dtool_PyModuleClassInit_EggTextureCollection(module);
  PyModule_AddObject(module, "EggTextureCollection", (PyObject *)&Dtool_EggTextureCollection);
  // EggTriangleFan
  Dtool_PyModuleClassInit_EggTriangleFan(module);
  PyModule_AddObject(module, "EggTriangleFan", (PyObject *)&Dtool_EggTriangleFan);
  // EggTriangleStrip
  Dtool_PyModuleClassInit_EggTriangleStrip(module);
  PyModule_AddObject(module, "EggTriangleStrip", (PyObject *)&Dtool_EggTriangleStrip);
  // EggXfmSAnim
  Dtool_PyModuleClassInit_EggXfmSAnim(module);
  PyModule_AddObject(module, "EggXfmSAnim", (PyObject *)&Dtool_EggXfmSAnim);
  // EggXfmAnimData
  Dtool_PyModuleClassInit_EggXfmAnimData(module);
  PyModule_AddObject(module, "EggXfmAnimData", (PyObject *)&Dtool_EggXfmAnimData);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3egg_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478214022,  /* file_identifier */
  "libp3egg",  /* library_name */
  "hhEq",  /* library_hash_name */
  "panda3d.egg",  /* module_name */
  "libp3egg.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  2444  /* next_index */
};

Configure(_in_configure_libp3egg);
ConfigureFn(_in_configure_libp3egg) {
  interrogate_request_module(&_in_module_def);
}

