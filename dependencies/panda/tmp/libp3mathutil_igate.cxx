/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/mathutil -Ipanda/src/mathutil -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3mathutil_igate.cxx -od built/pandac/input/libp3mathutil.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/mathutil -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/fftw/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3mathutil boundingBox.h boundingHexahedron.h boundingLine.h boundingPlane.h boundingSphere.h boundingVolume.h config_mathutil.h fftCompressor.h finiteBoundingVolume.h frustum.h geometricBoundingVolume.h intersectionBoundingVolume.h linmath_events.h look_at.h mersenne.h omniBoundingVolume.h p3mathutil_composite1.cxx p3mathutil_composite2.cxx parabola.h perlinNoise.h perlinNoise2.h perlinNoise3.h plane.h pta_LMatrix3.h pta_LMatrix3_ext.h pta_LMatrix4.h pta_LMatrix4_ext.h pta_LVecBase2.h pta_LVecBase2_ext.h pta_LVecBase3.h pta_LVecBase3_ext.h pta_LVecBase4.h pta_LVecBase4_ext.h randomizer.h rotate_to.h stackedPerlinNoise2.h stackedPerlinNoise3.h triangulator.h triangulator3.h unionBoundingVolume.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3mathutil
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "boundingBox.h"
#include "boundingHexahedron.h"
#include "boundingLine.h"
#include "boundingPlane.h"
#include "boundingSphere.h"
#include "boundingVolume.h"
#include "cmath.h"
#include "config_mathutil.h"
#include "coordinateSystem.h"
#include "dblnames.h"
#include "fftCompressor.h"
#include "finiteBoundingVolume.h"
#include "fltnames.h"
#include "frustum.h"
#include "geometricBoundingVolume.h"
#include "intersectionBoundingVolume.h"
#include "linmath_events.h"
#include "look_at.h"
#include "luse.h"
#include "mersenne.h"
#include "omniBoundingVolume.h"
#include "pandabase.h"
#include "parabola.h"
#include "paramValue.h"
#include "perlinNoise.h"
#include "perlinNoise2.h"
#include "perlinNoise3.h"
#include "plane.h"
#include "pointerToArray.h"
#include "pointerToArray_ext.h"
#include "pta_LMatrix3.h"
#include "pta_LMatrix3_ext.h"
#include "pta_LMatrix4.h"
#include "pta_LMatrix4_ext.h"
#include "pta_LVecBase2.h"
#include "pta_LVecBase2_ext.h"
#include "pta_LVecBase3.h"
#include "pta_LVecBase3_ext.h"
#include "pta_LVecBase4.h"
#include "pta_LVecBase4_ext.h"
#include "pvector.h"
#include "randomizer.h"
#include "rotate_to.h"
#include "stackedPerlinNoise2.h"
#include "stackedPerlinNoise3.h"
#include "triangulator.h"
#include "triangulator3.h"
#include "unionBoundingVolume.h"
#include "vector_double.h"
#include "vector_stdfloat.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ConstPointerToArray_LMatrix3d
 */
typedef ConstPointerToArray< LMatrix3d > ConstPointerToArray_LMatrix3d_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LMatrix3d, ConstPointerToArray_LMatrix3d_localtype, ConstPointerToArray_LMatrix3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LMatrix3d = &Dtool_ConstPointerToArray_LMatrix3d;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d(PyObject *module);
ConstPointerToArray< LMatrix3d > *Dtool_Coerce_ConstPointerToArray_LMatrix3d(PyObject *args, ConstPointerToArray< LMatrix3d > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LMatrix3d
 */
typedef PointerToArrayBase< LMatrix3d > PointerToArrayBase_LMatrix3d_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LMatrix3d, PointerToArrayBase_LMatrix3d_localtype, PointerToArrayBase_LMatrix3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LMatrix3d = &Dtool_PointerToArrayBase_LMatrix3d;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LMatrix3d
 */
typedef PointerToBase< ReferenceCountedVector< LMatrix3d > > PointerToBase_ReferenceCountedVector_LMatrix3d_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LMatrix3d, PointerToBase_ReferenceCountedVector_LMatrix3d_localtype, PointerToBase_ReferenceCountedVector_LMatrix3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d = &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3d(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LMatrix3f
 */
typedef ConstPointerToArray< LMatrix3f > ConstPointerToArray_LMatrix3f_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LMatrix3f, ConstPointerToArray_LMatrix3f_localtype, ConstPointerToArray_LMatrix3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LMatrix3f = &Dtool_ConstPointerToArray_LMatrix3f;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(PyObject *module);
ConstPointerToArray< LMatrix3f > *Dtool_Coerce_ConstPointerToArray_LMatrix3f(PyObject *args, ConstPointerToArray< LMatrix3f > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LMatrix3f
 */
typedef PointerToArrayBase< LMatrix3f > PointerToArrayBase_LMatrix3f_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LMatrix3f, PointerToArrayBase_LMatrix3f_localtype, PointerToArrayBase_LMatrix3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LMatrix3f = &Dtool_PointerToArrayBase_LMatrix3f;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LMatrix3f
 */
typedef PointerToBase< ReferenceCountedVector< LMatrix3f > > PointerToBase_ReferenceCountedVector_LMatrix3f_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LMatrix3f, PointerToBase_ReferenceCountedVector_LMatrix3f_localtype, PointerToBase_ReferenceCountedVector_LMatrix3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f = &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase2d
 */
typedef ConstPointerToArray< LVecBase2d > ConstPointerToArray_LVecBase2d_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase2d, ConstPointerToArray_LVecBase2d_localtype, ConstPointerToArray_LVecBase2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase2d = &Dtool_ConstPointerToArray_LVecBase2d;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d(PyObject *module);
ConstPointerToArray< LVecBase2d > *Dtool_Coerce_ConstPointerToArray_LVecBase2d(PyObject *args, ConstPointerToArray< LVecBase2d > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase2d
 */
typedef PointerToArrayBase< LVecBase2d > PointerToArrayBase_LVecBase2d_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase2d, PointerToArrayBase_LVecBase2d_localtype, PointerToArrayBase_LVecBase2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase2d = &Dtool_PointerToArrayBase_LVecBase2d;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase2d
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase2d > > PointerToBase_ReferenceCountedVector_LVecBase2d_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase2d, PointerToBase_ReferenceCountedVector_LVecBase2d_localtype, PointerToBase_ReferenceCountedVector_LVecBase2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2d(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase2f
 */
typedef ConstPointerToArray< LVecBase2f > ConstPointerToArray_LVecBase2f_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase2f, ConstPointerToArray_LVecBase2f_localtype, ConstPointerToArray_LVecBase2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase2f = &Dtool_ConstPointerToArray_LVecBase2f;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(PyObject *module);
ConstPointerToArray< LVecBase2f > *Dtool_Coerce_ConstPointerToArray_LVecBase2f(PyObject *args, ConstPointerToArray< LVecBase2f > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase2f
 */
typedef PointerToArrayBase< LVecBase2f > PointerToArrayBase_LVecBase2f_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase2f, PointerToArrayBase_LVecBase2f_localtype, PointerToArrayBase_LVecBase2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase2f = &Dtool_PointerToArrayBase_LVecBase2f;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase2f
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase2f > > PointerToBase_ReferenceCountedVector_LVecBase2f_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase2f, PointerToBase_ReferenceCountedVector_LVecBase2f_localtype, PointerToBase_ReferenceCountedVector_LVecBase2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase2i
 */
typedef ConstPointerToArray< LVecBase2i > ConstPointerToArray_LVecBase2i_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase2i, ConstPointerToArray_LVecBase2i_localtype, ConstPointerToArray_LVecBase2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase2i = &Dtool_ConstPointerToArray_LVecBase2i;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2i(PyObject *module);
ConstPointerToArray< LVecBase2i > *Dtool_Coerce_ConstPointerToArray_LVecBase2i(PyObject *args, ConstPointerToArray< LVecBase2i > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase2i
 */
typedef PointerToArrayBase< LVecBase2i > PointerToArrayBase_LVecBase2i_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase2i, PointerToArrayBase_LVecBase2i_localtype, PointerToArrayBase_LVecBase2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase2i = &Dtool_PointerToArrayBase_LVecBase2i;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase2i
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase2i > > PointerToBase_ReferenceCountedVector_LVecBase2i_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase2i, PointerToBase_ReferenceCountedVector_LVecBase2i_localtype, PointerToBase_ReferenceCountedVector_LVecBase2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2i(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase3d
 */
typedef ConstPointerToArray< LVecBase3d > ConstPointerToArray_LVecBase3d_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase3d, ConstPointerToArray_LVecBase3d_localtype, ConstPointerToArray_LVecBase3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase3d = &Dtool_ConstPointerToArray_LVecBase3d;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d(PyObject *module);
ConstPointerToArray< LVecBase3d > *Dtool_Coerce_ConstPointerToArray_LVecBase3d(PyObject *args, ConstPointerToArray< LVecBase3d > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase3d
 */
typedef PointerToArrayBase< LVecBase3d > PointerToArrayBase_LVecBase3d_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase3d, PointerToArrayBase_LVecBase3d_localtype, PointerToArrayBase_LVecBase3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase3d = &Dtool_PointerToArrayBase_LVecBase3d;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase3d
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase3d > > PointerToBase_ReferenceCountedVector_LVecBase3d_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase3d, PointerToBase_ReferenceCountedVector_LVecBase3d_localtype, PointerToBase_ReferenceCountedVector_LVecBase3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3d(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase3f
 */
typedef ConstPointerToArray< LVecBase3f > ConstPointerToArray_LVecBase3f_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase3f, ConstPointerToArray_LVecBase3f_localtype, ConstPointerToArray_LVecBase3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase3f = &Dtool_ConstPointerToArray_LVecBase3f;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(PyObject *module);
ConstPointerToArray< LVecBase3f > *Dtool_Coerce_ConstPointerToArray_LVecBase3f(PyObject *args, ConstPointerToArray< LVecBase3f > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase3f
 */
typedef PointerToArrayBase< LVecBase3f > PointerToArrayBase_LVecBase3f_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase3f, PointerToArrayBase_LVecBase3f_localtype, PointerToArrayBase_LVecBase3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase3f = &Dtool_PointerToArrayBase_LVecBase3f;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase3f
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase3f > > PointerToBase_ReferenceCountedVector_LVecBase3f_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase3f, PointerToBase_ReferenceCountedVector_LVecBase3f_localtype, PointerToBase_ReferenceCountedVector_LVecBase3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase3i
 */
typedef ConstPointerToArray< LVecBase3i > ConstPointerToArray_LVecBase3i_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase3i, ConstPointerToArray_LVecBase3i_localtype, ConstPointerToArray_LVecBase3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase3i = &Dtool_ConstPointerToArray_LVecBase3i;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3i(PyObject *module);
ConstPointerToArray< LVecBase3i > *Dtool_Coerce_ConstPointerToArray_LVecBase3i(PyObject *args, ConstPointerToArray< LVecBase3i > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase3i
 */
typedef PointerToArrayBase< LVecBase3i > PointerToArrayBase_LVecBase3i_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase3i, PointerToArrayBase_LVecBase3i_localtype, PointerToArrayBase_LVecBase3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase3i = &Dtool_PointerToArrayBase_LVecBase3i;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase3i
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase3i > > PointerToBase_ReferenceCountedVector_LVecBase3i_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase3i, PointerToBase_ReferenceCountedVector_LVecBase3i_localtype, PointerToBase_ReferenceCountedVector_LVecBase3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3i(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_UnalignedLMatrix4d
 */
typedef ConstPointerToArray< UnalignedLMatrix4d > ConstPointerToArray_UnalignedLMatrix4d_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_UnalignedLMatrix4d, ConstPointerToArray_UnalignedLMatrix4d_localtype, ConstPointerToArray_UnalignedLMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d = &Dtool_ConstPointerToArray_UnalignedLMatrix4d;
static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d(PyObject *module);
ConstPointerToArray< UnalignedLMatrix4d > *Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4d(PyObject *args, ConstPointerToArray< UnalignedLMatrix4d > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_UnalignedLMatrix4d
 */
typedef PointerToArrayBase< UnalignedLMatrix4d > PointerToArrayBase_UnalignedLMatrix4d_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_UnalignedLMatrix4d, PointerToArrayBase_UnalignedLMatrix4d_localtype, PointerToArrayBase_UnalignedLMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d = &Dtool_PointerToArrayBase_UnalignedLMatrix4d;
static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d
 */
typedef PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_localtype, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_UnalignedLMatrix4f
 */
typedef ConstPointerToArray< UnalignedLMatrix4f > ConstPointerToArray_UnalignedLMatrix4f_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_UnalignedLMatrix4f, ConstPointerToArray_UnalignedLMatrix4f_localtype, ConstPointerToArray_UnalignedLMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f = &Dtool_ConstPointerToArray_UnalignedLMatrix4f;
static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(PyObject *module);
ConstPointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4f(PyObject *args, ConstPointerToArray< UnalignedLMatrix4f > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_UnalignedLMatrix4f
 */
typedef PointerToArrayBase< UnalignedLMatrix4f > PointerToArrayBase_UnalignedLMatrix4f_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_UnalignedLMatrix4f, PointerToArrayBase_UnalignedLMatrix4f_localtype, PointerToArrayBase_UnalignedLMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f = &Dtool_PointerToArrayBase_UnalignedLMatrix4f;
static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f
 */
typedef PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_localtype, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_UnalignedLVecBase4d
 */
typedef ConstPointerToArray< UnalignedLVecBase4d > ConstPointerToArray_UnalignedLVecBase4d_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_UnalignedLVecBase4d, ConstPointerToArray_UnalignedLVecBase4d_localtype, ConstPointerToArray_UnalignedLVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d = &Dtool_ConstPointerToArray_UnalignedLVecBase4d;
static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d(PyObject *module);
ConstPointerToArray< UnalignedLVecBase4d > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4d(PyObject *args, ConstPointerToArray< UnalignedLVecBase4d > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_UnalignedLVecBase4d
 */
typedef PointerToArrayBase< UnalignedLVecBase4d > PointerToArrayBase_UnalignedLVecBase4d_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_UnalignedLVecBase4d, PointerToArrayBase_UnalignedLVecBase4d_localtype, PointerToArrayBase_UnalignedLVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d = &Dtool_PointerToArrayBase_UnalignedLVecBase4d;
static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d
 */
typedef PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_localtype, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_UnalignedLVecBase4f
 */
typedef ConstPointerToArray< UnalignedLVecBase4f > ConstPointerToArray_UnalignedLVecBase4f_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_UnalignedLVecBase4f, ConstPointerToArray_UnalignedLVecBase4f_localtype, ConstPointerToArray_UnalignedLVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f = &Dtool_ConstPointerToArray_UnalignedLVecBase4f;
static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(PyObject *module);
ConstPointerToArray< UnalignedLVecBase4f > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4f(PyObject *args, ConstPointerToArray< UnalignedLVecBase4f > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_UnalignedLVecBase4f
 */
typedef PointerToArrayBase< UnalignedLVecBase4f > PointerToArrayBase_UnalignedLVecBase4f_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_UnalignedLVecBase4f, PointerToArrayBase_UnalignedLVecBase4f_localtype, PointerToArrayBase_UnalignedLVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f = &Dtool_PointerToArrayBase_UnalignedLVecBase4f;
static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f
 */
typedef PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_localtype, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_UnalignedLVecBase4i
 */
typedef ConstPointerToArray< UnalignedLVecBase4i > ConstPointerToArray_UnalignedLVecBase4i_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_UnalignedLVecBase4i, ConstPointerToArray_UnalignedLVecBase4i_localtype, ConstPointerToArray_UnalignedLVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i = &Dtool_ConstPointerToArray_UnalignedLVecBase4i;
static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4i(PyObject *module);
ConstPointerToArray< UnalignedLVecBase4i > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4i(PyObject *args, ConstPointerToArray< UnalignedLVecBase4i > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_UnalignedLVecBase4i
 */
typedef PointerToArrayBase< UnalignedLVecBase4i > PointerToArrayBase_UnalignedLVecBase4i_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_UnalignedLVecBase4i, PointerToArrayBase_UnalignedLVecBase4i_localtype, PointerToArrayBase_UnalignedLVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i = &Dtool_PointerToArrayBase_UnalignedLVecBase4i;
static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i
 */
typedef PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_localtype, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(PyObject *module);

/**
 * Forward declarations for top-level class PointerToArray_LMatrix3d
 */
typedef PointerToArray< LMatrix3d > PointerToArray_LMatrix3d_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LMatrix3d, PointerToArray_LMatrix3d_localtype, PointerToArray_LMatrix3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LMatrix3d = &Dtool_PointerToArray_LMatrix3d;
static void Dtool_PyModuleClassInit_PointerToArray_LMatrix3d(PyObject *module);
PointerToArray< LMatrix3d > *Dtool_Coerce_PointerToArray_LMatrix3d(PyObject *args, PointerToArray< LMatrix3d > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LMatrix3f
 */
typedef PointerToArray< LMatrix3f > PointerToArray_LMatrix3f_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LMatrix3f, PointerToArray_LMatrix3f_localtype, PointerToArray_LMatrix3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LMatrix3f = &Dtool_PointerToArray_LMatrix3f;
static void Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(PyObject *module);
PointerToArray< LMatrix3f > *Dtool_Coerce_PointerToArray_LMatrix3f(PyObject *args, PointerToArray< LMatrix3f > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase2d
 */
typedef PointerToArray< LVecBase2d > PointerToArray_LVecBase2d_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase2d, PointerToArray_LVecBase2d_localtype, PointerToArray_LVecBase2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase2d = &Dtool_PointerToArray_LVecBase2d;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2d(PyObject *module);
PointerToArray< LVecBase2d > *Dtool_Coerce_PointerToArray_LVecBase2d(PyObject *args, PointerToArray< LVecBase2d > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase2f
 */
typedef PointerToArray< LVecBase2f > PointerToArray_LVecBase2f_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase2f, PointerToArray_LVecBase2f_localtype, PointerToArray_LVecBase2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase2f = &Dtool_PointerToArray_LVecBase2f;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(PyObject *module);
PointerToArray< LVecBase2f > *Dtool_Coerce_PointerToArray_LVecBase2f(PyObject *args, PointerToArray< LVecBase2f > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase2i
 */
typedef PointerToArray< LVecBase2i > PointerToArray_LVecBase2i_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase2i, PointerToArray_LVecBase2i_localtype, PointerToArray_LVecBase2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase2i = &Dtool_PointerToArray_LVecBase2i;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2i(PyObject *module);
PointerToArray< LVecBase2i > *Dtool_Coerce_PointerToArray_LVecBase2i(PyObject *args, PointerToArray< LVecBase2i > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase3d
 */
typedef PointerToArray< LVecBase3d > PointerToArray_LVecBase3d_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase3d, PointerToArray_LVecBase3d_localtype, PointerToArray_LVecBase3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase3d = &Dtool_PointerToArray_LVecBase3d;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3d(PyObject *module);
PointerToArray< LVecBase3d > *Dtool_Coerce_PointerToArray_LVecBase3d(PyObject *args, PointerToArray< LVecBase3d > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase3f
 */
typedef PointerToArray< LVecBase3f > PointerToArray_LVecBase3f_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase3f, PointerToArray_LVecBase3f_localtype, PointerToArray_LVecBase3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase3f = &Dtool_PointerToArray_LVecBase3f;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(PyObject *module);
PointerToArray< LVecBase3f > *Dtool_Coerce_PointerToArray_LVecBase3f(PyObject *args, PointerToArray< LVecBase3f > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase3i
 */
typedef PointerToArray< LVecBase3i > PointerToArray_LVecBase3i_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase3i, PointerToArray_LVecBase3i_localtype, PointerToArray_LVecBase3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase3i = &Dtool_PointerToArray_LVecBase3i;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3i(PyObject *module);
PointerToArray< LVecBase3i > *Dtool_Coerce_PointerToArray_LVecBase3i(PyObject *args, PointerToArray< LVecBase3i > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_UnalignedLMatrix4d
 */
typedef PointerToArray< UnalignedLMatrix4d > PointerToArray_UnalignedLMatrix4d_localtype;
Define_Module_Class(panda3d.core, PointerToArray_UnalignedLMatrix4d, PointerToArray_UnalignedLMatrix4d_localtype, PointerToArray_UnalignedLMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLMatrix4d = &Dtool_PointerToArray_UnalignedLMatrix4d;
static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d(PyObject *module);
PointerToArray< UnalignedLMatrix4d > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4d(PyObject *args, PointerToArray< UnalignedLMatrix4d > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_UnalignedLMatrix4f
 */
typedef PointerToArray< UnalignedLMatrix4f > PointerToArray_UnalignedLMatrix4f_localtype;
Define_Module_Class(panda3d.core, PointerToArray_UnalignedLMatrix4f, PointerToArray_UnalignedLMatrix4f_localtype, PointerToArray_UnalignedLMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLMatrix4f = &Dtool_PointerToArray_UnalignedLMatrix4f;
static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(PyObject *module);
PointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(PyObject *args, PointerToArray< UnalignedLMatrix4f > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_UnalignedLVecBase4d
 */
typedef PointerToArray< UnalignedLVecBase4d > PointerToArray_UnalignedLVecBase4d_localtype;
Define_Module_Class(panda3d.core, PointerToArray_UnalignedLVecBase4d, PointerToArray_UnalignedLVecBase4d_localtype, PointerToArray_UnalignedLVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLVecBase4d = &Dtool_PointerToArray_UnalignedLVecBase4d;
static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d(PyObject *module);
PointerToArray< UnalignedLVecBase4d > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4d(PyObject *args, PointerToArray< UnalignedLVecBase4d > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_UnalignedLVecBase4f
 */
typedef PointerToArray< UnalignedLVecBase4f > PointerToArray_UnalignedLVecBase4f_localtype;
Define_Module_Class(panda3d.core, PointerToArray_UnalignedLVecBase4f, PointerToArray_UnalignedLVecBase4f_localtype, PointerToArray_UnalignedLVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLVecBase4f = &Dtool_PointerToArray_UnalignedLVecBase4f;
static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(PyObject *module);
PointerToArray< UnalignedLVecBase4f > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4f(PyObject *args, PointerToArray< UnalignedLVecBase4f > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_UnalignedLVecBase4i
 */
typedef PointerToArray< UnalignedLVecBase4i > PointerToArray_UnalignedLVecBase4i_localtype;
Define_Module_Class(panda3d.core, PointerToArray_UnalignedLVecBase4i, PointerToArray_UnalignedLVecBase4i_localtype, PointerToArray_UnalignedLVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLVecBase4i = &Dtool_PointerToArray_UnalignedLVecBase4i;
static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4i(PyObject *module);
PointerToArray< UnalignedLVecBase4i > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4i(PyObject *args, PointerToArray< UnalignedLVecBase4i > &coerced);

/**
 * Forward declarations for top-level class BoundingVolume
 */
typedef BoundingVolume BoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, BoundingVolume, BoundingVolume_localtype, BoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingVolume = &Dtool_BoundingVolume;
static void Dtool_PyModuleClassInit_BoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class GeometricBoundingVolume
 */
typedef GeometricBoundingVolume GeometricBoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, GeometricBoundingVolume, GeometricBoundingVolume_localtype, GeometricBoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeometricBoundingVolume = &Dtool_GeometricBoundingVolume;
static void Dtool_PyModuleClassInit_GeometricBoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class FiniteBoundingVolume
 */
typedef FiniteBoundingVolume FiniteBoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, FiniteBoundingVolume, FiniteBoundingVolume_localtype, FiniteBoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FiniteBoundingVolume = &Dtool_FiniteBoundingVolume;
static void Dtool_PyModuleClassInit_FiniteBoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class LParabolaf
 */
typedef LParabolaf LParabolaf_localtype;
Define_Module_Class(panda3d.core, LParabolaf, LParabolaf_localtype, LParabolaf);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LParabolaf = &Dtool_LParabolaf;
static void Dtool_PyModuleClassInit_LParabolaf(PyObject *module);
LParabolaf *Dtool_Coerce_LParabolaf(PyObject *args, LParabolaf &coerced);

/**
 * Forward declarations for top-level class LParabolad
 */
typedef LParabolad LParabolad_localtype;
Define_Module_Class(panda3d.core, LParabolad, LParabolad_localtype, LParabolad);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LParabolad = &Dtool_LParabolad;
static void Dtool_PyModuleClassInit_LParabolad(PyObject *module);
LParabolad *Dtool_Coerce_LParabolad(PyObject *args, LParabolad &coerced);

/**
 * Forward declarations for top-level class LPlanef
 */
typedef LPlanef LPlanef_localtype;
Define_Module_Class(panda3d.core, LPlanef, LPlanef_localtype, LPlanef);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPlanef = &Dtool_LPlanef;
static void Dtool_PyModuleClassInit_LPlanef(PyObject *module);
LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced);

/**
 * Forward declarations for top-level class LPlaned
 */
typedef LPlaned LPlaned_localtype;
Define_Module_Class(panda3d.core, LPlaned, LPlaned_localtype, LPlaned);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPlaned = &Dtool_LPlaned;
static void Dtool_PyModuleClassInit_LPlaned(PyObject *module);
LPlaned *Dtool_Coerce_LPlaned(PyObject *args, LPlaned &coerced);

/**
 * Forward declarations for top-level class BoundingBox
 */
typedef BoundingBox BoundingBox_localtype;
Define_Module_ClassRef(panda3d.core, BoundingBox, BoundingBox_localtype, BoundingBox);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingBox = &Dtool_BoundingBox;
static void Dtool_PyModuleClassInit_BoundingBox(PyObject *module);
bool Dtool_ConstCoerce_BoundingBox(PyObject *args, CPT(BoundingBox) &coerced);
bool Dtool_Coerce_BoundingBox(PyObject *args, PT(BoundingBox) &coerced);

/**
 * Forward declarations for top-level class LFrustumf
 */
typedef LFrustumf LFrustumf_localtype;
Define_Module_Class(panda3d.core, LFrustumf, LFrustumf_localtype, LFrustumf);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LFrustumf = &Dtool_LFrustumf;
static void Dtool_PyModuleClassInit_LFrustumf(PyObject *module);

/**
 * Forward declarations for top-level class LFrustumd
 */
typedef LFrustumd LFrustumd_localtype;
Define_Module_Class(panda3d.core, LFrustumd, LFrustumd_localtype, LFrustumd);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LFrustumd = &Dtool_LFrustumd;
static void Dtool_PyModuleClassInit_LFrustumd(PyObject *module);

/**
 * Forward declarations for top-level class BoundingHexahedron
 */
typedef BoundingHexahedron BoundingHexahedron_localtype;
Define_Module_ClassRef(panda3d.core, BoundingHexahedron, BoundingHexahedron_localtype, BoundingHexahedron);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingHexahedron = &Dtool_BoundingHexahedron;
static void Dtool_PyModuleClassInit_BoundingHexahedron(PyObject *module);
bool Dtool_ConstCoerce_BoundingHexahedron(PyObject *args, CPT(BoundingHexahedron) &coerced);
bool Dtool_Coerce_BoundingHexahedron(PyObject *args, PT(BoundingHexahedron) &coerced);

/**
 * Forward declarations for top-level class BoundingLine
 */
typedef BoundingLine BoundingLine_localtype;
Define_Module_ClassRef(panda3d.core, BoundingLine, BoundingLine_localtype, BoundingLine);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingLine = &Dtool_BoundingLine;
static void Dtool_PyModuleClassInit_BoundingLine(PyObject *module);
bool Dtool_ConstCoerce_BoundingLine(PyObject *args, CPT(BoundingLine) &coerced);
bool Dtool_Coerce_BoundingLine(PyObject *args, PT(BoundingLine) &coerced);

/**
 * Forward declarations for top-level class BoundingPlane
 */
typedef BoundingPlane BoundingPlane_localtype;
Define_Module_ClassRef(panda3d.core, BoundingPlane, BoundingPlane_localtype, BoundingPlane);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingPlane = &Dtool_BoundingPlane;
static void Dtool_PyModuleClassInit_BoundingPlane(PyObject *module);
bool Dtool_ConstCoerce_BoundingPlane(PyObject *args, CPT(BoundingPlane) &coerced);
bool Dtool_Coerce_BoundingPlane(PyObject *args, PT(BoundingPlane) &coerced);

/**
 * Forward declarations for top-level class BoundingSphere
 */
typedef BoundingSphere BoundingSphere_localtype;
Define_Module_ClassRef(panda3d.core, BoundingSphere, BoundingSphere_localtype, BoundingSphere);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingSphere = &Dtool_BoundingSphere;
static void Dtool_PyModuleClassInit_BoundingSphere(PyObject *module);
bool Dtool_ConstCoerce_BoundingSphere(PyObject *args, CPT(BoundingSphere) &coerced);
bool Dtool_Coerce_BoundingSphere(PyObject *args, PT(BoundingSphere) &coerced);

/**
 * Forward declarations for top-level class IntersectionBoundingVolume
 */
typedef IntersectionBoundingVolume IntersectionBoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, IntersectionBoundingVolume, IntersectionBoundingVolume_localtype, IntersectionBoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IntersectionBoundingVolume = &Dtool_IntersectionBoundingVolume;
static void Dtool_PyModuleClassInit_IntersectionBoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class Mersenne
 */
typedef Mersenne Mersenne_localtype;
Define_Module_Class(panda3d.core, Mersenne, Mersenne_localtype, Mersenne);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Mersenne = &Dtool_Mersenne;
static void Dtool_PyModuleClassInit_Mersenne(PyObject *module);
bool Dtool_ConstCoerce_Mersenne(PyObject *args, Mersenne const *&coerced, bool &manage);
bool Dtool_Coerce_Mersenne(PyObject *args, Mersenne *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OmniBoundingVolume
 */
typedef OmniBoundingVolume OmniBoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, OmniBoundingVolume, OmniBoundingVolume_localtype, OmniBoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OmniBoundingVolume = &Dtool_OmniBoundingVolume;
static void Dtool_PyModuleClassInit_OmniBoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class UnionBoundingVolume
 */
typedef UnionBoundingVolume UnionBoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, UnionBoundingVolume, UnionBoundingVolume_localtype, UnionBoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnionBoundingVolume = &Dtool_UnionBoundingVolume;
static void Dtool_PyModuleClassInit_UnionBoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class Randomizer
 */
typedef Randomizer Randomizer_localtype;
Define_Module_Class(panda3d.core, Randomizer, Randomizer_localtype, Randomizer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Randomizer = &Dtool_Randomizer;
static void Dtool_PyModuleClassInit_Randomizer(PyObject *module);
bool Dtool_ConstCoerce_Randomizer(PyObject *args, Randomizer const *&coerced, bool &manage);
bool Dtool_Coerce_Randomizer(PyObject *args, Randomizer *&coerced, bool &manage);

/**
 * Forward declarations for top-level class PerlinNoise
 */
typedef PerlinNoise PerlinNoise_localtype;
Define_Module_Class(panda3d.core, PerlinNoise, PerlinNoise_localtype, PerlinNoise);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PerlinNoise = &Dtool_PerlinNoise;
static void Dtool_PyModuleClassInit_PerlinNoise(PyObject *module);

/**
 * Forward declarations for top-level class PerlinNoise2
 */
typedef PerlinNoise2 PerlinNoise2_localtype;
Define_Module_Class(panda3d.core, PerlinNoise2, PerlinNoise2_localtype, PerlinNoise2);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PerlinNoise2 = &Dtool_PerlinNoise2;
static void Dtool_PyModuleClassInit_PerlinNoise2(PyObject *module);
bool Dtool_ConstCoerce_PerlinNoise2(PyObject *args, PerlinNoise2 const *&coerced, bool &manage);
bool Dtool_Coerce_PerlinNoise2(PyObject *args, PerlinNoise2 *&coerced, bool &manage);

/**
 * Forward declarations for top-level class PerlinNoise3
 */
typedef PerlinNoise3 PerlinNoise3_localtype;
Define_Module_Class(panda3d.core, PerlinNoise3, PerlinNoise3_localtype, PerlinNoise3);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PerlinNoise3 = &Dtool_PerlinNoise3;
static void Dtool_PyModuleClassInit_PerlinNoise3(PyObject *module);
bool Dtool_ConstCoerce_PerlinNoise3(PyObject *args, PerlinNoise3 const *&coerced, bool &manage);
bool Dtool_Coerce_PerlinNoise3(PyObject *args, PerlinNoise3 *&coerced, bool &manage);

/**
 * Forward declarations for top-level class StackedPerlinNoise2
 */
typedef StackedPerlinNoise2 StackedPerlinNoise2_localtype;
Define_Module_Class(panda3d.core, StackedPerlinNoise2, StackedPerlinNoise2_localtype, StackedPerlinNoise2);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StackedPerlinNoise2 = &Dtool_StackedPerlinNoise2;
static void Dtool_PyModuleClassInit_StackedPerlinNoise2(PyObject *module);
bool Dtool_ConstCoerce_StackedPerlinNoise2(PyObject *args, StackedPerlinNoise2 const *&coerced, bool &manage);
bool Dtool_Coerce_StackedPerlinNoise2(PyObject *args, StackedPerlinNoise2 *&coerced, bool &manage);

/**
 * Forward declarations for top-level class StackedPerlinNoise3
 */
typedef StackedPerlinNoise3 StackedPerlinNoise3_localtype;
Define_Module_Class(panda3d.core, StackedPerlinNoise3, StackedPerlinNoise3_localtype, StackedPerlinNoise3);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StackedPerlinNoise3 = &Dtool_StackedPerlinNoise3;
static void Dtool_PyModuleClassInit_StackedPerlinNoise3(PyObject *module);
bool Dtool_ConstCoerce_StackedPerlinNoise3(PyObject *args, StackedPerlinNoise3 const *&coerced, bool &manage);
bool Dtool_Coerce_StackedPerlinNoise3(PyObject *args, StackedPerlinNoise3 *&coerced, bool &manage);

/**
 * Forward declarations for top-level class Triangulator
 */
typedef Triangulator Triangulator_localtype;
Define_Module_Class(panda3d.core, Triangulator, Triangulator_localtype, Triangulator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Triangulator = &Dtool_Triangulator;
static void Dtool_PyModuleClassInit_Triangulator(PyObject *module);

/**
 * Forward declarations for top-level class Triangulator3
 */
typedef Triangulator3 Triangulator3_localtype;
Define_Module_Class(panda3d.core, Triangulator3, Triangulator3_localtype, Triangulator3);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Triangulator3 = &Dtool_Triangulator3;
static void Dtool_PyModuleClassInit_Triangulator3(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// PointerToVoid
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PointerToVoid;
#else
extern struct Dtool_PyTypedObject Dtool_PointerToVoid;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToVoid = &Dtool_PointerToVoid;
#endif
// DatagramIterator
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DatagramIterator;
inline static DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  nassertr(Dtool_Ptr_DatagramIterator != NULL, NULL);
  nassertr(Dtool_Ptr_DatagramIterator->_Dtool_Coerce != NULL, NULL);
  return ((DatagramIterator *(*)(PyObject *, DatagramIterator &))Dtool_Ptr_DatagramIterator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DatagramIterator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
extern DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);
#endif
// Datagram
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Datagram;
inline static bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram const *&, bool&))Dtool_Ptr_Datagram->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram *&, bool&))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage);
extern bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage);
#endif
// LVecBase2d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2d;
inline static LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced) {
  nassertr(Dtool_Ptr_LVecBase2d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2d *(*)(PyObject *, LVecBase2d &))Dtool_Ptr_LVecBase2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2d = &Dtool_LVecBase2d;
extern LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced);
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2f;
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LMatrix3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix3f;
inline static LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced) {
  nassertr(Dtool_Ptr_LMatrix3f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix3f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix3f *(*)(PyObject *, LMatrix3f &))Dtool_Ptr_LMatrix3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f = &Dtool_LMatrix3f;
extern LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced);
#endif
// LMatrix4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4d;
inline static LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced) {
  nassertr(Dtool_Ptr_LMatrix4d != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4d->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4d *(*)(PyObject *, LMatrix4d &))Dtool_Ptr_LMatrix4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d = &Dtool_LMatrix4d;
extern LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced);
#endif
// UnalignedLVecBase4i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_UnalignedLVecBase4i;
inline static UnalignedLVecBase4i *Dtool_Coerce_UnalignedLVecBase4i(PyObject *args, UnalignedLVecBase4i &coerced) {
  nassertr(Dtool_Ptr_UnalignedLVecBase4i != NULL, NULL);
  nassertr(Dtool_Ptr_UnalignedLVecBase4i->_Dtool_Coerce != NULL, NULL);
  return ((UnalignedLVecBase4i *(*)(PyObject *, UnalignedLVecBase4i &))Dtool_Ptr_UnalignedLVecBase4i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_UnalignedLVecBase4i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLVecBase4i = &Dtool_UnalignedLVecBase4i;
extern UnalignedLVecBase4i *Dtool_Coerce_UnalignedLVecBase4i(PyObject *args, UnalignedLVecBase4i &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LMatrix3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix3d;
inline static LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced) {
  nassertr(Dtool_Ptr_LMatrix3d != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix3d->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix3d *(*)(PyObject *, LMatrix3d &))Dtool_Ptr_LMatrix3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3d = &Dtool_LMatrix3d;
extern LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced);
#endif
// UnalignedLMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_UnalignedLMatrix4f;
inline static UnalignedLMatrix4f *Dtool_Coerce_UnalignedLMatrix4f(PyObject *args, UnalignedLMatrix4f &coerced) {
  nassertr(Dtool_Ptr_UnalignedLMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_UnalignedLMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((UnalignedLMatrix4f *(*)(PyObject *, UnalignedLMatrix4f &))Dtool_Ptr_UnalignedLMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_UnalignedLMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLMatrix4f = &Dtool_UnalignedLMatrix4f;
extern UnalignedLMatrix4f *Dtool_Coerce_UnalignedLMatrix4f(PyObject *args, UnalignedLMatrix4f &coerced);
#endif
// UnalignedLMatrix4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_UnalignedLMatrix4d;
inline static UnalignedLMatrix4d *Dtool_Coerce_UnalignedLMatrix4d(PyObject *args, UnalignedLMatrix4d &coerced) {
  nassertr(Dtool_Ptr_UnalignedLMatrix4d != NULL, NULL);
  nassertr(Dtool_Ptr_UnalignedLMatrix4d->_Dtool_Coerce != NULL, NULL);
  return ((UnalignedLMatrix4d *(*)(PyObject *, UnalignedLMatrix4d &))Dtool_Ptr_UnalignedLMatrix4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_UnalignedLMatrix4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLMatrix4d = &Dtool_UnalignedLMatrix4d;
extern UnalignedLMatrix4d *Dtool_Coerce_UnalignedLMatrix4d(PyObject *args, UnalignedLMatrix4d &coerced);
#endif
// LQuaternionf
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LQuaternionf;
inline static LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced) {
  nassertr(Dtool_Ptr_LQuaternionf != NULL, NULL);
  nassertr(Dtool_Ptr_LQuaternionf->_Dtool_Coerce != NULL, NULL);
  return ((LQuaternionf *(*)(PyObject *, LQuaternionf &))Dtool_Ptr_LQuaternionf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaternionf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaternionf = &Dtool_LQuaternionf;
extern LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced);
#endif
// LQuaterniond
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LQuaterniond;
inline static LQuaterniond *Dtool_Coerce_LQuaterniond(PyObject *args, LQuaterniond &coerced) {
  nassertr(Dtool_Ptr_LQuaterniond != NULL, NULL);
  nassertr(Dtool_Ptr_LQuaterniond->_Dtool_Coerce != NULL, NULL);
  return ((LQuaterniond *(*)(PyObject *, LQuaterniond &))Dtool_Ptr_LQuaterniond->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaterniond;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaterniond = &Dtool_LQuaterniond;
extern LQuaterniond *Dtool_Coerce_LQuaterniond(PyObject *args, LQuaterniond &coerced);
#endif
// LVecBase3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3d;
inline static LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced) {
  nassertr(Dtool_Ptr_LVecBase3d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3d *(*)(PyObject *, LVecBase3d &))Dtool_Ptr_LVecBase3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3d = &Dtool_LVecBase3d;
extern LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced);
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase2i;
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LVecBase3i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3i;
inline static LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced) {
  nassertr(Dtool_Ptr_LVecBase3i != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3i->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3i *(*)(PyObject *, LVecBase3i &))Dtool_Ptr_LVecBase3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3i = &Dtool_LVecBase3i;
extern LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced);
#endif
// LVector3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3d;
inline static LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced) {
  nassertr(Dtool_Ptr_LVector3d != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3d->_Dtool_Coerce != NULL, NULL);
  return ((LVector3d *(*)(PyObject *, LVector3d &))Dtool_Ptr_LVector3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3d = &Dtool_LVector3d;
extern LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LPoint3d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3d;
inline static LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced) {
  nassertr(Dtool_Ptr_LPoint3d != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3d->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3d *(*)(PyObject *, LPoint3d &))Dtool_Ptr_LPoint3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3d = &Dtool_LPoint3d;
extern LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced);
#endif
// LPoint2d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint2d;
inline static LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced) {
  nassertr(Dtool_Ptr_LPoint2d != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint2d->_Dtool_Coerce != NULL, NULL);
  return ((LPoint2d *(*)(PyObject *, LPoint2d &))Dtool_Ptr_LPoint2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2d = &Dtool_LPoint2d;
extern LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3f;
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != NULL, NULL);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// UnalignedLVecBase4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_UnalignedLVecBase4d;
inline static UnalignedLVecBase4d *Dtool_Coerce_UnalignedLVecBase4d(PyObject *args, UnalignedLVecBase4d &coerced) {
  nassertr(Dtool_Ptr_UnalignedLVecBase4d != NULL, NULL);
  nassertr(Dtool_Ptr_UnalignedLVecBase4d->_Dtool_Coerce != NULL, NULL);
  return ((UnalignedLVecBase4d *(*)(PyObject *, UnalignedLVecBase4d &))Dtool_Ptr_UnalignedLVecBase4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_UnalignedLVecBase4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLVecBase4d = &Dtool_UnalignedLVecBase4d;
extern UnalignedLVecBase4d *Dtool_Coerce_UnalignedLVecBase4d(PyObject *args, UnalignedLVecBase4d &coerced);
#endif
// UnalignedLVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_UnalignedLVecBase4f;
inline static UnalignedLVecBase4f *Dtool_Coerce_UnalignedLVecBase4f(PyObject *args, UnalignedLVecBase4f &coerced) {
  nassertr(Dtool_Ptr_UnalignedLVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_UnalignedLVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((UnalignedLVecBase4f *(*)(PyObject *, UnalignedLVecBase4f &))Dtool_Ptr_UnalignedLVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_UnalignedLVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLVecBase4f = &Dtool_UnalignedLVecBase4f;
extern UnalignedLVecBase4f *Dtool_Coerce_UnalignedLVecBase4f(PyObject *args, UnalignedLVecBase4f &coerced);
#endif
// LVecBase4d
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4d;
inline static LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced) {
  nassertr(Dtool_Ptr_LVecBase4d != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4d->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4d *(*)(PyObject *, LVecBase4d &))Dtool_Ptr_LVecBase4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4d = &Dtool_LVecBase4d;
extern LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * inline void heads_up(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void heads_up(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 * inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 * inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_heads_up_665(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "heads_up", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "heads_up", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "heads_up", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "heads_up", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "heads_up", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "heads_up", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "heads_up", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          LVector3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3d, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "heads_up", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          LVector3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "heads_up", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          LVector3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "heads_up", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          LVector3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3d, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "heads_up", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          LVector3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3d, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "heads_up", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          LVector3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "heads_up", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "heads_up", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "heads_up", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "heads_up", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "heads_up", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "heads_up", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "heads_up() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "heads_up(LQuaterniond quat, const LVector3d fwd)\n"
      "heads_up(LMatrix3f mat, const LVector3f fwd)\n"
      "heads_up(LQuaternionf quat, const LVector3f fwd)\n"
      "heads_up(LMatrix4d mat, const LVector3d fwd)\n"
      "heads_up(LMatrix3d mat, const LVector3d fwd)\n"
      "heads_up(LMatrix4f mat, const LVector3f fwd)\n"
      "heads_up(LQuaterniond quat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "heads_up(LMatrix3f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "heads_up(LQuaternionf quat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "heads_up(LMatrix4d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "heads_up(LMatrix3d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "heads_up(LMatrix4f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "heads_up(LMatrix4d mat, const LVector3d fwd, int cs)\n"
      "heads_up(LMatrix3d mat, const LVector3d fwd, int cs)\n"
      "heads_up(LMatrix4f mat, const LVector3f fwd, int cs)\n"
      "heads_up(LMatrix3f mat, const LVector3f fwd, int cs)\n"
      "heads_up(LQuaterniond quat, const LVector3d fwd, int cs)\n"
      "heads_up(LQuaternionf quat, const LVector3f fwd, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_heads_up_665_comment =
  "C++ Interface:\n"
  "heads_up(LQuaterniond quat, const LVector3d fwd)\n"
  "heads_up(LMatrix3f mat, const LVector3f fwd)\n"
  "heads_up(LQuaternionf quat, const LVector3f fwd)\n"
  "heads_up(LMatrix4d mat, const LVector3d fwd)\n"
  "heads_up(LMatrix3d mat, const LVector3d fwd)\n"
  "heads_up(LMatrix4f mat, const LVector3f fwd)\n"
  "heads_up(LQuaterniond quat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "heads_up(LMatrix3f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "heads_up(LQuaternionf quat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "heads_up(LMatrix4d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "heads_up(LMatrix3d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "heads_up(LMatrix4f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "heads_up(LMatrix4d mat, const LVector3d fwd, int cs)\n"
  "heads_up(LMatrix3d mat, const LVector3d fwd, int cs)\n"
  "heads_up(LMatrix4f mat, const LVector3f fwd, int cs)\n"
  "heads_up(LMatrix3f mat, const LVector3f fwd, int cs)\n"
  "heads_up(LQuaterniond quat, const LVector3d fwd, int cs)\n"
  "heads_up(LQuaternionf quat, const LVector3f fwd, int cs)\n";
#else
static const char *Dtool_heads_up_665_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void look_at(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void look_at(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 * inline void look_at(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void look_at(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 * inline void look_at(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void look_at(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_look_at_666(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "look_at", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "look_at", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "look_at", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "look_at", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "look_at", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "look_at", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "look_at", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          LVector3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "look_at", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          LVector3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "look_at", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          LVector3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3d, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "look_at", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          LVector3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3d, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "look_at", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          LVector3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3d, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "look_at", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          LVector3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "look_at", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "look_at", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "look_at", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "look_at", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "look_at", false, false);
          LVector3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "look_at", false, false);
          LVector3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "look_at() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "look_at(LMatrix4f mat, const LVector3f fwd)\n"
      "look_at(LMatrix3f mat, const LVector3f fwd)\n"
      "look_at(LMatrix3d mat, const LVector3d fwd)\n"
      "look_at(LMatrix4d mat, const LVector3d fwd)\n"
      "look_at(LQuaterniond quat, const LVector3d fwd)\n"
      "look_at(LQuaternionf quat, const LVector3f fwd)\n"
      "look_at(LMatrix4f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "look_at(LMatrix3f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "look_at(LMatrix3d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "look_at(LMatrix4d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "look_at(LQuaterniond quat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "look_at(LQuaternionf quat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "look_at(LQuaterniond quat, const LVector3d fwd, int cs)\n"
      "look_at(LMatrix3d mat, const LVector3d fwd, int cs)\n"
      "look_at(LQuaternionf quat, const LVector3f fwd, int cs)\n"
      "look_at(LMatrix3f mat, const LVector3f fwd, int cs)\n"
      "look_at(LMatrix4d mat, const LVector3d fwd, int cs)\n"
      "look_at(LMatrix4f mat, const LVector3f fwd, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_look_at_666_comment =
  "C++ Interface:\n"
  "look_at(LMatrix4f mat, const LVector3f fwd)\n"
  "look_at(LMatrix3f mat, const LVector3f fwd)\n"
  "look_at(LMatrix3d mat, const LVector3d fwd)\n"
  "look_at(LMatrix4d mat, const LVector3d fwd)\n"
  "look_at(LQuaterniond quat, const LVector3d fwd)\n"
  "look_at(LQuaternionf quat, const LVector3f fwd)\n"
  "look_at(LMatrix4f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "look_at(LMatrix3f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "look_at(LMatrix3d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "look_at(LMatrix4d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "look_at(LQuaterniond quat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "look_at(LQuaternionf quat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "look_at(LQuaterniond quat, const LVector3d fwd, int cs)\n"
  "look_at(LMatrix3d mat, const LVector3d fwd, int cs)\n"
  "look_at(LQuaternionf quat, const LVector3f fwd, int cs)\n"
  "look_at(LMatrix3f mat, const LVector3f fwd, int cs)\n"
  "look_at(LMatrix4d mat, const LVector3d fwd, int cs)\n"
  "look_at(LMatrix4f mat, const LVector3f fwd, int cs)\n";
#else
static const char *Dtool_look_at_666_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void rotate_to(LMatrix3d &mat, LVector3d const &a, LVector3d const &b)
 * void rotate_to(LMatrix3f &mat, LVector3f const &a, LVector3f const &b)
 * void rotate_to(LMatrix4d &mat, LVector3d const &a, LVector3d const &b)
 * void rotate_to(LMatrix4f &mat, LVector3f const &a, LVector3f const &b)
 */
static PyObject *Dtool_rotate_to_772(PyObject *, PyObject *args, PyObject *kwds) {
  {
    // -2 void rotate_to(LMatrix4d &mat, LVector3d const &a, LVector3d const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "rotate_to", false, false);
      LVector3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
      LVector3d const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3d, (void **)&param2_this);
      if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
        rotate_to(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix3f &mat, LVector3f const &a, LVector3f const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "rotate_to", false, false);
      LVector3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
      LVector3f const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3f, (void **)&param2_this);
      if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
        rotate_to(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix4f &mat, LVector3f const &a, LVector3f const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "rotate_to", false, false);
      LVector3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3f, (void **)&param1_this);
      LVector3f const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3f, (void **)&param2_this);
      if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
        rotate_to(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix3d &mat, LVector3d const &a, LVector3d const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "rotate_to", false, false);
      LVector3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVector3d, (void **)&param1_this);
      LVector3d const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVector3d, (void **)&param2_this);
      if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
        rotate_to(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix4d &mat, LVector3d const &a, LVector3d const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix4d param0_local;
      LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
      LVector3d param1_local;
      LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
      LVector3d param2_local;
      LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
      if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
        rotate_to(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix3f &mat, LVector3f const &a, LVector3f const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix3f param0_local;
      LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
      LVector3f param1_local;
      LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
      LVector3f param2_local;
      LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
      if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
        rotate_to(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix4f &mat, LVector3f const &a, LVector3f const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix4f param0_local;
      LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
      LVector3f param1_local;
      LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
      LVector3f param2_local;
      LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
      if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
        rotate_to(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix3d &mat, LVector3d const &a, LVector3d const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix3d param0_local;
      LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
      LVector3d param1_local;
      LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
      LVector3d param2_local;
      LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
      if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
        rotate_to(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate_to(LMatrix4d mat, const LVector3d a, const LVector3d b)\n"
      "rotate_to(LMatrix3f mat, const LVector3f a, const LVector3f b)\n"
      "rotate_to(LMatrix4f mat, const LVector3f a, const LVector3f b)\n"
      "rotate_to(LMatrix3d mat, const LVector3d a, const LVector3d b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_rotate_to_772_comment =
  "C++ Interface:\n"
  "rotate_to(LMatrix4d mat, const LVector3d a, const LVector3d b)\n"
  "rotate_to(LMatrix3f mat, const LVector3f a, const LVector3f b)\n"
  "rotate_to(LMatrix4f mat, const LVector3f a, const LVector3f b)\n"
  "rotate_to(LMatrix3d mat, const LVector3d a, const LVector3d b)\n";
#else
static const char *Dtool_rotate_to_772_comment = NULL;
#endif

/**
 * Python wrappers for functions of class ConstPointerToArray< LMatrix3d >
 */
/**
 * Python function wrapper for:
 * inline LMatrix3d const &ConstPointerToArray< LMatrix3d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_get_element_10(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3d const &ConstPointerToArray< LMatrix3d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LMatrix3d const *return_value = &((*(const ConstPointerToArray< LMatrix3d >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_element_10_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_element_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LMatrix3d >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_get_data_12(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LMatrix3d >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< LMatrix3d >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_data_12_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_data_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LMatrix3d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_get_subdata_13(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LMatrix3d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< LMatrix3d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_subdata_13_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_subdata_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LMatrix3d >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_14(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LMatrix3d >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LMatrix3d >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_14_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LMatrix3d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_15(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LMatrix3d >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LMatrix3d >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_15_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(ConstPointerToArray< LMatrix3d > const &copy)
 * inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PointerToArray< LMatrix3d > const &copy)
 * ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_LMatrix3d(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PointerToArray< LMatrix3d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LMatrix3d > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LMatrix3d, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LMatrix3d > *return_value = new ConstPointerToArray< LMatrix3d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(ConstPointerToArray< LMatrix3d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LMatrix3d > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_LMatrix3d, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LMatrix3d > *return_value = new ConstPointerToArray< LMatrix3d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_LMatrix3d, false, false);
      ConstPointerToArray< LMatrix3d > *result = new ConstPointerToArray< LMatrix3d >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< LMatrix3d > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PointerToArray< LMatrix3d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LMatrix3d > param0_local;
      PointerToArray< LMatrix3d > const *param0_this = Dtool_Coerce_PointerToArray_LMatrix3d(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LMatrix3d > *return_value = new ConstPointerToArray< LMatrix3d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(ConstPointerToArray< LMatrix3d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LMatrix3d > param0_local;
      ConstPointerToArray< LMatrix3d > const *param0_this = Dtool_Coerce_ConstPointerToArray_LMatrix3d(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LMatrix3d > *return_value = new ConstPointerToArray< LMatrix3d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3d, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< LMatrix3d > *Dtool_Coerce_ConstPointerToArray_LMatrix3d(PyObject *args, ConstPointerToArray< LMatrix3d > &coerced) {
  ConstPointerToArray< LMatrix3d > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_LMatrix3d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LMatrix3d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PointerToArray< LMatrix3d > const &copy)
      PointerToArray< LMatrix3d > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_LMatrix3d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< LMatrix3d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_LMatrix3d(&Dtool_ConstPointerToArray_LMatrix3d._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LMatrix3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_LMatrix3d) {
    printf("ConstPointerToArray_LMatrix3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< LMatrix3d > *local_this = (ConstPointerToArray< LMatrix3d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_LMatrix3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    return (PointerToArrayBase< LMatrix3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3d > > *)(PointerToArrayBase< LMatrix3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3d > > *)(PointerToArrayBase< LMatrix3d > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LMatrix3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LMatrix3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    PointerToArrayBase< LMatrix3d >* other_this = (PointerToArrayBase< LMatrix3d >*)from_this;
    return (ConstPointerToArray< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    PointerToBase< ReferenceCountedVector< LMatrix3d > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3d > >*)from_this;
    return (ConstPointerToArray< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LMatrix3d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LMatrix3d >
 */
static int Dtool_Init_PointerToArrayBase_LMatrix3d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LMatrix3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    printf("PointerToArrayBase_LMatrix3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< LMatrix3d > *local_this = (PointerToArrayBase< LMatrix3d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3d > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3d > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LMatrix3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    PointerToBase< ReferenceCountedVector< LMatrix3d > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3d > >*)from_this;
    return (PointerToArrayBase< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LMatrix3d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LMatrix3d > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LMatrix3d > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_clear_5(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LMatrix3d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LMatrix3d.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LMatrix3d > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_clear_5_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_clear_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LMatrix3d > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_output_6(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LMatrix3d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LMatrix3d > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< LMatrix3d > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_output_6_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_output_6_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LMatrix3d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LMatrix3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    printf("PointerToBase_ReferenceCountedVector_LMatrix3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< LMatrix3d > > *local_this = (PointerToBase< ReferenceCountedVector< LMatrix3d > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LMatrix3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LMatrix3d > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LMatrix3f >
 */
/**
 * Python function wrapper for:
 * inline LMatrix3f const &ConstPointerToArray< LMatrix3f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_element_27(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3f const &ConstPointerToArray< LMatrix3f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LMatrix3f const *return_value = &((*(const ConstPointerToArray< LMatrix3f >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_element_27_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_element_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LMatrix3f >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_data_29(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LMatrix3f >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< LMatrix3f >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_data_29_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_data_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LMatrix3f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_subdata_30(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LMatrix3f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< LMatrix3f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_subdata_30_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_subdata_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LMatrix3f >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_31(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LMatrix3f >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LMatrix3f >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_31_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LMatrix3f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_32(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LMatrix3f >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LMatrix3f >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_32_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(ConstPointerToArray< LMatrix3f > const &copy)
 * inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PointerToArray< LMatrix3f > const &copy)
 * ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PointerToArray< LMatrix3f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LMatrix3f > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LMatrix3f, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LMatrix3f > *return_value = new ConstPointerToArray< LMatrix3f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(ConstPointerToArray< LMatrix3f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LMatrix3f > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_LMatrix3f, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LMatrix3f > *return_value = new ConstPointerToArray< LMatrix3f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_LMatrix3f, false, false);
      ConstPointerToArray< LMatrix3f > *result = new ConstPointerToArray< LMatrix3f >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< LMatrix3f > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PointerToArray< LMatrix3f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LMatrix3f > param0_local;
      PointerToArray< LMatrix3f > const *param0_this = Dtool_Coerce_PointerToArray_LMatrix3f(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LMatrix3f > *return_value = new ConstPointerToArray< LMatrix3f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(ConstPointerToArray< LMatrix3f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LMatrix3f > param0_local;
      ConstPointerToArray< LMatrix3f > const *param0_this = Dtool_Coerce_ConstPointerToArray_LMatrix3f(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LMatrix3f > *return_value = new ConstPointerToArray< LMatrix3f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3f, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< LMatrix3f > *Dtool_Coerce_ConstPointerToArray_LMatrix3f(PyObject *args, ConstPointerToArray< LMatrix3f > &coerced) {
  ConstPointerToArray< LMatrix3f > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_LMatrix3f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LMatrix3f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PointerToArray< LMatrix3f > const &copy)
      PointerToArray< LMatrix3f > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_LMatrix3f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< LMatrix3f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_LMatrix3f(&Dtool_ConstPointerToArray_LMatrix3f._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_LMatrix3f) {
    printf("ConstPointerToArray_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< LMatrix3f > *local_this = (ConstPointerToArray< LMatrix3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_LMatrix3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    return (PointerToArrayBase< LMatrix3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3f > > *)(PointerToArrayBase< LMatrix3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3f > > *)(PointerToArrayBase< LMatrix3f > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LMatrix3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    PointerToArrayBase< LMatrix3f >* other_this = (PointerToArrayBase< LMatrix3f >*)from_this;
    return (ConstPointerToArray< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    PointerToBase< ReferenceCountedVector< LMatrix3f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)from_this;
    return (ConstPointerToArray< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LMatrix3f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LMatrix3f >
 */
static int Dtool_Init_PointerToArrayBase_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    printf("PointerToArrayBase_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< LMatrix3f > *local_this = (PointerToArrayBase< LMatrix3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3f > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3f > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    PointerToBase< ReferenceCountedVector< LMatrix3f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)from_this;
    return (PointerToArrayBase< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LMatrix3f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LMatrix3f > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LMatrix3f > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_22(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LMatrix3f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LMatrix3f.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LMatrix3f > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_22_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LMatrix3f > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_23(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LMatrix3f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LMatrix3f > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< LMatrix3f > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_23_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_23_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    printf("PointerToBase_ReferenceCountedVector_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< LMatrix3f > > *local_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase2d >
 */
/**
 * Python function wrapper for:
 * inline LVecBase2d const &ConstPointerToArray< LVecBase2d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_get_element_44(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d const &ConstPointerToArray< LVecBase2d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2d const *return_value = &((*(const ConstPointerToArray< LVecBase2d >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_element_44_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_element_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase2d >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_get_data_46(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase2d >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase2d >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_data_46_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_data_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase2d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_get_subdata_47(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase2d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase2d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_subdata_47_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_subdata_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2d >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_48(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase2d >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase2d >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_48_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_49(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase2d >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase2d >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_49_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(ConstPointerToArray< LVecBase2d > const &copy)
 * inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PointerToArray< LVecBase2d > const &copy)
 * ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase2d(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PointerToArray< LVecBase2d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase2d > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase2d, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase2d > *return_value = new ConstPointerToArray< LVecBase2d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(ConstPointerToArray< LVecBase2d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase2d > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_LVecBase2d, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase2d > *return_value = new ConstPointerToArray< LVecBase2d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_LVecBase2d, false, false);
      ConstPointerToArray< LVecBase2d > *result = new ConstPointerToArray< LVecBase2d >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< LVecBase2d > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PointerToArray< LVecBase2d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase2d > param0_local;
      PointerToArray< LVecBase2d > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase2d(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase2d > *return_value = new ConstPointerToArray< LVecBase2d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(ConstPointerToArray< LVecBase2d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase2d > param0_local;
      ConstPointerToArray< LVecBase2d > const *param0_this = Dtool_Coerce_ConstPointerToArray_LVecBase2d(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase2d > *return_value = new ConstPointerToArray< LVecBase2d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2d, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase2d > *Dtool_Coerce_ConstPointerToArray_LVecBase2d(PyObject *args, ConstPointerToArray< LVecBase2d > &coerced) {
  ConstPointerToArray< LVecBase2d > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_LVecBase2d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase2d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PointerToArray< LVecBase2d > const &copy)
      PointerToArray< LVecBase2d > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_LVecBase2d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< LVecBase2d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_LVecBase2d(&Dtool_ConstPointerToArray_LVecBase2d._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_LVecBase2d) {
    printf("ConstPointerToArray_LVecBase2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< LVecBase2d > *local_this = (ConstPointerToArray< LVecBase2d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_LVecBase2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    return (PointerToArrayBase< LVecBase2d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2d > > *)(PointerToArrayBase< LVecBase2d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2d > > *)(PointerToArrayBase< LVecBase2d > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    PointerToArrayBase< LVecBase2d >* other_this = (PointerToArrayBase< LVecBase2d >*)from_this;
    return (ConstPointerToArray< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    PointerToBase< ReferenceCountedVector< LVecBase2d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2d > >*)from_this;
    return (ConstPointerToArray< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase2d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase2d >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase2d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    printf("PointerToArrayBase_LVecBase2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< LVecBase2d > *local_this = (PointerToArrayBase< LVecBase2d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2d > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2d > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    PointerToBase< ReferenceCountedVector< LVecBase2d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2d > >*)from_this;
    return (PointerToArrayBase< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase2d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase2d > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase2d > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_clear_39(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase2d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase2d.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase2d > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_clear_39_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_clear_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase2d > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_output_40(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase2d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase2d > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< LVecBase2d > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_output_40_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_output_40_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< LVecBase2d > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase2d > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase2d > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase2f >
 */
/**
 * Python function wrapper for:
 * inline LVecBase2f const &ConstPointerToArray< LVecBase2f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_element_61(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f const &ConstPointerToArray< LVecBase2f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2f const *return_value = &((*(const ConstPointerToArray< LVecBase2f >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_element_61_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_element_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase2f >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_data_63(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase2f >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase2f >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_data_63_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_data_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase2f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_subdata_64(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase2f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase2f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_subdata_64_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_subdata_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2f >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_65(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase2f >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase2f >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_65_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_66(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase2f >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase2f >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_66_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(ConstPointerToArray< LVecBase2f > const &copy)
 * inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PointerToArray< LVecBase2f > const &copy)
 * ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PointerToArray< LVecBase2f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase2f > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase2f, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase2f > *return_value = new ConstPointerToArray< LVecBase2f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(ConstPointerToArray< LVecBase2f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase2f > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_LVecBase2f, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase2f > *return_value = new ConstPointerToArray< LVecBase2f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_LVecBase2f, false, false);
      ConstPointerToArray< LVecBase2f > *result = new ConstPointerToArray< LVecBase2f >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< LVecBase2f > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PointerToArray< LVecBase2f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase2f > param0_local;
      PointerToArray< LVecBase2f > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase2f(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase2f > *return_value = new ConstPointerToArray< LVecBase2f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(ConstPointerToArray< LVecBase2f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase2f > param0_local;
      ConstPointerToArray< LVecBase2f > const *param0_this = Dtool_Coerce_ConstPointerToArray_LVecBase2f(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase2f > *return_value = new ConstPointerToArray< LVecBase2f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2f, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase2f > *Dtool_Coerce_ConstPointerToArray_LVecBase2f(PyObject *args, ConstPointerToArray< LVecBase2f > &coerced) {
  ConstPointerToArray< LVecBase2f > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_LVecBase2f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase2f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PointerToArray< LVecBase2f > const &copy)
      PointerToArray< LVecBase2f > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_LVecBase2f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< LVecBase2f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_LVecBase2f(&Dtool_ConstPointerToArray_LVecBase2f._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_LVecBase2f) {
    printf("ConstPointerToArray_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< LVecBase2f > *local_this = (ConstPointerToArray< LVecBase2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_LVecBase2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    return (PointerToArrayBase< LVecBase2f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2f > > *)(PointerToArrayBase< LVecBase2f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2f > > *)(PointerToArrayBase< LVecBase2f > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    PointerToArrayBase< LVecBase2f >* other_this = (PointerToArrayBase< LVecBase2f >*)from_this;
    return (ConstPointerToArray< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    PointerToBase< ReferenceCountedVector< LVecBase2f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)from_this;
    return (ConstPointerToArray< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase2f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase2f >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    printf("PointerToArrayBase_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< LVecBase2f > *local_this = (PointerToArrayBase< LVecBase2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2f > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2f > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    PointerToBase< ReferenceCountedVector< LVecBase2f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)from_this;
    return (PointerToArrayBase< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase2f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase2f > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase2f > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_56(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase2f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase2f.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase2f > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_56_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase2f > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_57(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase2f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase2f > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< LVecBase2f > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_57_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_57_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< LVecBase2f > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase2i >
 */
/**
 * Python function wrapper for:
 * inline LVecBase2i const &ConstPointerToArray< LVecBase2i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_get_element_78(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i const &ConstPointerToArray< LVecBase2i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2i const *return_value = &((*(const ConstPointerToArray< LVecBase2i >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_element_78_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_element_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase2i >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_get_data_80(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase2i >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase2i >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_data_80_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_data_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase2i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_get_subdata_81(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase2i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase2i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_subdata_81_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_subdata_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2i >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_82(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase2i >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase2i >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_82_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_83(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase2i >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase2i >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_83_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(ConstPointerToArray< LVecBase2i > const &copy)
 * inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PointerToArray< LVecBase2i > const &copy)
 * ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase2i(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PointerToArray< LVecBase2i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase2i > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase2i, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase2i > *return_value = new ConstPointerToArray< LVecBase2i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(ConstPointerToArray< LVecBase2i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase2i > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_LVecBase2i, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase2i > *return_value = new ConstPointerToArray< LVecBase2i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_LVecBase2i, false, false);
      ConstPointerToArray< LVecBase2i > *result = new ConstPointerToArray< LVecBase2i >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< LVecBase2i > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PointerToArray< LVecBase2i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase2i > param0_local;
      PointerToArray< LVecBase2i > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase2i(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase2i > *return_value = new ConstPointerToArray< LVecBase2i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(ConstPointerToArray< LVecBase2i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase2i > param0_local;
      ConstPointerToArray< LVecBase2i > const *param0_this = Dtool_Coerce_ConstPointerToArray_LVecBase2i(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase2i > *return_value = new ConstPointerToArray< LVecBase2i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2i, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase2i > *Dtool_Coerce_ConstPointerToArray_LVecBase2i(PyObject *args, ConstPointerToArray< LVecBase2i > &coerced) {
  ConstPointerToArray< LVecBase2i > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_LVecBase2i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase2i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PointerToArray< LVecBase2i > const &copy)
      PointerToArray< LVecBase2i > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_LVecBase2i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< LVecBase2i >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_LVecBase2i(&Dtool_ConstPointerToArray_LVecBase2i._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_LVecBase2i) {
    printf("ConstPointerToArray_LVecBase2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< LVecBase2i > *local_this = (ConstPointerToArray< LVecBase2i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_LVecBase2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    return (PointerToArrayBase< LVecBase2i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2i > > *)(PointerToArrayBase< LVecBase2i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2i > > *)(PointerToArrayBase< LVecBase2i > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    PointerToArrayBase< LVecBase2i >* other_this = (PointerToArrayBase< LVecBase2i >*)from_this;
    return (ConstPointerToArray< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    PointerToBase< ReferenceCountedVector< LVecBase2i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2i > >*)from_this;
    return (ConstPointerToArray< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase2i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase2i >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase2i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    printf("PointerToArrayBase_LVecBase2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< LVecBase2i > *local_this = (PointerToArrayBase< LVecBase2i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2i > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2i > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    PointerToBase< ReferenceCountedVector< LVecBase2i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2i > >*)from_this;
    return (PointerToArrayBase< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase2i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase2i > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase2i > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_clear_73(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase2i > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase2i.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase2i > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_clear_73_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_clear_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase2i > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_output_74(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase2i > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase2i > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< LVecBase2i > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_output_74_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_output_74_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< LVecBase2i > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase2i > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase2i > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase3d >
 */
/**
 * Python function wrapper for:
 * inline LVecBase3d const &ConstPointerToArray< LVecBase3d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_get_element_95(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d const &ConstPointerToArray< LVecBase3d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3d const *return_value = &((*(const ConstPointerToArray< LVecBase3d >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_element_95_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_element_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase3d >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_get_data_97(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase3d >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase3d >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_data_97_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_data_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase3d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_get_subdata_98(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase3d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase3d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_subdata_98_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_subdata_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3d >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_99(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase3d >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase3d >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_99_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_100(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase3d >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase3d >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_100_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(ConstPointerToArray< LVecBase3d > const &copy)
 * inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PointerToArray< LVecBase3d > const &copy)
 * ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase3d(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(ConstPointerToArray< LVecBase3d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase3d > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_LVecBase3d, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase3d > *return_value = new ConstPointerToArray< LVecBase3d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PointerToArray< LVecBase3d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase3d > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase3d, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase3d > *return_value = new ConstPointerToArray< LVecBase3d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_LVecBase3d, false, false);
      ConstPointerToArray< LVecBase3d > *result = new ConstPointerToArray< LVecBase3d >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< LVecBase3d > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(ConstPointerToArray< LVecBase3d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase3d > param0_local;
      ConstPointerToArray< LVecBase3d > const *param0_this = Dtool_Coerce_ConstPointerToArray_LVecBase3d(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase3d > *return_value = new ConstPointerToArray< LVecBase3d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PointerToArray< LVecBase3d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase3d > param0_local;
      PointerToArray< LVecBase3d > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase3d(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase3d > *return_value = new ConstPointerToArray< LVecBase3d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3d, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase3d > *Dtool_Coerce_ConstPointerToArray_LVecBase3d(PyObject *args, ConstPointerToArray< LVecBase3d > &coerced) {
  ConstPointerToArray< LVecBase3d > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_LVecBase3d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase3d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PointerToArray< LVecBase3d > const &copy)
      PointerToArray< LVecBase3d > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_LVecBase3d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< LVecBase3d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_LVecBase3d(&Dtool_ConstPointerToArray_LVecBase3d._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_LVecBase3d) {
    printf("ConstPointerToArray_LVecBase3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< LVecBase3d > *local_this = (ConstPointerToArray< LVecBase3d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_LVecBase3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    return (PointerToArrayBase< LVecBase3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3d > > *)(PointerToArrayBase< LVecBase3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3d > > *)(PointerToArrayBase< LVecBase3d > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    PointerToArrayBase< LVecBase3d >* other_this = (PointerToArrayBase< LVecBase3d >*)from_this;
    return (ConstPointerToArray< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    PointerToBase< ReferenceCountedVector< LVecBase3d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3d > >*)from_this;
    return (ConstPointerToArray< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase3d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase3d >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase3d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    printf("PointerToArrayBase_LVecBase3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< LVecBase3d > *local_this = (PointerToArrayBase< LVecBase3d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3d > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3d > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    PointerToBase< ReferenceCountedVector< LVecBase3d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3d > >*)from_this;
    return (PointerToArrayBase< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase3d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase3d > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase3d > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_clear_90(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase3d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase3d.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase3d > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_clear_90_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_clear_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase3d > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_output_91(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase3d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase3d > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< LVecBase3d > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_output_91_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_output_91_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< LVecBase3d > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase3d > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase3d > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase3f >
 */
/**
 * Python function wrapper for:
 * inline LVecBase3f const &ConstPointerToArray< LVecBase3f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_element_112(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f const &ConstPointerToArray< LVecBase3f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3f const *return_value = &((*(const ConstPointerToArray< LVecBase3f >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_element_112_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_element_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase3f >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_data_114(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase3f >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase3f >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_data_114_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_data_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase3f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_subdata_115(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase3f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase3f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_subdata_115_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_subdata_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3f >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_116(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase3f >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase3f >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_116_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_117(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase3f >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase3f >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_117_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(ConstPointerToArray< LVecBase3f > const &copy)
 * inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PointerToArray< LVecBase3f > const &copy)
 * ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PointerToArray< LVecBase3f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase3f > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase3f, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase3f > *return_value = new ConstPointerToArray< LVecBase3f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(ConstPointerToArray< LVecBase3f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase3f > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_LVecBase3f, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase3f > *return_value = new ConstPointerToArray< LVecBase3f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_LVecBase3f, false, false);
      ConstPointerToArray< LVecBase3f > *result = new ConstPointerToArray< LVecBase3f >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< LVecBase3f > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PointerToArray< LVecBase3f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase3f > param0_local;
      PointerToArray< LVecBase3f > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase3f(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase3f > *return_value = new ConstPointerToArray< LVecBase3f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(ConstPointerToArray< LVecBase3f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase3f > param0_local;
      ConstPointerToArray< LVecBase3f > const *param0_this = Dtool_Coerce_ConstPointerToArray_LVecBase3f(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase3f > *return_value = new ConstPointerToArray< LVecBase3f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3f, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase3f > *Dtool_Coerce_ConstPointerToArray_LVecBase3f(PyObject *args, ConstPointerToArray< LVecBase3f > &coerced) {
  ConstPointerToArray< LVecBase3f > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_LVecBase3f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase3f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PointerToArray< LVecBase3f > const &copy)
      PointerToArray< LVecBase3f > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_LVecBase3f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< LVecBase3f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_LVecBase3f(&Dtool_ConstPointerToArray_LVecBase3f._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_LVecBase3f) {
    printf("ConstPointerToArray_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< LVecBase3f > *local_this = (ConstPointerToArray< LVecBase3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_LVecBase3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    return (PointerToArrayBase< LVecBase3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3f > > *)(PointerToArrayBase< LVecBase3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3f > > *)(PointerToArrayBase< LVecBase3f > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    PointerToArrayBase< LVecBase3f >* other_this = (PointerToArrayBase< LVecBase3f >*)from_this;
    return (ConstPointerToArray< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    PointerToBase< ReferenceCountedVector< LVecBase3f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)from_this;
    return (ConstPointerToArray< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase3f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase3f >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    printf("PointerToArrayBase_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< LVecBase3f > *local_this = (PointerToArrayBase< LVecBase3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3f > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3f > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    PointerToBase< ReferenceCountedVector< LVecBase3f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)from_this;
    return (PointerToArrayBase< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase3f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase3f > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase3f > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_107(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase3f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase3f.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase3f > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_107_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase3f > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_108(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase3f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase3f > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< LVecBase3f > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_108_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_108_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< LVecBase3f > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase3i >
 */
/**
 * Python function wrapper for:
 * inline LVecBase3i const &ConstPointerToArray< LVecBase3i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_get_element_129(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3i const &ConstPointerToArray< LVecBase3i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3i const *return_value = &((*(const ConstPointerToArray< LVecBase3i >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_element_129_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_element_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase3i >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_get_data_131(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase3i >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase3i >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_data_131_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_data_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< LVecBase3i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_get_subdata_132(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< LVecBase3i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< LVecBase3i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_subdata_132_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_subdata_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3i >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_133(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase3i >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase3i >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_133_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_134(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< LVecBase3i >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< LVecBase3i >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_134_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(ConstPointerToArray< LVecBase3i > const &copy)
 * inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PointerToArray< LVecBase3i > const &copy)
 * ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase3i(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(ConstPointerToArray< LVecBase3i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase3i > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_LVecBase3i, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase3i > *return_value = new ConstPointerToArray< LVecBase3i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PointerToArray< LVecBase3i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase3i > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase3i, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< LVecBase3i > *return_value = new ConstPointerToArray< LVecBase3i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_LVecBase3i, false, false);
      ConstPointerToArray< LVecBase3i > *result = new ConstPointerToArray< LVecBase3i >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< LVecBase3i > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(ConstPointerToArray< LVecBase3i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< LVecBase3i > param0_local;
      ConstPointerToArray< LVecBase3i > const *param0_this = Dtool_Coerce_ConstPointerToArray_LVecBase3i(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase3i > *return_value = new ConstPointerToArray< LVecBase3i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PointerToArray< LVecBase3i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< LVecBase3i > param0_local;
      PointerToArray< LVecBase3i > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase3i(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< LVecBase3i > *return_value = new ConstPointerToArray< LVecBase3i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3i, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase3i > *Dtool_Coerce_ConstPointerToArray_LVecBase3i(PyObject *args, ConstPointerToArray< LVecBase3i > &coerced) {
  ConstPointerToArray< LVecBase3i > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_LVecBase3i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase3i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PointerToArray< LVecBase3i > const &copy)
      PointerToArray< LVecBase3i > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_LVecBase3i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< LVecBase3i >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_LVecBase3i(&Dtool_ConstPointerToArray_LVecBase3i._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_LVecBase3i) {
    printf("ConstPointerToArray_LVecBase3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< LVecBase3i > *local_this = (ConstPointerToArray< LVecBase3i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_LVecBase3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    return (PointerToArrayBase< LVecBase3i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3i > > *)(PointerToArrayBase< LVecBase3i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3i > > *)(PointerToArrayBase< LVecBase3i > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    PointerToArrayBase< LVecBase3i >* other_this = (PointerToArrayBase< LVecBase3i >*)from_this;
    return (ConstPointerToArray< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    PointerToBase< ReferenceCountedVector< LVecBase3i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3i > >*)from_this;
    return (ConstPointerToArray< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase3i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase3i >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase3i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    printf("PointerToArrayBase_LVecBase3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< LVecBase3i > *local_this = (PointerToArrayBase< LVecBase3i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3i > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3i > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    PointerToBase< ReferenceCountedVector< LVecBase3i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3i > >*)from_this;
    return (PointerToArrayBase< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase3i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase3i > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase3i > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_clear_124(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase3i > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase3i.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase3i > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_clear_124_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_clear_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase3i > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_output_125(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase3i > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase3i > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< LVecBase3i > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_output_125_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_output_125_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< LVecBase3i > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase3i > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase3i > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< UnalignedLMatrix4d >
 */
/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4d const &ConstPointerToArray< UnalignedLMatrix4d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_146(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UnalignedLMatrix4d const &ConstPointerToArray< UnalignedLMatrix4d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLMatrix4d const *return_value = &((*(const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_146_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< UnalignedLMatrix4d >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_148(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< UnalignedLMatrix4d >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_148_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< UnalignedLMatrix4d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_149(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< UnalignedLMatrix4d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_149_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLMatrix4d >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_150(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< UnalignedLMatrix4d >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_150_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLMatrix4d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_151(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< UnalignedLMatrix4d >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_151_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4d > const &copy)
 * inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
 * ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_UnalignedLMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< UnalignedLMatrix4d > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< UnalignedLMatrix4d > *return_value = new ConstPointerToArray< UnalignedLMatrix4d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< UnalignedLMatrix4d > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_UnalignedLMatrix4d, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< UnalignedLMatrix4d > *return_value = new ConstPointerToArray< UnalignedLMatrix4d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_UnalignedLMatrix4d, false, false);
      ConstPointerToArray< UnalignedLMatrix4d > *result = new ConstPointerToArray< UnalignedLMatrix4d >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< UnalignedLMatrix4d > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< UnalignedLMatrix4d > param0_local;
      ConstPointerToArray< UnalignedLMatrix4d > const *param0_this = Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4d(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< UnalignedLMatrix4d > *return_value = new ConstPointerToArray< UnalignedLMatrix4d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< UnalignedLMatrix4d > param0_local;
      PointerToArray< UnalignedLMatrix4d > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLMatrix4d(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< UnalignedLMatrix4d > *return_value = new ConstPointerToArray< UnalignedLMatrix4d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4d, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< UnalignedLMatrix4d > *Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4d(PyObject *args, ConstPointerToArray< UnalignedLMatrix4d > &coerced) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< UnalignedLMatrix4d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
      PointerToArray< UnalignedLMatrix4d > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_UnalignedLMatrix4d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< UnalignedLMatrix4d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_UnalignedLMatrix4d(&Dtool_ConstPointerToArray_UnalignedLMatrix4d._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_UnalignedLMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d) {
    printf("ConstPointerToArray_UnalignedLMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< UnalignedLMatrix4d > *local_this = (ConstPointerToArray< UnalignedLMatrix4d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    return (PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *)(PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *)(PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_UnalignedLMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    PointerToArrayBase< UnalignedLMatrix4d >* other_this = (PointerToArrayBase< UnalignedLMatrix4d >*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< UnalignedLMatrix4d >
 */
static int Dtool_Init_PointerToArrayBase_UnalignedLMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_UnalignedLMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    printf("PointerToArrayBase_UnalignedLMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< UnalignedLMatrix4d > *local_this = (PointerToArrayBase< UnalignedLMatrix4d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_UnalignedLMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >*)from_this;
    return (PointerToArrayBase< UnalignedLMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< UnalignedLMatrix4d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_clear_141(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d, (void **)&local_this, "PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_clear_141_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_clear_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_output_142(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_output_142_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_output_142_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    printf("PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *local_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< UnalignedLMatrix4f >
 */
/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4f const &ConstPointerToArray< UnalignedLMatrix4f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_163(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UnalignedLMatrix4f const &ConstPointerToArray< UnalignedLMatrix4f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLMatrix4f const *return_value = &((*(const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_163_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< UnalignedLMatrix4f >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_165(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< UnalignedLMatrix4f >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_165_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< UnalignedLMatrix4f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_166(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< UnalignedLMatrix4f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_166_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLMatrix4f >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_167(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< UnalignedLMatrix4f >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_167_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLMatrix4f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_168(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< UnalignedLMatrix4f >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_168_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4f > const &copy)
 * inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
 * ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_UnalignedLMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< UnalignedLMatrix4f > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< UnalignedLMatrix4f > *return_value = new ConstPointerToArray< UnalignedLMatrix4f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< UnalignedLMatrix4f > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_UnalignedLMatrix4f, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< UnalignedLMatrix4f > *return_value = new ConstPointerToArray< UnalignedLMatrix4f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_UnalignedLMatrix4f, false, false);
      ConstPointerToArray< UnalignedLMatrix4f > *result = new ConstPointerToArray< UnalignedLMatrix4f >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< UnalignedLMatrix4f > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< UnalignedLMatrix4f > param0_local;
      ConstPointerToArray< UnalignedLMatrix4f > const *param0_this = Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4f(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< UnalignedLMatrix4f > *return_value = new ConstPointerToArray< UnalignedLMatrix4f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< UnalignedLMatrix4f > param0_local;
      PointerToArray< UnalignedLMatrix4f > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< UnalignedLMatrix4f > *return_value = new ConstPointerToArray< UnalignedLMatrix4f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4f, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4f(PyObject *args, ConstPointerToArray< UnalignedLMatrix4f > &coerced) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< UnalignedLMatrix4f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
      PointerToArray< UnalignedLMatrix4f > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_UnalignedLMatrix4f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< UnalignedLMatrix4f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_UnalignedLMatrix4f(&Dtool_ConstPointerToArray_UnalignedLMatrix4f._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_UnalignedLMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f) {
    printf("ConstPointerToArray_UnalignedLMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< UnalignedLMatrix4f > *local_this = (ConstPointerToArray< UnalignedLMatrix4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    return (PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *)(PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *)(PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_UnalignedLMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    PointerToArrayBase< UnalignedLMatrix4f >* other_this = (PointerToArrayBase< UnalignedLMatrix4f >*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< UnalignedLMatrix4f >
 */
static int Dtool_Init_PointerToArrayBase_UnalignedLMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_UnalignedLMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    printf("PointerToArrayBase_UnalignedLMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< UnalignedLMatrix4f > *local_this = (PointerToArrayBase< UnalignedLMatrix4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_UnalignedLMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >*)from_this;
    return (PointerToArrayBase< UnalignedLMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< UnalignedLMatrix4f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_clear_158(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f, (void **)&local_this, "PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_clear_158_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_clear_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_output_159(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_output_159_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_output_159_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    printf("PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *local_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< UnalignedLVecBase4d >
 */
/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4d const &ConstPointerToArray< UnalignedLVecBase4d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_180(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UnalignedLVecBase4d const &ConstPointerToArray< UnalignedLVecBase4d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4d const *return_value = &((*(const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_180_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4d >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_182(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4d >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_182_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_183(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_183_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4d >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_184(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4d >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_184_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_185(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4d >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_185_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4d > const &copy)
 * inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
 * ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_UnalignedLVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< UnalignedLVecBase4d > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_UnalignedLVecBase4d, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< UnalignedLVecBase4d > *return_value = new ConstPointerToArray< UnalignedLVecBase4d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< UnalignedLVecBase4d > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< UnalignedLVecBase4d > *return_value = new ConstPointerToArray< UnalignedLVecBase4d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_UnalignedLVecBase4d, false, false);
      ConstPointerToArray< UnalignedLVecBase4d > *result = new ConstPointerToArray< UnalignedLVecBase4d >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< UnalignedLVecBase4d > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< UnalignedLVecBase4d > param0_local;
      PointerToArray< UnalignedLVecBase4d > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4d(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< UnalignedLVecBase4d > *return_value = new ConstPointerToArray< UnalignedLVecBase4d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4d > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< UnalignedLVecBase4d > param0_local;
      ConstPointerToArray< UnalignedLVecBase4d > const *param0_this = Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4d(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< UnalignedLVecBase4d > *return_value = new ConstPointerToArray< UnalignedLVecBase4d >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4d, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< UnalignedLVecBase4d > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4d(PyObject *args, ConstPointerToArray< UnalignedLVecBase4d > &coerced) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< UnalignedLVecBase4d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
      PointerToArray< UnalignedLVecBase4d > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_UnalignedLVecBase4d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< UnalignedLVecBase4d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_UnalignedLVecBase4d(&Dtool_ConstPointerToArray_UnalignedLVecBase4d._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d) {
    printf("ConstPointerToArray_UnalignedLVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< UnalignedLVecBase4d > *local_this = (ConstPointerToArray< UnalignedLVecBase4d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    return (PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *)(PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *)(PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    PointerToArrayBase< UnalignedLVecBase4d >* other_this = (PointerToArrayBase< UnalignedLVecBase4d >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< UnalignedLVecBase4d >
 */
static int Dtool_Init_PointerToArrayBase_UnalignedLVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    printf("PointerToArrayBase_UnalignedLVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< UnalignedLVecBase4d > *local_this = (PointerToArrayBase< UnalignedLVecBase4d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_clear_175(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d, (void **)&local_this, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_clear_175_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_clear_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_output_176(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_output_176_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_output_176_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    printf("PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *local_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< UnalignedLVecBase4f >
 */
/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4f const &ConstPointerToArray< UnalignedLVecBase4f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_197(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UnalignedLVecBase4f const &ConstPointerToArray< UnalignedLVecBase4f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4f const *return_value = &((*(const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_197_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4f >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_199(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4f >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_199_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_200(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_200_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4f >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_201(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4f >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_201_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_202(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4f >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_202_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4f > const &copy)
 * inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
 * ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_UnalignedLVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< UnalignedLVecBase4f > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< UnalignedLVecBase4f > *return_value = new ConstPointerToArray< UnalignedLVecBase4f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< UnalignedLVecBase4f > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_UnalignedLVecBase4f, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< UnalignedLVecBase4f > *return_value = new ConstPointerToArray< UnalignedLVecBase4f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_UnalignedLVecBase4f, false, false);
      ConstPointerToArray< UnalignedLVecBase4f > *result = new ConstPointerToArray< UnalignedLVecBase4f >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< UnalignedLVecBase4f > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< UnalignedLVecBase4f > param0_local;
      ConstPointerToArray< UnalignedLVecBase4f > const *param0_this = Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4f(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< UnalignedLVecBase4f > *return_value = new ConstPointerToArray< UnalignedLVecBase4f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< UnalignedLVecBase4f > param0_local;
      PointerToArray< UnalignedLVecBase4f > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4f(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< UnalignedLVecBase4f > *return_value = new ConstPointerToArray< UnalignedLVecBase4f >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4f, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< UnalignedLVecBase4f > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4f(PyObject *args, ConstPointerToArray< UnalignedLVecBase4f > &coerced) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< UnalignedLVecBase4f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
      PointerToArray< UnalignedLVecBase4f > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_UnalignedLVecBase4f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< UnalignedLVecBase4f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_UnalignedLVecBase4f(&Dtool_ConstPointerToArray_UnalignedLVecBase4f._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f) {
    printf("ConstPointerToArray_UnalignedLVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< UnalignedLVecBase4f > *local_this = (ConstPointerToArray< UnalignedLVecBase4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    return (PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *)(PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *)(PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    PointerToArrayBase< UnalignedLVecBase4f >* other_this = (PointerToArrayBase< UnalignedLVecBase4f >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< UnalignedLVecBase4f >
 */
static int Dtool_Init_PointerToArrayBase_UnalignedLVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    printf("PointerToArrayBase_UnalignedLVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< UnalignedLVecBase4f > *local_this = (PointerToArrayBase< UnalignedLVecBase4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_clear_192(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f, (void **)&local_this, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_clear_192_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_clear_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_output_193(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_output_193_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_output_193_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    printf("PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *local_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< UnalignedLVecBase4i >
 */
/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4i const &ConstPointerToArray< UnalignedLVecBase4i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_214(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UnalignedLVecBase4i const &ConstPointerToArray< UnalignedLVecBase4i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4i const *return_value = &((*(const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_214_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4i >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_216(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4i >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_216_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_217(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< UnalignedLVecBase4i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_217_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4i >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_218(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4i >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_218_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_219(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4i >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_219_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4i > const &copy)
 * inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
 * ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_UnalignedLVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< UnalignedLVecBase4i > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_UnalignedLVecBase4i, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< UnalignedLVecBase4i > *return_value = new ConstPointerToArray< UnalignedLVecBase4i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< UnalignedLVecBase4i > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< UnalignedLVecBase4i > *return_value = new ConstPointerToArray< UnalignedLVecBase4i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_UnalignedLVecBase4i, false, false);
      ConstPointerToArray< UnalignedLVecBase4i > *result = new ConstPointerToArray< UnalignedLVecBase4i >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< UnalignedLVecBase4i > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< UnalignedLVecBase4i > param0_local;
      PointerToArray< UnalignedLVecBase4i > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4i(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< UnalignedLVecBase4i > *return_value = new ConstPointerToArray< UnalignedLVecBase4i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4i, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4i > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< UnalignedLVecBase4i > param0_local;
      ConstPointerToArray< UnalignedLVecBase4i > const *param0_this = Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4i(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< UnalignedLVecBase4i > *return_value = new ConstPointerToArray< UnalignedLVecBase4i >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4i, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< UnalignedLVecBase4i > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4i(PyObject *args, ConstPointerToArray< UnalignedLVecBase4i > &coerced) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< UnalignedLVecBase4i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
      PointerToArray< UnalignedLVecBase4i > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_UnalignedLVecBase4i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< UnalignedLVecBase4i >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_UnalignedLVecBase4i(&Dtool_ConstPointerToArray_UnalignedLVecBase4i._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i) {
    printf("ConstPointerToArray_UnalignedLVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< UnalignedLVecBase4i > *local_this = (ConstPointerToArray< UnalignedLVecBase4i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    return (PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *)(PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *)(PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    PointerToArrayBase< UnalignedLVecBase4i >* other_this = (PointerToArrayBase< UnalignedLVecBase4i >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< UnalignedLVecBase4i >
 */
static int Dtool_Init_PointerToArrayBase_UnalignedLVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    printf("PointerToArrayBase_UnalignedLVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< UnalignedLVecBase4i > *local_this = (PointerToArrayBase< UnalignedLVecBase4i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_clear_209(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i, (void **)&local_this, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_clear_209_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_clear_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_output_210(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_output_210_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_output_210_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    printf("PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *local_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< LMatrix3d >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LMatrix3d > PointerToArray< LMatrix3d >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((LMatrix3d const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_empty_array_225(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< LMatrix3d > PointerToArray< LMatrix3d >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >(PointerToArray< LMatrix3d >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LMatrix3d, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< LMatrix3d > PointerToArray< LMatrix3d >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >(PointerToArray< LMatrix3d >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LMatrix3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_empty_array_225_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_empty_array_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3d >::push_back(LMatrix3d const &x)
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_push_back_227(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this, "PointerToArray_LMatrix3d.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LMatrix3d >::push_back(LMatrix3d const &x)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LMatrix3d");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LMatrix3d x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_push_back_227_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LMatrix3d x)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_push_back_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3d >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_pop_back_228(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this, "PointerToArray_LMatrix3d.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LMatrix3d >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_pop_back_228_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_pop_back_228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d const &PointerToArray< LMatrix3d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_get_element_229(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3d const &PointerToArray< LMatrix3d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LMatrix3d const *return_value = &((*(const PointerToArray< LMatrix3d >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_get_element_229_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_get_element_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3d >::set_element(unsigned long int n, LMatrix3d const &value)
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_set_element_230(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this, "PointerToArray_LMatrix3d.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LMatrix3d >::set_element(unsigned long int n, LMatrix3d const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LMatrix3d param2_local;
    LMatrix3d const *param2_this = Dtool_Coerce_LMatrix3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LMatrix3d");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LMatrix3d value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_set_element_230_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LMatrix3d value)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_set_element_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LMatrix3d >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_get_data_233(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LMatrix3d >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< LMatrix3d >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_get_data_233_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_get_data_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3d >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_set_data_234(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this, "PointerToArray_LMatrix3d.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LMatrix3d >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_set_data_234_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_set_data_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LMatrix3d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_get_subdata_235(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LMatrix3d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< LMatrix3d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_get_subdata_235_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_get_subdata_235_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_set_subdata_236(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this, "PointerToArray_LMatrix3d.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LMatrix3d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_set_subdata_236_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_set_subdata_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LMatrix3d >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_get_ref_count_237(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LMatrix3d >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< LMatrix3d >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_get_ref_count_237_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_get_ref_count_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LMatrix3d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_get_node_ref_count_238(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LMatrix3d >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< LMatrix3d >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_get_node_ref_count_238_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_get_node_ref_count_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LMatrix3d >::PointerToArray(PointerToArray< LMatrix3d > const &copy)
 * PointerToArray< LMatrix3d >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LMatrix3d >::PointerToArray(TypeHandle type_handle = (_get_type_handle((LMatrix3d const *)(0))))
 */
static int Dtool_Init_PointerToArray_LMatrix3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LMatrix3d >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LMatrix3d >::PointerToArray(PointerToArray< LMatrix3d > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LMatrix3d > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LMatrix3d, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LMatrix3d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< LMatrix3d >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LMatrix3d, false, false);
          PointerToArray< LMatrix3d > *result = new PointerToArray< LMatrix3d >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LMatrix3d > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LMatrix3d >::PointerToArray(PointerToArray< LMatrix3d > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LMatrix3d > param0_local;
          PointerToArray< LMatrix3d > const *param0_this = Dtool_Coerce_PointerToArray_LMatrix3d(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LMatrix3d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< LMatrix3d >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LMatrix3d > *Dtool_Coerce_PointerToArray_LMatrix3d(PyObject *args, PointerToArray< LMatrix3d > &coerced) {
  PointerToArray< LMatrix3d > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_LMatrix3d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LMatrix3d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LMatrix3d >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< LMatrix3d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LMatrix3d >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LMatrix3d(&Dtool_PointerToArray_LMatrix3d._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_LMatrix3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_LMatrix3d) {
    printf("PointerToArray_LMatrix3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< LMatrix3d > *local_this = (PointerToArray< LMatrix3d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_LMatrix3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    return (PointerToArrayBase< LMatrix3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3d > > *)(PointerToArrayBase< LMatrix3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3d > > *)(PointerToArrayBase< LMatrix3d > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_LMatrix3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LMatrix3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    PointerToArrayBase< LMatrix3d >* other_this = (PointerToArrayBase< LMatrix3d >*)from_this;
    return (PointerToArray< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    PointerToBase< ReferenceCountedVector< LMatrix3d > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3d > >*)from_this;
    return (PointerToArray< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LMatrix3d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< LMatrix3f >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LMatrix3f > PointerToArray< LMatrix3f >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((LMatrix3f const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_empty_array_244(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< LMatrix3f > PointerToArray< LMatrix3f >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(PointerToArray< LMatrix3f >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LMatrix3f, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< LMatrix3f > PointerToArray< LMatrix3f >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(PointerToArray< LMatrix3f >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LMatrix3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_empty_array_244_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_empty_array_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3f >::push_back(LMatrix3f const &x)
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_push_back_246(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this, "PointerToArray_LMatrix3f.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LMatrix3f >::push_back(LMatrix3f const &x)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LMatrix3f");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LMatrix3f x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_push_back_246_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LMatrix3f x)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_push_back_246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3f >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_pop_back_247(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this, "PointerToArray_LMatrix3f.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LMatrix3f >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_pop_back_247_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_pop_back_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f const &PointerToArray< LMatrix3f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_get_element_248(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3f const &PointerToArray< LMatrix3f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LMatrix3f const *return_value = &((*(const PointerToArray< LMatrix3f >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_get_element_248_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_get_element_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3f >::set_element(unsigned long int n, LMatrix3f const &value)
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_set_element_249(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this, "PointerToArray_LMatrix3f.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LMatrix3f >::set_element(unsigned long int n, LMatrix3f const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LMatrix3f param2_local;
    LMatrix3f const *param2_this = Dtool_Coerce_LMatrix3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LMatrix3f");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LMatrix3f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_set_element_249_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LMatrix3f value)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_set_element_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LMatrix3f >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_get_data_252(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LMatrix3f >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< LMatrix3f >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_get_data_252_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_get_data_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3f >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_set_data_253(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this, "PointerToArray_LMatrix3f.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LMatrix3f >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_set_data_253_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_set_data_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LMatrix3f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_get_subdata_254(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LMatrix3f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< LMatrix3f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_get_subdata_254_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_get_subdata_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_set_subdata_255(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this, "PointerToArray_LMatrix3f.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LMatrix3f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_set_subdata_255_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_set_subdata_255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LMatrix3f >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_get_ref_count_256(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LMatrix3f >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< LMatrix3f >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_get_ref_count_256_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_get_ref_count_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LMatrix3f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_get_node_ref_count_257(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LMatrix3f >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< LMatrix3f >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_get_node_ref_count_257_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_get_node_ref_count_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LMatrix3f >::PointerToArray(PointerToArray< LMatrix3f > const &copy)
 * PointerToArray< LMatrix3f >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle = (_get_type_handle((LMatrix3f const *)(0))))
 */
static int Dtool_Init_PointerToArray_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LMatrix3f >::PointerToArray(PointerToArray< LMatrix3f > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LMatrix3f > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LMatrix3f, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< LMatrix3f >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LMatrix3f, false, false);
          PointerToArray< LMatrix3f > *result = new PointerToArray< LMatrix3f >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LMatrix3f > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LMatrix3f >::PointerToArray(PointerToArray< LMatrix3f > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LMatrix3f > param0_local;
          PointerToArray< LMatrix3f > const *param0_this = Dtool_Coerce_PointerToArray_LMatrix3f(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< LMatrix3f >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LMatrix3f > *Dtool_Coerce_PointerToArray_LMatrix3f(PyObject *args, PointerToArray< LMatrix3f > &coerced) {
  PointerToArray< LMatrix3f > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_LMatrix3f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LMatrix3f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< LMatrix3f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LMatrix3f >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LMatrix3f(&Dtool_PointerToArray_LMatrix3f._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_LMatrix3f) {
    printf("PointerToArray_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< LMatrix3f > *local_this = (PointerToArray< LMatrix3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_LMatrix3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    return (PointerToArrayBase< LMatrix3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3f > > *)(PointerToArrayBase< LMatrix3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3f > > *)(PointerToArrayBase< LMatrix3f > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LMatrix3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    PointerToArrayBase< LMatrix3f >* other_this = (PointerToArrayBase< LMatrix3f >*)from_this;
    return (PointerToArray< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    PointerToBase< ReferenceCountedVector< LMatrix3f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)from_this;
    return (PointerToArray< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LMatrix3f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase2d >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase2d > PointerToArray< LVecBase2d >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((LVecBase2d const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_empty_array_263(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< LVecBase2d > PointerToArray< LVecBase2d >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >(PointerToArray< LVecBase2d >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase2d, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< LVecBase2d > PointerToArray< LVecBase2d >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >(PointerToArray< LVecBase2d >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase2d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_empty_array_263_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_empty_array_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2d >::push_back(LVecBase2d const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_push_back_265(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this, "PointerToArray_LVecBase2d.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2d >::push_back(LVecBase2d const &x)
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase2d");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase2d x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_push_back_265_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase2d x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_push_back_265_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2d >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_pop_back_266(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this, "PointerToArray_LVecBase2d.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2d >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_pop_back_266_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_pop_back_266_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d const &PointerToArray< LVecBase2d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_get_element_267(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d const &PointerToArray< LVecBase2d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2d const *return_value = &((*(const PointerToArray< LVecBase2d >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_get_element_267_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_get_element_267_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2d >::set_element(unsigned long int n, LVecBase2d const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_set_element_268(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this, "PointerToArray_LVecBase2d.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2d >::set_element(unsigned long int n, LVecBase2d const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase2d param2_local;
    LVecBase2d const *param2_this = Dtool_Coerce_LVecBase2d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase2d");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase2d value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_set_element_268_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase2d value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_set_element_268_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase2d >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_get_data_271(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase2d >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< LVecBase2d >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_get_data_271_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_get_data_271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2d >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_set_data_272(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this, "PointerToArray_LVecBase2d.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2d >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_set_data_272_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_set_data_272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase2d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_get_subdata_273(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase2d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< LVecBase2d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_get_subdata_273_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_get_subdata_273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_set_subdata_274(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this, "PointerToArray_LVecBase2d.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_set_subdata_274_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_set_subdata_274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2d >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_get_ref_count_275(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase2d >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase2d >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_get_ref_count_275_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_get_ref_count_275_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_get_node_ref_count_276(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase2d >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase2d >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_get_node_ref_count_276_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_get_node_ref_count_276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase2d >::PointerToArray(PointerToArray< LVecBase2d > const &copy)
 * PointerToArray< LVecBase2d >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase2d >::PointerToArray(TypeHandle type_handle = (_get_type_handle((LVecBase2d const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase2d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase2d >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase2d >::PointerToArray(PointerToArray< LVecBase2d > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase2d > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase2d, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase2d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< LVecBase2d >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LVecBase2d, false, false);
          PointerToArray< LVecBase2d > *result = new PointerToArray< LVecBase2d >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase2d > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase2d >::PointerToArray(PointerToArray< LVecBase2d > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase2d > param0_local;
          PointerToArray< LVecBase2d > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase2d(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase2d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< LVecBase2d >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase2d > *Dtool_Coerce_PointerToArray_LVecBase2d(PyObject *args, PointerToArray< LVecBase2d > &coerced) {
  PointerToArray< LVecBase2d > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_LVecBase2d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase2d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase2d >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< LVecBase2d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase2d >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase2d(&Dtool_PointerToArray_LVecBase2d._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_LVecBase2d) {
    printf("PointerToArray_LVecBase2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< LVecBase2d > *local_this = (PointerToArray< LVecBase2d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_LVecBase2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    return (PointerToArrayBase< LVecBase2d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2d > > *)(PointerToArrayBase< LVecBase2d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2d > > *)(PointerToArrayBase< LVecBase2d > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    PointerToArrayBase< LVecBase2d >* other_this = (PointerToArrayBase< LVecBase2d >*)from_this;
    return (PointerToArray< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    PointerToBase< ReferenceCountedVector< LVecBase2d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2d > >*)from_this;
    return (PointerToArray< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase2d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase2f >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase2f > PointerToArray< LVecBase2f >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((LVecBase2f const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_empty_array_282(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< LVecBase2f > PointerToArray< LVecBase2f >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(PointerToArray< LVecBase2f >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase2f, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< LVecBase2f > PointerToArray< LVecBase2f >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(PointerToArray< LVecBase2f >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase2f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_empty_array_282_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_empty_array_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2f >::push_back(LVecBase2f const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_push_back_284(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this, "PointerToArray_LVecBase2f.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2f >::push_back(LVecBase2f const &x)
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase2f");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase2f x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_push_back_284_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase2f x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_push_back_284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2f >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_pop_back_285(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this, "PointerToArray_LVecBase2f.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2f >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_pop_back_285_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_pop_back_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f const &PointerToArray< LVecBase2f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_get_element_286(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f const &PointerToArray< LVecBase2f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2f const *return_value = &((*(const PointerToArray< LVecBase2f >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_get_element_286_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_get_element_286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2f >::set_element(unsigned long int n, LVecBase2f const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_set_element_287(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this, "PointerToArray_LVecBase2f.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2f >::set_element(unsigned long int n, LVecBase2f const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase2f param2_local;
    LVecBase2f const *param2_this = Dtool_Coerce_LVecBase2f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase2f");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase2f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_set_element_287_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase2f value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_set_element_287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase2f >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_get_data_290(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase2f >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< LVecBase2f >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_get_data_290_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_get_data_290_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2f >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_set_data_291(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this, "PointerToArray_LVecBase2f.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2f >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_set_data_291_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_set_data_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase2f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_get_subdata_292(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase2f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< LVecBase2f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_get_subdata_292_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_get_subdata_292_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_set_subdata_293(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this, "PointerToArray_LVecBase2f.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_set_subdata_293_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_set_subdata_293_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2f >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_get_ref_count_294(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase2f >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase2f >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_get_ref_count_294_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_get_ref_count_294_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_get_node_ref_count_295(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase2f >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase2f >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_get_node_ref_count_295_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_get_node_ref_count_295_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase2f >::PointerToArray(PointerToArray< LVecBase2f > const &copy)
 * PointerToArray< LVecBase2f >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle = (_get_type_handle((LVecBase2f const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase2f >::PointerToArray(PointerToArray< LVecBase2f > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase2f > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase2f, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< LVecBase2f >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LVecBase2f, false, false);
          PointerToArray< LVecBase2f > *result = new PointerToArray< LVecBase2f >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase2f > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase2f >::PointerToArray(PointerToArray< LVecBase2f > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase2f > param0_local;
          PointerToArray< LVecBase2f > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase2f(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< LVecBase2f >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase2f > *Dtool_Coerce_PointerToArray_LVecBase2f(PyObject *args, PointerToArray< LVecBase2f > &coerced) {
  PointerToArray< LVecBase2f > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_LVecBase2f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase2f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< LVecBase2f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase2f >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase2f(&Dtool_PointerToArray_LVecBase2f._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_LVecBase2f) {
    printf("PointerToArray_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< LVecBase2f > *local_this = (PointerToArray< LVecBase2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_LVecBase2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    return (PointerToArrayBase< LVecBase2f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2f > > *)(PointerToArrayBase< LVecBase2f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2f > > *)(PointerToArrayBase< LVecBase2f > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    PointerToArrayBase< LVecBase2f >* other_this = (PointerToArrayBase< LVecBase2f >*)from_this;
    return (PointerToArray< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    PointerToBase< ReferenceCountedVector< LVecBase2f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)from_this;
    return (PointerToArray< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase2f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase2i >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase2i > PointerToArray< LVecBase2i >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((LVecBase2i const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_empty_array_301(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< LVecBase2i > PointerToArray< LVecBase2i >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >(PointerToArray< LVecBase2i >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase2i, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< LVecBase2i > PointerToArray< LVecBase2i >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >(PointerToArray< LVecBase2i >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase2i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_empty_array_301_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_empty_array_301_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2i >::push_back(LVecBase2i const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_push_back_303(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this, "PointerToArray_LVecBase2i.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2i >::push_back(LVecBase2i const &x)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase2i");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase2i x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_push_back_303_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase2i x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_push_back_303_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2i >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_pop_back_304(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this, "PointerToArray_LVecBase2i.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2i >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_pop_back_304_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_pop_back_304_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i const &PointerToArray< LVecBase2i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_get_element_305(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i const &PointerToArray< LVecBase2i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2i const *return_value = &((*(const PointerToArray< LVecBase2i >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_get_element_305_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_get_element_305_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2i >::set_element(unsigned long int n, LVecBase2i const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_set_element_306(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this, "PointerToArray_LVecBase2i.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2i >::set_element(unsigned long int n, LVecBase2i const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase2i param2_local;
    LVecBase2i const *param2_this = Dtool_Coerce_LVecBase2i(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase2i");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase2i value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_set_element_306_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase2i value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_set_element_306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase2i >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_get_data_309(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase2i >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< LVecBase2i >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_get_data_309_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_get_data_309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2i >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_set_data_310(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this, "PointerToArray_LVecBase2i.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2i >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_set_data_310_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_set_data_310_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase2i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_get_subdata_311(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase2i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< LVecBase2i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_get_subdata_311_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_get_subdata_311_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_set_subdata_312(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this, "PointerToArray_LVecBase2i.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase2i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_set_subdata_312_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_set_subdata_312_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2i >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_get_ref_count_313(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase2i >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase2i >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_get_ref_count_313_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_get_ref_count_313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_get_node_ref_count_314(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase2i >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase2i >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_get_node_ref_count_314_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_get_node_ref_count_314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase2i >::PointerToArray(PointerToArray< LVecBase2i > const &copy)
 * PointerToArray< LVecBase2i >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase2i >::PointerToArray(TypeHandle type_handle = (_get_type_handle((LVecBase2i const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase2i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase2i >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase2i >::PointerToArray(PointerToArray< LVecBase2i > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase2i > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase2i, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase2i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< LVecBase2i >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LVecBase2i, false, false);
          PointerToArray< LVecBase2i > *result = new PointerToArray< LVecBase2i >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase2i > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase2i >::PointerToArray(PointerToArray< LVecBase2i > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase2i > param0_local;
          PointerToArray< LVecBase2i > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase2i(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase2i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< LVecBase2i >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase2i > *Dtool_Coerce_PointerToArray_LVecBase2i(PyObject *args, PointerToArray< LVecBase2i > &coerced) {
  PointerToArray< LVecBase2i > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_LVecBase2i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase2i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase2i >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< LVecBase2i >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase2i >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase2i(&Dtool_PointerToArray_LVecBase2i._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_LVecBase2i) {
    printf("PointerToArray_LVecBase2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< LVecBase2i > *local_this = (PointerToArray< LVecBase2i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_LVecBase2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    return (PointerToArrayBase< LVecBase2i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2i > > *)(PointerToArrayBase< LVecBase2i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2i > > *)(PointerToArrayBase< LVecBase2i > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    PointerToArrayBase< LVecBase2i >* other_this = (PointerToArrayBase< LVecBase2i >*)from_this;
    return (PointerToArray< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    PointerToBase< ReferenceCountedVector< LVecBase2i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2i > >*)from_this;
    return (PointerToArray< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase2i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase3d >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase3d > PointerToArray< LVecBase3d >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((LVecBase3d const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_empty_array_320(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< LVecBase3d > PointerToArray< LVecBase3d >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >(PointerToArray< LVecBase3d >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase3d, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< LVecBase3d > PointerToArray< LVecBase3d >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >(PointerToArray< LVecBase3d >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_empty_array_320_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_empty_array_320_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3d >::push_back(LVecBase3d const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_push_back_322(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this, "PointerToArray_LVecBase3d.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3d >::push_back(LVecBase3d const &x)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase3d");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase3d x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_push_back_322_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase3d x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_push_back_322_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3d >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_pop_back_323(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this, "PointerToArray_LVecBase3d.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3d >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_pop_back_323_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_pop_back_323_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &PointerToArray< LVecBase3d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_get_element_324(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d const &PointerToArray< LVecBase3d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3d const *return_value = &((*(const PointerToArray< LVecBase3d >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_get_element_324_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_get_element_324_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3d >::set_element(unsigned long int n, LVecBase3d const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_set_element_325(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this, "PointerToArray_LVecBase3d.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3d >::set_element(unsigned long int n, LVecBase3d const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase3d param2_local;
    LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase3d");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase3d value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_set_element_325_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase3d value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_set_element_325_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase3d >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_get_data_328(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase3d >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< LVecBase3d >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_get_data_328_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_get_data_328_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3d >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_set_data_329(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this, "PointerToArray_LVecBase3d.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3d >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_set_data_329_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_set_data_329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase3d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_get_subdata_330(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase3d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< LVecBase3d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_get_subdata_330_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_get_subdata_330_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_set_subdata_331(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this, "PointerToArray_LVecBase3d.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_set_subdata_331_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_set_subdata_331_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3d >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_get_ref_count_332(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase3d >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase3d >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_get_ref_count_332_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_get_ref_count_332_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_get_node_ref_count_333(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase3d >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase3d >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_get_node_ref_count_333_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_get_node_ref_count_333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase3d >::PointerToArray(PointerToArray< LVecBase3d > const &copy)
 * PointerToArray< LVecBase3d >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase3d >::PointerToArray(TypeHandle type_handle = (_get_type_handle((LVecBase3d const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase3d >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase3d >::PointerToArray(PointerToArray< LVecBase3d > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase3d > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase3d, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase3d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< LVecBase3d >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LVecBase3d, false, false);
          PointerToArray< LVecBase3d > *result = new PointerToArray< LVecBase3d >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase3d > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase3d >::PointerToArray(PointerToArray< LVecBase3d > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase3d > param0_local;
          PointerToArray< LVecBase3d > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase3d(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase3d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< LVecBase3d >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase3d > *Dtool_Coerce_PointerToArray_LVecBase3d(PyObject *args, PointerToArray< LVecBase3d > &coerced) {
  PointerToArray< LVecBase3d > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_LVecBase3d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase3d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase3d >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< LVecBase3d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase3d >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase3d(&Dtool_PointerToArray_LVecBase3d._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_LVecBase3d) {
    printf("PointerToArray_LVecBase3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< LVecBase3d > *local_this = (PointerToArray< LVecBase3d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_LVecBase3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    return (PointerToArrayBase< LVecBase3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3d > > *)(PointerToArrayBase< LVecBase3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3d > > *)(PointerToArrayBase< LVecBase3d > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    PointerToArrayBase< LVecBase3d >* other_this = (PointerToArrayBase< LVecBase3d >*)from_this;
    return (PointerToArray< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    PointerToBase< ReferenceCountedVector< LVecBase3d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3d > >*)from_this;
    return (PointerToArray< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase3d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase3f >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase3f > PointerToArray< LVecBase3f >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((LVecBase3f const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_empty_array_339(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< LVecBase3f > PointerToArray< LVecBase3f >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(PointerToArray< LVecBase3f >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase3f, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< LVecBase3f > PointerToArray< LVecBase3f >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(PointerToArray< LVecBase3f >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_empty_array_339_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_empty_array_339_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3f >::push_back(LVecBase3f const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_push_back_341(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this, "PointerToArray_LVecBase3f.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3f >::push_back(LVecBase3f const &x)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase3f");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase3f x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_push_back_341_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase3f x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_push_back_341_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3f >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_pop_back_342(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this, "PointerToArray_LVecBase3f.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3f >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_pop_back_342_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_pop_back_342_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &PointerToArray< LVecBase3f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_get_element_343(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f const &PointerToArray< LVecBase3f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3f const *return_value = &((*(const PointerToArray< LVecBase3f >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_get_element_343_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_get_element_343_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3f >::set_element(unsigned long int n, LVecBase3f const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_set_element_344(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this, "PointerToArray_LVecBase3f.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3f >::set_element(unsigned long int n, LVecBase3f const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase3f");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase3f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_set_element_344_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase3f value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_set_element_344_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase3f >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_get_data_347(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase3f >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< LVecBase3f >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_get_data_347_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_get_data_347_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3f >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_set_data_348(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this, "PointerToArray_LVecBase3f.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3f >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_set_data_348_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_set_data_348_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase3f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_get_subdata_349(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase3f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< LVecBase3f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_get_subdata_349_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_get_subdata_349_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_set_subdata_350(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this, "PointerToArray_LVecBase3f.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_set_subdata_350_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_set_subdata_350_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3f >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_get_ref_count_351(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase3f >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase3f >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_get_ref_count_351_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_get_ref_count_351_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_get_node_ref_count_352(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase3f >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase3f >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_get_node_ref_count_352_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_get_node_ref_count_352_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase3f >::PointerToArray(PointerToArray< LVecBase3f > const &copy)
 * PointerToArray< LVecBase3f >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle = (_get_type_handle((LVecBase3f const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase3f >::PointerToArray(PointerToArray< LVecBase3f > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase3f > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase3f, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< LVecBase3f >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LVecBase3f, false, false);
          PointerToArray< LVecBase3f > *result = new PointerToArray< LVecBase3f >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase3f > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase3f >::PointerToArray(PointerToArray< LVecBase3f > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase3f > param0_local;
          PointerToArray< LVecBase3f > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase3f(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< LVecBase3f >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase3f > *Dtool_Coerce_PointerToArray_LVecBase3f(PyObject *args, PointerToArray< LVecBase3f > &coerced) {
  PointerToArray< LVecBase3f > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_LVecBase3f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase3f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< LVecBase3f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase3f >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase3f(&Dtool_PointerToArray_LVecBase3f._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_LVecBase3f) {
    printf("PointerToArray_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< LVecBase3f > *local_this = (PointerToArray< LVecBase3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_LVecBase3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    return (PointerToArrayBase< LVecBase3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3f > > *)(PointerToArrayBase< LVecBase3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3f > > *)(PointerToArrayBase< LVecBase3f > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    PointerToArrayBase< LVecBase3f >* other_this = (PointerToArrayBase< LVecBase3f >*)from_this;
    return (PointerToArray< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    PointerToBase< ReferenceCountedVector< LVecBase3f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)from_this;
    return (PointerToArray< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase3f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase3i >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase3i > PointerToArray< LVecBase3i >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((LVecBase3i const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_empty_array_358(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< LVecBase3i > PointerToArray< LVecBase3i >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >(PointerToArray< LVecBase3i >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase3i, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< LVecBase3i > PointerToArray< LVecBase3i >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >(PointerToArray< LVecBase3i >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase3i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_empty_array_358_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_empty_array_358_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3i >::push_back(LVecBase3i const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_push_back_360(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this, "PointerToArray_LVecBase3i.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3i >::push_back(LVecBase3i const &x)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase3i");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase3i x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_push_back_360_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase3i x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_push_back_360_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3i >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_pop_back_361(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this, "PointerToArray_LVecBase3i.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3i >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_pop_back_361_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_pop_back_361_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i const &PointerToArray< LVecBase3i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_get_element_362(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3i const &PointerToArray< LVecBase3i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3i const *return_value = &((*(const PointerToArray< LVecBase3i >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_get_element_362_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_get_element_362_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3i >::set_element(unsigned long int n, LVecBase3i const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_set_element_363(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this, "PointerToArray_LVecBase3i.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3i >::set_element(unsigned long int n, LVecBase3i const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase3i param2_local;
    LVecBase3i const *param2_this = Dtool_Coerce_LVecBase3i(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase3i");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase3i value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_set_element_363_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase3i value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_set_element_363_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase3i >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_get_data_366(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase3i >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< LVecBase3i >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_get_data_366_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_get_data_366_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3i >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_set_data_367(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this, "PointerToArray_LVecBase3i.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3i >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_set_data_367_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_set_data_367_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< LVecBase3i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_get_subdata_368(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< LVecBase3i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< LVecBase3i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_get_subdata_368_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_get_subdata_368_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_set_subdata_369(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this, "PointerToArray_LVecBase3i.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< LVecBase3i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_set_subdata_369_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_set_subdata_369_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3i >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_get_ref_count_370(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase3i >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase3i >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_get_ref_count_370_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_get_ref_count_370_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_get_node_ref_count_371(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< LVecBase3i >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< LVecBase3i >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_get_node_ref_count_371_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_get_node_ref_count_371_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase3i >::PointerToArray(PointerToArray< LVecBase3i > const &copy)
 * PointerToArray< LVecBase3i >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase3i >::PointerToArray(TypeHandle type_handle = (_get_type_handle((LVecBase3i const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase3i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase3i >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase3i >::PointerToArray(PointerToArray< LVecBase3i > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase3i > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_LVecBase3i, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase3i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< LVecBase3i >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LVecBase3i, false, false);
          PointerToArray< LVecBase3i > *result = new PointerToArray< LVecBase3i >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase3i > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase3i >::PointerToArray(PointerToArray< LVecBase3i > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< LVecBase3i > param0_local;
          PointerToArray< LVecBase3i > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase3i(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< LVecBase3i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< LVecBase3i >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase3i > *Dtool_Coerce_PointerToArray_LVecBase3i(PyObject *args, PointerToArray< LVecBase3i > &coerced) {
  PointerToArray< LVecBase3i > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_LVecBase3i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase3i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase3i >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< LVecBase3i >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase3i >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase3i(&Dtool_PointerToArray_LVecBase3i._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_LVecBase3i) {
    printf("PointerToArray_LVecBase3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< LVecBase3i > *local_this = (PointerToArray< LVecBase3i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_LVecBase3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    return (PointerToArrayBase< LVecBase3i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3i > > *)(PointerToArrayBase< LVecBase3i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3i > > *)(PointerToArrayBase< LVecBase3i > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    PointerToArrayBase< LVecBase3i >* other_this = (PointerToArrayBase< LVecBase3i >*)from_this;
    return (PointerToArray< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    PointerToBase< ReferenceCountedVector< LVecBase3i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3i > >*)from_this;
    return (PointerToArray< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase3i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< UnalignedLMatrix4d >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< UnalignedLMatrix4d > PointerToArray< UnalignedLMatrix4d >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((UnalignedLMatrix4d const *)(0))))
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_377(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< UnalignedLMatrix4d > PointerToArray< UnalignedLMatrix4d >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >(PointerToArray< UnalignedLMatrix4d >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4d, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< UnalignedLMatrix4d > PointerToArray< UnalignedLMatrix4d >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >(PointerToArray< UnalignedLMatrix4d >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_377_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_377_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4d >::push_back(UnalignedLMatrix4d const &x)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_push_back_379(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this, "PointerToArray_UnalignedLMatrix4d.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4d >::push_back(UnalignedLMatrix4d const &x)
  UnalignedLMatrix4d arg_local;
  UnalignedLMatrix4d const *arg_this = Dtool_Coerce_UnalignedLMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "UnalignedLMatrix4d");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const UnalignedLMatrix4d x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_push_back_379_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const UnalignedLMatrix4d x)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_push_back_379_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4d >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_380(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this, "PointerToArray_UnalignedLMatrix4d.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4d >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_380_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_380_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4d const &PointerToArray< UnalignedLMatrix4d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_get_element_381(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UnalignedLMatrix4d const &PointerToArray< UnalignedLMatrix4d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLMatrix4d const *return_value = &((*(const PointerToArray< UnalignedLMatrix4d >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_element_381_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_element_381_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4d >::set_element(unsigned long int n, UnalignedLMatrix4d const &value)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_set_element_382(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this, "PointerToArray_UnalignedLMatrix4d.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4d >::set_element(unsigned long int n, UnalignedLMatrix4d const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    UnalignedLMatrix4d param2_local;
    UnalignedLMatrix4d const *param2_this = Dtool_Coerce_UnalignedLMatrix4d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "UnalignedLMatrix4d");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const UnalignedLMatrix4d value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_element_382_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const UnalignedLMatrix4d value)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_element_382_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< UnalignedLMatrix4d >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_get_data_385(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< UnalignedLMatrix4d >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< UnalignedLMatrix4d >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_data_385_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_data_385_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4d >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_set_data_386(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this, "PointerToArray_UnalignedLMatrix4d.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4d >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_data_386_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_data_386_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< UnalignedLMatrix4d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_387(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< UnalignedLMatrix4d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< UnalignedLMatrix4d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_387_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_387_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_388(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this, "PointerToArray_UnalignedLMatrix4d.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_388_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_388_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLMatrix4d >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_389(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< UnalignedLMatrix4d >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< UnalignedLMatrix4d >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_389_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_389_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLMatrix4d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_390(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< UnalignedLMatrix4d >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< UnalignedLMatrix4d >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_390_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_390_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
 * PointerToArray< UnalignedLMatrix4d >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(TypeHandle type_handle = (_get_type_handle((UnalignedLMatrix4d const *)(0))))
 */
static int Dtool_Init_PointerToArray_UnalignedLMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(TypeHandle type_handle)
      PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< UnalignedLMatrix4d > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_UnalignedLMatrix4d, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< UnalignedLMatrix4d >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_UnalignedLMatrix4d, false, false);
          PointerToArray< UnalignedLMatrix4d > *result = new PointerToArray< UnalignedLMatrix4d >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< UnalignedLMatrix4d > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< UnalignedLMatrix4d > param0_local;
          PointerToArray< UnalignedLMatrix4d > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLMatrix4d(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< UnalignedLMatrix4d >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< UnalignedLMatrix4d > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4d(PyObject *args, PointerToArray< UnalignedLMatrix4d > &coerced) {
  PointerToArray< UnalignedLMatrix4d > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_UnalignedLMatrix4d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< UnalignedLMatrix4d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< UnalignedLMatrix4d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< UnalignedLMatrix4d >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_UnalignedLMatrix4d(&Dtool_PointerToArray_UnalignedLMatrix4d._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_UnalignedLMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_UnalignedLMatrix4d) {
    printf("PointerToArray_UnalignedLMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< UnalignedLMatrix4d > *local_this = (PointerToArray< UnalignedLMatrix4d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_UnalignedLMatrix4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    return (PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *)(PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *)(PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_UnalignedLMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_UnalignedLMatrix4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    PointerToArrayBase< UnalignedLMatrix4d >* other_this = (PointerToArrayBase< UnalignedLMatrix4d >*)from_this;
    return (PointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >*)from_this;
    return (PointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< UnalignedLMatrix4f >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< UnalignedLMatrix4f > PointerToArray< UnalignedLMatrix4f >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((UnalignedLMatrix4f const *)(0))))
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_396(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< UnalignedLMatrix4f > PointerToArray< UnalignedLMatrix4f >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >(PointerToArray< UnalignedLMatrix4f >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4f, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< UnalignedLMatrix4f > PointerToArray< UnalignedLMatrix4f >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >(PointerToArray< UnalignedLMatrix4f >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_396_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_396_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4f >::push_back(UnalignedLMatrix4f const &x)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_push_back_398(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this, "PointerToArray_UnalignedLMatrix4f.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4f >::push_back(UnalignedLMatrix4f const &x)
  UnalignedLMatrix4f arg_local;
  UnalignedLMatrix4f const *arg_this = Dtool_Coerce_UnalignedLMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "UnalignedLMatrix4f");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const UnalignedLMatrix4f x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_push_back_398_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const UnalignedLMatrix4f x)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_push_back_398_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4f >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_399(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this, "PointerToArray_UnalignedLMatrix4f.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4f >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_399_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_399_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4f const &PointerToArray< UnalignedLMatrix4f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_get_element_400(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UnalignedLMatrix4f const &PointerToArray< UnalignedLMatrix4f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLMatrix4f const *return_value = &((*(const PointerToArray< UnalignedLMatrix4f >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_element_400_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_element_400_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4f >::set_element(unsigned long int n, UnalignedLMatrix4f const &value)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_set_element_401(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this, "PointerToArray_UnalignedLMatrix4f.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4f >::set_element(unsigned long int n, UnalignedLMatrix4f const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    UnalignedLMatrix4f param2_local;
    UnalignedLMatrix4f const *param2_this = Dtool_Coerce_UnalignedLMatrix4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "UnalignedLMatrix4f");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const UnalignedLMatrix4f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_element_401_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const UnalignedLMatrix4f value)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_element_401_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< UnalignedLMatrix4f >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_get_data_404(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< UnalignedLMatrix4f >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< UnalignedLMatrix4f >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_data_404_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_data_404_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4f >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_set_data_405(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this, "PointerToArray_UnalignedLMatrix4f.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4f >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_data_405_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_data_405_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< UnalignedLMatrix4f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_406(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< UnalignedLMatrix4f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< UnalignedLMatrix4f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_406_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_406_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_407(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this, "PointerToArray_UnalignedLMatrix4f.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_407_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_407_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLMatrix4f >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_408(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< UnalignedLMatrix4f >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< UnalignedLMatrix4f >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_408_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_408_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLMatrix4f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_409(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< UnalignedLMatrix4f >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< UnalignedLMatrix4f >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_409_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_409_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
 * PointerToArray< UnalignedLMatrix4f >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(TypeHandle type_handle = (_get_type_handle((UnalignedLMatrix4f const *)(0))))
 */
static int Dtool_Init_PointerToArray_UnalignedLMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(TypeHandle type_handle)
      PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< UnalignedLMatrix4f > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_UnalignedLMatrix4f, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< UnalignedLMatrix4f >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_UnalignedLMatrix4f, false, false);
          PointerToArray< UnalignedLMatrix4f > *result = new PointerToArray< UnalignedLMatrix4f >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< UnalignedLMatrix4f > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< UnalignedLMatrix4f > param0_local;
          PointerToArray< UnalignedLMatrix4f > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< UnalignedLMatrix4f >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(PyObject *args, PointerToArray< UnalignedLMatrix4f > &coerced) {
  PointerToArray< UnalignedLMatrix4f > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_UnalignedLMatrix4f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< UnalignedLMatrix4f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< UnalignedLMatrix4f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< UnalignedLMatrix4f >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_UnalignedLMatrix4f(&Dtool_PointerToArray_UnalignedLMatrix4f._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_UnalignedLMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_UnalignedLMatrix4f) {
    printf("PointerToArray_UnalignedLMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< UnalignedLMatrix4f > *local_this = (PointerToArray< UnalignedLMatrix4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_UnalignedLMatrix4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    return (PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *)(PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *)(PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_UnalignedLMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_UnalignedLMatrix4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    PointerToArrayBase< UnalignedLMatrix4f >* other_this = (PointerToArrayBase< UnalignedLMatrix4f >*)from_this;
    return (PointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >*)from_this;
    return (PointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< UnalignedLVecBase4d >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< UnalignedLVecBase4d > PointerToArray< UnalignedLVecBase4d >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((UnalignedLVecBase4d const *)(0))))
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_415(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< UnalignedLVecBase4d > PointerToArray< UnalignedLVecBase4d >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >(PointerToArray< UnalignedLVecBase4d >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4d, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< UnalignedLVecBase4d > PointerToArray< UnalignedLVecBase4d >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >(PointerToArray< UnalignedLVecBase4d >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_415_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_415_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4d >::push_back(UnalignedLVecBase4d const &x)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_push_back_417(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this, "PointerToArray_UnalignedLVecBase4d.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4d >::push_back(UnalignedLVecBase4d const &x)
  UnalignedLVecBase4d arg_local;
  UnalignedLVecBase4d const *arg_this = Dtool_Coerce_UnalignedLVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "UnalignedLVecBase4d");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const UnalignedLVecBase4d x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_push_back_417_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const UnalignedLVecBase4d x)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_push_back_417_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4d >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_418(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this, "PointerToArray_UnalignedLVecBase4d.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4d >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_418_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_418_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4d const &PointerToArray< UnalignedLVecBase4d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_get_element_419(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UnalignedLVecBase4d const &PointerToArray< UnalignedLVecBase4d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4d const *return_value = &((*(const PointerToArray< UnalignedLVecBase4d >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_element_419_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_element_419_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4d >::set_element(unsigned long int n, UnalignedLVecBase4d const &value)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_set_element_420(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this, "PointerToArray_UnalignedLVecBase4d.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4d >::set_element(unsigned long int n, UnalignedLVecBase4d const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    UnalignedLVecBase4d param2_local;
    UnalignedLVecBase4d const *param2_this = Dtool_Coerce_UnalignedLVecBase4d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "UnalignedLVecBase4d");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const UnalignedLVecBase4d value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_element_420_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const UnalignedLVecBase4d value)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_element_420_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< UnalignedLVecBase4d >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_get_data_423(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< UnalignedLVecBase4d >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< UnalignedLVecBase4d >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_data_423_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_data_423_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4d >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_set_data_424(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this, "PointerToArray_UnalignedLVecBase4d.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4d >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_data_424_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_data_424_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< UnalignedLVecBase4d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_425(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< UnalignedLVecBase4d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< UnalignedLVecBase4d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_425_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_425_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_426(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this, "PointerToArray_UnalignedLVecBase4d.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_426_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_426_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4d >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_427(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4d >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< UnalignedLVecBase4d >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_427_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_427_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_428(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4d >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< UnalignedLVecBase4d >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_428_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_428_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
 * PointerToArray< UnalignedLVecBase4d >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(TypeHandle type_handle = (_get_type_handle((UnalignedLVecBase4d const *)(0))))
 */
static int Dtool_Init_PointerToArray_UnalignedLVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(TypeHandle type_handle)
      PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< UnalignedLVecBase4d > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_UnalignedLVecBase4d, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< UnalignedLVecBase4d >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_UnalignedLVecBase4d, false, false);
          PointerToArray< UnalignedLVecBase4d > *result = new PointerToArray< UnalignedLVecBase4d >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< UnalignedLVecBase4d > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< UnalignedLVecBase4d > param0_local;
          PointerToArray< UnalignedLVecBase4d > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4d(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< UnalignedLVecBase4d >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< UnalignedLVecBase4d > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4d(PyObject *args, PointerToArray< UnalignedLVecBase4d > &coerced) {
  PointerToArray< UnalignedLVecBase4d > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_UnalignedLVecBase4d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< UnalignedLVecBase4d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< UnalignedLVecBase4d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< UnalignedLVecBase4d >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_UnalignedLVecBase4d(&Dtool_PointerToArray_UnalignedLVecBase4d._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_UnalignedLVecBase4d) {
    printf("PointerToArray_UnalignedLVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< UnalignedLVecBase4d > *local_this = (PointerToArray< UnalignedLVecBase4d > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_UnalignedLVecBase4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    return (PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *)(PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *)(PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_UnalignedLVecBase4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    PointerToArrayBase< UnalignedLVecBase4d >* other_this = (PointerToArrayBase< UnalignedLVecBase4d >*)from_this;
    return (PointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >*)from_this;
    return (PointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< UnalignedLVecBase4f >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< UnalignedLVecBase4f > PointerToArray< UnalignedLVecBase4f >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((UnalignedLVecBase4f const *)(0))))
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_434(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< UnalignedLVecBase4f > PointerToArray< UnalignedLVecBase4f >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >(PointerToArray< UnalignedLVecBase4f >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4f, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< UnalignedLVecBase4f > PointerToArray< UnalignedLVecBase4f >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >(PointerToArray< UnalignedLVecBase4f >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_434_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_434_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4f >::push_back(UnalignedLVecBase4f const &x)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_push_back_436(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this, "PointerToArray_UnalignedLVecBase4f.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4f >::push_back(UnalignedLVecBase4f const &x)
  UnalignedLVecBase4f arg_local;
  UnalignedLVecBase4f const *arg_this = Dtool_Coerce_UnalignedLVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "UnalignedLVecBase4f");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const UnalignedLVecBase4f x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_push_back_436_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const UnalignedLVecBase4f x)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_push_back_436_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4f >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_437(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this, "PointerToArray_UnalignedLVecBase4f.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4f >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_437_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_437_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4f const &PointerToArray< UnalignedLVecBase4f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_get_element_438(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UnalignedLVecBase4f const &PointerToArray< UnalignedLVecBase4f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4f const *return_value = &((*(const PointerToArray< UnalignedLVecBase4f >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_element_438_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_element_438_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4f >::set_element(unsigned long int n, UnalignedLVecBase4f const &value)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_set_element_439(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this, "PointerToArray_UnalignedLVecBase4f.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4f >::set_element(unsigned long int n, UnalignedLVecBase4f const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    UnalignedLVecBase4f param2_local;
    UnalignedLVecBase4f const *param2_this = Dtool_Coerce_UnalignedLVecBase4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "UnalignedLVecBase4f");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const UnalignedLVecBase4f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_element_439_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const UnalignedLVecBase4f value)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_element_439_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< UnalignedLVecBase4f >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_get_data_442(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< UnalignedLVecBase4f >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< UnalignedLVecBase4f >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_data_442_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_data_442_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4f >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_set_data_443(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this, "PointerToArray_UnalignedLVecBase4f.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4f >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_data_443_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_data_443_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< UnalignedLVecBase4f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_444(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< UnalignedLVecBase4f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< UnalignedLVecBase4f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_444_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_444_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_445(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this, "PointerToArray_UnalignedLVecBase4f.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_445_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_445_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4f >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_446(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4f >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< UnalignedLVecBase4f >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_446_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_446_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_447(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4f >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< UnalignedLVecBase4f >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_447_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_447_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
 * PointerToArray< UnalignedLVecBase4f >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(TypeHandle type_handle = (_get_type_handle((UnalignedLVecBase4f const *)(0))))
 */
static int Dtool_Init_PointerToArray_UnalignedLVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(TypeHandle type_handle)
      PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< UnalignedLVecBase4f > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_UnalignedLVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< UnalignedLVecBase4f >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_UnalignedLVecBase4f, false, false);
          PointerToArray< UnalignedLVecBase4f > *result = new PointerToArray< UnalignedLVecBase4f >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< UnalignedLVecBase4f > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< UnalignedLVecBase4f > param0_local;
          PointerToArray< UnalignedLVecBase4f > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< UnalignedLVecBase4f >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< UnalignedLVecBase4f > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4f(PyObject *args, PointerToArray< UnalignedLVecBase4f > &coerced) {
  PointerToArray< UnalignedLVecBase4f > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_UnalignedLVecBase4f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< UnalignedLVecBase4f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< UnalignedLVecBase4f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< UnalignedLVecBase4f >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_UnalignedLVecBase4f(&Dtool_PointerToArray_UnalignedLVecBase4f._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_UnalignedLVecBase4f) {
    printf("PointerToArray_UnalignedLVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< UnalignedLVecBase4f > *local_this = (PointerToArray< UnalignedLVecBase4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_UnalignedLVecBase4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    return (PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *)(PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *)(PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_UnalignedLVecBase4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    PointerToArrayBase< UnalignedLVecBase4f >* other_this = (PointerToArrayBase< UnalignedLVecBase4f >*)from_this;
    return (PointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >*)from_this;
    return (PointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< UnalignedLVecBase4i >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< UnalignedLVecBase4i > PointerToArray< UnalignedLVecBase4i >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((UnalignedLVecBase4i const *)(0))))
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_453(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< UnalignedLVecBase4i > PointerToArray< UnalignedLVecBase4i >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >(PointerToArray< UnalignedLVecBase4i >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4i, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< UnalignedLVecBase4i > PointerToArray< UnalignedLVecBase4i >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >(PointerToArray< UnalignedLVecBase4i >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_453_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_453_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4i >::push_back(UnalignedLVecBase4i const &x)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_push_back_455(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this, "PointerToArray_UnalignedLVecBase4i.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4i >::push_back(UnalignedLVecBase4i const &x)
  UnalignedLVecBase4i arg_local;
  UnalignedLVecBase4i const *arg_this = Dtool_Coerce_UnalignedLVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "UnalignedLVecBase4i");
  }
  (*local_this).push_back(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const UnalignedLVecBase4i x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_push_back_455_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const UnalignedLVecBase4i x)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_push_back_455_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4i >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_456(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this, "PointerToArray_UnalignedLVecBase4i.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4i >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_456_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_456_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4i const &PointerToArray< UnalignedLVecBase4i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_get_element_457(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UnalignedLVecBase4i const &PointerToArray< UnalignedLVecBase4i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4i const *return_value = &((*(const PointerToArray< UnalignedLVecBase4i >*)local_this).get_element((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_element_457_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_element_457_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4i >::set_element(unsigned long int n, UnalignedLVecBase4i const &value)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_set_element_458(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this, "PointerToArray_UnalignedLVecBase4i.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4i >::set_element(unsigned long int n, UnalignedLVecBase4i const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    UnalignedLVecBase4i param2_local;
    UnalignedLVecBase4i const *param2_this = Dtool_Coerce_UnalignedLVecBase4i(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "UnalignedLVecBase4i");
    }
    (*local_this).set_element((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const UnalignedLVecBase4i value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_element_458_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const UnalignedLVecBase4i value)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_element_458_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< UnalignedLVecBase4i >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_get_data_461(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< UnalignedLVecBase4i >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< UnalignedLVecBase4i >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_data_461_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_data_461_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4i >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_set_data_462(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this, "PointerToArray_UnalignedLVecBase4i.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4i >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_data_462_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_data_462_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< UnalignedLVecBase4i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_463(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< UnalignedLVecBase4i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< UnalignedLVecBase4i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_463_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_463_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_464(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this, "PointerToArray_UnalignedLVecBase4i.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_464_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_464_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4i >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_465(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4i >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< UnalignedLVecBase4i >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_465_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_465_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_466(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4i >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< UnalignedLVecBase4i >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_466_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_466_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
 * PointerToArray< UnalignedLVecBase4i >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(TypeHandle type_handle = (_get_type_handle((UnalignedLVecBase4i const *)(0))))
 */
static int Dtool_Init_PointerToArray_UnalignedLVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(TypeHandle type_handle)
      PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< UnalignedLVecBase4i > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_UnalignedLVecBase4i, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< UnalignedLVecBase4i >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_UnalignedLVecBase4i, false, false);
          PointerToArray< UnalignedLVecBase4i > *result = new PointerToArray< UnalignedLVecBase4i >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< UnalignedLVecBase4i > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< UnalignedLVecBase4i > param0_local;
          PointerToArray< UnalignedLVecBase4i > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4i(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< UnalignedLVecBase4i >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< UnalignedLVecBase4i > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4i(PyObject *args, PointerToArray< UnalignedLVecBase4i > &coerced) {
  PointerToArray< UnalignedLVecBase4i > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_UnalignedLVecBase4i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< UnalignedLVecBase4i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< UnalignedLVecBase4i >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< UnalignedLVecBase4i >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_UnalignedLVecBase4i(&Dtool_PointerToArray_UnalignedLVecBase4i._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_UnalignedLVecBase4i) {
    printf("PointerToArray_UnalignedLVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< UnalignedLVecBase4i > *local_this = (PointerToArray< UnalignedLVecBase4i > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_UnalignedLVecBase4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    return (PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *)(PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *)(PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_UnalignedLVecBase4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    PointerToArrayBase< UnalignedLVecBase4i >* other_this = (PointerToArrayBase< UnalignedLVecBase4i >*)from_this;
    return (PointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >*)from_this;
    return (PointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BoundingVolume
 */
/**
 * Python function wrapper for:
 * virtual BoundingVolume *BoundingVolume::make_copy(void) const = 0
 */
static PyObject *Dtool_BoundingVolume_make_copy_472(PyObject *self, PyObject *) {
  BoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual BoundingVolume *BoundingVolume::make_copy(void) const = 0
  BoundingVolume *return_value = (*(const BoundingVolume*)local_this).make_copy();
  if (return_value != (BoundingVolume *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (BoundingVolume *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BoundingVolume, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_make_copy_472_comment =
  "C++ Interface:\n"
  "make_copy(BoundingVolume self)\n";
#else
static const char *Dtool_BoundingVolume_make_copy_472_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BoundingVolume::is_empty(void) const
 */
static PyObject *Dtool_BoundingVolume_is_empty_473(PyObject *self, PyObject *) {
  BoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BoundingVolume::is_empty(void) const
  bool return_value = (*(const BoundingVolume*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_is_empty_473_comment =
  "C++ Interface:\n"
  "is_empty(BoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Any kind of volume might be empty.  This is a degenerate volume that\n"
  " * contains no points; it's not the same as, for instance, a sphere with\n"
  " * radius zero, since that contains one point (the center).  It intersects\n"
  " * with no other volumes.\n"
  " */";
#else
static const char *Dtool_BoundingVolume_is_empty_473_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BoundingVolume::is_infinite(void) const
 */
static PyObject *Dtool_BoundingVolume_is_infinite_474(PyObject *self, PyObject *) {
  BoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool BoundingVolume::is_infinite(void) const
  bool return_value = (*(const BoundingVolume*)local_this).is_infinite();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_is_infinite_474_comment =
  "C++ Interface:\n"
  "is_infinite(BoundingVolume self)\n"
  "\n"
  "/**\n"
  " * The other side of the empty coin is an infinite volume.  This is a\n"
  " * degenerate state of a normally finite volume that contains all points.\n"
  " * (Note that some kinds of infinite bounding volumes, like binary separating\n"
  " * planes, do not contain all points and thus correctly return is_infinite()\n"
  " * == false, even though they are technically infinite.  This is a special\n"
  " * case of the word 'infinite' meaning the volume covers all points in space.)\n"
  " *\n"
  " * It completely intersects with all other volumes except empty volumes.\n"
  " */";
#else
static const char *Dtool_BoundingVolume_is_infinite_474_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BoundingVolume::set_infinite(void)
 */
static PyObject *Dtool_BoundingVolume_set_infinite_475(PyObject *self, PyObject *) {
  BoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingVolume, (void **)&local_this, "BoundingVolume.set_infinite")) {
    return NULL;
  }
  // 1-inline void BoundingVolume::set_infinite(void)
  (*local_this).set_infinite();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_set_infinite_475_comment =
  "C++ Interface:\n"
  "set_infinite(const BoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Marks the volume as infinite, even if it is normally finite.  You can think\n"
  " * of this as an infinite extend_by() operation.\n"
  " */";
#else
static const char *Dtool_BoundingVolume_set_infinite_475_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool BoundingVolume::extend_by(BoundingVolume const *vol)
 */
static PyObject *Dtool_BoundingVolume_extend_by_476(PyObject *self, PyObject *arg) {
  BoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingVolume, (void **)&local_this, "BoundingVolume.extend_by")) {
    return NULL;
  }
  // 1-inline bool BoundingVolume::extend_by(BoundingVolume const *vol)
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "BoundingVolume.extend_by", true, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).extend_by(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extend_by(const BoundingVolume self, const BoundingVolume vol)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_extend_by_476_comment =
  "C++ Interface:\n"
  "extend_by(const BoundingVolume self, const BoundingVolume vol)\n"
  "\n"
  "/**\n"
  " * Increases the size of the volume to include the given volume.\n"
  " */";
#else
static const char *Dtool_BoundingVolume_extend_by_476_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BoundingVolume::contains(BoundingVolume const *vol) const
 */
static PyObject *Dtool_BoundingVolume_contains_478(PyObject *self, PyObject *arg) {
  BoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BoundingVolume::contains(BoundingVolume const *vol) const
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "BoundingVolume.contains", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const BoundingVolume*)local_this).contains(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "contains(BoundingVolume self, const BoundingVolume vol)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_contains_478_comment =
  "C++ Interface:\n"
  "contains(BoundingVolume self, const BoundingVolume vol)\n"
  "\n"
  "/**\n"
  " * Returns the appropriate set of IntersectionFlags to indicate the amount of\n"
  " * intersection with the indicated volume.\n"
  " */";
#else
static const char *Dtool_BoundingVolume_contains_478_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BoundingVolume::output(ostream &out) const = 0
 */
static PyObject *Dtool_BoundingVolume_output_479(PyObject *self, PyObject *arg) {
  BoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BoundingVolume::output(ostream &out) const = 0
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "BoundingVolume.output", false, true);
  if (arg_this != NULL) {
    (*(const BoundingVolume*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BoundingVolume self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_output_479_comment =
  "C++ Interface:\n"
  "output(BoundingVolume self, ostream out)\n";
#else
static const char *Dtool_BoundingVolume_output_479_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void BoundingVolume::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BoundingVolume_write_480(PyObject *self, PyObject *args, PyObject *kwds) {
  BoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void BoundingVolume::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "BoundingVolume.write", false, true);
    if (param1_this != NULL) {
      (*(const BoundingVolume*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BoundingVolume self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_write_480_comment =
  "C++ Interface:\n"
  "write(BoundingVolume self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BoundingVolume_write_480_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_BoundingVolume_get_class_type_482(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BoundingVolume::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_get_class_type_482_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingVolume_get_class_type_482_comment = NULL;
#endif

static int Dtool_Init_BoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BoundingVolume) {
    printf("BoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BoundingVolume *local_this = (BoundingVolume *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingVolume*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class GeometricBoundingVolume
 */
/**
 * Python function wrapper for:
 * inline bool GeometricBoundingVolume::extend_by(GeometricBoundingVolume const *vol)
 * inline bool GeometricBoundingVolume::extend_by(LPoint3 const &point)
 */
static PyObject *Dtool_GeometricBoundingVolume_extend_by_485(PyObject *self, PyObject *arg) {
  GeometricBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeometricBoundingVolume, (void **)&local_this, "GeometricBoundingVolume.extend_by")) {
    return NULL;
  }
  {
    // -2 inline bool GeometricBoundingVolume::extend_by(GeometricBoundingVolume const *vol)
    GeometricBoundingVolume const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_GeometricBoundingVolume, (void **)&arg_this);
    if (arg_this != NULL) {
      bool return_value = (*local_this).extend_by(arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: inline bool GeometricBoundingVolume::extend_by(GeometricBoundingVolume const *vol)
  {
    // -2 inline bool GeometricBoundingVolume::extend_by(LPoint3 const &point)
    LPoint3f arg_local;
    LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
    if ((arg_this != NULL)) {
      bool return_value = (*local_this).extend_by(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extend_by(const GeometricBoundingVolume self, const GeometricBoundingVolume vol)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeometricBoundingVolume_extend_by_485_comment =
  "C++ Interface:\n"
  "extend_by(const GeometricBoundingVolume self, const GeometricBoundingVolume vol)\n"
  "\n"
  "/**\n"
  " * Increases the size of the volume to include the given volume.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Increases the size of the volume to include the given point.\n"
  " */";
#else
static const char *Dtool_GeometricBoundingVolume_extend_by_485_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int GeometricBoundingVolume::contains(GeometricBoundingVolume const *vol) const
 * inline int GeometricBoundingVolume::contains(LPoint3 const &point) const
 * inline int GeometricBoundingVolume::contains(LPoint3 const &a, LPoint3 const &b) const
 */
static PyObject *Dtool_GeometricBoundingVolume_contains_486(PyObject *self, PyObject *args, PyObject *kwds) {
  GeometricBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeometricBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline int GeometricBoundingVolume::contains(GeometricBoundingVolume const *vol) const
        PyObject *param1;
        static const char *keyword_list[] = {"vol", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:contains", (char **)keyword_list, &param1)) {
          GeometricBoundingVolume const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_GeometricBoundingVolume, (void **)&param1_this);
          if (param1_this != NULL) {
            int return_value = (*(const GeometricBoundingVolume*)local_this).contains(param1_this);
            if (Dtool_CheckErrorOccurred()) {
              return NULL;
            }
            return Dtool_WrapValue(return_value);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline int GeometricBoundingVolume::contains(GeometricBoundingVolume const *vol) const
      {
        // -2 inline int GeometricBoundingVolume::contains(LPoint3 const &point) const
        PyObject *param1;
        static const char *keyword_list[] = {"point", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:contains", (char **)keyword_list, &param1)) {
          LPoint3f param1_local;
          LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
          if ((param1_this != NULL)) {
            int return_value = (*(const GeometricBoundingVolume*)local_this).contains(*param1_this);
            if (Dtool_CheckErrorOccurred()) {
              return NULL;
            }
            return Dtool_WrapValue(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline int GeometricBoundingVolume::contains(LPoint3 const &a, LPoint3 const &b) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:contains", (char **)keyword_list, &param1, &param2)) {
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "GeometricBoundingVolume.contains", "LPoint3f");
        }
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "GeometricBoundingVolume.contains", "LPoint3f");
        }
        int return_value = (*(const GeometricBoundingVolume*)local_this).contains(*param1_this, *param2_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "contains() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "contains(GeometricBoundingVolume self, const GeometricBoundingVolume vol)\n"
      "contains(GeometricBoundingVolume self, const LPoint3f a, const LPoint3f b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeometricBoundingVolume_contains_486_comment =
  "C++ Interface:\n"
  "contains(GeometricBoundingVolume self, const GeometricBoundingVolume vol)\n"
  "contains(GeometricBoundingVolume self, const LPoint3f a, const LPoint3f b)\n"
  "\n"
  "/**\n"
  " * Returns the appropriate set of IntersectionFlags to indicate the amount of\n"
  " * intersection with the indicated volume.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the appropriate set of IntersectionFlags to indicate the amount of\n"
  " * intersection with the indicated point.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the appropriate set of IntersectionFlags to indicate the amount of\n"
  " * intersection with the indicated line segment.\n"
  " */";
#else
static const char *Dtool_GeometricBoundingVolume_contains_486_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual LPoint3 GeometricBoundingVolume::get_approx_center(void) const = 0
 */
static PyObject *Dtool_GeometricBoundingVolume_get_approx_center_487(PyObject *self, PyObject *) {
  GeometricBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GeometricBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual LPoint3 GeometricBoundingVolume::get_approx_center(void) const = 0
  LPoint3 *return_value = new LPoint3((*(const GeometricBoundingVolume*)local_this).get_approx_center());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeometricBoundingVolume_get_approx_center_487_comment =
  "C++ Interface:\n"
  "get_approx_center(GeometricBoundingVolume self)\n";
#else
static const char *Dtool_GeometricBoundingVolume_get_approx_center_487_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void GeometricBoundingVolume::xform(LMatrix4 const &mat) = 0
 */
static PyObject *Dtool_GeometricBoundingVolume_xform_488(PyObject *self, PyObject *arg) {
  GeometricBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeometricBoundingVolume, (void **)&local_this, "GeometricBoundingVolume.xform")) {
    return NULL;
  }
  // 1-virtual void GeometricBoundingVolume::xform(LMatrix4 const &mat) = 0
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeometricBoundingVolume.xform", "LMatrix4f");
  }
  (*local_this).xform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const GeometricBoundingVolume self, const LMatrix4f mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GeometricBoundingVolume_xform_488_comment =
  "C++ Interface:\n"
  "xform(const GeometricBoundingVolume self, const LMatrix4f mat)\n";
#else
static const char *Dtool_GeometricBoundingVolume_xform_488_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeometricBoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_GeometricBoundingVolume_get_class_type_489(PyObject *, PyObject *) {
  // 1-static TypeHandle GeometricBoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(GeometricBoundingVolume::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeometricBoundingVolume_get_class_type_489_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeometricBoundingVolume_get_class_type_489_comment = NULL;
#endif

static int Dtool_Init_GeometricBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GeometricBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_GeometricBoundingVolume) {
    printf("GeometricBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  GeometricBoundingVolume *local_this = (GeometricBoundingVolume *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_GeometricBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (GeometricBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeometricBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeometricBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (GeometricBoundingVolume*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class FiniteBoundingVolume
 */
/**
 * Python function wrapper for:
 * virtual LPoint3 FiniteBoundingVolume::get_min(void) const = 0
 */
static PyObject *Dtool_FiniteBoundingVolume_get_min_492(PyObject *self, PyObject *) {
  FiniteBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FiniteBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual LPoint3 FiniteBoundingVolume::get_min(void) const = 0
  LPoint3 *return_value = new LPoint3((*(const FiniteBoundingVolume*)local_this).get_min());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FiniteBoundingVolume_get_min_492_comment =
  "C++ Interface:\n"
  "get_min(FiniteBoundingVolume self)\n";
#else
static const char *Dtool_FiniteBoundingVolume_get_min_492_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual LPoint3 FiniteBoundingVolume::get_max(void) const = 0
 */
static PyObject *Dtool_FiniteBoundingVolume_get_max_493(PyObject *self, PyObject *) {
  FiniteBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FiniteBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual LPoint3 FiniteBoundingVolume::get_max(void) const = 0
  LPoint3 *return_value = new LPoint3((*(const FiniteBoundingVolume*)local_this).get_max());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FiniteBoundingVolume_get_max_493_comment =
  "C++ Interface:\n"
  "get_max(FiniteBoundingVolume self)\n";
#else
static const char *Dtool_FiniteBoundingVolume_get_max_493_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat FiniteBoundingVolume::get_volume(void) const
 */
static PyObject *Dtool_FiniteBoundingVolume_get_volume_494(PyObject *self, PyObject *) {
  FiniteBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FiniteBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat FiniteBoundingVolume::get_volume(void) const
  PN_stdfloat return_value = (*(const FiniteBoundingVolume*)local_this).get_volume();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FiniteBoundingVolume_get_volume_494_comment =
  "C++ Interface:\n"
  "get_volume(FiniteBoundingVolume self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FiniteBoundingVolume_get_volume_494_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle FiniteBoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_FiniteBoundingVolume_get_class_type_495(PyObject *, PyObject *) {
  // 1-static TypeHandle FiniteBoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(FiniteBoundingVolume::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FiniteBoundingVolume_get_class_type_495_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FiniteBoundingVolume_get_class_type_495_comment = NULL;
#endif

static int Dtool_Init_FiniteBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_FiniteBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_FiniteBoundingVolume) {
    printf("FiniteBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  FiniteBoundingVolume *local_this = (FiniteBoundingVolume *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_FiniteBoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_FiniteBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_FiniteBoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (FiniteBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (FiniteBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FiniteBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FiniteBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (FiniteBoundingVolume*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LParabolaf
 */
/**
 * Python function wrapper for:
 * inline void LParabolaf::operator =(LParabolaf const &copy)
 */
static PyObject *Dtool_LParabolaf_operator_499(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolaf, (void **)&local_this, "LParabolaf.assign")) {
    return NULL;
  }
  // 1-inline void LParabolaf::operator =(LParabolaf const &copy)
  LParabolaf arg_local;
  LParabolaf const *arg_this = Dtool_Coerce_LParabolaf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.assign", "LParabolaf");
  }
  (*local_this).operator =(*arg_this);
  LParabolaf *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LParabolaf, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LParabolaf self, const LParabolaf copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_operator_499_comment =
  "C++ Interface:\n"
  "assign(const LParabolaf self, const LParabolaf copy)\n";
#else
static const char *Dtool_LParabolaf_operator_499_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::xform(LMatrix4f const &mat)
 */
static PyObject *Dtool_LParabolaf_xform_501(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolaf, (void **)&local_this, "LParabolaf.xform")) {
    return NULL;
  }
  // 1-void LParabolaf::xform(LMatrix4f const &mat)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.xform", "LMatrix4f");
  }
  (*local_this).xform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const LParabolaf self, const LMatrix4f mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_xform_501_comment =
  "C++ Interface:\n"
  "xform(const LParabolaf self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Transforms the parabola by the indicated matrix.\n"
  " */";
#else
static const char *Dtool_LParabolaf_xform_501_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &LParabolaf::get_a(void) const
 */
static PyObject *Dtool_LParabolaf_get_a_502(PyObject *self, PyObject *) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f const &LParabolaf::get_a(void) const
  LVecBase3f const *return_value = &((*(const LParabolaf*)local_this).get_a());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_get_a_502_comment =
  "C++ Interface:\n"
  "get_a(LParabolaf self)\n"
  "\n"
  "/**\n"
  " * Returns the first point of the parabola's parametric equation: the\n"
  " * acceleration.\n"
  " */";
#else
static const char *Dtool_LParabolaf_get_a_502_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &LParabolaf::get_b(void) const
 */
static PyObject *Dtool_LParabolaf_get_b_503(PyObject *self, PyObject *) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f const &LParabolaf::get_b(void) const
  LVecBase3f const *return_value = &((*(const LParabolaf*)local_this).get_b());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_get_b_503_comment =
  "C++ Interface:\n"
  "get_b(LParabolaf self)\n"
  "\n"
  "/**\n"
  " * Returns the second point of the parabola's parametric equation: the initial\n"
  " * velocity.\n"
  " */";
#else
static const char *Dtool_LParabolaf_get_b_503_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &LParabolaf::get_c(void) const
 */
static PyObject *Dtool_LParabolaf_get_c_504(PyObject *self, PyObject *) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f const &LParabolaf::get_c(void) const
  LVecBase3f const *return_value = &((*(const LParabolaf*)local_this).get_c());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_get_c_504_comment =
  "C++ Interface:\n"
  "get_c(LParabolaf self)\n"
  "\n"
  "/**\n"
  " * Returns the third point of the parabola's parametric equation: the start\n"
  " * point.\n"
  " */";
#else
static const char *Dtool_LParabolaf_get_c_504_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f LParabolaf::calc_point(float t) const
 */
static PyObject *Dtool_LParabolaf_calc_point_505(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f LParabolaf::calc_point(float t) const
  if (PyNumber_Check(arg)) {
    LPoint3f *return_value = new LPoint3f((*(const LParabolaf*)local_this).calc_point((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_point(LParabolaf self, float t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_calc_point_505_comment =
  "C++ Interface:\n"
  "calc_point(LParabolaf self, float t)\n"
  "\n"
  "/**\n"
  " * Computes the point on the parabola at time t.\n"
  " */";
#else
static const char *Dtool_LParabolaf_calc_point_505_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::output(ostream &out) const
 */
static PyObject *Dtool_LParabolaf_output_506(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LParabolaf::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LParabolaf.output", false, true);
  if (arg_this != NULL) {
    (*(const LParabolaf*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LParabolaf self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_output_506_comment =
  "C++ Interface:\n"
  "output(LParabolaf self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LParabolaf_output_506_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LParabolaf_write_507(PyObject *self, PyObject *args, PyObject *kwds) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LParabolaf::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "LParabolaf.write", false, true);
    if (param1_this != NULL) {
      (*(const LParabolaf*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LParabolaf self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_write_507_comment =
  "C++ Interface:\n"
  "write(LParabolaf self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LParabolaf_write_507_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LParabolaf_write_datagram_fixed_508(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LParabolaf::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.write_datagram_fixed", "Datagram");
  }
  (*(const LParabolaf*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LParabolaf self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_write_datagram_fixed_508_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LParabolaf self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the parabola to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the parabola, regardless of the setting\n"
  " * of Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LParabolaf_write_datagram_fixed_508_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LParabolaf_read_datagram_fixed_509(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolaf, (void **)&local_this, "LParabolaf.read_datagram_fixed")) {
    return NULL;
  }
  // 1-void LParabolaf::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LParabolaf self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_read_datagram_fixed_509_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LParabolaf self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the parabola from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LParabolaf_read_datagram_fixed_509_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LParabolaf_write_datagram_510(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LParabolaf::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.write_datagram", "Datagram");
  }
  (*(const LParabolaf*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LParabolaf self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_write_datagram_510_comment =
  "C++ Interface:\n"
  "write_datagram(LParabolaf self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the parabola to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LParabolaf_write_datagram_510_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LParabolaf_read_datagram_511(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolaf, (void **)&local_this, "LParabolaf.read_datagram")) {
    return NULL;
  }
  // 1-void LParabolaf::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LParabolaf self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_read_datagram_511_comment =
  "C++ Interface:\n"
  "read_datagram(const LParabolaf self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the parabola from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LParabolaf_read_datagram_511_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LParabolaf::LParabolaf(void)
 * inline LParabolaf::LParabolaf(LParabolaf const &copy)
 * inline LParabolaf::LParabolaf(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c)
 */
static int Dtool_Init_LParabolaf(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LParabolaf::LParabolaf(void)
      LParabolaf *return_value = new LParabolaf();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolaf, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline LParabolaf::LParabolaf(LParabolaf const &copy)
      LParabolaf arg_local;
      LParabolaf const *arg_this = Dtool_Coerce_LParabolaf(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 0, "LParabolaf.LParabolaf", "LParabolaf");
        return -1;
      }
      LParabolaf *return_value = new LParabolaf(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolaf, true, false);
    }
    break;
  case 3:
    {
      // 1-inline LParabolaf::LParabolaf(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:LParabolaf", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3f param0_local;
        LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LParabolaf.LParabolaf", "LVecBase3f");
          return -1;
        }
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LParabolaf.LParabolaf", "LVecBase3f");
          return -1;
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          Dtool_Raise_ArgTypeError(param2, 2, "LParabolaf.LParabolaf", "LVecBase3f");
          return -1;
        }
        LParabolaf *return_value = new LParabolaf(*param0_this, *param1_this, *param2_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolaf, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LParabolaf() takes 0, 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LParabolaf()\n"
      "LParabolaf(const LParabolaf copy)\n"
      "LParabolaf(const LVecBase3f a, const LVecBase3f b, const LVecBase3f c)\n");
  }
  return -1;
}

LParabolaf *Dtool_Coerce_LParabolaf(PyObject *args, LParabolaf &coerced) {
  LParabolaf *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LParabolaf, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LParabolaf *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline LParabolaf::LParabolaf(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      if (PyArg_UnpackTuple(args, "LParabolaf", 3, 3, &param0, &param1, &param2)) {
        LVecBase3f const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
        LVecBase3f const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
        LVecBase3f const *param2_this;
        DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
        if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
          coerced = LParabolaf(*param0_this, *param1_this, *param2_this);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LParabolaf(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LParabolaf) {
    printf("LParabolaf ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LParabolaf *local_this = (LParabolaf *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LParabolaf) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LParabolaf(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LParabolaf) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LParabolad
 */
/**
 * Python function wrapper for:
 * inline void LParabolad::operator =(LParabolad const &copy)
 */
static PyObject *Dtool_LParabolad_operator_514(PyObject *self, PyObject *arg) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolad, (void **)&local_this, "LParabolad.assign")) {
    return NULL;
  }
  // 1-inline void LParabolad::operator =(LParabolad const &copy)
  LParabolad arg_local;
  LParabolad const *arg_this = Dtool_Coerce_LParabolad(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.assign", "LParabolad");
  }
  (*local_this).operator =(*arg_this);
  LParabolad *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LParabolad, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LParabolad self, const LParabolad copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_operator_514_comment =
  "C++ Interface:\n"
  "assign(const LParabolad self, const LParabolad copy)\n";
#else
static const char *Dtool_LParabolad_operator_514_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::xform(LMatrix4d const &mat)
 */
static PyObject *Dtool_LParabolad_xform_516(PyObject *self, PyObject *arg) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolad, (void **)&local_this, "LParabolad.xform")) {
    return NULL;
  }
  // 1-void LParabolad::xform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.xform", "LMatrix4d");
  }
  (*local_this).xform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const LParabolad self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_xform_516_comment =
  "C++ Interface:\n"
  "xform(const LParabolad self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Transforms the parabola by the indicated matrix.\n"
  " */";
#else
static const char *Dtool_LParabolad_xform_516_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &LParabolad::get_a(void) const
 */
static PyObject *Dtool_LParabolad_get_a_517(PyObject *self, PyObject *) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d const &LParabolad::get_a(void) const
  LVecBase3d const *return_value = &((*(const LParabolad*)local_this).get_a());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_get_a_517_comment =
  "C++ Interface:\n"
  "get_a(LParabolad self)\n"
  "\n"
  "/**\n"
  " * Returns the first point of the parabola's parametric equation: the\n"
  " * acceleration.\n"
  " */";
#else
static const char *Dtool_LParabolad_get_a_517_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &LParabolad::get_b(void) const
 */
static PyObject *Dtool_LParabolad_get_b_518(PyObject *self, PyObject *) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d const &LParabolad::get_b(void) const
  LVecBase3d const *return_value = &((*(const LParabolad*)local_this).get_b());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_get_b_518_comment =
  "C++ Interface:\n"
  "get_b(LParabolad self)\n"
  "\n"
  "/**\n"
  " * Returns the second point of the parabola's parametric equation: the initial\n"
  " * velocity.\n"
  " */";
#else
static const char *Dtool_LParabolad_get_b_518_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &LParabolad::get_c(void) const
 */
static PyObject *Dtool_LParabolad_get_c_519(PyObject *self, PyObject *) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d const &LParabolad::get_c(void) const
  LVecBase3d const *return_value = &((*(const LParabolad*)local_this).get_c());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_get_c_519_comment =
  "C++ Interface:\n"
  "get_c(LParabolad self)\n"
  "\n"
  "/**\n"
  " * Returns the third point of the parabola's parametric equation: the start\n"
  " * point.\n"
  " */";
#else
static const char *Dtool_LParabolad_get_c_519_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d LParabolad::calc_point(double t) const
 */
static PyObject *Dtool_LParabolad_calc_point_520(PyObject *self, PyObject *arg) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3d LParabolad::calc_point(double t) const
  if (PyNumber_Check(arg)) {
    LPoint3d *return_value = new LPoint3d((*(const LParabolad*)local_this).calc_point(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_point(LParabolad self, double t)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_calc_point_520_comment =
  "C++ Interface:\n"
  "calc_point(LParabolad self, double t)\n"
  "\n"
  "/**\n"
  " * Computes the point on the parabola at time t.\n"
  " */";
#else
static const char *Dtool_LParabolad_calc_point_520_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::output(ostream &out) const
 */
static PyObject *Dtool_LParabolad_output_521(PyObject *self, PyObject *arg) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LParabolad::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LParabolad.output", false, true);
  if (arg_this != NULL) {
    (*(const LParabolad*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LParabolad self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_output_521_comment =
  "C++ Interface:\n"
  "output(LParabolad self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LParabolad_output_521_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LParabolad_write_522(PyObject *self, PyObject *args, PyObject *kwds) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LParabolad::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "LParabolad.write", false, true);
    if (param1_this != NULL) {
      (*(const LParabolad*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LParabolad self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_write_522_comment =
  "C++ Interface:\n"
  "write(LParabolad self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LParabolad_write_522_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LParabolad_write_datagram_fixed_523(PyObject *self, PyObject *arg) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LParabolad::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.write_datagram_fixed", "Datagram");
  }
  (*(const LParabolad*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LParabolad self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_write_datagram_fixed_523_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LParabolad self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the parabola to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the parabola, regardless of the setting\n"
  " * of Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LParabolad_write_datagram_fixed_523_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LParabolad_read_datagram_fixed_524(PyObject *self, PyObject *arg) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolad, (void **)&local_this, "LParabolad.read_datagram_fixed")) {
    return NULL;
  }
  // 1-void LParabolad::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LParabolad self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_read_datagram_fixed_524_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LParabolad self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the parabola from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LParabolad_read_datagram_fixed_524_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LParabolad_write_datagram_525(PyObject *self, PyObject *arg) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LParabolad::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.write_datagram", "Datagram");
  }
  (*(const LParabolad*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LParabolad self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_write_datagram_525_comment =
  "C++ Interface:\n"
  "write_datagram(LParabolad self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the parabola to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LParabolad_write_datagram_525_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LParabolad_read_datagram_526(PyObject *self, PyObject *arg) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolad, (void **)&local_this, "LParabolad.read_datagram")) {
    return NULL;
  }
  // 1-void LParabolad::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LParabolad self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_read_datagram_526_comment =
  "C++ Interface:\n"
  "read_datagram(const LParabolad self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the parabola from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LParabolad_read_datagram_526_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LParabolad::LParabolad(void)
 * inline LParabolad::LParabolad(LParabolad const &copy)
 * inline LParabolad::LParabolad(LVecBase3d const &a, LVecBase3d const &b, LVecBase3d const &c)
 */
static int Dtool_Init_LParabolad(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LParabolad::LParabolad(void)
      LParabolad *return_value = new LParabolad();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolad, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline LParabolad::LParabolad(LParabolad const &copy)
      LParabolad arg_local;
      LParabolad const *arg_this = Dtool_Coerce_LParabolad(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 0, "LParabolad.LParabolad", "LParabolad");
        return -1;
      }
      LParabolad *return_value = new LParabolad(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolad, true, false);
    }
    break;
  case 3:
    {
      // 1-inline LParabolad::LParabolad(LVecBase3d const &a, LVecBase3d const &b, LVecBase3d const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:LParabolad", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3d param0_local;
        LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LParabolad.LParabolad", "LVecBase3d");
          return -1;
        }
        LVecBase3d param1_local;
        LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LParabolad.LParabolad", "LVecBase3d");
          return -1;
        }
        LVecBase3d param2_local;
        LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
        if (!(param2_this != NULL)) {
          Dtool_Raise_ArgTypeError(param2, 2, "LParabolad.LParabolad", "LVecBase3d");
          return -1;
        }
        LParabolad *return_value = new LParabolad(*param0_this, *param1_this, *param2_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolad, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LParabolad() takes 0, 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LParabolad()\n"
      "LParabolad(const LParabolad copy)\n"
      "LParabolad(const LVecBase3d a, const LVecBase3d b, const LVecBase3d c)\n");
  }
  return -1;
}

LParabolad *Dtool_Coerce_LParabolad(PyObject *args, LParabolad &coerced) {
  LParabolad *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LParabolad, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LParabolad *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline LParabolad::LParabolad(LVecBase3d const &a, LVecBase3d const &b, LVecBase3d const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      if (PyArg_UnpackTuple(args, "LParabolad", 3, 3, &param0, &param1, &param2)) {
        LVecBase3d const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3d, (void **)&param0_this);
        LVecBase3d const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3d, (void **)&param1_this);
        LVecBase3d const *param2_this;
        DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
        if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
          coerced = LParabolad(*param0_this, *param1_this, *param2_this);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LParabolad(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LParabolad) {
    printf("LParabolad ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LParabolad *local_this = (LParabolad *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LParabolad) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LParabolad(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LParabolad) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LPlanef
 */
/**
 * Python function wrapper for:
 * inline void LPlanef::xform(LMatrix4f const &mat)
 */
static PyObject *Dtool_LPlanef_xform_533(PyObject *self, PyObject *arg) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LPlanef, (void **)&local_this, "LPlanef.xform")) {
    return NULL;
  }
  // 1-inline void LPlanef::xform(LMatrix4f const &mat)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlanef.xform", "LMatrix4f");
  }
  (*local_this).xform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const LPlanef self, const LMatrix4f mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_xform_533_comment =
  "C++ Interface:\n"
  "xform(const LPlanef self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Transforms the plane by the indicated matrix.\n"
  " */";
#else
static const char *Dtool_LPlanef_xform_533_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LMatrix4f LPlanef::get_reflection_mat(void) const
 */
static PyObject *Dtool_LPlanef_get_reflection_mat_535(PyObject *self, PyObject *) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }
  // 1-LMatrix4f LPlanef::get_reflection_mat(void) const
  LMatrix4f *return_value = new LMatrix4f((*(const LPlanef*)local_this).get_reflection_mat());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_get_reflection_mat_535_comment =
  "C++ Interface:\n"
  "get_reflection_mat(LPlanef self)\n"
  "\n"
  "/**\n"
  " * This computes a transform matrix that reflects the universe to the other\n"
  " * side of the plane, as in a mirror.\n"
  " */";
#else
static const char *Dtool_LPlanef_get_reflection_mat_535_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f LPlanef::get_normal(void) const
 */
static PyObject *Dtool_LPlanef_get_normal_536(PyObject *self, PyObject *) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f LPlanef::get_normal(void) const
  LVector3f *return_value = new LVector3f((*(const LPlanef*)local_this).get_normal());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_get_normal_536_comment =
  "C++ Interface:\n"
  "get_normal(LPlanef self)\n"
  "\n"
  "/**\n"
  " * Returns the surface normal of the plane.\n"
  " */";
#else
static const char *Dtool_LPlanef_get_normal_536_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LPoint3f LPlanef::get_point(void) const
 */
static PyObject *Dtool_LPlanef_get_point_537(PyObject *self, PyObject *) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }
  // 1-LPoint3f LPlanef::get_point(void) const
  LPoint3f *return_value = new LPoint3f((*(const LPlanef*)local_this).get_point());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_get_point_537_comment =
  "C++ Interface:\n"
  "get_point(LPlanef self)\n"
  "\n"
  "/**\n"
  " * Returns an arbitrary point in the plane.  This can be used along with the\n"
  " * normal returned by get_normal() to reconstruct the plane.\n"
  " */";
#else
static const char *Dtool_LPlanef_get_point_537_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LPlanef::dist_to_plane(LPoint3f const &point) const
 */
static PyObject *Dtool_LPlanef_dist_to_plane_538(PyObject *self, PyObject *arg) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LPlanef::dist_to_plane(LPoint3f const &point) const
  LPoint3f arg_local;
  LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlanef.dist_to_plane", "LPoint3f");
  }
  float return_value = (*(const LPlanef*)local_this).dist_to_plane(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dist_to_plane(LPlanef self, const LPoint3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_dist_to_plane_538_comment =
  "C++ Interface:\n"
  "dist_to_plane(LPlanef self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Returns the straight-line shortest distance from the point to the plane.\n"
  " * The returned value is positive if the point is in front of the plane (on\n"
  " * the side with the normal), or negative in the point is behind the plane (on\n"
  " * the opposite side from the normal). It's zero if the point is exactly in\n"
  " * the plane.\n"
  " */";
#else
static const char *Dtool_LPlanef_dist_to_plane_538_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f LPlanef::project(LPoint3f const &point) const
 */
static PyObject *Dtool_LPlanef_project_539(PyObject *self, PyObject *arg) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f LPlanef::project(LPoint3f const &point) const
  LPoint3f arg_local;
  LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlanef.project", "LPoint3f");
  }
  LPoint3f *return_value = new LPoint3f((*(const LPlanef*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LPlanef self, const LPoint3f point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_project_539_comment =
  "C++ Interface:\n"
  "project(LPlanef self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Returns the point within the plane nearest to the indicated point in space.\n"
  " */";
#else
static const char *Dtool_LPlanef_project_539_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LPlanef::flip(void)
 */
static PyObject *Dtool_LPlanef_flip_540(PyObject *self, PyObject *) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LPlanef, (void **)&local_this, "LPlanef.flip")) {
    return NULL;
  }
  // 1-inline void LPlanef::flip(void)
  (*local_this).flip();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_flip_540_comment =
  "C++ Interface:\n"
  "flip(const LPlanef self)\n"
  "\n"
  "/**\n"
  " * Convenience method that flips the plane in-place.  This is done by simply\n"
  " * flipping the normal vector.\n"
  " */";
#else
static const char *Dtool_LPlanef_flip_540_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LPlanef::intersects_line(LPoint3f &intersection_point, LPoint3f const &p1, LPoint3f const &p2) const
 */
static PyObject *Dtool_LPlanef_intersects_line_541(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LPlanef::intersects_line(LPoint3f &intersection_point, LPoint3f const &p1, LPoint3f const &p2) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"intersection_point", "p1", "p2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:intersects_line", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LPlanef.intersects_line", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3f const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LPlanef.intersects_line", "LPoint3f");
    }
    LPoint3f param3_local;
    LPoint3f const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "LPlanef.intersects_line", "LPoint3f");
    }
    bool return_value = (*(const LPlanef*)local_this).intersects_line(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "intersects_line(LPlanef self, LPoint3f intersection_point, const LPoint3f p1, const LPoint3f p2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_intersects_line_541_comment =
  "C++ Interface:\n"
  "intersects_line(LPlanef self, LPoint3f intersection_point, const LPoint3f p1, const LPoint3f p2)\n"
  "\n"
  "/**\n"
  " * Returns true if the plane intersects the infinite line passing through\n"
  " * points p1 and p2, false if the line is parallel.  The points p1 and p2 are\n"
  " * used only to define the Euclidean line; they have no other bearing on the\n"
  " * intersection test.  If true, sets intersection_point to the point of\n"
  " * intersection.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of intersects_line() returns a bit more information about the\n"
  " * nature of the intersecting point.  The line is defined via the parametric\n"
  " * equation from + t * delta for all real values of t.\n"
  " *\n"
  " * If there is no intersection with the plane, the function returns false and\n"
  " * leaves t undefined.  If there is an intersection with the plane, the\n"
  " * function returns true and sets t to the parametric value that defines the\n"
  " * point of intersection.  That is, t == 0.0f implies that the intersection\n"
  " * occurred exactly at point from, and t == 1.0f implies at point from +\n"
  " * delta, with other values of t accordingly.\n"
  " */";
#else
static const char *Dtool_LPlanef_intersects_line_541_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool LPlanef::intersects_plane(LPoint3f &from, LVector3f &delta, LPlanef const &other) const
 */
static PyObject *Dtool_LPlanef_intersects_plane_542(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool LPlanef::intersects_plane(LPoint3f &from, LVector3f &delta, LPlanef const &other) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"from", "delta", "other", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:intersects_plane", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LPlanef.intersects_plane", "LPoint3f");
    }
    LVector3f param2_local;
    LVector3f *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LPlanef.intersects_plane", "LVector3f");
    }
    LPlanef param3_local;
    LPlanef const *param3_this = Dtool_Coerce_LPlanef(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "LPlanef.intersects_plane", "LPlanef");
    }
    bool return_value = (*(const LPlanef*)local_this).intersects_plane(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "intersects_plane(LPlanef self, LPoint3f from, LVector3f delta, const LPlanef other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_intersects_plane_542_comment =
  "C++ Interface:\n"
  "intersects_plane(LPlanef self, LPoint3f from, LVector3f delta, const LPlanef other)\n"
  "\n"
  "/**\n"
  " * Returns true if the two planes intersect, false if they do not.  If they do\n"
  " * intersect, then from and delta are filled in with the parametric\n"
  " * representation of the line of intersection: that is, from is a point on\n"
  " * that line, and delta is a vector showing the direction of the line.\n"
  " */";
#else
static const char *Dtool_LPlanef_intersects_plane_542_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LPlanef::output(ostream &out) const
 */
static PyObject *Dtool_LPlanef_output_544(PyObject *self, PyObject *arg) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LPlanef::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LPlanef.output", false, true);
  if (arg_this != NULL) {
    (*(const LPlanef*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LPlanef self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_output_544_comment =
  "C++ Interface:\n"
  "output(LPlanef self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LPlanef_output_544_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LPlanef::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LPlanef_write_545(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LPlanef::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "LPlanef.write", false, true);
    if (param1_this != NULL) {
      (*(const LPlanef*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LPlanef self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_write_545_comment =
  "C++ Interface:\n"
  "write(LPlanef self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LPlanef_write_545_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPlanef::LPlanef(void)
 * inline LPlanef::LPlanef(LPlanef const &) = default
 * inline LPlanef::LPlanef(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c)
 * inline LPlanef::LPlanef(LVecBase4f const &copy)
 * inline LPlanef::LPlanef(LVector3f const &normal, LPoint3f const &point)
 * inline LPlanef::LPlanef(float a, float b, float c, float d)
 */
static int Dtool_Init_LPlanef(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPlanef::LPlanef(void)
      LPlanef *return_value = new LPlanef();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPlanef::LPlanef(LPlanef const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPlanef", (char **)keyword_list, &param0)) {
          LPlanef const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPlanef, (void **)&param0_this);
          if (param0_this != NULL) {
            LPlanef *return_value = new LPlanef(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPlanef::LPlanef(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPlanef", (char **)keyword_list, &param0)) {
          LVecBase4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LPlanef *return_value = new LPlanef(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPlanef::LPlanef(LPlanef const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPlanef", (char **)keyword_list, &param0)) {
          LPlanef param0_local;
          LPlanef const *param0_this = Dtool_Coerce_LPlanef(param0, param0_local);
          if ((param0_this != NULL)) {
            LPlanef *return_value = new LPlanef(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPlanef::LPlanef(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPlanef", (char **)keyword_list, &param0)) {
          LVecBase4f param0_local;
          LVecBase4f const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LPlanef *return_value = new LPlanef(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline LPlanef::LPlanef(LVector3f const &normal, LPoint3f const &point)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"normal", "point", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:LPlanef", (char **)keyword_list, &param0, &param1)) {
        LVector3f param0_local;
        LVector3f const *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPlanef.LPlanef", "LVector3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3f const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LPlanef.LPlanef", "LPoint3f");
          return -1;
        }
        LPlanef *return_value = new LPlanef(*param0_this, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LPlanef::LPlanef(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:LPlanef", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3f param0_local;
        LPoint3f const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPlanef.LPlanef", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3f const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LPlanef.LPlanef", "LPoint3f");
          return -1;
        }
        LPoint3f param2_local;
        LPoint3f const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          Dtool_Raise_ArgTypeError(param2, 2, "LPlanef.LPlanef", "LPoint3f");
          return -1;
        }
        LPlanef *return_value = new LPlanef(*param0_this, *param1_this, *param2_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LPlanef::LPlanef(float a, float b, float c, float d)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"a", "b", "c", "d", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:LPlanef", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LPlanef *return_value = new LPlanef((float)param0, (float)param1, (float)param2, (float)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPlanef() takes 0, 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPlanef()\n"
      "LPlanef(const LPlanef param0)\n"
      "LPlanef(const LVecBase4f copy)\n"
      "LPlanef(const LVector3f normal, const LPoint3f point)\n"
      "LPlanef(const LPoint3f a, const LPoint3f b, const LPoint3f c)\n"
      "LPlanef(float a, float b, float c, float d)\n");
  }
  return -1;
}

LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced) {
  LPlanef *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LPlanef, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LPlanef *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LPlanef::LPlanef(LVecBase4f const &copy)
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      coerced = LPlanef(*arg_this);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LPlanef::LPlanef(LVector3f const &normal, LPoint3f const &point)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "LPlanef", 2, 2, &param0, &param1)) {
          LVector3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3f, (void **)&param0_this);
          LPoint3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            coerced = LPlanef(*param0_this, *param1_this);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LPlanef::LPlanef(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_UnpackTuple(args, "LPlanef", 3, 3, &param0, &param1, &param2)) {
          LPoint3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LPoint3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          LPoint3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LPoint3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            coerced = LPlanef(*param0_this, *param1_this, *param2_this);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LPlanef::LPlanef(float a, float b, float c, float d)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:LPlanef", &param0, &param1, &param2, &param3)) {
          coerced = LPlanef((float)param0, (float)param1, (float)param2, (float)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LPlanef(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LPlanef) {
    printf("LPlanef ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LPlanef *local_this = (LPlanef *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LPlanef) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4f) {
    return (LVecBase4f *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LPlanef(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LPlanef) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4f) {
    LVecBase4f* other_this = (LVecBase4f*)from_this;
    return (LPlanef*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LPlaned
 */
/**
 * Python function wrapper for:
 * inline void LPlaned::xform(LMatrix4d const &mat)
 */
static PyObject *Dtool_LPlaned_xform_552(PyObject *self, PyObject *arg) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LPlaned, (void **)&local_this, "LPlaned.xform")) {
    return NULL;
  }
  // 1-inline void LPlaned::xform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlaned.xform", "LMatrix4d");
  }
  (*local_this).xform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const LPlaned self, const LMatrix4d mat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_xform_552_comment =
  "C++ Interface:\n"
  "xform(const LPlaned self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Transforms the plane by the indicated matrix.\n"
  " */";
#else
static const char *Dtool_LPlaned_xform_552_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LMatrix4d LPlaned::get_reflection_mat(void) const
 */
static PyObject *Dtool_LPlaned_get_reflection_mat_554(PyObject *self, PyObject *) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }
  // 1-LMatrix4d LPlaned::get_reflection_mat(void) const
  LMatrix4d *return_value = new LMatrix4d((*(const LPlaned*)local_this).get_reflection_mat());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_get_reflection_mat_554_comment =
  "C++ Interface:\n"
  "get_reflection_mat(LPlaned self)\n"
  "\n"
  "/**\n"
  " * This computes a transform matrix that reflects the universe to the other\n"
  " * side of the plane, as in a mirror.\n"
  " */";
#else
static const char *Dtool_LPlaned_get_reflection_mat_554_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3d LPlaned::get_normal(void) const
 */
static PyObject *Dtool_LPlaned_get_normal_555(PyObject *self, PyObject *) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3d LPlaned::get_normal(void) const
  LVector3d *return_value = new LVector3d((*(const LPlaned*)local_this).get_normal());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_get_normal_555_comment =
  "C++ Interface:\n"
  "get_normal(LPlaned self)\n"
  "\n"
  "/**\n"
  " * Returns the surface normal of the plane.\n"
  " */";
#else
static const char *Dtool_LPlaned_get_normal_555_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LPoint3d LPlaned::get_point(void) const
 */
static PyObject *Dtool_LPlaned_get_point_556(PyObject *self, PyObject *) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }
  // 1-LPoint3d LPlaned::get_point(void) const
  LPoint3d *return_value = new LPoint3d((*(const LPlaned*)local_this).get_point());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_get_point_556_comment =
  "C++ Interface:\n"
  "get_point(LPlaned self)\n"
  "\n"
  "/**\n"
  " * Returns an arbitrary point in the plane.  This can be used along with the\n"
  " * normal returned by get_normal() to reconstruct the plane.\n"
  " */";
#else
static const char *Dtool_LPlaned_get_point_556_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LPlaned::dist_to_plane(LPoint3d const &point) const
 */
static PyObject *Dtool_LPlaned_dist_to_plane_557(PyObject *self, PyObject *arg) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LPlaned::dist_to_plane(LPoint3d const &point) const
  LPoint3d arg_local;
  LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlaned.dist_to_plane", "LPoint3d");
  }
  double return_value = (*(const LPlaned*)local_this).dist_to_plane(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dist_to_plane(LPlaned self, const LPoint3d point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_dist_to_plane_557_comment =
  "C++ Interface:\n"
  "dist_to_plane(LPlaned self, const LPoint3d point)\n"
  "\n"
  "/**\n"
  " * Returns the straight-line shortest distance from the point to the plane.\n"
  " * The returned value is positive if the point is in front of the plane (on\n"
  " * the side with the normal), or negative in the point is behind the plane (on\n"
  " * the opposite side from the normal). It's zero if the point is exactly in\n"
  " * the plane.\n"
  " */";
#else
static const char *Dtool_LPlaned_dist_to_plane_557_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d LPlaned::project(LPoint3d const &point) const
 */
static PyObject *Dtool_LPlaned_project_558(PyObject *self, PyObject *arg) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3d LPlaned::project(LPoint3d const &point) const
  LPoint3d arg_local;
  LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlaned.project", "LPoint3d");
  }
  LPoint3d *return_value = new LPoint3d((*(const LPlaned*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LPlaned self, const LPoint3d point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_project_558_comment =
  "C++ Interface:\n"
  "project(LPlaned self, const LPoint3d point)\n"
  "\n"
  "/**\n"
  " * Returns the point within the plane nearest to the indicated point in space.\n"
  " */";
#else
static const char *Dtool_LPlaned_project_558_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LPlaned::flip(void)
 */
static PyObject *Dtool_LPlaned_flip_559(PyObject *self, PyObject *) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LPlaned, (void **)&local_this, "LPlaned.flip")) {
    return NULL;
  }
  // 1-inline void LPlaned::flip(void)
  (*local_this).flip();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_flip_559_comment =
  "C++ Interface:\n"
  "flip(const LPlaned self)\n"
  "\n"
  "/**\n"
  " * Convenience method that flips the plane in-place.  This is done by simply\n"
  " * flipping the normal vector.\n"
  " */";
#else
static const char *Dtool_LPlaned_flip_559_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LPlaned::intersects_line(LPoint3d &intersection_point, LPoint3d const &p1, LPoint3d const &p2) const
 */
static PyObject *Dtool_LPlaned_intersects_line_560(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LPlaned::intersects_line(LPoint3d &intersection_point, LPoint3d const &p1, LPoint3d const &p2) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"intersection_point", "p1", "p2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:intersects_line", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3d param1_local;
    LPoint3d *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LPlaned.intersects_line", "LPoint3d");
    }
    LPoint3d param2_local;
    LPoint3d const *param2_this = Dtool_Coerce_LPoint3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LPlaned.intersects_line", "LPoint3d");
    }
    LPoint3d param3_local;
    LPoint3d const *param3_this = Dtool_Coerce_LPoint3d(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "LPlaned.intersects_line", "LPoint3d");
    }
    bool return_value = (*(const LPlaned*)local_this).intersects_line(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "intersects_line(LPlaned self, LPoint3d intersection_point, const LPoint3d p1, const LPoint3d p2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_intersects_line_560_comment =
  "C++ Interface:\n"
  "intersects_line(LPlaned self, LPoint3d intersection_point, const LPoint3d p1, const LPoint3d p2)\n"
  "\n"
  "/**\n"
  " * Returns true if the plane intersects the infinite line passing through\n"
  " * points p1 and p2, false if the line is parallel.  The points p1 and p2 are\n"
  " * used only to define the Euclidean line; they have no other bearing on the\n"
  " * intersection test.  If true, sets intersection_point to the point of\n"
  " * intersection.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of intersects_line() returns a bit more information about the\n"
  " * nature of the intersecting point.  The line is defined via the parametric\n"
  " * equation from + t * delta for all real values of t.\n"
  " *\n"
  " * If there is no intersection with the plane, the function returns false and\n"
  " * leaves t undefined.  If there is an intersection with the plane, the\n"
  " * function returns true and sets t to the parametric value that defines the\n"
  " * point of intersection.  That is, t == 0.0f implies that the intersection\n"
  " * occurred exactly at point from, and t == 1.0f implies at point from +\n"
  " * delta, with other values of t accordingly.\n"
  " */";
#else
static const char *Dtool_LPlaned_intersects_line_560_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool LPlaned::intersects_plane(LPoint3d &from, LVector3d &delta, LPlaned const &other) const
 */
static PyObject *Dtool_LPlaned_intersects_plane_561(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool LPlaned::intersects_plane(LPoint3d &from, LVector3d &delta, LPlaned const &other) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"from", "delta", "other", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:intersects_plane", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3d param1_local;
    LPoint3d *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LPlaned.intersects_plane", "LPoint3d");
    }
    LVector3d param2_local;
    LVector3d *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LPlaned.intersects_plane", "LVector3d");
    }
    LPlaned param3_local;
    LPlaned const *param3_this = Dtool_Coerce_LPlaned(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "LPlaned.intersects_plane", "LPlaned");
    }
    bool return_value = (*(const LPlaned*)local_this).intersects_plane(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "intersects_plane(LPlaned self, LPoint3d from, LVector3d delta, const LPlaned other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_intersects_plane_561_comment =
  "C++ Interface:\n"
  "intersects_plane(LPlaned self, LPoint3d from, LVector3d delta, const LPlaned other)\n"
  "\n"
  "/**\n"
  " * Returns true if the two planes intersect, false if they do not.  If they do\n"
  " * intersect, then from and delta are filled in with the parametric\n"
  " * representation of the line of intersection: that is, from is a point on\n"
  " * that line, and delta is a vector showing the direction of the line.\n"
  " */";
#else
static const char *Dtool_LPlaned_intersects_plane_561_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LPlaned::output(ostream &out) const
 */
static PyObject *Dtool_LPlaned_output_563(PyObject *self, PyObject *arg) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LPlaned::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LPlaned.output", false, true);
  if (arg_this != NULL) {
    (*(const LPlaned*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LPlaned self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_output_563_comment =
  "C++ Interface:\n"
  "output(LPlaned self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LPlaned_output_563_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LPlaned::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LPlaned_write_564(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LPlaned::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "LPlaned.write", false, true);
    if (param1_this != NULL) {
      (*(const LPlaned*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LPlaned self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_write_564_comment =
  "C++ Interface:\n"
  "write(LPlaned self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LPlaned_write_564_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPlaned::LPlaned(void)
 * inline LPlaned::LPlaned(LPlaned const &) = default
 * inline LPlaned::LPlaned(LPoint3d const &a, LPoint3d const &b, LPoint3d const &c)
 * inline LPlaned::LPlaned(LVecBase4d const &copy)
 * inline LPlaned::LPlaned(LVector3d const &normal, LPoint3d const &point)
 * inline LPlaned::LPlaned(double a, double b, double c, double d)
 */
static int Dtool_Init_LPlaned(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPlaned::LPlaned(void)
      LPlaned *return_value = new LPlaned();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPlaned::LPlaned(LPlaned const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPlaned", (char **)keyword_list, &param0)) {
          LPlaned const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPlaned, (void **)&param0_this);
          if (param0_this != NULL) {
            LPlaned *return_value = new LPlaned(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPlaned::LPlaned(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPlaned", (char **)keyword_list, &param0)) {
          LVecBase4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LPlaned *return_value = new LPlaned(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPlaned::LPlaned(LPlaned const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPlaned", (char **)keyword_list, &param0)) {
          LPlaned param0_local;
          LPlaned const *param0_this = Dtool_Coerce_LPlaned(param0, param0_local);
          if ((param0_this != NULL)) {
            LPlaned *return_value = new LPlaned(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPlaned::LPlaned(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPlaned", (char **)keyword_list, &param0)) {
          LVecBase4d param0_local;
          LVecBase4d const *param0_this = Dtool_Coerce_LVecBase4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LPlaned *return_value = new LPlaned(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline LPlaned::LPlaned(LVector3d const &normal, LPoint3d const &point)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"normal", "point", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:LPlaned", (char **)keyword_list, &param0, &param1)) {
        LVector3d param0_local;
        LVector3d const *param0_this = Dtool_Coerce_LVector3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPlaned.LPlaned", "LVector3d");
          return -1;
        }
        LPoint3d param1_local;
        LPoint3d const *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LPlaned.LPlaned", "LPoint3d");
          return -1;
        }
        LPlaned *return_value = new LPlaned(*param0_this, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LPlaned::LPlaned(LPoint3d const &a, LPoint3d const &b, LPoint3d const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:LPlaned", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3d param0_local;
        LPoint3d const *param0_this = Dtool_Coerce_LPoint3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPlaned.LPlaned", "LPoint3d");
          return -1;
        }
        LPoint3d param1_local;
        LPoint3d const *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LPlaned.LPlaned", "LPoint3d");
          return -1;
        }
        LPoint3d param2_local;
        LPoint3d const *param2_this = Dtool_Coerce_LPoint3d(param2, param2_local);
        if (!(param2_this != NULL)) {
          Dtool_Raise_ArgTypeError(param2, 2, "LPlaned.LPlaned", "LPoint3d");
          return -1;
        }
        LPlaned *return_value = new LPlaned(*param0_this, *param1_this, *param2_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LPlaned::LPlaned(double a, double b, double c, double d)
      double param0;
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"a", "b", "c", "d", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:LPlaned", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LPlaned *return_value = new LPlaned((double)param0, (double)param1, (double)param2, (double)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPlaned() takes 0, 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPlaned()\n"
      "LPlaned(const LPlaned param0)\n"
      "LPlaned(const LVecBase4d copy)\n"
      "LPlaned(const LVector3d normal, const LPoint3d point)\n"
      "LPlaned(const LPoint3d a, const LPoint3d b, const LPoint3d c)\n"
      "LPlaned(double a, double b, double c, double d)\n");
  }
  return -1;
}

LPlaned *Dtool_Coerce_LPlaned(PyObject *args, LPlaned &coerced) {
  LPlaned *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LPlaned, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LPlaned *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LPlaned::LPlaned(LVecBase4d const &copy)
    LVecBase4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
    if (arg_this != NULL) {
      coerced = LPlaned(*arg_this);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LPlaned::LPlaned(LVector3d const &normal, LPoint3d const &point)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "LPlaned", 2, 2, &param0, &param1)) {
          LVector3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3d, (void **)&param0_this);
          LPoint3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            coerced = LPlaned(*param0_this, *param1_this);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LPlaned::LPlaned(LPoint3d const &a, LPoint3d const &b, LPoint3d const &c)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_UnpackTuple(args, "LPlaned", 3, 3, &param0, &param1, &param2)) {
          LPoint3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3d, (void **)&param0_this);
          LPoint3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3d, (void **)&param1_this);
          LPoint3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LPoint3d, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            coerced = LPlaned(*param0_this, *param1_this, *param2_this);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LPlaned::LPlaned(double a, double b, double c, double d)
        double param0;
        double param1;
        double param2;
        double param3;
        if (PyArg_ParseTuple(args, "dddd:LPlaned", &param0, &param1, &param2, &param3)) {
          coerced = LPlaned((double)param0, (double)param1, (double)param2, (double)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LPlaned(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LPlaned) {
    printf("LPlaned ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LPlaned *local_this = (LPlaned *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LPlaned) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4d) {
    return (LVecBase4d *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LPlaned(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LPlaned) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4d) {
    LVecBase4d* other_this = (LVecBase4d*)from_this;
    return (LPlaned*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BoundingBox
 */
/**
 * Python function wrapper for:
 * inline int BoundingBox::get_num_points(void) const
 */
static PyObject *Dtool_BoundingBox_get_num_points_575(PyObject *self, PyObject *) {
  BoundingBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BoundingBox::get_num_points(void) const
  int return_value = (*(const BoundingBox*)local_this).get_num_points();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_get_num_points_575_comment =
  "C++ Interface:\n"
  "get_num_points(BoundingBox self)\n"
  "\n"
  "/**\n"
  " * Returns 8: the number of vertices of a rectangular solid.\n"
  " */";
#else
static const char *Dtool_BoundingBox_get_num_points_575_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BoundingBox::get_point(int n) const
 */
static PyObject *Dtool_BoundingBox_get_point_576(PyObject *self, PyObject *arg) {
  BoundingBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 BoundingBox::get_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3((*(const BoundingBox*)local_this).get_point((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(BoundingBox self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_get_point_576_comment =
  "C++ Interface:\n"
  "get_point(BoundingBox self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the rectangular solid.\n"
  " */";
#else
static const char *Dtool_BoundingBox_get_point_576_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BoundingBox::get_num_planes(void) const
 */
static PyObject *Dtool_BoundingBox_get_num_planes_578(PyObject *self, PyObject *) {
  BoundingBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BoundingBox::get_num_planes(void) const
  int return_value = (*(const BoundingBox*)local_this).get_num_planes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_get_num_planes_578_comment =
  "C++ Interface:\n"
  "get_num_planes(BoundingBox self)\n"
  "\n"
  "/**\n"
  " * Returns 6: the number of faces of a rectangular solid.\n"
  " */";
#else
static const char *Dtool_BoundingBox_get_num_planes_578_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPlane BoundingBox::get_plane(int n) const
 */
static PyObject *Dtool_BoundingBox_get_plane_579(PyObject *self, PyObject *arg) {
  BoundingBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPlane BoundingBox::get_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPlane *return_value = new LPlane((*(const BoundingBox*)local_this).get_plane((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(BoundingBox self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_get_plane_579_comment =
  "C++ Interface:\n"
  "get_plane(BoundingBox self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth face of the rectangular solid.\n"
  " */";
#else
static const char *Dtool_BoundingBox_get_plane_579_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BoundingBox::set_min_max(LPoint3 const &min, LPoint3 const &max)
 */
static PyObject *Dtool_BoundingBox_set_min_max_585(PyObject *self, PyObject *args, PyObject *kwds) {
  BoundingBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingBox, (void **)&local_this, "BoundingBox.set_min_max")) {
    return NULL;
  }
  // 1-inline void BoundingBox::set_min_max(LPoint3 const &min, LPoint3 const &max)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"min", "max", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_min_max", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "BoundingBox.set_min_max", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "BoundingBox.set_min_max", "LPoint3f");
    }
    (*local_this).set_min_max(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_max(const BoundingBox self, const LPoint3f min, const LPoint3f max)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_set_min_max_585_comment =
  "C++ Interface:\n"
  "set_min_max(const BoundingBox self, const LPoint3f min, const LPoint3f max)\n"
  "\n"
  "/**\n"
  " * Sets the min and max point of the rectangular solid.\n"
  " */";
#else
static const char *Dtool_BoundingBox_set_min_max_585_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingBox::get_class_type(void)
 */
static PyObject *Dtool_BoundingBox_get_class_type_586(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingBox::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BoundingBox::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_get_class_type_586_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingBox_get_class_type_586_comment = NULL;
#endif

/**
 * sequence length function for property BoundingBox::points
 */
static Py_ssize_t Dtool_BoundingBox_points_Len(PyObject *self) {
  BoundingBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_points();
}

/**
 * sequence getter for property BoundingBox::points
 */
static PyObject *Dtool_BoundingBox_points_Getitem(PyObject *self, Py_ssize_t index) {
  BoundingBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_points()) {
    PyErr_SetString(PyExc_IndexError, "BoundingBox.points[] index out of range");
    return NULL;
  }
  // 1-inline LPoint3 BoundingBox::get_point(int n) const
  LPoint3 *return_value = new LPoint3((*(const BoundingBox*)local_this).get_point(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(BoundingBox self, index)\n");
  }
}

static PyObject *Dtool_BoundingBox_points_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_BoundingBox_points_Len;
  wrap->_getitem_func = &Dtool_BoundingBox_points_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property BoundingBox::planes
 */
static Py_ssize_t Dtool_BoundingBox_planes_Len(PyObject *self) {
  BoundingBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_planes();
}

/**
 * sequence getter for property BoundingBox::planes
 */
static PyObject *Dtool_BoundingBox_planes_Getitem(PyObject *self, Py_ssize_t index) {
  BoundingBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_planes()) {
    PyErr_SetString(PyExc_IndexError, "BoundingBox.planes[] index out of range");
    return NULL;
  }
  // 1-inline LPlane BoundingBox::get_plane(int n) const
  LPlane *return_value = new LPlane((*(const BoundingBox*)local_this).get_plane(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(BoundingBox self, index)\n");
  }
}

static PyObject *Dtool_BoundingBox_planes_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_BoundingBox_planes_Len;
  wrap->_getitem_func = &Dtool_BoundingBox_planes_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline BoundingBox::BoundingBox(void)
 * inline BoundingBox::BoundingBox(LPoint3 const &min, LPoint3 const &max)
 */
static int Dtool_Init_BoundingBox(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BoundingBox::BoundingBox(void)
      BoundingBox *return_value = new BoundingBox();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingBox, true, false);
    }
    break;
  case 2:
    {
      // 1-inline BoundingBox::BoundingBox(LPoint3 const &min, LPoint3 const &max)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"min", "max", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:BoundingBox", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "BoundingBox.BoundingBox", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "BoundingBox.BoundingBox", "LPoint3f");
          return -1;
        }
        BoundingBox *return_value = new BoundingBox(*param0_this, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingBox, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BoundingBox() takes 0 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BoundingBox()\n"
      "BoundingBox(const LPoint3f min, const LPoint3f max)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BoundingBox(PyObject *args, CPT(BoundingBox) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BoundingBox, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline BoundingBox::BoundingBox(LPoint3 const &min, LPoint3 const &max)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "BoundingBox", 2, 2, &param0, &param1)) {
        LPoint3 const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
        LPoint3 const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          BoundingBox *return_value = new BoundingBox(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_BoundingBox(PyObject *args, PT(BoundingBox) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BoundingBox, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline BoundingBox::BoundingBox(LPoint3 const &min, LPoint3 const &max)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "BoundingBox", 2, 2, &param0, &param1)) {
        LPoint3 const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
        LPoint3 const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          BoundingBox *return_value = new BoundingBox(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_BoundingBox_get_points(PyObject *self, PyObject *) {
  BoundingBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_points();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_BoundingBox_get_point_576(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_BoundingBox_get_planes(PyObject *self, PyObject *) {
  BoundingBox *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_planes();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_BoundingBox_get_plane_579(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_BoundingBox(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BoundingBox) {
    printf("BoundingBox ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BoundingBox *local_this = (BoundingBox *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BoundingBox) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_FiniteBoundingVolume) {
    return (FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BoundingBox(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BoundingBox) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (BoundingBox*)other_this;
  }
  if (from_type == Dtool_Ptr_FiniteBoundingVolume) {
    FiniteBoundingVolume* other_this = (FiniteBoundingVolume*)from_this;
    return (BoundingBox*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (BoundingBox*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingBox*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingBox*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingBox*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LFrustumf
 */
/**
 * Python function wrapper for:
 * inline void LFrustumf::make_ortho_2D(void)
 * inline void LFrustumf::make_ortho_2D(float l, float r, float t, float b)
 */
static PyObject *Dtool_LFrustumf_make_ortho_2D_590(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumf, (void **)&local_this, "LFrustumf.make_ortho_2D")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void LFrustumf::make_ortho_2D(void)
      (*local_this).make_ortho_2D();
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void LFrustumf::make_ortho_2D(float l, float r, float t, float b)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"l", "r", "t", "b", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_ortho_2D", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).make_ortho_2D((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_ortho_2D() takes 1 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_ortho_2D(const LFrustumf self)\n"
      "make_ortho_2D(const LFrustumf self, float l, float r, float t, float b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumf_make_ortho_2D_590_comment =
  "C++ Interface:\n"
  "make_ortho_2D(const LFrustumf self)\n"
  "make_ortho_2D(const LFrustumf self, float l, float r, float t, float b)\n"
  "\n"
  "/**\n"
  " * Sets up a two-dimensional orthographic frustum\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up a two-dimensional orthographic frustum\n"
  " */";
#else
static const char *Dtool_LFrustumf_make_ortho_2D_590_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumf::make_ortho(float fnear, float ffar)
 * inline void LFrustumf::make_ortho(float fnear, float ffar, float l, float r, float t, float b)
 */
static PyObject *Dtool_LFrustumf_make_ortho_591(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumf, (void **)&local_this, "LFrustumf.make_ortho")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void LFrustumf::make_ortho(float fnear, float ffar)
      float param1;
      float param2;
      static const char *keyword_list[] = {"fnear", "ffar", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:make_ortho", (char **)keyword_list, &param1, &param2)) {
        (*local_this).make_ortho((float)param1, (float)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void LFrustumf::make_ortho(float fnear, float ffar, float l, float r, float t, float b)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"fnear", "ffar", "l", "r", "t", "b", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:make_ortho", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        (*local_this).make_ortho((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_ortho() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_ortho(const LFrustumf self, float fnear, float ffar)\n"
      "make_ortho(const LFrustumf self, float fnear, float ffar, float l, float r, float t, float b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumf_make_ortho_591_comment =
  "C++ Interface:\n"
  "make_ortho(const LFrustumf self, float fnear, float ffar)\n"
  "make_ortho(const LFrustumf self, float fnear, float ffar, float l, float r, float t, float b)\n"
  "\n"
  "/**\n"
  " * Behaves like gluOrtho\n"
  " */\n"
  "\n"
  "/**\n"
  " * Behaves like gluOrtho\n"
  " */";
#else
static const char *Dtool_LFrustumf_make_ortho_591_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumf::make_perspective_hfov(float xfov, float aspect, float fnear, float ffar)
 */
static PyObject *Dtool_LFrustumf_make_perspective_hfov_592(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumf, (void **)&local_this, "LFrustumf.make_perspective_hfov")) {
    return NULL;
  }
  // 1-inline void LFrustumf::make_perspective_hfov(float xfov, float aspect, float fnear, float ffar)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"xfov", "aspect", "fnear", "ffar", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_perspective_hfov", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).make_perspective_hfov((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective_hfov(const LFrustumf self, float xfov, float aspect, float fnear, float ffar)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumf_make_perspective_hfov_592_comment =
  "C++ Interface:\n"
  "make_perspective_hfov(const LFrustumf self, float xfov, float aspect, float fnear, float ffar)\n"
  "\n"
  "/**\n"
  " * Behaves like gluPerspective (Aspect = width/height, Yfov in degrees) aspect\n"
  " * +------------+ |            | 1 |            | yfov |            |\n"
  " * +------------+\n"
  " *\n"
  " * -------+------ \\     | \\    | \\   | \\  | \\ | \\| W yfov\n"
  " *\n"
  " */";
#else
static const char *Dtool_LFrustumf_make_perspective_hfov_592_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumf::make_perspective_vfov(float yfov, float aspect, float fnear, float ffar)
 */
static PyObject *Dtool_LFrustumf_make_perspective_vfov_593(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumf, (void **)&local_this, "LFrustumf.make_perspective_vfov")) {
    return NULL;
  }
  // 1-inline void LFrustumf::make_perspective_vfov(float yfov, float aspect, float fnear, float ffar)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"yfov", "aspect", "fnear", "ffar", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_perspective_vfov", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).make_perspective_vfov((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective_vfov(const LFrustumf self, float yfov, float aspect, float fnear, float ffar)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumf_make_perspective_vfov_593_comment =
  "C++ Interface:\n"
  "make_perspective_vfov(const LFrustumf self, float yfov, float aspect, float fnear, float ffar)\n";
#else
static const char *Dtool_LFrustumf_make_perspective_vfov_593_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumf::make_perspective(float xfov, float yfov, float fnear, float ffar)
 */
static PyObject *Dtool_LFrustumf_make_perspective_594(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumf, (void **)&local_this, "LFrustumf.make_perspective")) {
    return NULL;
  }
  // 1-inline void LFrustumf::make_perspective(float xfov, float yfov, float fnear, float ffar)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"xfov", "yfov", "fnear", "ffar", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_perspective", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).make_perspective((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective(const LFrustumf self, float xfov, float yfov, float fnear, float ffar)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumf_make_perspective_594_comment =
  "C++ Interface:\n"
  "make_perspective(const LFrustumf self, float xfov, float yfov, float fnear, float ffar)\n";
#else
static const char *Dtool_LFrustumf_make_perspective_594_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LFrustumf::LFrustumf(void)
 * inline LFrustumf::LFrustumf(LFrustumf const &) = default
 */
static int Dtool_Init_LFrustumf(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LFrustumf::LFrustumf(void)
      LFrustumf *return_value = new LFrustumf();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LFrustumf, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline LFrustumf::LFrustumf(LFrustumf const &) = default
      LFrustumf const *arg_this = (LFrustumf *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LFrustumf, 0, "LFrustumf.LFrustumf", true, true);
      if (arg_this != NULL) {
        LFrustumf *return_value = new LFrustumf(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LFrustumf, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LFrustumf() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LFrustumf()\n"
      "LFrustumf(const LFrustumf param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LFrustumf(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LFrustumf) {
    printf("LFrustumf ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LFrustumf *local_this = (LFrustumf *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LFrustumf) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LFrustumf(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LFrustumf) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LFrustumd
 */
/**
 * Python function wrapper for:
 * inline void LFrustumd::make_ortho_2D(void)
 * inline void LFrustumd::make_ortho_2D(double l, double r, double t, double b)
 */
static PyObject *Dtool_LFrustumd_make_ortho_2D_599(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumd *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumd, (void **)&local_this, "LFrustumd.make_ortho_2D")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void LFrustumd::make_ortho_2D(void)
      (*local_this).make_ortho_2D();
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void LFrustumd::make_ortho_2D(double l, double r, double t, double b)
      double param1;
      double param2;
      double param3;
      double param4;
      static const char *keyword_list[] = {"l", "r", "t", "b", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:make_ortho_2D", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        (*local_this).make_ortho_2D((double)param1, (double)param2, (double)param3, (double)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_ortho_2D() takes 1 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_ortho_2D(const LFrustumd self)\n"
      "make_ortho_2D(const LFrustumd self, double l, double r, double t, double b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumd_make_ortho_2D_599_comment =
  "C++ Interface:\n"
  "make_ortho_2D(const LFrustumd self)\n"
  "make_ortho_2D(const LFrustumd self, double l, double r, double t, double b)\n"
  "\n"
  "/**\n"
  " * Sets up a two-dimensional orthographic frustum\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up a two-dimensional orthographic frustum\n"
  " */";
#else
static const char *Dtool_LFrustumd_make_ortho_2D_599_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumd::make_ortho(double fnear, double ffar)
 * inline void LFrustumd::make_ortho(double fnear, double ffar, double l, double r, double t, double b)
 */
static PyObject *Dtool_LFrustumd_make_ortho_600(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumd *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumd, (void **)&local_this, "LFrustumd.make_ortho")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void LFrustumd::make_ortho(double fnear, double ffar)
      double param1;
      double param2;
      static const char *keyword_list[] = {"fnear", "ffar", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:make_ortho", (char **)keyword_list, &param1, &param2)) {
        (*local_this).make_ortho((double)param1, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void LFrustumd::make_ortho(double fnear, double ffar, double l, double r, double t, double b)
      double param1;
      double param2;
      double param3;
      double param4;
      double param5;
      double param6;
      static const char *keyword_list[] = {"fnear", "ffar", "l", "r", "t", "b", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddddd:make_ortho", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        (*local_this).make_ortho((double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_ortho() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_ortho(const LFrustumd self, double fnear, double ffar)\n"
      "make_ortho(const LFrustumd self, double fnear, double ffar, double l, double r, double t, double b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumd_make_ortho_600_comment =
  "C++ Interface:\n"
  "make_ortho(const LFrustumd self, double fnear, double ffar)\n"
  "make_ortho(const LFrustumd self, double fnear, double ffar, double l, double r, double t, double b)\n"
  "\n"
  "/**\n"
  " * Behaves like gluOrtho\n"
  " */\n"
  "\n"
  "/**\n"
  " * Behaves like gluOrtho\n"
  " */";
#else
static const char *Dtool_LFrustumd_make_ortho_600_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumd::make_perspective_hfov(double xfov, double aspect, double fnear, double ffar)
 */
static PyObject *Dtool_LFrustumd_make_perspective_hfov_601(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumd *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumd, (void **)&local_this, "LFrustumd.make_perspective_hfov")) {
    return NULL;
  }
  // 1-inline void LFrustumd::make_perspective_hfov(double xfov, double aspect, double fnear, double ffar)
  double param1;
  double param2;
  double param3;
  double param4;
  static const char *keyword_list[] = {"xfov", "aspect", "fnear", "ffar", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:make_perspective_hfov", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).make_perspective_hfov((double)param1, (double)param2, (double)param3, (double)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective_hfov(const LFrustumd self, double xfov, double aspect, double fnear, double ffar)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumd_make_perspective_hfov_601_comment =
  "C++ Interface:\n"
  "make_perspective_hfov(const LFrustumd self, double xfov, double aspect, double fnear, double ffar)\n"
  "\n"
  "/**\n"
  " * Behaves like gluPerspective (Aspect = width/height, Yfov in degrees) aspect\n"
  " * +------------+ |            | 1 |            | yfov |            |\n"
  " * +------------+\n"
  " *\n"
  " * -------+------ \\     | \\    | \\   | \\  | \\ | \\| W yfov\n"
  " *\n"
  " */";
#else
static const char *Dtool_LFrustumd_make_perspective_hfov_601_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumd::make_perspective_vfov(double yfov, double aspect, double fnear, double ffar)
 */
static PyObject *Dtool_LFrustumd_make_perspective_vfov_602(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumd *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumd, (void **)&local_this, "LFrustumd.make_perspective_vfov")) {
    return NULL;
  }
  // 1-inline void LFrustumd::make_perspective_vfov(double yfov, double aspect, double fnear, double ffar)
  double param1;
  double param2;
  double param3;
  double param4;
  static const char *keyword_list[] = {"yfov", "aspect", "fnear", "ffar", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:make_perspective_vfov", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).make_perspective_vfov((double)param1, (double)param2, (double)param3, (double)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective_vfov(const LFrustumd self, double yfov, double aspect, double fnear, double ffar)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumd_make_perspective_vfov_602_comment =
  "C++ Interface:\n"
  "make_perspective_vfov(const LFrustumd self, double yfov, double aspect, double fnear, double ffar)\n";
#else
static const char *Dtool_LFrustumd_make_perspective_vfov_602_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumd::make_perspective(double xfov, double yfov, double fnear, double ffar)
 */
static PyObject *Dtool_LFrustumd_make_perspective_603(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumd *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumd, (void **)&local_this, "LFrustumd.make_perspective")) {
    return NULL;
  }
  // 1-inline void LFrustumd::make_perspective(double xfov, double yfov, double fnear, double ffar)
  double param1;
  double param2;
  double param3;
  double param4;
  static const char *keyword_list[] = {"xfov", "yfov", "fnear", "ffar", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:make_perspective", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).make_perspective((double)param1, (double)param2, (double)param3, (double)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective(const LFrustumd self, double xfov, double yfov, double fnear, double ffar)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumd_make_perspective_603_comment =
  "C++ Interface:\n"
  "make_perspective(const LFrustumd self, double xfov, double yfov, double fnear, double ffar)\n";
#else
static const char *Dtool_LFrustumd_make_perspective_603_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LFrustumd::LFrustumd(void)
 * inline LFrustumd::LFrustumd(LFrustumd const &) = default
 */
static int Dtool_Init_LFrustumd(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LFrustumd::LFrustumd(void)
      LFrustumd *return_value = new LFrustumd();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LFrustumd, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline LFrustumd::LFrustumd(LFrustumd const &) = default
      LFrustumd const *arg_this = (LFrustumd *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LFrustumd, 0, "LFrustumd.LFrustumd", true, true);
      if (arg_this != NULL) {
        LFrustumd *return_value = new LFrustumd(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LFrustumd, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LFrustumd() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LFrustumd()\n"
      "LFrustumd(const LFrustumd param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LFrustumd(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LFrustumd) {
    printf("LFrustumd ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LFrustumd *local_this = (LFrustumd *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LFrustumd) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LFrustumd(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LFrustumd) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BoundingHexahedron
 */
/**
 * Python function wrapper for:
 * inline int BoundingHexahedron::get_num_points(void) const
 */
static PyObject *Dtool_BoundingHexahedron_get_num_points_612(PyObject *self, PyObject *) {
  BoundingHexahedron *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BoundingHexahedron::get_num_points(void) const
  int return_value = (*(const BoundingHexahedron*)local_this).get_num_points();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingHexahedron_get_num_points_612_comment =
  "C++ Interface:\n"
  "get_num_points(BoundingHexahedron self)\n"
  "\n"
  "/**\n"
  " * Returns 8: the number of vertices of a hexahedron.\n"
  " */";
#else
static const char *Dtool_BoundingHexahedron_get_num_points_612_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BoundingHexahedron::get_point(int n) const
 */
static PyObject *Dtool_BoundingHexahedron_get_point_613(PyObject *self, PyObject *arg) {
  BoundingHexahedron *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 BoundingHexahedron::get_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3((*(const BoundingHexahedron*)local_this).get_point((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(BoundingHexahedron self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoundingHexahedron_get_point_613_comment =
  "C++ Interface:\n"
  "get_point(BoundingHexahedron self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the hexahedron.\n"
  " */";
#else
static const char *Dtool_BoundingHexahedron_get_point_613_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int BoundingHexahedron::get_num_planes(void) const
 */
static PyObject *Dtool_BoundingHexahedron_get_num_planes_615(PyObject *self, PyObject *) {
  BoundingHexahedron *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int BoundingHexahedron::get_num_planes(void) const
  int return_value = (*(const BoundingHexahedron*)local_this).get_num_planes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingHexahedron_get_num_planes_615_comment =
  "C++ Interface:\n"
  "get_num_planes(BoundingHexahedron self)\n"
  "\n"
  "/**\n"
  " * Returns 6: the number of faces of a hexahedron.\n"
  " */";
#else
static const char *Dtool_BoundingHexahedron_get_num_planes_615_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPlane BoundingHexahedron::get_plane(int n) const
 */
static PyObject *Dtool_BoundingHexahedron_get_plane_616(PyObject *self, PyObject *arg) {
  BoundingHexahedron *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPlane BoundingHexahedron::get_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPlane *return_value = new LPlane((*(const BoundingHexahedron*)local_this).get_plane((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(BoundingHexahedron self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoundingHexahedron_get_plane_616_comment =
  "C++ Interface:\n"
  "get_plane(BoundingHexahedron self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth face of the hexahedron.\n"
  " */";
#else
static const char *Dtool_BoundingHexahedron_get_plane_616_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingHexahedron::get_class_type(void)
 */
static PyObject *Dtool_BoundingHexahedron_get_class_type_620(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingHexahedron::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BoundingHexahedron::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingHexahedron_get_class_type_620_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingHexahedron_get_class_type_620_comment = NULL;
#endif

/**
 * sequence length function for property BoundingHexahedron::points
 */
static Py_ssize_t Dtool_BoundingHexahedron_points_Len(PyObject *self) {
  BoundingHexahedron *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_points();
}

/**
 * sequence getter for property BoundingHexahedron::points
 */
static PyObject *Dtool_BoundingHexahedron_points_Getitem(PyObject *self, Py_ssize_t index) {
  BoundingHexahedron *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_points()) {
    PyErr_SetString(PyExc_IndexError, "BoundingHexahedron.points[] index out of range");
    return NULL;
  }
  // 1-inline LPoint3 BoundingHexahedron::get_point(int n) const
  LPoint3 *return_value = new LPoint3((*(const BoundingHexahedron*)local_this).get_point(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(BoundingHexahedron self, index)\n");
  }
}

static PyObject *Dtool_BoundingHexahedron_points_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_BoundingHexahedron_points_Len;
  wrap->_getitem_func = &Dtool_BoundingHexahedron_points_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property BoundingHexahedron::planes
 */
static Py_ssize_t Dtool_BoundingHexahedron_planes_Len(PyObject *self) {
  BoundingHexahedron *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_planes();
}

/**
 * sequence getter for property BoundingHexahedron::planes
 */
static PyObject *Dtool_BoundingHexahedron_planes_Getitem(PyObject *self, Py_ssize_t index) {
  BoundingHexahedron *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_planes()) {
    PyErr_SetString(PyExc_IndexError, "BoundingHexahedron.planes[] index out of range");
    return NULL;
  }
  // 1-inline LPlane BoundingHexahedron::get_plane(int n) const
  LPlane *return_value = new LPlane((*(const BoundingHexahedron*)local_this).get_plane(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(BoundingHexahedron self, index)\n");
  }
}

static PyObject *Dtool_BoundingHexahedron_planes_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_BoundingHexahedron_planes_Len;
  wrap->_getitem_func = &Dtool_BoundingHexahedron_planes_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs = ::CS_default)
 * BoundingHexahedron::BoundingHexahedron(LPoint3 const &fll, LPoint3 const &flr, LPoint3 const &fur, LPoint3 const &ful, LPoint3 const &nll, LPoint3 const &nlr, LPoint3 const &nur, LPoint3 const &nul)
 */
static int Dtool_Init_BoundingHexahedron(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"frustum", "is_ortho", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:BoundingHexahedron", (char **)keyword_list, &param0, &param1)) {
        LFrustum const *param0_this = (LFrustumf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LFrustumf, 0, "BoundingHexahedron.BoundingHexahedron", true, true);
        if (param0_this != NULL) {
          BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingHexahedron, true, false);
        }
      }
    }
    break;
  case 3:
    {
      // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"frustum", "is_ortho", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:BoundingHexahedron", (char **)keyword_list, &param0, &param1, &param2)) {
        LFrustum const *param0_this = (LFrustumf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LFrustumf, 0, "BoundingHexahedron.BoundingHexahedron", true, true);
        if (param0_this != NULL) {
          BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0), (CoordinateSystem)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingHexahedron, true, false);
        }
      }
    }
    break;
  case 8:
    {
      // 1-BoundingHexahedron::BoundingHexahedron(LPoint3 const &fll, LPoint3 const &flr, LPoint3 const &fur, LPoint3 const &ful, LPoint3 const &nll, LPoint3 const &nlr, LPoint3 const &nur, LPoint3 const &nul)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      PyObject *param6;
      PyObject *param7;
      static const char *keyword_list[] = {"fll", "flr", "fur", "ful", "nll", "nlr", "nur", "nul", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO:BoundingHexahedron", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          Dtool_Raise_ArgTypeError(param2, 2, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param3_local;
        LPoint3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
        if (!(param3_this != NULL)) {
          Dtool_Raise_ArgTypeError(param3, 3, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param4_local;
        LPoint3 const *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
        if (!(param4_this != NULL)) {
          Dtool_Raise_ArgTypeError(param4, 4, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param5_local;
        LPoint3 const *param5_this = Dtool_Coerce_LPoint3f(param5, param5_local);
        if (!(param5_this != NULL)) {
          Dtool_Raise_ArgTypeError(param5, 5, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param6_local;
        LPoint3 const *param6_this = Dtool_Coerce_LPoint3f(param6, param6_local);
        if (!(param6_this != NULL)) {
          Dtool_Raise_ArgTypeError(param6, 6, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param7_local;
        LPoint3 const *param7_this = Dtool_Coerce_LPoint3f(param7, param7_local);
        if (!(param7_this != NULL)) {
          Dtool_Raise_ArgTypeError(param7, 7, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, *param5_this, *param6_this, *param7_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingHexahedron, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BoundingHexahedron() takes 2, 3 or 8 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BoundingHexahedron(const LFrustumf frustum, bool is_ortho)\n"
      "BoundingHexahedron(const LFrustumf frustum, bool is_ortho, int cs)\n"
      "BoundingHexahedron(const LPoint3f fll, const LPoint3f flr, const LPoint3f fur, const LPoint3f ful, const LPoint3f nll, const LPoint3f nlr, const LPoint3f nur, const LPoint3f nul)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BoundingHexahedron(PyObject *args, CPT(BoundingHexahedron) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BoundingHexahedron, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "BoundingHexahedron", 2, 2, &param0, &param1)) {
          LFrustum const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LFrustumf, (void **)&param0_this);
          if (param0_this != NULL) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        if (PyArg_ParseTuple(args, "OOi:BoundingHexahedron", &param0, &param1, &param2)) {
          LFrustum const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LFrustumf, (void **)&param0_this);
          if (param0_this != NULL) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0), (CoordinateSystem)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 8: {
        // 1-BoundingHexahedron::BoundingHexahedron(LPoint3 const &fll, LPoint3 const &flr, LPoint3 const &fur, LPoint3 const &ful, LPoint3 const &nll, LPoint3 const &nlr, LPoint3 const &nur, LPoint3 const &nul)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        PyObject *param6;
        PyObject *param7;
        if (PyArg_UnpackTuple(args, "BoundingHexahedron", 8, 8, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LPoint3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          LPoint3 const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LPoint3f, (void **)&param2_this);
          LPoint3 const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LPoint3f, (void **)&param3_this);
          LPoint3 const *param4_this;
          DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LPoint3f, (void **)&param4_this);
          LPoint3 const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LPoint3f, (void **)&param5_this);
          LPoint3 const *param6_this;
          DTOOL_Call_ExtractThisPointerForType(param6, Dtool_Ptr_LPoint3f, (void **)&param6_this);
          LPoint3 const *param7_this;
          DTOOL_Call_ExtractThisPointerForType(param7, Dtool_Ptr_LPoint3f, (void **)&param7_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL && param5_this != NULL && param6_this != NULL && param7_this != NULL) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, *param5_this, *param6_this, *param7_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_BoundingHexahedron(PyObject *args, PT(BoundingHexahedron) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BoundingHexahedron, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "BoundingHexahedron", 2, 2, &param0, &param1)) {
          LFrustum const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LFrustumf, (void **)&param0_this);
          if (param0_this != NULL) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        if (PyArg_ParseTuple(args, "OOi:BoundingHexahedron", &param0, &param1, &param2)) {
          LFrustum const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LFrustumf, (void **)&param0_this);
          if (param0_this != NULL) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0), (CoordinateSystem)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 8: {
        // 1-BoundingHexahedron::BoundingHexahedron(LPoint3 const &fll, LPoint3 const &flr, LPoint3 const &fur, LPoint3 const &ful, LPoint3 const &nll, LPoint3 const &nlr, LPoint3 const &nur, LPoint3 const &nul)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        PyObject *param6;
        PyObject *param7;
        if (PyArg_UnpackTuple(args, "BoundingHexahedron", 8, 8, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
          LPoint3 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          LPoint3 const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
          LPoint3 const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LPoint3f, (void **)&param2_this);
          LPoint3 const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LPoint3f, (void **)&param3_this);
          LPoint3 const *param4_this;
          DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LPoint3f, (void **)&param4_this);
          LPoint3 const *param5_this;
          DTOOL_Call_ExtractThisPointerForType(param5, Dtool_Ptr_LPoint3f, (void **)&param5_this);
          LPoint3 const *param6_this;
          DTOOL_Call_ExtractThisPointerForType(param6, Dtool_Ptr_LPoint3f, (void **)&param6_this);
          LPoint3 const *param7_this;
          DTOOL_Call_ExtractThisPointerForType(param7, Dtool_Ptr_LPoint3f, (void **)&param7_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL && param5_this != NULL && param6_this != NULL && param7_this != NULL) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, *param5_this, *param6_this, *param7_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = MOVE(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_BoundingHexahedron_get_points(PyObject *self, PyObject *) {
  BoundingHexahedron *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_points();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_BoundingHexahedron_get_point_613(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_BoundingHexahedron_get_planes(PyObject *self, PyObject *) {
  BoundingHexahedron *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_planes();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_BoundingHexahedron_get_plane_616(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_BoundingHexahedron(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BoundingHexahedron) {
    printf("BoundingHexahedron ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BoundingHexahedron *local_this = (BoundingHexahedron *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BoundingHexahedron) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_FiniteBoundingVolume) {
    return (FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BoundingHexahedron(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BoundingHexahedron) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  if (from_type == Dtool_Ptr_FiniteBoundingVolume) {
    FiniteBoundingVolume* other_this = (FiniteBoundingVolume*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BoundingLine
 */
/**
 * Python function wrapper for:
 * inline LPoint3 const &BoundingLine::get_point_a(void) const
 */
static PyObject *Dtool_BoundingLine_get_point_a_627(PyObject *self, PyObject *) {
  BoundingLine *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingLine, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 const &BoundingLine::get_point_a(void) const
  LPoint3 const *return_value = &((*(const BoundingLine*)local_this).get_point_a());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BoundingLine_get_point_a_627_comment =
  "C++ Interface:\n"
  "get_point_a(BoundingLine self)\n"
  "\n"
  "/**\n"
  " * Returns the first point that defines the line.\n"
  " */";
#else
static const char *Dtool_BoundingLine_get_point_a_627_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BoundingLine::get_point_b(void) const
 */
static PyObject *Dtool_BoundingLine_get_point_b_628(PyObject *self, PyObject *) {
  BoundingLine *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingLine, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 BoundingLine::get_point_b(void) const
  LPoint3 *return_value = new LPoint3((*(const BoundingLine*)local_this).get_point_b());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingLine_get_point_b_628_comment =
  "C++ Interface:\n"
  "get_point_b(BoundingLine self)\n"
  "\n"
  "/**\n"
  " * Returns the second point that defines the line.\n"
  " */";
#else
static const char *Dtool_BoundingLine_get_point_b_628_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingLine::get_class_type(void)
 */
static PyObject *Dtool_BoundingLine_get_class_type_629(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingLine::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BoundingLine::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingLine_get_class_type_629_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingLine_get_class_type_629_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BoundingLine::BoundingLine(LPoint3 const &a, LPoint3 const &b)
 */
static int Dtool_Init_BoundingLine(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline BoundingLine::BoundingLine(LPoint3 const &a, LPoint3 const &b)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"a", "b", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:BoundingLine", (char **)keyword_list, &param0, &param1)) {
    LPoint3f param0_local;
    LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
    if (!(param0_this != NULL)) {
      Dtool_Raise_ArgTypeError(param0, 0, "BoundingLine.BoundingLine", "LPoint3f");
      return -1;
    }
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      Dtool_Raise_ArgTypeError(param1, 1, "BoundingLine.BoundingLine", "LPoint3f");
      return -1;
    }
    BoundingLine *return_value = new BoundingLine(*param0_this, *param1_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingLine, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BoundingLine(const LPoint3f a, const LPoint3f b)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BoundingLine(PyObject *args, CPT(BoundingLine) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BoundingLine, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline BoundingLine::BoundingLine(LPoint3 const &a, LPoint3 const &b)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "BoundingLine", 2, 2, &param0, &param1)) {
        LPoint3 const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
        LPoint3 const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          BoundingLine *return_value = new BoundingLine(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_BoundingLine(PyObject *args, PT(BoundingLine) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BoundingLine, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline BoundingLine::BoundingLine(LPoint3 const &a, LPoint3 const &b)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "BoundingLine", 2, 2, &param0, &param1)) {
        LPoint3 const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
        LPoint3 const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LPoint3f, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          BoundingLine *return_value = new BoundingLine(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_BoundingLine(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BoundingLine) {
    printf("BoundingLine ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BoundingLine *local_this = (BoundingLine *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BoundingLine) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BoundingLine(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BoundingLine) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (BoundingLine*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (BoundingLine*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingLine*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BoundingPlane
 */
/**
 * Python function wrapper for:
 * inline LPlane const &BoundingPlane::get_plane(void) const
 */
static PyObject *Dtool_BoundingPlane_get_plane_636(PyObject *self, PyObject *) {
  BoundingPlane *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingPlane, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPlane const &BoundingPlane::get_plane(void) const
  LPlane const *return_value = &((*(const BoundingPlane*)local_this).get_plane());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BoundingPlane_get_plane_636_comment =
  "C++ Interface:\n"
  "get_plane(BoundingPlane self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BoundingPlane_get_plane_636_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingPlane::get_class_type(void)
 */
static PyObject *Dtool_BoundingPlane_get_class_type_637(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingPlane::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BoundingPlane::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingPlane_get_class_type_637_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingPlane_get_class_type_637_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BoundingPlane::BoundingPlane(void)
 * inline BoundingPlane::BoundingPlane(LPlane const &plane)
 */
static int Dtool_Init_BoundingPlane(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BoundingPlane::BoundingPlane(void)
      BoundingPlane *return_value = new BoundingPlane();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingPlane, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "plane");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'plane' (pos 1) not found");
        return -1;
      }
      // 1-inline BoundingPlane::BoundingPlane(LPlane const &plane)
      LPlanef arg_local;
      LPlane const *arg_this = Dtool_Coerce_LPlanef(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 0, "BoundingPlane.BoundingPlane", "LPlanef");
        return -1;
      }
      BoundingPlane *return_value = new BoundingPlane(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingPlane, true, false);
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BoundingPlane() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BoundingPlane()\n"
      "BoundingPlane(const LPlanef plane)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BoundingPlane(PyObject *args, CPT(BoundingPlane) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BoundingPlane, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline BoundingPlane::BoundingPlane(LPlane const &plane)
    LPlane const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPlanef, (void **)&arg_this);
    if (arg_this != NULL) {
      BoundingPlane *return_value = new BoundingPlane(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_BoundingPlane(PyObject *args, PT(BoundingPlane) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BoundingPlane, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline BoundingPlane::BoundingPlane(LPlane const &plane)
    LPlane const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPlanef, (void **)&arg_this);
    if (arg_this != NULL) {
      BoundingPlane *return_value = new BoundingPlane(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_BoundingPlane(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BoundingPlane) {
    printf("BoundingPlane ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BoundingPlane *local_this = (BoundingPlane *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BoundingPlane) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BoundingPlane(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BoundingPlane) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (BoundingPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (BoundingPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingPlane*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class BoundingSphere
 */
/**
 * Python function wrapper for:
 * inline LPoint3 BoundingSphere::get_center(void) const
 */
static PyObject *Dtool_BoundingSphere_get_center_644(PyObject *self, PyObject *) {
  BoundingSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingSphere, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3 BoundingSphere::get_center(void) const
  LPoint3 *return_value = new LPoint3((*(const BoundingSphere*)local_this).get_center());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingSphere_get_center_644_comment =
  "C++ Interface:\n"
  "get_center(BoundingSphere self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BoundingSphere_get_center_644_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BoundingSphere::get_radius(void) const
 */
static PyObject *Dtool_BoundingSphere_get_radius_645(PyObject *self, PyObject *) {
  BoundingSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingSphere, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat BoundingSphere::get_radius(void) const
  PN_stdfloat return_value = (*(const BoundingSphere*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingSphere_get_radius_645_comment =
  "C++ Interface:\n"
  "get_radius(BoundingSphere self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BoundingSphere_get_radius_645_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BoundingSphere::set_center(LPoint3 const &center)
 */
static PyObject *Dtool_BoundingSphere_set_center_646(PyObject *self, PyObject *arg) {
  BoundingSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingSphere, (void **)&local_this, "BoundingSphere.set_center")) {
    return NULL;
  }
  // 1-inline void BoundingSphere::set_center(LPoint3 const &center)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BoundingSphere.set_center", "LPoint3f");
  }
  (*local_this).set_center(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center(const BoundingSphere self, const LPoint3f center)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoundingSphere_set_center_646_comment =
  "C++ Interface:\n"
  "set_center(const BoundingSphere self, const LPoint3f center)\n"
  "\n"
  "/**\n"
  " * Sets the center point of the sphere.\n"
  " */";
#else
static const char *Dtool_BoundingSphere_set_center_646_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void BoundingSphere::set_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_BoundingSphere_set_radius_647(PyObject *self, PyObject *arg) {
  BoundingSphere *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingSphere, (void **)&local_this, "BoundingSphere.set_radius")) {
    return NULL;
  }
  // 1-inline void BoundingSphere::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const BoundingSphere self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BoundingSphere_set_radius_647_comment =
  "C++ Interface:\n"
  "set_radius(const BoundingSphere self, float radius)\n"
  "\n"
  "/**\n"
  " * Sets the radius of the sphere.\n"
  " */";
#else
static const char *Dtool_BoundingSphere_set_radius_647_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingSphere::get_class_type(void)
 */
static PyObject *Dtool_BoundingSphere_get_class_type_648(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingSphere::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BoundingSphere::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingSphere_get_class_type_648_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingSphere_get_class_type_648_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline BoundingSphere::BoundingSphere(void)
 * inline BoundingSphere::BoundingSphere(LPoint3 const &center, PN_stdfloat radius)
 */
static int Dtool_Init_BoundingSphere(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BoundingSphere::BoundingSphere(void)
      BoundingSphere *return_value = new BoundingSphere();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingSphere, true, false);
    }
    break;
  case 2:
    {
      // 1-inline BoundingSphere::BoundingSphere(LPoint3 const &center, PN_stdfloat radius)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"center", "radius", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:BoundingSphere", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "BoundingSphere.BoundingSphere", "LPoint3f");
          return -1;
        }
        BoundingSphere *return_value = new BoundingSphere(*param0_this, (PN_stdfloat)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingSphere, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BoundingSphere() takes 0 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BoundingSphere()\n"
      "BoundingSphere(const LPoint3f center, float radius)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BoundingSphere(PyObject *args, CPT(BoundingSphere) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BoundingSphere, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline BoundingSphere::BoundingSphere(LPoint3 const &center, PN_stdfloat radius)
      PyObject *param0;
      float param1;
      if (PyArg_ParseTuple(args, "Of:BoundingSphere", &param0, &param1)) {
        LPoint3 const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
        if (param0_this != NULL) {
          BoundingSphere *return_value = new BoundingSphere(*param0_this, (PN_stdfloat)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_BoundingSphere(PyObject *args, PT(BoundingSphere) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_BoundingSphere, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline BoundingSphere::BoundingSphere(LPoint3 const &center, PN_stdfloat radius)
      PyObject *param0;
      float param1;
      if (PyArg_ParseTuple(args, "Of:BoundingSphere", &param0, &param1)) {
        LPoint3 const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
        if (param0_this != NULL) {
          BoundingSphere *return_value = new BoundingSphere(*param0_this, (PN_stdfloat)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_BoundingSphere(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_BoundingSphere) {
    printf("BoundingSphere ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BoundingSphere *local_this = (BoundingSphere *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_BoundingSphere) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_FiniteBoundingVolume) {
    return (FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BoundingSphere(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BoundingSphere) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (BoundingSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_FiniteBoundingVolume) {
    FiniteBoundingVolume* other_this = (FiniteBoundingVolume*)from_this;
    return (BoundingSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (BoundingSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingSphere*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class IntersectionBoundingVolume
 */
/**
 * Python function wrapper for:
 * inline int IntersectionBoundingVolume::get_num_components(void) const
 */
static PyObject *Dtool_IntersectionBoundingVolume_get_num_components_655(PyObject *self, PyObject *) {
  IntersectionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IntersectionBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int IntersectionBoundingVolume::get_num_components(void) const
  int return_value = (*(const IntersectionBoundingVolume*)local_this).get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_IntersectionBoundingVolume_get_num_components_655_comment =
  "C++ Interface:\n"
  "get_num_components(IntersectionBoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Returns the number of components in the intersection.\n"
  " */";
#else
static const char *Dtool_IntersectionBoundingVolume_get_num_components_655_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline GeometricBoundingVolume const *IntersectionBoundingVolume::get_component(int n) const
 */
static PyObject *Dtool_IntersectionBoundingVolume_get_component_656(PyObject *self, PyObject *arg) {
  IntersectionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IntersectionBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline GeometricBoundingVolume const *IntersectionBoundingVolume::get_component(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    GeometricBoundingVolume const *return_value = (*(const IntersectionBoundingVolume*)local_this).get_component((int)arg_val);
    if (return_value != (GeometricBoundingVolume const *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (GeometricBoundingVolume const *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeometricBoundingVolume, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(IntersectionBoundingVolume self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_IntersectionBoundingVolume_get_component_656_comment =
  "C++ Interface:\n"
  "get_component(IntersectionBoundingVolume self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth component in the intersection.\n"
  " */";
#else
static const char *Dtool_IntersectionBoundingVolume_get_component_656_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void IntersectionBoundingVolume::clear_components(void)
 */
static PyObject *Dtool_IntersectionBoundingVolume_clear_components_661(PyObject *self, PyObject *) {
  IntersectionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IntersectionBoundingVolume, (void **)&local_this, "IntersectionBoundingVolume.clear_components")) {
    return NULL;
  }
  // 1-void IntersectionBoundingVolume::clear_components(void)
  (*local_this).clear_components();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_IntersectionBoundingVolume_clear_components_661_comment =
  "C++ Interface:\n"
  "clear_components(const IntersectionBoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Removes all components from the volume.\n"
  " */";
#else
static const char *Dtool_IntersectionBoundingVolume_clear_components_661_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void IntersectionBoundingVolume::add_component(GeometricBoundingVolume const *component)
 */
static PyObject *Dtool_IntersectionBoundingVolume_add_component_662(PyObject *self, PyObject *arg) {
  IntersectionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IntersectionBoundingVolume, (void **)&local_this, "IntersectionBoundingVolume.add_component")) {
    return NULL;
  }
  // 1-void IntersectionBoundingVolume::add_component(GeometricBoundingVolume const *component)
  GeometricBoundingVolume const *arg_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeometricBoundingVolume, 1, "IntersectionBoundingVolume.add_component", true, true);
  if (arg_this != NULL) {
    (*local_this).add_component(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_component(const IntersectionBoundingVolume self, const GeometricBoundingVolume component)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_IntersectionBoundingVolume_add_component_662_comment =
  "C++ Interface:\n"
  "add_component(const IntersectionBoundingVolume self, const GeometricBoundingVolume component)\n"
  "\n"
  "/**\n"
  " * Adds a new component to the volume.  This does not necessarily increase the\n"
  " * total number of components by one, and you may or may not be able to find\n"
  " * this component in the volume by a subsequent call to get_component();\n"
  " * certain optimizations may prevent the component from being added, or have\n"
  " * other unexpected effects on the total set of components.\n"
  " */";
#else
static const char *Dtool_IntersectionBoundingVolume_add_component_662_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle IntersectionBoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_IntersectionBoundingVolume_get_class_type_663(PyObject *, PyObject *) {
  // 1-static TypeHandle IntersectionBoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(IntersectionBoundingVolume::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_IntersectionBoundingVolume_get_class_type_663_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_IntersectionBoundingVolume_get_class_type_663_comment = NULL;
#endif

/**
 * sequence length function for property IntersectionBoundingVolume::components
 */
static Py_ssize_t Dtool_IntersectionBoundingVolume_components_Len(PyObject *self) {
  IntersectionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IntersectionBoundingVolume, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_components();
}

/**
 * sequence getter for property IntersectionBoundingVolume::components
 */
static PyObject *Dtool_IntersectionBoundingVolume_components_Getitem(PyObject *self, Py_ssize_t index) {
  IntersectionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IntersectionBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_components()) {
    PyErr_SetString(PyExc_IndexError, "IntersectionBoundingVolume.components[] index out of range");
    return NULL;
  }
  // 1-inline GeometricBoundingVolume const *IntersectionBoundingVolume::get_component(int n) const
  GeometricBoundingVolume const *return_value = (*(const IntersectionBoundingVolume*)local_this).get_component(index);
  if (return_value != (GeometricBoundingVolume const *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (GeometricBoundingVolume const *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeometricBoundingVolume, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(IntersectionBoundingVolume self, index)\n");
  }
}

static PyObject *Dtool_IntersectionBoundingVolume_components_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_IntersectionBoundingVolume_components_Len;
  wrap->_getitem_func = &Dtool_IntersectionBoundingVolume_components_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline IntersectionBoundingVolume::IntersectionBoundingVolume(void)
 */
static int Dtool_Init_IntersectionBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "IntersectionBoundingVolume() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline IntersectionBoundingVolume::IntersectionBoundingVolume(void)
  IntersectionBoundingVolume *return_value = new IntersectionBoundingVolume();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IntersectionBoundingVolume, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IntersectionBoundingVolume()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_IntersectionBoundingVolume_get_components(PyObject *self, PyObject *) {
  IntersectionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IntersectionBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_components();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_IntersectionBoundingVolume_get_component_656(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_IntersectionBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_IntersectionBoundingVolume) {
    printf("IntersectionBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  IntersectionBoundingVolume *local_this = (IntersectionBoundingVolume *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_IntersectionBoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_IntersectionBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_IntersectionBoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (IntersectionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (IntersectionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (IntersectionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (IntersectionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (IntersectionBoundingVolume*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Mersenne
 */
/**
 * Python function wrapper for:
 * unsigned long int Mersenne::get_uint31(void)
 */
static PyObject *Dtool_Mersenne_get_uint31_669(PyObject *self, PyObject *) {
  Mersenne *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Mersenne, (void **)&local_this, "Mersenne.get_uint31")) {
    return NULL;
  }
  // 1-unsigned long int Mersenne::get_uint31(void)
  unsigned long int return_value = (*local_this).get_uint31();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Mersenne_get_uint31_669_comment =
  "C++ Interface:\n"
  "get_uint31(const Mersenne self)\n"
  "\n"
  "/* generates a random number on [0,0x7fffffff]-interval */";
#else
static const char *Dtool_Mersenne_get_uint31_669_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Mersenne::Mersenne(unsigned long int seed)
 */
static int Dtool_Init_Mersenne(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Mersenne() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "seed");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'seed' (pos 1) not found");
    return -1;
  }
  // 1-Mersenne::Mersenne(unsigned long int seed)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param0 = PyLong_AsUnsignedLong(arg);
    Mersenne *return_value = new Mersenne((unsigned long int)param0);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Mersenne, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Mersenne(int seed)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Mersenne(PyObject *args, Mersenne const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Mersenne, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Mersenne::Mersenne(unsigned long int seed)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
      Mersenne *return_value = new Mersenne((unsigned long int)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_Mersenne(PyObject *args, Mersenne *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Mersenne, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Mersenne::Mersenne(unsigned long int seed)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
      Mersenne *return_value = new Mersenne((unsigned long int)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_Mersenne(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Mersenne) {
    printf("Mersenne ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Mersenne *local_this = (Mersenne *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Mersenne) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Mersenne(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Mersenne) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OmniBoundingVolume
 */
/**
 * Python function wrapper for:
 * static TypeHandle OmniBoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_OmniBoundingVolume_get_class_type_674(PyObject *, PyObject *) {
  // 1-static TypeHandle OmniBoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OmniBoundingVolume::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OmniBoundingVolume_get_class_type_674_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OmniBoundingVolume_get_class_type_674_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OmniBoundingVolume::OmniBoundingVolume(void)
 */
static int Dtool_Init_OmniBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OmniBoundingVolume() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline OmniBoundingVolume::OmniBoundingVolume(void)
  OmniBoundingVolume *return_value = new OmniBoundingVolume();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OmniBoundingVolume, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OmniBoundingVolume()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OmniBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OmniBoundingVolume) {
    printf("OmniBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OmniBoundingVolume *local_this = (OmniBoundingVolume *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OmniBoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OmniBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OmniBoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (OmniBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (OmniBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OmniBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OmniBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OmniBoundingVolume*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class UnionBoundingVolume
 */
/**
 * Python function wrapper for:
 * inline int UnionBoundingVolume::get_num_components(void) const
 */
static PyObject *Dtool_UnionBoundingVolume_get_num_components_681(PyObject *self, PyObject *) {
  UnionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnionBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int UnionBoundingVolume::get_num_components(void) const
  int return_value = (*(const UnionBoundingVolume*)local_this).get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_get_num_components_681_comment =
  "C++ Interface:\n"
  "get_num_components(UnionBoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Returns the number of components in the union.\n"
  " */";
#else
static const char *Dtool_UnionBoundingVolume_get_num_components_681_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline GeometricBoundingVolume const *UnionBoundingVolume::get_component(int n) const
 */
static PyObject *Dtool_UnionBoundingVolume_get_component_682(PyObject *self, PyObject *arg) {
  UnionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnionBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline GeometricBoundingVolume const *UnionBoundingVolume::get_component(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    GeometricBoundingVolume const *return_value = (*(const UnionBoundingVolume*)local_this).get_component((int)arg_val);
    if (return_value != (GeometricBoundingVolume const *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (GeometricBoundingVolume const *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeometricBoundingVolume, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(UnionBoundingVolume self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_get_component_682_comment =
  "C++ Interface:\n"
  "get_component(UnionBoundingVolume self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth component in the union.\n"
  " */";
#else
static const char *Dtool_UnionBoundingVolume_get_component_682_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void UnionBoundingVolume::clear_components(void)
 */
static PyObject *Dtool_UnionBoundingVolume_clear_components_685(PyObject *self, PyObject *) {
  UnionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnionBoundingVolume, (void **)&local_this, "UnionBoundingVolume.clear_components")) {
    return NULL;
  }
  // 1-void UnionBoundingVolume::clear_components(void)
  (*local_this).clear_components();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_clear_components_685_comment =
  "C++ Interface:\n"
  "clear_components(const UnionBoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Removes all components from the volume.\n"
  " */";
#else
static const char *Dtool_UnionBoundingVolume_clear_components_685_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void UnionBoundingVolume::add_component(GeometricBoundingVolume const *component)
 */
static PyObject *Dtool_UnionBoundingVolume_add_component_686(PyObject *self, PyObject *arg) {
  UnionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnionBoundingVolume, (void **)&local_this, "UnionBoundingVolume.add_component")) {
    return NULL;
  }
  // 1-void UnionBoundingVolume::add_component(GeometricBoundingVolume const *component)
  GeometricBoundingVolume const *arg_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeometricBoundingVolume, 1, "UnionBoundingVolume.add_component", true, true);
  if (arg_this != NULL) {
    (*local_this).add_component(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_component(const UnionBoundingVolume self, const GeometricBoundingVolume component)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_add_component_686_comment =
  "C++ Interface:\n"
  "add_component(const UnionBoundingVolume self, const GeometricBoundingVolume component)\n"
  "\n"
  "/**\n"
  " * Adds a new component to the volume.  This does not necessarily increase the\n"
  " * total number of components by one, and you may or may not be able to find\n"
  " * this component in the volume by a subsequent call to get_component();\n"
  " * certain optimizations may prevent the component from being added, or have\n"
  " * other unexpected effects on the total set of components.\n"
  " */";
#else
static const char *Dtool_UnionBoundingVolume_add_component_686_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void UnionBoundingVolume::filter_intersection(BoundingVolume const *volume)
 */
static PyObject *Dtool_UnionBoundingVolume_filter_intersection_687(PyObject *self, PyObject *arg) {
  UnionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnionBoundingVolume, (void **)&local_this, "UnionBoundingVolume.filter_intersection")) {
    return NULL;
  }
  // 1-void UnionBoundingVolume::filter_intersection(BoundingVolume const *volume)
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "UnionBoundingVolume.filter_intersection", true, true);
  if (arg_this != NULL) {
    (*local_this).filter_intersection(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "filter_intersection(const UnionBoundingVolume self, const BoundingVolume volume)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_filter_intersection_687_comment =
  "C++ Interface:\n"
  "filter_intersection(const UnionBoundingVolume self, const BoundingVolume volume)\n"
  "\n"
  "/**\n"
  " * Removes from the union any components that have no intersection with the\n"
  " * indicated volume.\n"
  " */";
#else
static const char *Dtool_UnionBoundingVolume_filter_intersection_687_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UnionBoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_UnionBoundingVolume_get_class_type_688(PyObject *, PyObject *) {
  // 1-static TypeHandle UnionBoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(UnionBoundingVolume::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_get_class_type_688_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UnionBoundingVolume_get_class_type_688_comment = NULL;
#endif

/**
 * sequence length function for property UnionBoundingVolume::components
 */
static Py_ssize_t Dtool_UnionBoundingVolume_components_Len(PyObject *self) {
  UnionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnionBoundingVolume, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_components();
}

/**
 * sequence getter for property UnionBoundingVolume::components
 */
static PyObject *Dtool_UnionBoundingVolume_components_Getitem(PyObject *self, Py_ssize_t index) {
  UnionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnionBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_components()) {
    PyErr_SetString(PyExc_IndexError, "UnionBoundingVolume.components[] index out of range");
    return NULL;
  }
  // 1-inline GeometricBoundingVolume const *UnionBoundingVolume::get_component(int n) const
  GeometricBoundingVolume const *return_value = (*(const UnionBoundingVolume*)local_this).get_component(index);
  if (return_value != (GeometricBoundingVolume const *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (GeometricBoundingVolume const *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeometricBoundingVolume, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(UnionBoundingVolume self, index)\n");
  }
}

static PyObject *Dtool_UnionBoundingVolume_components_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_UnionBoundingVolume_components_Len;
  wrap->_getitem_func = &Dtool_UnionBoundingVolume_components_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline UnionBoundingVolume::UnionBoundingVolume(void)
 */
static int Dtool_Init_UnionBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "UnionBoundingVolume() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline UnionBoundingVolume::UnionBoundingVolume(void)
  UnionBoundingVolume *return_value = new UnionBoundingVolume();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnionBoundingVolume, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UnionBoundingVolume()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_UnionBoundingVolume_get_components(PyObject *self, PyObject *) {
  UnionBoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnionBoundingVolume, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_components();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_UnionBoundingVolume_get_component_682(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_UnionBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_UnionBoundingVolume) {
    printf("UnionBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  UnionBoundingVolume *local_this = (UnionBoundingVolume *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_UnionBoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_UnionBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_UnionBoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (UnionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (UnionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (UnionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (UnionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (UnionBoundingVolume*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Randomizer
 */
/**
 * Python function wrapper for:
 * inline void Randomizer::operator =(Randomizer const &copy)
 */
static PyObject *Dtool_Randomizer_operator_692(PyObject *self, PyObject *arg) {
  Randomizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Randomizer, (void **)&local_this, "Randomizer.assign")) {
    return NULL;
  }
  // 1-inline void Randomizer::operator =(Randomizer const &copy)
  Randomizer const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Randomizer(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Randomizer.assign", "Randomizer");
  }
  (*local_this).operator =(*arg_this);
  Randomizer *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Randomizer, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Randomizer self, const Randomizer copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_operator_692_comment =
  "C++ Interface:\n"
  "assign(const Randomizer self, const Randomizer copy)\n";
#else
static const char *Dtool_Randomizer_operator_692_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Randomizer::random_int(int range)
 */
static PyObject *Dtool_Randomizer_random_int_693(PyObject *self, PyObject *arg) {
  Randomizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Randomizer, (void **)&local_this, "Randomizer.random_int")) {
    return NULL;
  }
  // 1-inline int Randomizer::random_int(int range)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*local_this).random_int((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "random_int(const Randomizer self, int range)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_random_int_693_comment =
  "C++ Interface:\n"
  "random_int(const Randomizer self, int range)\n"
  "\n"
  "/**\n"
  " * Returns a random integer in the range [0, range).\n"
  " */";
#else
static const char *Dtool_Randomizer_random_int_693_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double Randomizer::random_real(double range)
 */
static PyObject *Dtool_Randomizer_random_real_694(PyObject *self, PyObject *arg) {
  Randomizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Randomizer, (void **)&local_this, "Randomizer.random_real")) {
    return NULL;
  }
  // 1-inline double Randomizer::random_real(double range)
  if (PyNumber_Check(arg)) {
    double return_value = (*local_this).random_real(PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "random_real(const Randomizer self, double range)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_random_real_694_comment =
  "C++ Interface:\n"
  "random_real(const Randomizer self, double range)\n"
  "\n"
  "/**\n"
  " * Returns a random double in the range [0, range).\n"
  " */";
#else
static const char *Dtool_Randomizer_random_real_694_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double Randomizer::random_real_unit(void)
 */
static PyObject *Dtool_Randomizer_random_real_unit_695(PyObject *self, PyObject *) {
  Randomizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Randomizer, (void **)&local_this, "Randomizer.random_real_unit")) {
    return NULL;
  }
  // 1-inline double Randomizer::random_real_unit(void)
  double return_value = (*local_this).random_real_unit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_random_real_unit_695_comment =
  "C++ Interface:\n"
  "random_real_unit(const Randomizer self)\n"
  "\n"
  "/**\n"
  " * Returns a random double in the range [-0.5, 0.5).\n"
  " */";
#else
static const char *Dtool_Randomizer_random_real_unit_695_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline unsigned long int Randomizer::get_next_seed(void)
 */
static PyObject *Dtool_Randomizer_get_next_seed_696(PyObject *, PyObject *) {
  // 1-static inline unsigned long int Randomizer::get_next_seed(void)
  unsigned long int return_value = Randomizer::get_next_seed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_get_next_seed_696_comment =
  "C++ Interface:\n"
  "get_next_seed()\n"
  "\n"
  "/**\n"
  " * Returns a random seed value for the next global Randomizer object.\n"
  " */";
#else
static const char *Dtool_Randomizer_get_next_seed_696_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int Randomizer::get_seed(void)
 */
static PyObject *Dtool_Randomizer_get_seed_697(PyObject *self, PyObject *) {
  Randomizer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Randomizer, (void **)&local_this, "Randomizer.get_seed")) {
    return NULL;
  }
  // 1-inline unsigned long int Randomizer::get_seed(void)
  unsigned long int return_value = (*local_this).get_seed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_get_seed_697_comment =
  "C++ Interface:\n"
  "get_seed(const Randomizer self)\n"
  "\n"
  "/**\n"
  " * Returns a unique seed value based on the seed value passed to this\n"
  " * Randomizer object (and on its current state).\n"
  " */";
#else
static const char *Dtool_Randomizer_get_seed_697_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Randomizer::Randomizer(Randomizer const &copy)
 * inline Randomizer::Randomizer(unsigned long int seed = 0)
 */
static int Dtool_Init_Randomizer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Randomizer::Randomizer(unsigned long int seed)
      Randomizer *return_value = new Randomizer();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Randomizer, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Randomizer::Randomizer(Randomizer const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Randomizer", (char **)keyword_list, &param0)) {
          Randomizer const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Randomizer, (void **)&param0_this);
          if (param0_this != NULL) {
            Randomizer *return_value = new Randomizer(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Randomizer, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline Randomizer::Randomizer(unsigned long int seed)
        unsigned long param0;
        static const char *keyword_list[] = {"seed", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "k:Randomizer", (char **)keyword_list, &param0)) {
          Randomizer *return_value = new Randomizer((unsigned long int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Randomizer, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline Randomizer::Randomizer(Randomizer const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Randomizer", (char **)keyword_list, &param0)) {
          Randomizer const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_Randomizer(param0, param0_this, param0_manage)) {
            Randomizer *return_value = new Randomizer(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Randomizer, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline Randomizer::Randomizer(unsigned long int seed)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Randomizer() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Randomizer()\n"
      "Randomizer(const Randomizer copy)\n"
      "Randomizer(int seed)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Randomizer(PyObject *args, Randomizer const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Randomizer, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Randomizer::Randomizer(unsigned long int seed)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
      Randomizer *return_value = new Randomizer((unsigned long int)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_Randomizer(PyObject *args, Randomizer *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Randomizer, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Randomizer::Randomizer(unsigned long int seed)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
      Randomizer *return_value = new Randomizer((unsigned long int)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_Randomizer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Randomizer) {
    printf("Randomizer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Randomizer *local_this = (Randomizer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Randomizer) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Randomizer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Randomizer) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PerlinNoise
 */
/**
 * Python function wrapper for:
 * inline unsigned long int PerlinNoise::get_seed(void)
 */
static PyObject *Dtool_PerlinNoise_get_seed_700(PyObject *self, PyObject *) {
  PerlinNoise *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PerlinNoise, (void **)&local_this, "PerlinNoise.get_seed")) {
    return NULL;
  }
  // 1-inline unsigned long int PerlinNoise::get_seed(void)
  unsigned long int return_value = (*local_this).get_seed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise_get_seed_700_comment =
  "C++ Interface:\n"
  "get_seed(const PerlinNoise self)\n"
  "\n"
  "/**\n"
  " * Returns a unique seed value based on the seed value passed to this\n"
  " * PerlinNoise object (and on its current state).\n"
  " */";
#else
static const char *Dtool_PerlinNoise_get_seed_700_comment = NULL;
#endif

static int Dtool_Init_PerlinNoise(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PerlinNoise(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PerlinNoise) {
    printf("PerlinNoise ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PerlinNoise *local_this = (PerlinNoise *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PerlinNoise) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PerlinNoise(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PerlinNoise) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PerlinNoise2
 */
/**
 * Python function wrapper for:
 * inline void PerlinNoise2::operator =(PerlinNoise2 const &copy)
 */
static PyObject *Dtool_PerlinNoise2_operator_704(PyObject *self, PyObject *arg) {
  PerlinNoise2 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PerlinNoise2, (void **)&local_this, "PerlinNoise2.assign")) {
    return NULL;
  }
  // 1-inline void PerlinNoise2::operator =(PerlinNoise2 const &copy)
  PerlinNoise2 const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_PerlinNoise2(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PerlinNoise2.assign", "PerlinNoise2");
  }
  (*local_this).operator =(*arg_this);
  PerlinNoise2 *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PerlinNoise2, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PerlinNoise2 self, const PerlinNoise2 copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise2_operator_704_comment =
  "C++ Interface:\n"
  "assign(const PerlinNoise2 self, const PerlinNoise2 copy)\n";
#else
static const char *Dtool_PerlinNoise2_operator_704_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PerlinNoise2::set_scale(LVecBase2d const &scale)
 * inline void PerlinNoise2::set_scale(LVecBase2f const &scale)
 * inline void PerlinNoise2::set_scale(double scale)
 * inline void PerlinNoise2::set_scale(double sx, double sy)
 */
static PyObject *Dtool_PerlinNoise2_set_scale_705(PyObject *self, PyObject *args, PyObject *kwds) {
  PerlinNoise2 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PerlinNoise2, (void **)&local_this, "PerlinNoise2.set_scale")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "scale");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'scale' (pos 1) not found");
      }
      {
        // -2 inline void PerlinNoise2::set_scale(LVecBase2d const &scale)
        LVecBase2d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
        if (arg_this != NULL) {
          (*local_this).set_scale(*arg_this);
          return Dtool_Return_None();
        }
      }

      {
        // -2 inline void PerlinNoise2::set_scale(LVecBase2f const &scale)
        LVecBase2f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
        if (arg_this != NULL) {
          (*local_this).set_scale(*arg_this);
          return Dtool_Return_None();
        }
      }

      {
        // -2 inline void PerlinNoise2::set_scale(double scale)
        if (PyNumber_Check(arg)) {
          (*local_this).set_scale(PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }

      {
        // -2 inline void PerlinNoise2::set_scale(LVecBase2d const &scale)
        LVecBase2d arg_local;
        LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
        if ((arg_this != NULL)) {
          (*local_this).set_scale(*arg_this);
          return Dtool_Return_None();
        }
      }

      {
        // -2 inline void PerlinNoise2::set_scale(LVecBase2f const &scale)
        LVecBase2f arg_local;
        LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if ((arg_this != NULL)) {
          (*local_this).set_scale(*arg_this);
          return Dtool_Return_None();
        }
      }

      // No coercion possible: inline void PerlinNoise2::set_scale(double scale)
    }
    break;
  case 2:
    {
      // 1-inline void PerlinNoise2::set_scale(double sx, double sy)
      double param1;
      double param2;
      static const char *keyword_list[] = {"sx", "sy", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:set_scale", (char **)keyword_list, &param1, &param2)) {
        (*local_this).set_scale((double)param1, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_scale() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale(const PerlinNoise2 self, const LVecBase2d scale)\n"
      "set_scale(const PerlinNoise2 self, const LVecBase2f scale)\n"
      "set_scale(const PerlinNoise2 self, double scale)\n"
      "set_scale(const PerlinNoise2 self, double sx, double sy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise2_set_scale_705_comment =
  "C++ Interface:\n"
  "set_scale(const PerlinNoise2 self, const LVecBase2d scale)\n"
  "set_scale(const PerlinNoise2 self, const LVecBase2f scale)\n"
  "set_scale(const PerlinNoise2 self, double scale)\n"
  "set_scale(const PerlinNoise2 self, double sx, double sy)\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */";
#else
static const char *Dtool_PerlinNoise2_set_scale_705_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double PerlinNoise2::noise(LVecBase2d const &value) const
 * inline float PerlinNoise2::noise(LVecBase2f const &value) const
 * inline double PerlinNoise2::noise(double x, double y) const
 */
static PyObject *Dtool_PerlinNoise2_noise_706(PyObject *self, PyObject *args, PyObject *kwds) {
  PerlinNoise2 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PerlinNoise2, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "value");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
      }
      {
        // -2 inline float PerlinNoise2::noise(LVecBase2f const &value) const
        LVecBase2f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
        if (arg_this != NULL) {
          float return_value = (*(const PerlinNoise2*)local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 double PerlinNoise2::noise(LVecBase2d const &value) const
        LVecBase2d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
        if (arg_this != NULL) {
          double return_value = (*(const PerlinNoise2*)local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline float PerlinNoise2::noise(LVecBase2f const &value) const
        LVecBase2f arg_local;
        LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if ((arg_this != NULL)) {
          float return_value = (*(const PerlinNoise2*)local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 double PerlinNoise2::noise(LVecBase2d const &value) const
        LVecBase2d arg_local;
        LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
        if ((arg_this != NULL)) {
          double return_value = (*(const PerlinNoise2*)local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

    }
    break;
  case 2:
    {
      // 1-inline double PerlinNoise2::noise(double x, double y) const
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:noise", (char **)keyword_list, &param1, &param2)) {
        double return_value = (*(const PerlinNoise2*)local_this).noise((double)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "noise() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "noise(PerlinNoise2 self, const LVecBase2f value)\n"
      "noise(PerlinNoise2 self, const LVecBase2d value)\n"
      "noise(PerlinNoise2 self, double x, double y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise2_noise_706_comment =
  "C++ Interface:\n"
  "noise(PerlinNoise2 self, const LVecBase2f value)\n"
  "noise(PerlinNoise2 self, const LVecBase2d value)\n"
  "noise(PerlinNoise2 self, double x, double y)\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */";
#else
static const char *Dtool_PerlinNoise2_noise_706_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PerlinNoise2::PerlinNoise2(void)
 * inline PerlinNoise2::PerlinNoise2(PerlinNoise2 const &copy)
 * inline PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size = 256, unsigned long int seed = 0)
 */
static int Dtool_Init_PerlinNoise2(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PerlinNoise2::PerlinNoise2(void)
      PerlinNoise2 *return_value = new PerlinNoise2();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise2, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline PerlinNoise2::PerlinNoise2(PerlinNoise2 const &copy)
      PerlinNoise2 const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_PerlinNoise2(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "PerlinNoise2.PerlinNoise2", "PerlinNoise2");
        return -1;
      }
      PerlinNoise2 *return_value = new PerlinNoise2(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise2, true, false);
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      // 1-inline PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      int param2 = 256;
      unsigned long param3 = 0;
      static const char *keyword_list[] = {"sx", "sy", "table_size", "seed", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd|ik:PerlinNoise2", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        PerlinNoise2 *return_value = new PerlinNoise2((double)param0, (double)param1, (int)param2, (unsigned long int)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise2, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PerlinNoise2() takes 0, 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PerlinNoise2()\n"
      "PerlinNoise2(const PerlinNoise2 copy)\n"
      "PerlinNoise2(double sx, double sy, int table_size, int seed)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PerlinNoise2(PyObject *args, PerlinNoise2 const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PerlinNoise2, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      // 1-inline PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      int param2 = 256;
      unsigned long param3 = 0;
      if (PyArg_ParseTuple(args, "dd|ik:PerlinNoise2", &param0, &param1, &param2, &param3)) {
        PerlinNoise2 *return_value = new PerlinNoise2((double)param0, (double)param1, (int)param2, (unsigned long int)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PerlinNoise2(PyObject *args, PerlinNoise2 *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PerlinNoise2, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      // 1-inline PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      int param2 = 256;
      unsigned long param3 = 0;
      if (PyArg_ParseTuple(args, "dd|ik:PerlinNoise2", &param0, &param1, &param2, &param3)) {
        PerlinNoise2 *return_value = new PerlinNoise2((double)param0, (double)param1, (int)param2, (unsigned long int)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PerlinNoise2(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PerlinNoise2) {
    printf("PerlinNoise2 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PerlinNoise2 *local_this = (PerlinNoise2 *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PerlinNoise2) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PerlinNoise) {
    return (PerlinNoise *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PerlinNoise2(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PerlinNoise2) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PerlinNoise) {
    PerlinNoise* other_this = (PerlinNoise*)from_this;
    return (PerlinNoise2*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PerlinNoise3
 */
/**
 * Python function wrapper for:
 * inline void PerlinNoise3::operator =(PerlinNoise3 const &copy)
 */
static PyObject *Dtool_PerlinNoise3_operator_711(PyObject *self, PyObject *arg) {
  PerlinNoise3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PerlinNoise3, (void **)&local_this, "PerlinNoise3.assign")) {
    return NULL;
  }
  // 1-inline void PerlinNoise3::operator =(PerlinNoise3 const &copy)
  PerlinNoise3 const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_PerlinNoise3(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PerlinNoise3.assign", "PerlinNoise3");
  }
  (*local_this).operator =(*arg_this);
  PerlinNoise3 *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PerlinNoise3, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PerlinNoise3 self, const PerlinNoise3 copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise3_operator_711_comment =
  "C++ Interface:\n"
  "assign(const PerlinNoise3 self, const PerlinNoise3 copy)\n";
#else
static const char *Dtool_PerlinNoise3_operator_711_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PerlinNoise3::set_scale(LVecBase3d const &scale)
 * inline void PerlinNoise3::set_scale(LVecBase3f const &scale)
 * inline void PerlinNoise3::set_scale(double scale)
 * inline void PerlinNoise3::set_scale(double sx, double sy, double sz)
 */
static PyObject *Dtool_PerlinNoise3_set_scale_712(PyObject *self, PyObject *args, PyObject *kwds) {
  PerlinNoise3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PerlinNoise3, (void **)&local_this, "PerlinNoise3.set_scale")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "scale");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'scale' (pos 1) not found");
      }
      {
        // -2 inline void PerlinNoise3::set_scale(LVecBase3f const &scale)
        LVecBase3f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
        if (arg_this != NULL) {
          (*local_this).set_scale(*arg_this);
          return Dtool_Return_None();
        }
      }

      {
        // -2 inline void PerlinNoise3::set_scale(LVecBase3d const &scale)
        LVecBase3d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
        if (arg_this != NULL) {
          (*local_this).set_scale(*arg_this);
          return Dtool_Return_None();
        }
      }

      {
        // -2 inline void PerlinNoise3::set_scale(double scale)
        if (PyNumber_Check(arg)) {
          (*local_this).set_scale(PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }

      {
        // -2 inline void PerlinNoise3::set_scale(LVecBase3f const &scale)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if ((arg_this != NULL)) {
          (*local_this).set_scale(*arg_this);
          return Dtool_Return_None();
        }
      }

      {
        // -2 inline void PerlinNoise3::set_scale(LVecBase3d const &scale)
        LVecBase3d arg_local;
        LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
        if ((arg_this != NULL)) {
          (*local_this).set_scale(*arg_this);
          return Dtool_Return_None();
        }
      }

      // No coercion possible: inline void PerlinNoise3::set_scale(double scale)
    }
    break;
  case 3:
    {
      // 1-inline void PerlinNoise3::set_scale(double sx, double sy, double sz)
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"sx", "sy", "sz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:set_scale", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_scale((double)param1, (double)param2, (double)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_scale() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale(const PerlinNoise3 self, const LVecBase3f scale)\n"
      "set_scale(const PerlinNoise3 self, const LVecBase3d scale)\n"
      "set_scale(const PerlinNoise3 self, double scale)\n"
      "set_scale(const PerlinNoise3 self, double sx, double sy, double sz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise3_set_scale_712_comment =
  "C++ Interface:\n"
  "set_scale(const PerlinNoise3 self, const LVecBase3f scale)\n"
  "set_scale(const PerlinNoise3 self, const LVecBase3d scale)\n"
  "set_scale(const PerlinNoise3 self, double scale)\n"
  "set_scale(const PerlinNoise3 self, double sx, double sy, double sz)\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */";
#else
static const char *Dtool_PerlinNoise3_set_scale_712_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double PerlinNoise3::noise(LVecBase3d const &value) const
 * inline float PerlinNoise3::noise(LVecBase3f const &value) const
 * inline double PerlinNoise3::noise(double x, double y, double z) const
 */
static PyObject *Dtool_PerlinNoise3_noise_713(PyObject *self, PyObject *args, PyObject *kwds) {
  PerlinNoise3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PerlinNoise3, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "value");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
      }
      {
        // -2 double PerlinNoise3::noise(LVecBase3d const &value) const
        LVecBase3d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
        if (arg_this != NULL) {
          double return_value = (*(const PerlinNoise3*)local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline float PerlinNoise3::noise(LVecBase3f const &value) const
        LVecBase3f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
        if (arg_this != NULL) {
          float return_value = (*(const PerlinNoise3*)local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 double PerlinNoise3::noise(LVecBase3d const &value) const
        LVecBase3d arg_local;
        LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
        if ((arg_this != NULL)) {
          double return_value = (*(const PerlinNoise3*)local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline float PerlinNoise3::noise(LVecBase3f const &value) const
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if ((arg_this != NULL)) {
          float return_value = (*(const PerlinNoise3*)local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

    }
    break;
  case 3:
    {
      // 1-inline double PerlinNoise3::noise(double x, double y, double z) const
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:noise", (char **)keyword_list, &param1, &param2, &param3)) {
        double return_value = (*(const PerlinNoise3*)local_this).noise((double)param1, (double)param2, (double)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "noise() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "noise(PerlinNoise3 self, const LVecBase3d value)\n"
      "noise(PerlinNoise3 self, const LVecBase3f value)\n"
      "noise(PerlinNoise3 self, double x, double y, double z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise3_noise_713_comment =
  "C++ Interface:\n"
  "noise(PerlinNoise3 self, const LVecBase3d value)\n"
  "noise(PerlinNoise3 self, const LVecBase3f value)\n"
  "noise(PerlinNoise3 self, double x, double y, double z)\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */";
#else
static const char *Dtool_PerlinNoise3_noise_713_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PerlinNoise3::PerlinNoise3(void)
 * inline PerlinNoise3::PerlinNoise3(PerlinNoise3 const &copy)
 * inline PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size = 256, unsigned long int seed = 0)
 */
static int Dtool_Init_PerlinNoise3(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PerlinNoise3::PerlinNoise3(void)
      PerlinNoise3 *return_value = new PerlinNoise3();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise3, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline PerlinNoise3::PerlinNoise3(PerlinNoise3 const &copy)
      PerlinNoise3 const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_PerlinNoise3(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "PerlinNoise3.PerlinNoise3", "PerlinNoise3");
        return -1;
      }
      PerlinNoise3 *return_value = new PerlinNoise3(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise3, true, false);
    }
    break;
  case 3:
  case 4:
  case 5:
    {
      // 1-inline PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      double param2;
      int param3 = 256;
      unsigned long param4 = 0;
      static const char *keyword_list[] = {"sx", "sy", "sz", "table_size", "seed", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd|ik:PerlinNoise3", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        PerlinNoise3 *return_value = new PerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (unsigned long int)param4);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise3, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PerlinNoise3() takes 0, 1, 3, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PerlinNoise3()\n"
      "PerlinNoise3(const PerlinNoise3 copy)\n"
      "PerlinNoise3(double sx, double sy, double sz, int table_size, int seed)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PerlinNoise3(PyObject *args, PerlinNoise3 const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PerlinNoise3, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 5) {
      // 1-inline PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      double param2;
      int param3 = 256;
      unsigned long param4 = 0;
      if (PyArg_ParseTuple(args, "ddd|ik:PerlinNoise3", &param0, &param1, &param2, &param3, &param4)) {
        PerlinNoise3 *return_value = new PerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (unsigned long int)param4);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PerlinNoise3(PyObject *args, PerlinNoise3 *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PerlinNoise3, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 5) {
      // 1-inline PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      double param2;
      int param3 = 256;
      unsigned long param4 = 0;
      if (PyArg_ParseTuple(args, "ddd|ik:PerlinNoise3", &param0, &param1, &param2, &param3, &param4)) {
        PerlinNoise3 *return_value = new PerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (unsigned long int)param4);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PerlinNoise3(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PerlinNoise3) {
    printf("PerlinNoise3 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PerlinNoise3 *local_this = (PerlinNoise3 *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PerlinNoise3) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PerlinNoise) {
    return (PerlinNoise *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PerlinNoise3(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PerlinNoise3) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PerlinNoise) {
    PerlinNoise* other_this = (PerlinNoise*)from_this;
    return (PerlinNoise3*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class StackedPerlinNoise2
 */
/**
 * Python function wrapper for:
 * void StackedPerlinNoise2::operator =(StackedPerlinNoise2 const &copy)
 */
static PyObject *Dtool_StackedPerlinNoise2_operator_775(PyObject *self, PyObject *arg) {
  StackedPerlinNoise2 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise2, (void **)&local_this, "StackedPerlinNoise2.assign")) {
    return NULL;
  }
  // 1-void StackedPerlinNoise2::operator =(StackedPerlinNoise2 const &copy)
  StackedPerlinNoise2 const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_StackedPerlinNoise2(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "StackedPerlinNoise2.assign", "StackedPerlinNoise2");
  }
  (*local_this).operator =(*arg_this);
  StackedPerlinNoise2 *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StackedPerlinNoise2, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const StackedPerlinNoise2 self, const StackedPerlinNoise2 copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise2_operator_775_comment =
  "C++ Interface:\n"
  "assign(const StackedPerlinNoise2 self, const StackedPerlinNoise2 copy)\n";
#else
static const char *Dtool_StackedPerlinNoise2_operator_775_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void StackedPerlinNoise2::add_level(PerlinNoise2 const &level, double amp = 1.0)
 */
static PyObject *Dtool_StackedPerlinNoise2_add_level_776(PyObject *self, PyObject *args, PyObject *kwds) {
  StackedPerlinNoise2 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise2, (void **)&local_this, "StackedPerlinNoise2.add_level")) {
    return NULL;
  }
  // 1-void StackedPerlinNoise2::add_level(PerlinNoise2 const &level, double amp = 1.0)
  PyObject *param1;
  double param2 = 1.0;
  static const char *keyword_list[] = {"level", "amp", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:add_level", (char **)keyword_list, &param1, &param2)) {
    PerlinNoise2 const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_PerlinNoise2(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "StackedPerlinNoise2.add_level", "PerlinNoise2");
    }
    (*local_this).add_level(*param1_this, (double)param2);
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_level(const StackedPerlinNoise2 self, const PerlinNoise2 level, double amp)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise2_add_level_776_comment =
  "C++ Interface:\n"
  "add_level(const StackedPerlinNoise2 self, const PerlinNoise2 level, double amp)\n"
  "\n"
  "/**\n"
  " * Adds an arbitrary PerlinNoise2 object, and an associated amplitude, to the\n"
  " * stack.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise2_add_level_776_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void StackedPerlinNoise2::clear(void)
 */
static PyObject *Dtool_StackedPerlinNoise2_clear_777(PyObject *self, PyObject *) {
  StackedPerlinNoise2 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise2, (void **)&local_this, "StackedPerlinNoise2.clear")) {
    return NULL;
  }
  // 1-void StackedPerlinNoise2::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise2_clear_777_comment =
  "C++ Interface:\n"
  "clear(const StackedPerlinNoise2 self)\n"
  "\n"
  "/**\n"
  " * Removes all levels from the stack.  You must call add_level() again to\n"
  " * restore them.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise2_clear_777_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double StackedPerlinNoise2::noise(LVecBase2d const &value)
 * inline float StackedPerlinNoise2::noise(LVecBase2f const &value)
 * inline double StackedPerlinNoise2::noise(double x, double y)
 */
static PyObject *Dtool_StackedPerlinNoise2_noise_778(PyObject *self, PyObject *args, PyObject *kwds) {
  StackedPerlinNoise2 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise2, (void **)&local_this, "StackedPerlinNoise2.noise")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "value");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
      }
      {
        // -2 inline float StackedPerlinNoise2::noise(LVecBase2f const &value)
        LVecBase2f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
        if (arg_this != NULL) {
          float return_value = (*local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 double StackedPerlinNoise2::noise(LVecBase2d const &value)
        LVecBase2d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
        if (arg_this != NULL) {
          double return_value = (*local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline float StackedPerlinNoise2::noise(LVecBase2f const &value)
        LVecBase2f arg_local;
        LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if ((arg_this != NULL)) {
          float return_value = (*local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 double StackedPerlinNoise2::noise(LVecBase2d const &value)
        LVecBase2d arg_local;
        LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
        if ((arg_this != NULL)) {
          double return_value = (*local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

    }
    break;
  case 2:
    {
      // 1-inline double StackedPerlinNoise2::noise(double x, double y)
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:noise", (char **)keyword_list, &param1, &param2)) {
        double return_value = (*local_this).noise((double)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "noise() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "noise(const StackedPerlinNoise2 self, const LVecBase2f value)\n"
      "noise(const StackedPerlinNoise2 self, const LVecBase2d value)\n"
      "noise(const StackedPerlinNoise2 self, double x, double y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise2_noise_778_comment =
  "C++ Interface:\n"
  "noise(const StackedPerlinNoise2 self, const LVecBase2f value)\n"
  "noise(const StackedPerlinNoise2 self, const LVecBase2d value)\n"
  "noise(const StackedPerlinNoise2 self, double x, double y)\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise2_noise_778_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline StackedPerlinNoise2::StackedPerlinNoise2(void)
 * StackedPerlinNoise2::StackedPerlinNoise2(StackedPerlinNoise2 const &copy)
 * StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels = 2, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
 */
static int Dtool_Init_StackedPerlinNoise2(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline StackedPerlinNoise2::StackedPerlinNoise2(void)
      StackedPerlinNoise2 *return_value = new StackedPerlinNoise2();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise2, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-StackedPerlinNoise2::StackedPerlinNoise2(StackedPerlinNoise2 const &copy)
      StackedPerlinNoise2 const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_StackedPerlinNoise2(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "StackedPerlinNoise2.StackedPerlinNoise2", "StackedPerlinNoise2");
        return -1;
      }
      StackedPerlinNoise2 *return_value = new StackedPerlinNoise2(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise2, true, false);
    }
    break;
  case 2:
  case 3:
  case 4:
  case 5:
  case 6:
  case 7:
    {
      // 1-StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels = 2, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      int param2 = 2;
      double param3 = 4.0;
      double param4 = 0.5;
      int param5 = 256;
      unsigned long param6 = 0;
      static const char *keyword_list[] = {"sx", "sy", "num_levels", "scale_factor", "amp_scale", "table_size", "seed", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd|iddik:StackedPerlinNoise2", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        StackedPerlinNoise2 *return_value = new StackedPerlinNoise2((double)param0, (double)param1, (int)param2, (double)param3, (double)param4, (int)param5, (unsigned long int)param6);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise2, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "StackedPerlinNoise2() takes 0, 1, 2, 3, 4, 5, 6 or 7 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StackedPerlinNoise2()\n"
      "StackedPerlinNoise2(const StackedPerlinNoise2 copy)\n"
      "StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor, double amp_scale, int table_size, int seed)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_StackedPerlinNoise2(PyObject *args, StackedPerlinNoise2 const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StackedPerlinNoise2, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 7) {
      // 1-StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels = 2, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      int param2 = 2;
      double param3 = 4.0;
      double param4 = 0.5;
      int param5 = 256;
      unsigned long param6 = 0;
      if (PyArg_ParseTuple(args, "dd|iddik:StackedPerlinNoise2", &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        StackedPerlinNoise2 *return_value = new StackedPerlinNoise2((double)param0, (double)param1, (int)param2, (double)param3, (double)param4, (int)param5, (unsigned long int)param6);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_StackedPerlinNoise2(PyObject *args, StackedPerlinNoise2 *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StackedPerlinNoise2, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 7) {
      // 1-StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels = 2, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      int param2 = 2;
      double param3 = 4.0;
      double param4 = 0.5;
      int param5 = 256;
      unsigned long param6 = 0;
      if (PyArg_ParseTuple(args, "dd|iddik:StackedPerlinNoise2", &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        StackedPerlinNoise2 *return_value = new StackedPerlinNoise2((double)param0, (double)param1, (int)param2, (double)param3, (double)param4, (int)param5, (unsigned long int)param6);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_StackedPerlinNoise2(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_StackedPerlinNoise2) {
    printf("StackedPerlinNoise2 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  StackedPerlinNoise2 *local_this = (StackedPerlinNoise2 *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_StackedPerlinNoise2) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_StackedPerlinNoise2(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_StackedPerlinNoise2) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class StackedPerlinNoise3
 */
/**
 * Python function wrapper for:
 * void StackedPerlinNoise3::operator =(StackedPerlinNoise3 const &copy)
 */
static PyObject *Dtool_StackedPerlinNoise3_operator_783(PyObject *self, PyObject *arg) {
  StackedPerlinNoise3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise3, (void **)&local_this, "StackedPerlinNoise3.assign")) {
    return NULL;
  }
  // 1-void StackedPerlinNoise3::operator =(StackedPerlinNoise3 const &copy)
  StackedPerlinNoise3 const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_StackedPerlinNoise3(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "StackedPerlinNoise3.assign", "StackedPerlinNoise3");
  }
  (*local_this).operator =(*arg_this);
  StackedPerlinNoise3 *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StackedPerlinNoise3, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const StackedPerlinNoise3 self, const StackedPerlinNoise3 copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise3_operator_783_comment =
  "C++ Interface:\n"
  "assign(const StackedPerlinNoise3 self, const StackedPerlinNoise3 copy)\n";
#else
static const char *Dtool_StackedPerlinNoise3_operator_783_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void StackedPerlinNoise3::add_level(PerlinNoise3 const &level, double amp = 1.0)
 */
static PyObject *Dtool_StackedPerlinNoise3_add_level_784(PyObject *self, PyObject *args, PyObject *kwds) {
  StackedPerlinNoise3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise3, (void **)&local_this, "StackedPerlinNoise3.add_level")) {
    return NULL;
  }
  // 1-void StackedPerlinNoise3::add_level(PerlinNoise3 const &level, double amp = 1.0)
  PyObject *param1;
  double param2 = 1.0;
  static const char *keyword_list[] = {"level", "amp", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:add_level", (char **)keyword_list, &param1, &param2)) {
    PerlinNoise3 const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_PerlinNoise3(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "StackedPerlinNoise3.add_level", "PerlinNoise3");
    }
    (*local_this).add_level(*param1_this, (double)param2);
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_level(const StackedPerlinNoise3 self, const PerlinNoise3 level, double amp)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise3_add_level_784_comment =
  "C++ Interface:\n"
  "add_level(const StackedPerlinNoise3 self, const PerlinNoise3 level, double amp)\n"
  "\n"
  "/**\n"
  " * Adds an arbitrary PerlinNoise3 object, and an associated amplitude, to the\n"
  " * stack.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise3_add_level_784_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void StackedPerlinNoise3::clear(void)
 */
static PyObject *Dtool_StackedPerlinNoise3_clear_785(PyObject *self, PyObject *) {
  StackedPerlinNoise3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise3, (void **)&local_this, "StackedPerlinNoise3.clear")) {
    return NULL;
  }
  // 1-void StackedPerlinNoise3::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise3_clear_785_comment =
  "C++ Interface:\n"
  "clear(const StackedPerlinNoise3 self)\n"
  "\n"
  "/**\n"
  " * Removes all levels from the stack.  You must call add_level() again to\n"
  " * restore them.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise3_clear_785_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double StackedPerlinNoise3::noise(LVecBase3d const &value)
 * inline float StackedPerlinNoise3::noise(LVecBase3f const &value)
 * inline double StackedPerlinNoise3::noise(double x, double y, double z)
 */
static PyObject *Dtool_StackedPerlinNoise3_noise_786(PyObject *self, PyObject *args, PyObject *kwds) {
  StackedPerlinNoise3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise3, (void **)&local_this, "StackedPerlinNoise3.noise")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "value");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
      }
      {
        // -2 inline float StackedPerlinNoise3::noise(LVecBase3f const &value)
        LVecBase3f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
        if (arg_this != NULL) {
          float return_value = (*local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 double StackedPerlinNoise3::noise(LVecBase3d const &value)
        LVecBase3d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
        if (arg_this != NULL) {
          double return_value = (*local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline float StackedPerlinNoise3::noise(LVecBase3f const &value)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if ((arg_this != NULL)) {
          float return_value = (*local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 double StackedPerlinNoise3::noise(LVecBase3d const &value)
        LVecBase3d arg_local;
        LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
        if ((arg_this != NULL)) {
          double return_value = (*local_this).noise(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

    }
    break;
  case 3:
    {
      // 1-inline double StackedPerlinNoise3::noise(double x, double y, double z)
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:noise", (char **)keyword_list, &param1, &param2, &param3)) {
        double return_value = (*local_this).noise((double)param1, (double)param2, (double)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "noise() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "noise(const StackedPerlinNoise3 self, const LVecBase3f value)\n"
      "noise(const StackedPerlinNoise3 self, const LVecBase3d value)\n"
      "noise(const StackedPerlinNoise3 self, double x, double y, double z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise3_noise_786_comment =
  "C++ Interface:\n"
  "noise(const StackedPerlinNoise3 self, const LVecBase3f value)\n"
  "noise(const StackedPerlinNoise3 self, const LVecBase3d value)\n"
  "noise(const StackedPerlinNoise3 self, double x, double y, double z)\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise3_noise_786_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline StackedPerlinNoise3::StackedPerlinNoise3(void)
 * StackedPerlinNoise3::StackedPerlinNoise3(StackedPerlinNoise3 const &copy)
 * StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels = 3, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
 */
static int Dtool_Init_StackedPerlinNoise3(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline StackedPerlinNoise3::StackedPerlinNoise3(void)
      StackedPerlinNoise3 *return_value = new StackedPerlinNoise3();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise3, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-StackedPerlinNoise3::StackedPerlinNoise3(StackedPerlinNoise3 const &copy)
      StackedPerlinNoise3 const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_StackedPerlinNoise3(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "StackedPerlinNoise3.StackedPerlinNoise3", "StackedPerlinNoise3");
        return -1;
      }
      StackedPerlinNoise3 *return_value = new StackedPerlinNoise3(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise3, true, false);
    }
    break;
  case 3:
  case 4:
  case 5:
  case 6:
  case 7:
  case 8:
    {
      // 1-StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels = 3, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      double param2;
      int param3 = 3;
      double param4 = 4.0;
      double param5 = 0.5;
      int param6 = 256;
      unsigned long param7 = 0;
      static const char *keyword_list[] = {"sx", "sy", "sz", "num_levels", "scale_factor", "amp_scale", "table_size", "seed", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd|iddik:StackedPerlinNoise3", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        StackedPerlinNoise3 *return_value = new StackedPerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (double)param4, (double)param5, (int)param6, (unsigned long int)param7);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise3, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "StackedPerlinNoise3() takes 0, 1, 3, 4, 5, 6, 7 or 8 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StackedPerlinNoise3()\n"
      "StackedPerlinNoise3(const StackedPerlinNoise3 copy)\n"
      "StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor, double amp_scale, int table_size, int seed)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_StackedPerlinNoise3(PyObject *args, StackedPerlinNoise3 const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StackedPerlinNoise3, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 8) {
      // 1-StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels = 3, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      double param2;
      int param3 = 3;
      double param4 = 4.0;
      double param5 = 0.5;
      int param6 = 256;
      unsigned long param7 = 0;
      if (PyArg_ParseTuple(args, "ddd|iddik:StackedPerlinNoise3", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        StackedPerlinNoise3 *return_value = new StackedPerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (double)param4, (double)param5, (int)param6, (unsigned long int)param7);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_StackedPerlinNoise3(PyObject *args, StackedPerlinNoise3 *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StackedPerlinNoise3, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 8) {
      // 1-StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels = 3, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      double param2;
      int param3 = 3;
      double param4 = 4.0;
      double param5 = 0.5;
      int param6 = 256;
      unsigned long param7 = 0;
      if (PyArg_ParseTuple(args, "ddd|iddik:StackedPerlinNoise3", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        StackedPerlinNoise3 *return_value = new StackedPerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (double)param4, (double)param5, (int)param6, (unsigned long int)param7);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_StackedPerlinNoise3(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_StackedPerlinNoise3) {
    printf("StackedPerlinNoise3 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  StackedPerlinNoise3 *local_this = (StackedPerlinNoise3 *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_StackedPerlinNoise3) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_StackedPerlinNoise3(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_StackedPerlinNoise3) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Triangulator
 */
/**
 * Python function wrapper for:
 * void Triangulator::clear(void)
 */
static PyObject *Dtool_Triangulator_clear_791(PyObject *self, PyObject *) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.clear")) {
    return NULL;
  }
  // 1-void Triangulator::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_clear_791_comment =
  "C++ Interface:\n"
  "clear(const Triangulator self)\n"
  "\n"
  "/**\n"
  " * Removes all vertices and polygon specifications from the Triangulator, and\n"
  " * prepares it to start over.\n"
  " */";
#else
static const char *Dtool_Triangulator_clear_791_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Triangulator::add_vertex(LPoint2d const &point)
 * inline int Triangulator::add_vertex(double x, double y)
 */
static PyObject *Dtool_Triangulator_add_vertex_792(PyObject *self, PyObject *args, PyObject *kwds) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.add_vertex")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "point");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'point' (pos 1) not found");
      }
      // 1-int Triangulator::add_vertex(LPoint2d const &point)
      LPoint2d arg_local;
      LPoint2d const *arg_this = Dtool_Coerce_LPoint2d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "Triangulator.add_vertex", "LPoint2d");
      }
      int return_value = (*local_this).add_vertex(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-inline int Triangulator::add_vertex(double x, double y)
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:add_vertex", (char **)keyword_list, &param1, &param2)) {
        int return_value = (*local_this).add_vertex((double)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_vertex() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const Triangulator self, const LPoint2d point)\n"
      "add_vertex(const Triangulator self, double x, double y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_add_vertex_792_comment =
  "C++ Interface:\n"
  "add_vertex(const Triangulator self, const LPoint2d point)\n"
  "add_vertex(const Triangulator self, double x, double y)\n"
  "\n"
  "/**\n"
  " * Adds a new vertex to the vertex pool.  Returns the vertex index number.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new vertex to the vertex pool.  Returns the vertex index number.\n"
  " */";
#else
static const char *Dtool_Triangulator_add_vertex_792_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Triangulator::get_num_vertices(void) const
 */
static PyObject *Dtool_Triangulator_get_num_vertices_793(PyObject *self, PyObject *) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int Triangulator::get_num_vertices(void) const
  int return_value = (*(const Triangulator*)local_this).get_num_vertices();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_num_vertices_793_comment =
  "C++ Interface:\n"
  "get_num_vertices(Triangulator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices in the pool.  Note that the Triangulator\n"
  " * might append new vertices, in addition to those added by the user, if any\n"
  " * of the polygon is self-intersecting, or if any of the holes intersect some\n"
  " * part of the polygon edges.\n"
  " */";
#else
static const char *Dtool_Triangulator_get_num_vertices_793_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2d const &Triangulator::get_vertex(int n) const
 */
static PyObject *Dtool_Triangulator_get_vertex_794(PyObject *self, PyObject *arg) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2d const &Triangulator::get_vertex(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint2d const *return_value = &((*(const Triangulator*)local_this).get_vertex((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(Triangulator self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_vertex_794_comment =
  "C++ Interface:\n"
  "get_vertex(Triangulator self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex.\n"
  " */";
#else
static const char *Dtool_Triangulator_get_vertex_794_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Triangulator::clear_polygon(void)
 */
static PyObject *Dtool_Triangulator_clear_polygon_799(PyObject *self, PyObject *) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.clear_polygon")) {
    return NULL;
  }
  // 1-void Triangulator::clear_polygon(void)
  (*local_this).clear_polygon();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_clear_polygon_799_comment =
  "C++ Interface:\n"
  "clear_polygon(const Triangulator self)\n"
  "\n"
  "/**\n"
  " * Removes the current polygon definition (and its set of holes), but does not\n"
  " * clear the vertex pool.\n"
  " */";
#else
static const char *Dtool_Triangulator_clear_polygon_799_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Triangulator::add_polygon_vertex(int index)
 */
static PyObject *Dtool_Triangulator_add_polygon_vertex_800(PyObject *self, PyObject *arg) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.add_polygon_vertex")) {
    return NULL;
  }
  // 1-void Triangulator::add_polygon_vertex(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_polygon_vertex((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_polygon_vertex(const Triangulator self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_add_polygon_vertex_800_comment =
  "C++ Interface:\n"
  "add_polygon_vertex(const Triangulator self, int index)\n"
  "\n"
  "/**\n"
  " * Adds the next consecutive vertex of the polygon.  This vertex should index\n"
  " * into the vertex pool established by repeated calls to add_vertex().\n"
  " *\n"
  " * The vertices may be listed in either clockwise or counterclockwise order.\n"
  " * Vertices should not be repeated.  In particular, do not repeat the first\n"
  " * vertex at the end.\n"
  " */";
#else
static const char *Dtool_Triangulator_add_polygon_vertex_800_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Triangulator::is_left_winding(void) const
 */
static PyObject *Dtool_Triangulator_is_left_winding_801(PyObject *self, PyObject *) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Triangulator::is_left_winding(void) const
  bool return_value = (*(const Triangulator*)local_this).is_left_winding();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_is_left_winding_801_comment =
  "C++ Interface:\n"
  "is_left_winding(Triangulator self)\n"
  "\n"
  "/**\n"
  " * Returns true if the polygon vertices are listed in counterclockwise order,\n"
  " * or false if they appear to be listed in clockwise order.\n"
  " */";
#else
static const char *Dtool_Triangulator_is_left_winding_801_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Triangulator::begin_hole(void)
 */
static PyObject *Dtool_Triangulator_begin_hole_802(PyObject *self, PyObject *) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.begin_hole")) {
    return NULL;
  }
  // 1-void Triangulator::begin_hole(void)
  (*local_this).begin_hole();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_begin_hole_802_comment =
  "C++ Interface:\n"
  "begin_hole(const Triangulator self)\n"
  "\n"
  "/**\n"
  " * Finishes the previous hole, if any, and prepares to add a new hole.\n"
  " */";
#else
static const char *Dtool_Triangulator_begin_hole_802_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Triangulator::add_hole_vertex(int index)
 */
static PyObject *Dtool_Triangulator_add_hole_vertex_803(PyObject *self, PyObject *arg) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.add_hole_vertex")) {
    return NULL;
  }
  // 1-void Triangulator::add_hole_vertex(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_hole_vertex((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hole_vertex(const Triangulator self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_add_hole_vertex_803_comment =
  "C++ Interface:\n"
  "add_hole_vertex(const Triangulator self, int index)\n"
  "\n"
  "/**\n"
  " * Adds the next consecutive vertex of the current hole.  This vertex should\n"
  " * index into the vertex pool established by repeated calls to add_vertex().\n"
  " *\n"
  " * The vertices may be listed in either clockwise or counterclockwise order.\n"
  " * Vertices should not be repeated.\n"
  " */";
#else
static const char *Dtool_Triangulator_add_hole_vertex_803_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Triangulator::triangulate(void)
 */
static PyObject *Dtool_Triangulator_triangulate_804(PyObject *self, PyObject *) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.triangulate")) {
    return NULL;
  }
  // 1-void Triangulator::triangulate(void)
  (*local_this).triangulate();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_triangulate_804_comment =
  "C++ Interface:\n"
  "triangulate(const Triangulator self)\n"
  "\n"
  "/**\n"
  " * Does the work of triangulating the specified polygon.  After this call, you\n"
  " * may retrieve the new triangles one at a time by iterating through\n"
  " * get_triangle_v0/1/2().\n"
  " */";
#else
static const char *Dtool_Triangulator_triangulate_804_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Triangulator::get_num_triangles(void) const
 */
static PyObject *Dtool_Triangulator_get_num_triangles_805(PyObject *self, PyObject *) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return NULL;
  }
  // 1-int Triangulator::get_num_triangles(void) const
  int return_value = (*(const Triangulator*)local_this).get_num_triangles();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_num_triangles_805_comment =
  "C++ Interface:\n"
  "get_num_triangles(Triangulator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of triangles generated by the previous call to\n"
  " * triangulate().\n"
  " */";
#else
static const char *Dtool_Triangulator_get_num_triangles_805_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Triangulator::get_triangle_v0(int n) const
 */
static PyObject *Dtool_Triangulator_get_triangle_v0_806(PyObject *self, PyObject *arg) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return NULL;
  }
  // 1-int Triangulator::get_triangle_v0(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const Triangulator*)local_this).get_triangle_v0((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle_v0(Triangulator self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_triangle_v0_806_comment =
  "C++ Interface:\n"
  "get_triangle_v0(Triangulator self, int n)\n"
  "\n"
  "/**\n"
  " * Returns vertex 0 of the nth triangle generated by the previous call to\n"
  " * triangulate().\n"
  " *\n"
  " * This is a zero-based index into the vertices added by repeated calls to\n"
  " * add_vertex().\n"
  " */";
#else
static const char *Dtool_Triangulator_get_triangle_v0_806_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Triangulator::get_triangle_v1(int n) const
 */
static PyObject *Dtool_Triangulator_get_triangle_v1_807(PyObject *self, PyObject *arg) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return NULL;
  }
  // 1-int Triangulator::get_triangle_v1(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const Triangulator*)local_this).get_triangle_v1((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle_v1(Triangulator self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_triangle_v1_807_comment =
  "C++ Interface:\n"
  "get_triangle_v1(Triangulator self, int n)\n"
  "\n"
  "/**\n"
  " * Returns vertex 1 of the nth triangle generated by the previous call to\n"
  " * triangulate().\n"
  " *\n"
  " * This is a zero-based index into the vertices added by repeated calls to\n"
  " * add_vertex().\n"
  " */";
#else
static const char *Dtool_Triangulator_get_triangle_v1_807_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Triangulator::get_triangle_v2(int n) const
 */
static PyObject *Dtool_Triangulator_get_triangle_v2_808(PyObject *self, PyObject *arg) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return NULL;
  }
  // 1-int Triangulator::get_triangle_v2(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const Triangulator*)local_this).get_triangle_v2((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle_v2(Triangulator self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_triangle_v2_808_comment =
  "C++ Interface:\n"
  "get_triangle_v2(Triangulator self, int n)\n"
  "\n"
  "/**\n"
  " * Returns vertex 2 of the nth triangle generated by the previous call to\n"
  " * triangulate().\n"
  " *\n"
  " * This is a zero-based index into the vertices added by repeated calls to\n"
  " * add_vertex().\n"
  " */";
#else
static const char *Dtool_Triangulator_get_triangle_v2_808_comment = NULL;
#endif

/**
 * sequence length function for property Triangulator::vertices
 */
static Py_ssize_t Dtool_Triangulator_vertices_Len(PyObject *self) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_vertices();
}

/**
 * sequence getter for property Triangulator::vertices
 */
static PyObject *Dtool_Triangulator_vertices_Getitem(PyObject *self, Py_ssize_t index) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_vertices()) {
    PyErr_SetString(PyExc_IndexError, "Triangulator.vertices[] index out of range");
    return NULL;
  }
  // 1-inline LPoint2d const &Triangulator::get_vertex(int n) const
  LPoint2d const *return_value = &((*(const Triangulator*)local_this).get_vertex(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(Triangulator self, index)\n");
  }
}

static PyObject *Dtool_Triangulator_vertices_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_Triangulator_vertices_Len;
  wrap->_getitem_func = &Dtool_Triangulator_vertices_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * Triangulator::Triangulator(void)
 * inline Triangulator::Triangulator(Triangulator const &) = default
 */
static int Dtool_Init_Triangulator(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-Triangulator::Triangulator(void)
      Triangulator *return_value = new Triangulator();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Triangulator, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Triangulator::Triangulator(Triangulator const &) = default
      Triangulator const *arg_this = (Triangulator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Triangulator, 0, "Triangulator.Triangulator", true, true);
      if (arg_this != NULL) {
        Triangulator *return_value = new Triangulator(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Triangulator, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Triangulator() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Triangulator()\n"
      "Triangulator(const Triangulator param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Triangulator_get_vertices(PyObject *self, PyObject *) {
  Triangulator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_vertices();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Triangulator_get_vertex_794(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Triangulator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Triangulator) {
    printf("Triangulator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Triangulator *local_this = (Triangulator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Triangulator) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Triangulator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Triangulator) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Triangulator3
 */
/**
 * Python function wrapper for:
 * void Triangulator3::clear(void)
 */
static PyObject *Dtool_Triangulator3_clear_812(PyObject *self, PyObject *) {
  Triangulator3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator3, (void **)&local_this, "Triangulator3.clear")) {
    return NULL;
  }
  // 1-void Triangulator3::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_clear_812_comment =
  "C++ Interface:\n"
  "clear(const Triangulator3 self)\n"
  "\n"
  "/**\n"
  " * Removes all vertices and polygon specifications from the Triangulator, and\n"
  " * prepares it to start over.\n"
  " */";
#else
static const char *Dtool_Triangulator3_clear_812_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Triangulator3::add_vertex(LPoint3d const &point)
 * inline int Triangulator3::add_vertex(double x, double y, double z)
 */
static PyObject *Dtool_Triangulator3_add_vertex_813(PyObject *self, PyObject *args, PyObject *kwds) {
  Triangulator3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator3, (void **)&local_this, "Triangulator3.add_vertex")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "point");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'point' (pos 1) not found");
      }
      // 1-int Triangulator3::add_vertex(LPoint3d const &point)
      LPoint3d arg_local;
      LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "Triangulator3.add_vertex", "LPoint3d");
      }
      int return_value = (*local_this).add_vertex(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 3:
    {
      // 1-inline int Triangulator3::add_vertex(double x, double y, double z)
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:add_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
        int return_value = (*local_this).add_vertex((double)param1, (double)param2, (double)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_vertex() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const Triangulator3 self, const LPoint3d point)\n"
      "add_vertex(const Triangulator3 self, double x, double y, double z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_add_vertex_813_comment =
  "C++ Interface:\n"
  "add_vertex(const Triangulator3 self, const LPoint3d point)\n"
  "add_vertex(const Triangulator3 self, double x, double y, double z)\n"
  "\n"
  "/**\n"
  " * Adds a new vertex to the vertex pool.  Returns the vertex index number.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new vertex to the vertex pool.  Returns the vertex index number.\n"
  " */";
#else
static const char *Dtool_Triangulator3_add_vertex_813_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Triangulator3::get_num_vertices(void) const
 */
static PyObject *Dtool_Triangulator3_get_num_vertices_814(PyObject *self, PyObject *) {
  Triangulator3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator3, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int Triangulator3::get_num_vertices(void) const
  int return_value = (*(const Triangulator3*)local_this).get_num_vertices();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_get_num_vertices_814_comment =
  "C++ Interface:\n"
  "get_num_vertices(Triangulator3 self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices in the pool.  Note that the Triangulator\n"
  " * might append new vertices, in addition to those added by the user, if any\n"
  " * of the polygon is self-intersecting, or if any of the holes intersect some\n"
  " * part of the polygon edges.\n"
  " */";
#else
static const char *Dtool_Triangulator3_get_num_vertices_814_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d const &Triangulator3::get_vertex(int n) const
 */
static PyObject *Dtool_Triangulator3_get_vertex_815(PyObject *self, PyObject *arg) {
  Triangulator3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator3, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3d const &Triangulator3::get_vertex(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3d const *return_value = &((*(const Triangulator3*)local_this).get_vertex((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(Triangulator3 self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_get_vertex_815_comment =
  "C++ Interface:\n"
  "get_vertex(Triangulator3 self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex.\n"
  " */";
#else
static const char *Dtool_Triangulator3_get_vertex_815_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Triangulator3::triangulate(void)
 */
static PyObject *Dtool_Triangulator3_triangulate_817(PyObject *self, PyObject *) {
  Triangulator3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator3, (void **)&local_this, "Triangulator3.triangulate")) {
    return NULL;
  }
  // 1-void Triangulator3::triangulate(void)
  (*local_this).triangulate();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_triangulate_817_comment =
  "C++ Interface:\n"
  "triangulate(const Triangulator3 self)\n"
  "\n"
  "/**\n"
  " * Does the work of triangulating the specified polygon.  After this call, you\n"
  " * may retrieve the new triangles one at a time by iterating through\n"
  " * get_triangle_v0/1/2().\n"
  " */";
#else
static const char *Dtool_Triangulator3_triangulate_817_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPlaned const &Triangulator3::get_plane(void) const
 */
static PyObject *Dtool_Triangulator3_get_plane_818(PyObject *self, PyObject *) {
  Triangulator3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator3, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPlaned const &Triangulator3::get_plane(void) const
  LPlaned const *return_value = &((*(const Triangulator3*)local_this).get_plane());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_get_plane_818_comment =
  "C++ Interface:\n"
  "get_plane(Triangulator3 self)\n"
  "\n"
  "/**\n"
  " * Returns the plane of the polygon.  This is only available after calling\n"
  " * triangulate().\n"
  " */";
#else
static const char *Dtool_Triangulator3_get_plane_818_comment = NULL;
#endif

/**
 * sequence length function for property Triangulator3::vertices
 */
static Py_ssize_t Dtool_Triangulator3_vertices_Len(PyObject *self) {
  Triangulator3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator3, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_vertices();
}

/**
 * sequence getter for property Triangulator3::vertices
 */
static PyObject *Dtool_Triangulator3_vertices_Getitem(PyObject *self, Py_ssize_t index) {
  Triangulator3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator3, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_vertices()) {
    PyErr_SetString(PyExc_IndexError, "Triangulator3.vertices[] index out of range");
    return NULL;
  }
  // 1-inline LPoint3d const &Triangulator3::get_vertex(int n) const
  LPoint3d const *return_value = &((*(const Triangulator3*)local_this).get_vertex(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(Triangulator3 self, index)\n");
  }
}

static PyObject *Dtool_Triangulator3_vertices_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_Triangulator3_vertices_Len;
  wrap->_getitem_func = &Dtool_Triangulator3_vertices_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static PyObject *Dtool_Triangulator3_plane_Getter(PyObject *self, void *) {
  const Triangulator3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator3, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPlaned const &Triangulator3::get_plane(void) const
  LPlaned const *return_value = &((*(const Triangulator3*)local_this).get_plane());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, false, true);
}

/**
 * Python function wrapper for:
 * Triangulator3::Triangulator3(void)
 * inline Triangulator3::Triangulator3(Triangulator3 const &) = default
 */
static int Dtool_Init_Triangulator3(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-Triangulator3::Triangulator3(void)
      Triangulator3 *return_value = new Triangulator3();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Triangulator3, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Triangulator3::Triangulator3(Triangulator3 const &) = default
      Triangulator3 const *arg_this = (Triangulator3 *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Triangulator3, 0, "Triangulator3.Triangulator3", true, true);
      if (arg_this != NULL) {
        Triangulator3 *return_value = new Triangulator3(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Triangulator3, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Triangulator3() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Triangulator3()\n"
      "Triangulator3(const Triangulator3 param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Triangulator3_get_vertices(PyObject *self, PyObject *) {
  Triangulator3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator3, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_vertices();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Triangulator3_get_vertex_815(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Triangulator3(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Triangulator3) {
    printf("Triangulator3 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Triangulator3 *local_this = (Triangulator3 *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Triangulator3) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Triangulator) {
    return (Triangulator *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Triangulator3(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Triangulator3) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Triangulator) {
    Triangulator* other_this = (Triangulator*)from_this;
    return (Triangulator3*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for ConstPointerToArray_LMatrix3d (ConstPointerToArray_LMatrix3d)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LMatrix3d[] = {
  {"get_element", &Dtool_ConstPointerToArray_LMatrix3d_get_element_10, METH_O, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_element_10_comment},
  {"getElement", &Dtool_ConstPointerToArray_LMatrix3d_get_element_10, METH_O, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_element_10_comment},
  {"get_data", &Dtool_ConstPointerToArray_LMatrix3d_get_data_12, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_data_12_comment},
  {"getData", &Dtool_ConstPointerToArray_LMatrix3d_get_data_12, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_data_12_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LMatrix3d_get_subdata_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_subdata_13_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LMatrix3d_get_subdata_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_subdata_13_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_14, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_14_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_14, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_14_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_15, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_15_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_15, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_15_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LMatrix3d_getbuffer_16_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LMatrix3d > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LMatrix3d_releasebuffer_17_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LMatrix3d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_getitem_11_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LMatrix3d index out of range");
    return NULL;
  }
  // 1-LMatrix3d const &ConstPointerToArray< LMatrix3d >::__getitem__(unsigned long int n) const
  LMatrix3d const *return_value = &(invoke_extension((const ConstPointerToArray< LMatrix3d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LMatrix3d_size_9_sq_length(PyObject *self) {
  ConstPointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LMatrix3d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LMatrix3d = {
  &Dtool_ConstPointerToArray_LMatrix3d_size_9_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_LMatrix3d_getitem_11_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LMatrix3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LMatrix3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LMatrix3d_getbuffer_16_bf_getbuffer,
  &Dtool_ConstPointerToArray_LMatrix3d_releasebuffer_17_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LMatrix3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_LMatrix3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LMatrix3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_LMatrix3d,
    &Dtool_SequenceMethods_ConstPointerToArray_LMatrix3d,
    &Dtool_MappingMethods_ConstPointerToArray_LMatrix3d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_LMatrix3d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_LMatrix3d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LMatrix3d,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LMatrix3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d,
  Dtool_UpcastInterface_ConstPointerToArray_LMatrix3d,
  Dtool_DowncastInterface_ConstPointerToArray_LMatrix3d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LMatrix3d,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d(NULL);
    Dtool_ConstPointerToArray_LMatrix3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3d);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LMatrix3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LMatrix3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LMatrix3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  }
}

/**
 * Python method tables for PointerToArrayBase_LMatrix3d (PointerToArrayBase_LMatrix3d)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LMatrix3d[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LMatrix3d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LMatrix3d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LMatrix3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LMatrix3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LMatrix3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_LMatrix3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LMatrix3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_LMatrix3d,
    &Dtool_SequenceMethods_PointerToArrayBase_LMatrix3d,
    &Dtool_MappingMethods_PointerToArrayBase_LMatrix3d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_LMatrix3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_LMatrix3d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LMatrix3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LMatrix3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d,
  Dtool_UpcastInterface_PointerToArrayBase_LMatrix3d,
  Dtool_DowncastInterface_PointerToArrayBase_LMatrix3d,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3d(NULL);
    Dtool_PointerToArrayBase_LMatrix3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LMatrix3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LMatrix3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3d);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LMatrix3d (PointerToBase_ReferenceCountedVector_LMatrix3d)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LMatrix3d[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_clear_5, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_clear_5_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_output_6, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_output_6_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LMatrix3d
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3d(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LMatrix3d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LMatrix3d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LMatrix3d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LMatrix3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LMatrix3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LMatrix3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LMatrix3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3d,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LMatrix3d,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LMatrix3d,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LMatrix3d,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3d,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LMatrix3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LMatrix3d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LMatrix3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LMatrix3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3d,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LMatrix3d,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LMatrix3d,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LMatrix3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d);
  }
}

/**
 * Python method tables for ConstPointerToArray_LMatrix3f (ConstPointerToArray_LMatrix3f)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LMatrix3f[] = {
  {"get_element", &Dtool_ConstPointerToArray_LMatrix3f_get_element_27, METH_O, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_element_27_comment},
  {"getElement", &Dtool_ConstPointerToArray_LMatrix3f_get_element_27, METH_O, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_element_27_comment},
  {"get_data", &Dtool_ConstPointerToArray_LMatrix3f_get_data_29, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_data_29_comment},
  {"getData", &Dtool_ConstPointerToArray_LMatrix3f_get_data_29, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_data_29_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LMatrix3f_get_subdata_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_subdata_30_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LMatrix3f_get_subdata_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_subdata_30_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_31, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_31_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_31, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_31_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_32, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_32_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_32, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_32_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LMatrix3f_getbuffer_33_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LMatrix3f > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LMatrix3f_releasebuffer_34_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LMatrix3f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_getitem_28_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LMatrix3f index out of range");
    return NULL;
  }
  // 1-LMatrix3f const &ConstPointerToArray< LMatrix3f >::__getitem__(unsigned long int n) const
  LMatrix3f const *return_value = &(invoke_extension((const ConstPointerToArray< LMatrix3f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LMatrix3f_size_26_sq_length(PyObject *self) {
  ConstPointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LMatrix3f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LMatrix3f = {
  &Dtool_ConstPointerToArray_LMatrix3f_size_26_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_LMatrix3f_getitem_28_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LMatrix3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LMatrix3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LMatrix3f_getbuffer_33_bf_getbuffer,
  &Dtool_ConstPointerToArray_LMatrix3f_releasebuffer_34_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LMatrix3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_LMatrix3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LMatrix3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_LMatrix3f,
    &Dtool_SequenceMethods_ConstPointerToArray_LMatrix3f,
    &Dtool_MappingMethods_ConstPointerToArray_LMatrix3f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_LMatrix3f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_LMatrix3f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LMatrix3f,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LMatrix3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f,
  Dtool_UpcastInterface_ConstPointerToArray_LMatrix3f,
  Dtool_DowncastInterface_ConstPointerToArray_LMatrix3f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LMatrix3f,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(NULL);
    Dtool_ConstPointerToArray_LMatrix3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3f);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LMatrix3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LMatrix3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LMatrix3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  }
}

/**
 * Python method tables for PointerToArrayBase_LMatrix3f (PointerToArrayBase_LMatrix3f)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LMatrix3f[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LMatrix3f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LMatrix3f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LMatrix3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LMatrix3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LMatrix3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_LMatrix3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LMatrix3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_LMatrix3f,
    &Dtool_SequenceMethods_PointerToArrayBase_LMatrix3f,
    &Dtool_MappingMethods_PointerToArrayBase_LMatrix3f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_LMatrix3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_LMatrix3f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LMatrix3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LMatrix3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f,
  Dtool_UpcastInterface_PointerToArrayBase_LMatrix3f,
  Dtool_DowncastInterface_PointerToArrayBase_LMatrix3f,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f(NULL);
    Dtool_PointerToArrayBase_LMatrix3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LMatrix3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LMatrix3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3f);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LMatrix3f (PointerToBase_ReferenceCountedVector_LMatrix3f)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LMatrix3f[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_22, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_22_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_23, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_23_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LMatrix3f
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LMatrix3f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LMatrix3f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LMatrix3f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LMatrix3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LMatrix3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LMatrix3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LMatrix3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3f,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LMatrix3f,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LMatrix3f,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LMatrix3f,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3f,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LMatrix3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LMatrix3f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LMatrix3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LMatrix3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LMatrix3f,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LMatrix3f,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LMatrix3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase2d (ConstPointerToArray_LVecBase2d)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase2d[] = {
  {"get_element", &Dtool_ConstPointerToArray_LVecBase2d_get_element_44, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_element_44_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase2d_get_element_44, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_element_44_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase2d_get_data_46, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_data_46_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase2d_get_data_46, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_data_46_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2d_get_subdata_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_subdata_47_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2d_get_subdata_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_subdata_47_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_48, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_48_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_48, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_48_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_49, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_49_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_49, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_49_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase2d_getbuffer_50_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase2d > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase2d_releasebuffer_51_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase2d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_getitem_45_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase2d index out of range");
    return NULL;
  }
  // 1-LVecBase2d const &ConstPointerToArray< LVecBase2d >::__getitem__(unsigned long int n) const
  LVecBase2d const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase2d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase2d_size_43_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase2d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase2d = {
  &Dtool_ConstPointerToArray_LVecBase2d_size_43_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_LVecBase2d_getitem_45_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase2d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase2d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase2d_getbuffer_50_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase2d_releasebuffer_51_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase2d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_LVecBase2d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase2d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase2d,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase2d,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase2d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase2d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_LVecBase2d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase2d,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase2d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase2d,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase2d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase2d,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d(NULL);
    Dtool_ConstPointerToArray_LVecBase2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2d);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase2d (PointerToArrayBase_LVecBase2d)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase2d[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase2d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase2d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase2d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase2d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase2d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_LVecBase2d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase2d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase2d,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase2d,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase2d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase2d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_LVecBase2d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase2d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase2d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase2d,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase2d,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2d(NULL);
    Dtool_PointerToArrayBase_LVecBase2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2d);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase2d (PointerToBase_ReferenceCountedVector_LVecBase2d)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2d[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_clear_39, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_clear_39_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_output_40, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_output_40_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase2d
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2d(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase2d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase2d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase2d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2d,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2d,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2d,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2d,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2d,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2d,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase2d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2d,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2d,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2d,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase2f (ConstPointerToArray_LVecBase2f)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase2f[] = {
  {"get_element", &Dtool_ConstPointerToArray_LVecBase2f_get_element_61, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_element_61_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase2f_get_element_61, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_element_61_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase2f_get_data_63, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_data_63_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase2f_get_data_63, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_data_63_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2f_get_subdata_64, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_subdata_64_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2f_get_subdata_64, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_subdata_64_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_65, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_65_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_65, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_65_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_66, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_66_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_66, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_66_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase2f_getbuffer_67_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase2f > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase2f_releasebuffer_68_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase2f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_getitem_62_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase2f index out of range");
    return NULL;
  }
  // 1-LVecBase2f const &ConstPointerToArray< LVecBase2f >::__getitem__(unsigned long int n) const
  LVecBase2f const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase2f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase2f_size_60_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase2f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase2f = {
  &Dtool_ConstPointerToArray_LVecBase2f_size_60_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_LVecBase2f_getitem_62_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase2f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase2f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase2f_getbuffer_67_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase2f_releasebuffer_68_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase2f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_LVecBase2f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase2f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase2f,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase2f,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase2f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase2f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_LVecBase2f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase2f,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase2f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase2f,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase2f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase2f,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(NULL);
    Dtool_ConstPointerToArray_LVecBase2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2f);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase2f (PointerToArrayBase_LVecBase2f)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase2f[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase2f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase2f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase2f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase2f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase2f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_LVecBase2f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase2f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase2f,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase2f,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase2f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase2f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_LVecBase2f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase2f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase2f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase2f,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase2f,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f(NULL);
    Dtool_PointerToArrayBase_LVecBase2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2f);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase2f (PointerToBase_ReferenceCountedVector_LVecBase2f)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2f[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_56, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_56_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_57, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_57_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase2f
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase2f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase2f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase2f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2f,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2f,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2f,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2f,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2f,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2f,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase2f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2f,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2f,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase2i (ConstPointerToArray_LVecBase2i)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase2i[] = {
  {"get_element", &Dtool_ConstPointerToArray_LVecBase2i_get_element_78, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_element_78_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase2i_get_element_78, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_element_78_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase2i_get_data_80, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_data_80_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase2i_get_data_80, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_data_80_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2i_get_subdata_81, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_subdata_81_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2i_get_subdata_81, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_subdata_81_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_82, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_82_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_82, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_82_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_83, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_83_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_83, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_83_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase2i_getbuffer_84_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase2i > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase2i_releasebuffer_85_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase2i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_getitem_79_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase2i index out of range");
    return NULL;
  }
  // 1-LVecBase2i const &ConstPointerToArray< LVecBase2i >::__getitem__(unsigned long int n) const
  LVecBase2i const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase2i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase2i_size_77_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase2i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase2i = {
  &Dtool_ConstPointerToArray_LVecBase2i_size_77_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_LVecBase2i_getitem_79_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase2i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase2i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase2i_getbuffer_84_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase2i_releasebuffer_85_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase2i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_LVecBase2i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase2i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase2i,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase2i,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase2i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase2i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_LVecBase2i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase2i,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase2i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2i,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase2i,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase2i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase2i,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i(NULL);
    Dtool_ConstPointerToArray_LVecBase2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2i);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase2i (PointerToArrayBase_LVecBase2i)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase2i[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase2i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase2i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase2i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase2i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase2i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_LVecBase2i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase2i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase2i,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase2i,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase2i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase2i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_LVecBase2i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase2i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase2i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase2i,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase2i,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2i(NULL);
    Dtool_PointerToArrayBase_LVecBase2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2i);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase2i (PointerToBase_ReferenceCountedVector_LVecBase2i)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2i[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_clear_73, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_clear_73_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_output_74, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_output_74_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase2i
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2i(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase2i > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase2i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase2i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2i,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2i,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2i,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2i,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2i,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2i,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase2i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2i,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2i,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2i,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase3d (ConstPointerToArray_LVecBase3d)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase3d[] = {
  {"get_element", &Dtool_ConstPointerToArray_LVecBase3d_get_element_95, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_element_95_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase3d_get_element_95, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_element_95_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase3d_get_data_97, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_data_97_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase3d_get_data_97, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_data_97_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3d_get_subdata_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_subdata_98_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3d_get_subdata_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_subdata_98_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_99, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_99_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_99, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_99_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_100, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_100_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_100, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_100_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase3d_getbuffer_101_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase3d > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase3d_releasebuffer_102_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase3d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_getitem_96_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase3d index out of range");
    return NULL;
  }
  // 1-LVecBase3d const &ConstPointerToArray< LVecBase3d >::__getitem__(unsigned long int n) const
  LVecBase3d const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase3d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase3d_size_94_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase3d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase3d = {
  &Dtool_ConstPointerToArray_LVecBase3d_size_94_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_LVecBase3d_getitem_96_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase3d_getbuffer_101_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase3d_releasebuffer_102_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_LVecBase3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase3d,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase3d,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase3d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase3d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_LVecBase3d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase3d,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase3d,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase3d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase3d,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d(NULL);
    Dtool_ConstPointerToArray_LVecBase3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3d);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase3d (PointerToArrayBase_LVecBase3d)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase3d[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase3d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase3d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_LVecBase3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase3d,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase3d,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase3d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_LVecBase3d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase3d,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase3d,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3d(NULL);
    Dtool_PointerToArrayBase_LVecBase3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3d);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase3d (PointerToBase_ReferenceCountedVector_LVecBase3d)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3d[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_clear_90, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_clear_90_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_output_91, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_output_91_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase3d
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3d(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase3d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3d,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3d,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3d,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3d,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3d,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3d,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3d,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3d,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase3f (ConstPointerToArray_LVecBase3f)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase3f[] = {
  {"get_element", &Dtool_ConstPointerToArray_LVecBase3f_get_element_112, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_element_112_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase3f_get_element_112, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_element_112_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase3f_get_data_114, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_data_114_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase3f_get_data_114, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_data_114_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3f_get_subdata_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_subdata_115_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3f_get_subdata_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_subdata_115_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_116, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_116_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_116, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_116_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_117, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_117_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_117, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_117_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase3f_getbuffer_118_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase3f > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase3f_releasebuffer_119_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase3f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_getitem_113_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase3f index out of range");
    return NULL;
  }
  // 1-LVecBase3f const &ConstPointerToArray< LVecBase3f >::__getitem__(unsigned long int n) const
  LVecBase3f const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase3f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase3f_size_111_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase3f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase3f = {
  &Dtool_ConstPointerToArray_LVecBase3f_size_111_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_LVecBase3f_getitem_113_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase3f_getbuffer_118_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase3f_releasebuffer_119_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_LVecBase3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase3f,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase3f,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase3f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase3f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_LVecBase3f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase3f,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase3f,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase3f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase3f,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(NULL);
    Dtool_ConstPointerToArray_LVecBase3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3f);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase3f (PointerToArrayBase_LVecBase3f)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase3f[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase3f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase3f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_LVecBase3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase3f,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase3f,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase3f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_LVecBase3f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase3f,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase3f,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f(NULL);
    Dtool_PointerToArrayBase_LVecBase3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3f);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase3f (PointerToBase_ReferenceCountedVector_LVecBase3f)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3f[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_107, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_107_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_108, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_108_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase3f
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase3f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3f,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3f,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3f,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3f,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3f,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3f,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3f,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase3i (ConstPointerToArray_LVecBase3i)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase3i[] = {
  {"get_element", &Dtool_ConstPointerToArray_LVecBase3i_get_element_129, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_element_129_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase3i_get_element_129, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_element_129_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase3i_get_data_131, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_data_131_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase3i_get_data_131, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_data_131_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3i_get_subdata_132, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_subdata_132_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3i_get_subdata_132, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_subdata_132_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_133, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_133_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_133, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_133_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_134, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_134_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_134, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_134_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase3i_getbuffer_135_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase3i > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase3i_releasebuffer_136_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase3i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_getitem_130_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase3i index out of range");
    return NULL;
  }
  // 1-LVecBase3i const &ConstPointerToArray< LVecBase3i >::__getitem__(unsigned long int n) const
  LVecBase3i const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase3i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase3i_size_128_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase3i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase3i = {
  &Dtool_ConstPointerToArray_LVecBase3i_size_128_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_LVecBase3i_getitem_130_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase3i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase3i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase3i_getbuffer_135_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase3i_releasebuffer_136_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase3i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_LVecBase3i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase3i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase3i,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase3i,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase3i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase3i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_LVecBase3i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase3i,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase3i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3i,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase3i,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase3i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase3i,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i(NULL);
    Dtool_ConstPointerToArray_LVecBase3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3i);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase3i (PointerToArrayBase_LVecBase3i)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase3i[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase3i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase3i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase3i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase3i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase3i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_LVecBase3i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase3i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase3i,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase3i,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase3i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase3i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_LVecBase3i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase3i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase3i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase3i,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase3i,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3i(NULL);
    Dtool_PointerToArrayBase_LVecBase3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3i);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase3i (PointerToBase_ReferenceCountedVector_LVecBase3i)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3i[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_clear_124, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_clear_124_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_output_125, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_output_125_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase3i
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3i(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase3i > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase3i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase3i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3i,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3i,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3i,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3i,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3i,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3i,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase3i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3i,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3i,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3i,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i);
  }
}

/**
 * Python method tables for ConstPointerToArray_UnalignedLMatrix4d (ConstPointerToArray_UnalignedLMatrix4d)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_UnalignedLMatrix4d[] = {
  {"get_element", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_146, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_146_comment},
  {"getElement", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_146, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_146_comment},
  {"get_data", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_148, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_148_comment},
  {"getData", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_148, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_148_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_149_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_149_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_150, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_150_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_150, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_150_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_151, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_151_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_151, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_151_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_UnalignedLMatrix4d_getbuffer_152_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< UnalignedLMatrix4d > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_UnalignedLMatrix4d_releasebuffer_153_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< UnalignedLMatrix4d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_getitem_147_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_UnalignedLMatrix4d index out of range");
    return NULL;
  }
  // 1-UnalignedLMatrix4d const &ConstPointerToArray< UnalignedLMatrix4d >::__getitem__(unsigned long int n) const
  UnalignedLMatrix4d const *return_value = &(invoke_extension((const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_UnalignedLMatrix4d_size_145_sq_length(PyObject *self) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_UnalignedLMatrix4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_UnalignedLMatrix4d = {
  &Dtool_ConstPointerToArray_UnalignedLMatrix4d_size_145_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_UnalignedLMatrix4d_getitem_147_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_UnalignedLMatrix4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_UnalignedLMatrix4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_UnalignedLMatrix4d_getbuffer_152_bf_getbuffer,
  &Dtool_ConstPointerToArray_UnalignedLMatrix4d_releasebuffer_153_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_UnalignedLMatrix4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_UnalignedLMatrix4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_UnalignedLMatrix4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_UnalignedLMatrix4d,
    &Dtool_SequenceMethods_ConstPointerToArray_UnalignedLMatrix4d,
    &Dtool_MappingMethods_ConstPointerToArray_UnalignedLMatrix4d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_UnalignedLMatrix4d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_UnalignedLMatrix4d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_UnalignedLMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_UnalignedLMatrix4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d,
  Dtool_UpcastInterface_ConstPointerToArray_UnalignedLMatrix4d,
  Dtool_DowncastInterface_ConstPointerToArray_UnalignedLMatrix4d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4d,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d(NULL);
    Dtool_ConstPointerToArray_UnalignedLMatrix4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_UnalignedLMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_UnalignedLMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  }
}

/**
 * Python method tables for PointerToArrayBase_UnalignedLMatrix4d (PointerToArrayBase_UnalignedLMatrix4d)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_UnalignedLMatrix4d[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_UnalignedLMatrix4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_UnalignedLMatrix4d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_UnalignedLMatrix4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_UnalignedLMatrix4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_UnalignedLMatrix4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_UnalignedLMatrix4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_UnalignedLMatrix4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_UnalignedLMatrix4d,
    &Dtool_SequenceMethods_PointerToArrayBase_UnalignedLMatrix4d,
    &Dtool_MappingMethods_PointerToArrayBase_UnalignedLMatrix4d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_UnalignedLMatrix4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_UnalignedLMatrix4d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_UnalignedLMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_UnalignedLMatrix4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d,
  Dtool_UpcastInterface_PointerToArrayBase_UnalignedLMatrix4d,
  Dtool_DowncastInterface_PointerToArrayBase_UnalignedLMatrix4d,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(NULL);
    Dtool_PointerToArrayBase_UnalignedLMatrix4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_UnalignedLMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_UnalignedLMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d (PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_clear_141, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_clear_141_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_output_142, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_output_142_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(PyObject *self) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
  }
}

/**
 * Python method tables for ConstPointerToArray_UnalignedLMatrix4f (ConstPointerToArray_UnalignedLMatrix4f)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_UnalignedLMatrix4f[] = {
  {"get_element", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_163, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_163_comment},
  {"getElement", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_163, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_163_comment},
  {"get_data", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_165, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_165_comment},
  {"getData", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_165, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_165_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_166_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_166_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_167, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_167_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_167, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_167_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_168, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_168_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_168, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_168_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_UnalignedLMatrix4f_getbuffer_169_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< UnalignedLMatrix4f > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_UnalignedLMatrix4f_releasebuffer_170_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< UnalignedLMatrix4f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_getitem_164_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_UnalignedLMatrix4f index out of range");
    return NULL;
  }
  // 1-UnalignedLMatrix4f const &ConstPointerToArray< UnalignedLMatrix4f >::__getitem__(unsigned long int n) const
  UnalignedLMatrix4f const *return_value = &(invoke_extension((const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_UnalignedLMatrix4f_size_162_sq_length(PyObject *self) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_UnalignedLMatrix4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_UnalignedLMatrix4f = {
  &Dtool_ConstPointerToArray_UnalignedLMatrix4f_size_162_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_UnalignedLMatrix4f_getitem_164_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_UnalignedLMatrix4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_UnalignedLMatrix4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_UnalignedLMatrix4f_getbuffer_169_bf_getbuffer,
  &Dtool_ConstPointerToArray_UnalignedLMatrix4f_releasebuffer_170_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_UnalignedLMatrix4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_UnalignedLMatrix4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_UnalignedLMatrix4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_UnalignedLMatrix4f,
    &Dtool_SequenceMethods_ConstPointerToArray_UnalignedLMatrix4f,
    &Dtool_MappingMethods_ConstPointerToArray_UnalignedLMatrix4f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_UnalignedLMatrix4f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_UnalignedLMatrix4f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_UnalignedLMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_UnalignedLMatrix4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f,
  Dtool_UpcastInterface_ConstPointerToArray_UnalignedLMatrix4f,
  Dtool_DowncastInterface_ConstPointerToArray_UnalignedLMatrix4f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4f,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f(NULL);
    Dtool_ConstPointerToArray_UnalignedLMatrix4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_UnalignedLMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_UnalignedLMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  }
}

/**
 * Python method tables for PointerToArrayBase_UnalignedLMatrix4f (PointerToArrayBase_UnalignedLMatrix4f)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_UnalignedLMatrix4f[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_UnalignedLMatrix4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_UnalignedLMatrix4f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_UnalignedLMatrix4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_UnalignedLMatrix4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_UnalignedLMatrix4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_UnalignedLMatrix4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_UnalignedLMatrix4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_UnalignedLMatrix4f,
    &Dtool_SequenceMethods_PointerToArrayBase_UnalignedLMatrix4f,
    &Dtool_MappingMethods_PointerToArrayBase_UnalignedLMatrix4f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_UnalignedLMatrix4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_UnalignedLMatrix4f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_UnalignedLMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_UnalignedLMatrix4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f,
  Dtool_UpcastInterface_PointerToArrayBase_UnalignedLMatrix4f,
  Dtool_DowncastInterface_PointerToArrayBase_UnalignedLMatrix4f,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(NULL);
    Dtool_PointerToArrayBase_UnalignedLMatrix4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_UnalignedLMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_UnalignedLMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f (PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_clear_158, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_clear_158_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_output_159, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_output_159_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(PyObject *self) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
  }
}

/**
 * Python method tables for ConstPointerToArray_UnalignedLVecBase4d (ConstPointerToArray_UnalignedLVecBase4d)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4d[] = {
  {"get_element", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_180, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_180_comment},
  {"getElement", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_180, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_180_comment},
  {"get_data", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_182, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_182_comment},
  {"getData", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_182, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_182_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_183, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_183_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_183, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_183_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_184, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_184_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_184, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_184_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_185, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_185_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_185, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_185_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_UnalignedLVecBase4d_getbuffer_186_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< UnalignedLVecBase4d > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_UnalignedLVecBase4d_releasebuffer_187_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< UnalignedLVecBase4d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_getitem_181_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_UnalignedLVecBase4d index out of range");
    return NULL;
  }
  // 1-UnalignedLVecBase4d const &ConstPointerToArray< UnalignedLVecBase4d >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4d const *return_value = &(invoke_extension((const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_UnalignedLVecBase4d_size_179_sq_length(PyObject *self) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4d = {
  &Dtool_ConstPointerToArray_UnalignedLVecBase4d_size_179_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_UnalignedLVecBase4d_getitem_181_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_UnalignedLVecBase4d_getbuffer_186_bf_getbuffer,
  &Dtool_ConstPointerToArray_UnalignedLVecBase4d_releasebuffer_187_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_UnalignedLVecBase4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_UnalignedLVecBase4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_UnalignedLVecBase4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4d,
    &Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4d,
    &Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_UnalignedLVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_UnalignedLVecBase4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d,
  Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4d,
  Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4d,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d(NULL);
    Dtool_ConstPointerToArray_UnalignedLVecBase4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_UnalignedLVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_UnalignedLVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  }
}

/**
 * Python method tables for PointerToArrayBase_UnalignedLVecBase4d (PointerToArrayBase_UnalignedLVecBase4d)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4d[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_UnalignedLVecBase4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_UnalignedLVecBase4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_UnalignedLVecBase4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4d,
    &Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4d,
    &Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_UnalignedLVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_UnalignedLVecBase4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d,
  Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4d,
  Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4d,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(NULL);
    Dtool_PointerToArrayBase_UnalignedLVecBase4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_UnalignedLVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_UnalignedLVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d (PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_clear_175, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_clear_175_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_output_176, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_output_176_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(PyObject *self) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
  }
}

/**
 * Python method tables for ConstPointerToArray_UnalignedLVecBase4f (ConstPointerToArray_UnalignedLVecBase4f)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4f[] = {
  {"get_element", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_197, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_197_comment},
  {"getElement", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_197, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_197_comment},
  {"get_data", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_199, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_199_comment},
  {"getData", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_199, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_199_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_200_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_200_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_201, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_201_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_201, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_201_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_202, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_202_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_202, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_202_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_UnalignedLVecBase4f_getbuffer_203_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< UnalignedLVecBase4f > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_UnalignedLVecBase4f_releasebuffer_204_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< UnalignedLVecBase4f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_getitem_198_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_UnalignedLVecBase4f index out of range");
    return NULL;
  }
  // 1-UnalignedLVecBase4f const &ConstPointerToArray< UnalignedLVecBase4f >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4f const *return_value = &(invoke_extension((const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_UnalignedLVecBase4f_size_196_sq_length(PyObject *self) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4f = {
  &Dtool_ConstPointerToArray_UnalignedLVecBase4f_size_196_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_UnalignedLVecBase4f_getitem_198_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_UnalignedLVecBase4f_getbuffer_203_bf_getbuffer,
  &Dtool_ConstPointerToArray_UnalignedLVecBase4f_releasebuffer_204_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_UnalignedLVecBase4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_UnalignedLVecBase4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_UnalignedLVecBase4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4f,
    &Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4f,
    &Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_UnalignedLVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_UnalignedLVecBase4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f,
  Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4f,
  Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4f,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f(NULL);
    Dtool_ConstPointerToArray_UnalignedLVecBase4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_UnalignedLVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_UnalignedLVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  }
}

/**
 * Python method tables for PointerToArrayBase_UnalignedLVecBase4f (PointerToArrayBase_UnalignedLVecBase4f)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4f[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_UnalignedLVecBase4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_UnalignedLVecBase4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_UnalignedLVecBase4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4f,
    &Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4f,
    &Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_UnalignedLVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_UnalignedLVecBase4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f,
  Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4f,
  Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4f,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(NULL);
    Dtool_PointerToArrayBase_UnalignedLVecBase4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_UnalignedLVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_UnalignedLVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f (PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_clear_192, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_clear_192_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_output_193, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_output_193_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(PyObject *self) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
  }
}

/**
 * Python method tables for ConstPointerToArray_UnalignedLVecBase4i (ConstPointerToArray_UnalignedLVecBase4i)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4i[] = {
  {"get_element", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_214, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_214_comment},
  {"getElement", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_214, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_214_comment},
  {"get_data", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_216, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_216_comment},
  {"getData", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_216, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_216_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_217_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_217_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_218, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_218_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_218, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_218_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_219, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_219_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_219, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_219_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_UnalignedLVecBase4i_getbuffer_220_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< UnalignedLVecBase4i > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_UnalignedLVecBase4i_releasebuffer_221_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< UnalignedLVecBase4i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_getitem_215_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_UnalignedLVecBase4i index out of range");
    return NULL;
  }
  // 1-UnalignedLVecBase4i const &ConstPointerToArray< UnalignedLVecBase4i >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4i const *return_value = &(invoke_extension((const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_UnalignedLVecBase4i_size_213_sq_length(PyObject *self) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4i = {
  &Dtool_ConstPointerToArray_UnalignedLVecBase4i_size_213_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_UnalignedLVecBase4i_getitem_215_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_UnalignedLVecBase4i_getbuffer_220_bf_getbuffer,
  &Dtool_ConstPointerToArray_UnalignedLVecBase4i_releasebuffer_221_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_UnalignedLVecBase4i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_UnalignedLVecBase4i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_UnalignedLVecBase4i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4i,
    &Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4i,
    &Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_UnalignedLVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_UnalignedLVecBase4i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4i,
  Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4i,
  Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4i,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i(NULL);
    Dtool_ConstPointerToArray_UnalignedLVecBase4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_UnalignedLVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_UnalignedLVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  }
}

/**
 * Python method tables for PointerToArrayBase_UnalignedLVecBase4i (PointerToArrayBase_UnalignedLVecBase4i)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4i[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_UnalignedLVecBase4i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_UnalignedLVecBase4i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_UnalignedLVecBase4i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4i,
    &Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4i,
    &Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_UnalignedLVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_UnalignedLVecBase4i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i,
  Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4i,
  Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4i,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(NULL);
    Dtool_PointerToArrayBase_UnalignedLVecBase4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_UnalignedLVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_UnalignedLVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i (PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_clear_209, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_clear_209_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_output_210, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_output_210_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(PyObject *self) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
  }
}

/**
 * Python method tables for PointerToArray_LMatrix3d (PointerToArray_LMatrix3d)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LMatrix3d[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_empty_array_225, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LMatrix3d_empty_array_225_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_empty_array_225, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LMatrix3d_empty_array_225_comment},
  {"push_back", &Dtool_PointerToArray_LMatrix3d_push_back_227, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_push_back_227_comment},
  {"pushBack", &Dtool_PointerToArray_LMatrix3d_push_back_227, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_push_back_227_comment},
  {"pop_back", &Dtool_PointerToArray_LMatrix3d_pop_back_228, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_pop_back_228_comment},
  {"popBack", &Dtool_PointerToArray_LMatrix3d_pop_back_228, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_pop_back_228_comment},
  {"get_element", &Dtool_PointerToArray_LMatrix3d_get_element_229, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_get_element_229_comment},
  {"getElement", &Dtool_PointerToArray_LMatrix3d_get_element_229, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_get_element_229_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_set_element_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_set_element_230_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_set_element_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_set_element_230_comment},
  {"get_data", &Dtool_PointerToArray_LMatrix3d_get_data_233, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_data_233_comment},
  {"getData", &Dtool_PointerToArray_LMatrix3d_get_data_233, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_data_233_comment},
  {"set_data", &Dtool_PointerToArray_LMatrix3d_set_data_234, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_set_data_234_comment},
  {"setData", &Dtool_PointerToArray_LMatrix3d_set_data_234, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_set_data_234_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_get_subdata_235, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_get_subdata_235_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_get_subdata_235, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_get_subdata_235_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_set_subdata_236, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_set_subdata_236_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_set_subdata_236, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_set_subdata_236_comment},
  {"get_ref_count", &Dtool_PointerToArray_LMatrix3d_get_ref_count_237, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_ref_count_237_comment},
  {"getRefCount", &Dtool_PointerToArray_LMatrix3d_get_ref_count_237, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_ref_count_237_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LMatrix3d_get_node_ref_count_238, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_node_ref_count_238_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LMatrix3d_get_node_ref_count_238, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_node_ref_count_238_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LMatrix3d_getbuffer_239_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LMatrix3d.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LMatrix3d_releasebuffer_240_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LMatrix3d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3d slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LMatrix3d_setitem_232_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LMatrix3d index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< LMatrix3d >::__setitem__(unsigned long int n, LMatrix3d const &value)
      LMatrix3d arg_local;
      LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LMatrix3d");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LMatrix3d value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LMatrix3d_getitem_231_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LMatrix3d index out of range");
    return NULL;
  }
  // 1-LMatrix3d const &PointerToArray< LMatrix3d >::__getitem__(unsigned long int n) const
  LMatrix3d const *return_value = &(invoke_extension((const PointerToArray< LMatrix3d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LMatrix3d_size_226_sq_length(PyObject *self) {
  PointerToArray< LMatrix3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LMatrix3d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LMatrix3d = {
  &Dtool_PointerToArray_LMatrix3d_size_226_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_LMatrix3d_getitem_231_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_LMatrix3d_setitem_232_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LMatrix3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LMatrix3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LMatrix3d_getbuffer_239_bf_getbuffer,
  &Dtool_PointerToArray_LMatrix3d_releasebuffer_240_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_LMatrix3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_LMatrix3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LMatrix3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_LMatrix3d,
    &Dtool_SequenceMethods_PointerToArray_LMatrix3d,
    &Dtool_MappingMethods_PointerToArray_LMatrix3d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_LMatrix3d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_LMatrix3d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LMatrix3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LMatrix3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3d,
  Dtool_UpcastInterface_PointerToArray_LMatrix3d,
  Dtool_DowncastInterface_PointerToArray_LMatrix3d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LMatrix3d,
};

static void Dtool_PyModuleClassInit_PointerToArray_LMatrix3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d(NULL);
    Dtool_PointerToArray_LMatrix3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3d);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LMatrix3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LMatrix3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LMatrix3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LMatrix3d);
  }
}

/**
 * Python method tables for PointerToArray_LMatrix3f (PointerToArray_LMatrix3f)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LMatrix3f[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_empty_array_244, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LMatrix3f_empty_array_244_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_empty_array_244, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LMatrix3f_empty_array_244_comment},
  {"push_back", &Dtool_PointerToArray_LMatrix3f_push_back_246, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_push_back_246_comment},
  {"pushBack", &Dtool_PointerToArray_LMatrix3f_push_back_246, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_push_back_246_comment},
  {"pop_back", &Dtool_PointerToArray_LMatrix3f_pop_back_247, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_pop_back_247_comment},
  {"popBack", &Dtool_PointerToArray_LMatrix3f_pop_back_247, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_pop_back_247_comment},
  {"get_element", &Dtool_PointerToArray_LMatrix3f_get_element_248, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_get_element_248_comment},
  {"getElement", &Dtool_PointerToArray_LMatrix3f_get_element_248, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_get_element_248_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_set_element_249, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_set_element_249_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_set_element_249, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_set_element_249_comment},
  {"get_data", &Dtool_PointerToArray_LMatrix3f_get_data_252, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_data_252_comment},
  {"getData", &Dtool_PointerToArray_LMatrix3f_get_data_252, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_data_252_comment},
  {"set_data", &Dtool_PointerToArray_LMatrix3f_set_data_253, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_set_data_253_comment},
  {"setData", &Dtool_PointerToArray_LMatrix3f_set_data_253, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_set_data_253_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_get_subdata_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_get_subdata_254_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_get_subdata_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_get_subdata_254_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_set_subdata_255, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_set_subdata_255_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_set_subdata_255, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_set_subdata_255_comment},
  {"get_ref_count", &Dtool_PointerToArray_LMatrix3f_get_ref_count_256, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_ref_count_256_comment},
  {"getRefCount", &Dtool_PointerToArray_LMatrix3f_get_ref_count_256, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_ref_count_256_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LMatrix3f_get_node_ref_count_257, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_node_ref_count_257_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LMatrix3f_get_node_ref_count_257, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_node_ref_count_257_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LMatrix3f_getbuffer_258_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LMatrix3f.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LMatrix3f_releasebuffer_259_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LMatrix3f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3f slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LMatrix3f_setitem_251_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LMatrix3f index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< LMatrix3f >::__setitem__(unsigned long int n, LMatrix3f const &value)
      LMatrix3f arg_local;
      LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LMatrix3f");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LMatrix3f value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LMatrix3f_getitem_250_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LMatrix3f index out of range");
    return NULL;
  }
  // 1-LMatrix3f const &PointerToArray< LMatrix3f >::__getitem__(unsigned long int n) const
  LMatrix3f const *return_value = &(invoke_extension((const PointerToArray< LMatrix3f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LMatrix3f_size_245_sq_length(PyObject *self) {
  PointerToArray< LMatrix3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LMatrix3f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LMatrix3f = {
  &Dtool_PointerToArray_LMatrix3f_size_245_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_LMatrix3f_getitem_250_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_LMatrix3f_setitem_251_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LMatrix3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LMatrix3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LMatrix3f_getbuffer_258_bf_getbuffer,
  &Dtool_PointerToArray_LMatrix3f_releasebuffer_259_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_LMatrix3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_LMatrix3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LMatrix3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_LMatrix3f,
    &Dtool_SequenceMethods_PointerToArray_LMatrix3f,
    &Dtool_MappingMethods_PointerToArray_LMatrix3f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_LMatrix3f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_LMatrix3f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LMatrix3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LMatrix3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3f,
  Dtool_UpcastInterface_PointerToArray_LMatrix3f,
  Dtool_DowncastInterface_PointerToArray_LMatrix3f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LMatrix3f,
};

static void Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(NULL);
    Dtool_PointerToArray_LMatrix3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3f);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LMatrix3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LMatrix3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LMatrix3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LMatrix3f);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase2d (PointerToArray_LVecBase2d)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase2d[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_empty_array_263, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2d_empty_array_263_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_empty_array_263, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2d_empty_array_263_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase2d_push_back_265, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_push_back_265_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase2d_push_back_265, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_push_back_265_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase2d_pop_back_266, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_pop_back_266_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase2d_pop_back_266, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_pop_back_266_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase2d_get_element_267, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_get_element_267_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase2d_get_element_267, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_get_element_267_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_set_element_268, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_set_element_268_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_set_element_268, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_set_element_268_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase2d_get_data_271, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_data_271_comment},
  {"getData", &Dtool_PointerToArray_LVecBase2d_get_data_271, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_data_271_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase2d_set_data_272, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_set_data_272_comment},
  {"setData", &Dtool_PointerToArray_LVecBase2d_set_data_272, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_set_data_272_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_get_subdata_273, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_get_subdata_273_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_get_subdata_273, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_get_subdata_273_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_set_subdata_274, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_set_subdata_274_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_set_subdata_274, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_set_subdata_274_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase2d_get_ref_count_275, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_ref_count_275_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase2d_get_ref_count_275, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_ref_count_275_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase2d_get_node_ref_count_276, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_node_ref_count_276_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase2d_get_node_ref_count_276, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_node_ref_count_276_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase2d_getbuffer_277_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase2d.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase2d_releasebuffer_278_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase2d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2d slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase2d_setitem_270_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2d index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< LVecBase2d >::__setitem__(unsigned long int n, LVecBase2d const &value)
      LVecBase2d arg_local;
      LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase2d");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase2d value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase2d_getitem_269_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2d index out of range");
    return NULL;
  }
  // 1-LVecBase2d const &PointerToArray< LVecBase2d >::__getitem__(unsigned long int n) const
  LVecBase2d const *return_value = &(invoke_extension((const PointerToArray< LVecBase2d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase2d_size_264_sq_length(PyObject *self) {
  PointerToArray< LVecBase2d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase2d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase2d = {
  &Dtool_PointerToArray_LVecBase2d_size_264_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_LVecBase2d_getitem_269_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_LVecBase2d_setitem_270_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase2d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase2d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase2d_getbuffer_277_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase2d_releasebuffer_278_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase2d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_LVecBase2d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase2d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_LVecBase2d,
    &Dtool_SequenceMethods_PointerToArray_LVecBase2d,
    &Dtool_MappingMethods_PointerToArray_LVecBase2d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_LVecBase2d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_LVecBase2d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase2d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase2d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2d,
  Dtool_UpcastInterface_PointerToArray_LVecBase2d,
  Dtool_DowncastInterface_PointerToArray_LVecBase2d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase2d,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d(NULL);
    Dtool_PointerToArray_LVecBase2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2d);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase2d);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase2f (PointerToArray_LVecBase2f)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase2f[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_empty_array_282, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2f_empty_array_282_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_empty_array_282, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2f_empty_array_282_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase2f_push_back_284, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_push_back_284_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase2f_push_back_284, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_push_back_284_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase2f_pop_back_285, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_pop_back_285_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase2f_pop_back_285, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_pop_back_285_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase2f_get_element_286, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_get_element_286_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase2f_get_element_286, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_get_element_286_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_set_element_287, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_set_element_287_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_set_element_287, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_set_element_287_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase2f_get_data_290, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_data_290_comment},
  {"getData", &Dtool_PointerToArray_LVecBase2f_get_data_290, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_data_290_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase2f_set_data_291, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_set_data_291_comment},
  {"setData", &Dtool_PointerToArray_LVecBase2f_set_data_291, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_set_data_291_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_get_subdata_292, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_get_subdata_292_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_get_subdata_292, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_get_subdata_292_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_set_subdata_293, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_set_subdata_293_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_set_subdata_293, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_set_subdata_293_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase2f_get_ref_count_294, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_ref_count_294_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase2f_get_ref_count_294, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_ref_count_294_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase2f_get_node_ref_count_295, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_node_ref_count_295_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase2f_get_node_ref_count_295, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_node_ref_count_295_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase2f_getbuffer_296_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase2f.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase2f_releasebuffer_297_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase2f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2f slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase2f_setitem_289_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2f index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< LVecBase2f >::__setitem__(unsigned long int n, LVecBase2f const &value)
      LVecBase2f arg_local;
      LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase2f");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase2f value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase2f_getitem_288_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2f index out of range");
    return NULL;
  }
  // 1-LVecBase2f const &PointerToArray< LVecBase2f >::__getitem__(unsigned long int n) const
  LVecBase2f const *return_value = &(invoke_extension((const PointerToArray< LVecBase2f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase2f_size_283_sq_length(PyObject *self) {
  PointerToArray< LVecBase2f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase2f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase2f = {
  &Dtool_PointerToArray_LVecBase2f_size_283_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_LVecBase2f_getitem_288_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_LVecBase2f_setitem_289_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase2f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase2f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase2f_getbuffer_296_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase2f_releasebuffer_297_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase2f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_LVecBase2f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase2f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_LVecBase2f,
    &Dtool_SequenceMethods_PointerToArray_LVecBase2f,
    &Dtool_MappingMethods_PointerToArray_LVecBase2f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_LVecBase2f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_LVecBase2f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase2f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase2f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2f,
  Dtool_UpcastInterface_PointerToArray_LVecBase2f,
  Dtool_DowncastInterface_PointerToArray_LVecBase2f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase2f,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(NULL);
    Dtool_PointerToArray_LVecBase2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2f);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase2f);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase2i (PointerToArray_LVecBase2i)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase2i[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_empty_array_301, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2i_empty_array_301_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_empty_array_301, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2i_empty_array_301_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase2i_push_back_303, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_push_back_303_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase2i_push_back_303, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_push_back_303_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase2i_pop_back_304, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_pop_back_304_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase2i_pop_back_304, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_pop_back_304_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase2i_get_element_305, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_get_element_305_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase2i_get_element_305, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_get_element_305_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_set_element_306, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_set_element_306_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_set_element_306, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_set_element_306_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase2i_get_data_309, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_data_309_comment},
  {"getData", &Dtool_PointerToArray_LVecBase2i_get_data_309, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_data_309_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase2i_set_data_310, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_set_data_310_comment},
  {"setData", &Dtool_PointerToArray_LVecBase2i_set_data_310, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_set_data_310_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_get_subdata_311, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_get_subdata_311_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_get_subdata_311, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_get_subdata_311_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_set_subdata_312, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_set_subdata_312_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_set_subdata_312, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_set_subdata_312_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase2i_get_ref_count_313, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_ref_count_313_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase2i_get_ref_count_313, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_ref_count_313_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase2i_get_node_ref_count_314, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_node_ref_count_314_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase2i_get_node_ref_count_314, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_node_ref_count_314_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase2i_getbuffer_315_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase2i.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase2i_releasebuffer_316_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase2i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2i slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase2i_setitem_308_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2i index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< LVecBase2i >::__setitem__(unsigned long int n, LVecBase2i const &value)
      LVecBase2i arg_local;
      LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase2i");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase2i value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase2i_getitem_307_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2i index out of range");
    return NULL;
  }
  // 1-LVecBase2i const &PointerToArray< LVecBase2i >::__getitem__(unsigned long int n) const
  LVecBase2i const *return_value = &(invoke_extension((const PointerToArray< LVecBase2i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase2i_size_302_sq_length(PyObject *self) {
  PointerToArray< LVecBase2i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase2i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase2i = {
  &Dtool_PointerToArray_LVecBase2i_size_302_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_LVecBase2i_getitem_307_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_LVecBase2i_setitem_308_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase2i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase2i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase2i_getbuffer_315_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase2i_releasebuffer_316_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase2i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_LVecBase2i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase2i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_LVecBase2i,
    &Dtool_SequenceMethods_PointerToArray_LVecBase2i,
    &Dtool_MappingMethods_PointerToArray_LVecBase2i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_LVecBase2i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_LVecBase2i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase2i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase2i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2i,
  Dtool_UpcastInterface_PointerToArray_LVecBase2i,
  Dtool_DowncastInterface_PointerToArray_LVecBase2i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase2i,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i(NULL);
    Dtool_PointerToArray_LVecBase2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2i);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase2i);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase3d (PointerToArray_LVecBase3d)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase3d[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_empty_array_320, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3d_empty_array_320_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_empty_array_320, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3d_empty_array_320_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase3d_push_back_322, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_push_back_322_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase3d_push_back_322, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_push_back_322_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase3d_pop_back_323, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_pop_back_323_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase3d_pop_back_323, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_pop_back_323_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase3d_get_element_324, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_get_element_324_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase3d_get_element_324, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_get_element_324_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_set_element_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_set_element_325_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_set_element_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_set_element_325_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase3d_get_data_328, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_data_328_comment},
  {"getData", &Dtool_PointerToArray_LVecBase3d_get_data_328, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_data_328_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase3d_set_data_329, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_set_data_329_comment},
  {"setData", &Dtool_PointerToArray_LVecBase3d_set_data_329, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_set_data_329_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_get_subdata_330, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_get_subdata_330_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_get_subdata_330, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_get_subdata_330_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_set_subdata_331, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_set_subdata_331_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_set_subdata_331, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_set_subdata_331_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase3d_get_ref_count_332, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_ref_count_332_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase3d_get_ref_count_332, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_ref_count_332_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase3d_get_node_ref_count_333, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_node_ref_count_333_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase3d_get_node_ref_count_333, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_node_ref_count_333_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase3d_getbuffer_334_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase3d.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase3d_releasebuffer_335_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase3d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3d slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase3d_setitem_327_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3d index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< LVecBase3d >::__setitem__(unsigned long int n, LVecBase3d const &value)
      LVecBase3d arg_local;
      LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase3d");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase3d value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase3d_getitem_326_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3d index out of range");
    return NULL;
  }
  // 1-LVecBase3d const &PointerToArray< LVecBase3d >::__getitem__(unsigned long int n) const
  LVecBase3d const *return_value = &(invoke_extension((const PointerToArray< LVecBase3d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase3d_size_321_sq_length(PyObject *self) {
  PointerToArray< LVecBase3d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase3d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase3d = {
  &Dtool_PointerToArray_LVecBase3d_size_321_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_LVecBase3d_getitem_326_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_LVecBase3d_setitem_327_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase3d_getbuffer_334_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase3d_releasebuffer_335_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_LVecBase3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_LVecBase3d,
    &Dtool_SequenceMethods_PointerToArray_LVecBase3d,
    &Dtool_MappingMethods_PointerToArray_LVecBase3d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_LVecBase3d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_LVecBase3d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3d,
  Dtool_UpcastInterface_PointerToArray_LVecBase3d,
  Dtool_DowncastInterface_PointerToArray_LVecBase3d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase3d,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d(NULL);
    Dtool_PointerToArray_LVecBase3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3d);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase3d);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase3f (PointerToArray_LVecBase3f)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase3f[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_empty_array_339, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3f_empty_array_339_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_empty_array_339, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3f_empty_array_339_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase3f_push_back_341, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_push_back_341_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase3f_push_back_341, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_push_back_341_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase3f_pop_back_342, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_pop_back_342_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase3f_pop_back_342, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_pop_back_342_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase3f_get_element_343, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_get_element_343_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase3f_get_element_343, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_get_element_343_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_set_element_344, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_set_element_344_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_set_element_344, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_set_element_344_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase3f_get_data_347, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_data_347_comment},
  {"getData", &Dtool_PointerToArray_LVecBase3f_get_data_347, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_data_347_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase3f_set_data_348, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_set_data_348_comment},
  {"setData", &Dtool_PointerToArray_LVecBase3f_set_data_348, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_set_data_348_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_get_subdata_349, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_get_subdata_349_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_get_subdata_349, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_get_subdata_349_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_set_subdata_350, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_set_subdata_350_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_set_subdata_350, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_set_subdata_350_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase3f_get_ref_count_351, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_ref_count_351_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase3f_get_ref_count_351, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_ref_count_351_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase3f_get_node_ref_count_352, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_node_ref_count_352_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase3f_get_node_ref_count_352, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_node_ref_count_352_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase3f_getbuffer_353_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase3f.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase3f_releasebuffer_354_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase3f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3f slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase3f_setitem_346_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3f index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< LVecBase3f >::__setitem__(unsigned long int n, LVecBase3f const &value)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase3f");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase3f value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase3f_getitem_345_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3f index out of range");
    return NULL;
  }
  // 1-LVecBase3f const &PointerToArray< LVecBase3f >::__getitem__(unsigned long int n) const
  LVecBase3f const *return_value = &(invoke_extension((const PointerToArray< LVecBase3f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase3f_size_340_sq_length(PyObject *self) {
  PointerToArray< LVecBase3f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase3f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase3f = {
  &Dtool_PointerToArray_LVecBase3f_size_340_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_LVecBase3f_getitem_345_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_LVecBase3f_setitem_346_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase3f_getbuffer_353_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase3f_releasebuffer_354_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_LVecBase3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_LVecBase3f,
    &Dtool_SequenceMethods_PointerToArray_LVecBase3f,
    &Dtool_MappingMethods_PointerToArray_LVecBase3f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_LVecBase3f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_LVecBase3f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3f,
  Dtool_UpcastInterface_PointerToArray_LVecBase3f,
  Dtool_DowncastInterface_PointerToArray_LVecBase3f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase3f,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(NULL);
    Dtool_PointerToArray_LVecBase3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3f);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase3f);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase3i (PointerToArray_LVecBase3i)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase3i[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_empty_array_358, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3i_empty_array_358_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_empty_array_358, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3i_empty_array_358_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase3i_push_back_360, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_push_back_360_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase3i_push_back_360, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_push_back_360_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase3i_pop_back_361, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_pop_back_361_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase3i_pop_back_361, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_pop_back_361_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase3i_get_element_362, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_get_element_362_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase3i_get_element_362, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_get_element_362_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_set_element_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_set_element_363_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_set_element_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_set_element_363_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase3i_get_data_366, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_data_366_comment},
  {"getData", &Dtool_PointerToArray_LVecBase3i_get_data_366, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_data_366_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase3i_set_data_367, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_set_data_367_comment},
  {"setData", &Dtool_PointerToArray_LVecBase3i_set_data_367, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_set_data_367_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_get_subdata_368, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_get_subdata_368_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_get_subdata_368, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_get_subdata_368_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_set_subdata_369, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_set_subdata_369_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_set_subdata_369, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_set_subdata_369_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase3i_get_ref_count_370, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_ref_count_370_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase3i_get_ref_count_370, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_ref_count_370_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase3i_get_node_ref_count_371, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_node_ref_count_371_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase3i_get_node_ref_count_371, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_node_ref_count_371_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase3i_getbuffer_372_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase3i.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase3i_releasebuffer_373_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase3i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3i slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase3i_setitem_365_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3i index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< LVecBase3i >::__setitem__(unsigned long int n, LVecBase3i const &value)
      LVecBase3i arg_local;
      LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase3i");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase3i value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase3i_getitem_364_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3i index out of range");
    return NULL;
  }
  // 1-LVecBase3i const &PointerToArray< LVecBase3i >::__getitem__(unsigned long int n) const
  LVecBase3i const *return_value = &(invoke_extension((const PointerToArray< LVecBase3i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase3i_size_359_sq_length(PyObject *self) {
  PointerToArray< LVecBase3i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase3i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase3i = {
  &Dtool_PointerToArray_LVecBase3i_size_359_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_LVecBase3i_getitem_364_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_LVecBase3i_setitem_365_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase3i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase3i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase3i_getbuffer_372_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase3i_releasebuffer_373_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase3i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_LVecBase3i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase3i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_LVecBase3i,
    &Dtool_SequenceMethods_PointerToArray_LVecBase3i,
    &Dtool_MappingMethods_PointerToArray_LVecBase3i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_LVecBase3i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_LVecBase3i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase3i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase3i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3i,
  Dtool_UpcastInterface_PointerToArray_LVecBase3i,
  Dtool_DowncastInterface_PointerToArray_LVecBase3i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase3i,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i(NULL);
    Dtool_PointerToArray_LVecBase3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3i);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase3i);
  }
}

/**
 * Python method tables for PointerToArray_UnalignedLMatrix4d (PointerToArray_UnalignedLMatrix4d)
 */
static PyMethodDef Dtool_Methods_PointerToArray_UnalignedLMatrix4d[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_377, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_377_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_377, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_377_comment},
  {"push_back", &Dtool_PointerToArray_UnalignedLMatrix4d_push_back_379, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_push_back_379_comment},
  {"pushBack", &Dtool_PointerToArray_UnalignedLMatrix4d_push_back_379, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_push_back_379_comment},
  {"pop_back", &Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_380, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_380_comment},
  {"popBack", &Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_380, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_380_comment},
  {"get_element", &Dtool_PointerToArray_UnalignedLMatrix4d_get_element_381, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_element_381_comment},
  {"getElement", &Dtool_PointerToArray_UnalignedLMatrix4d_get_element_381, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_element_381_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_set_element_382, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_element_382_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_set_element_382, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_element_382_comment},
  {"get_data", &Dtool_PointerToArray_UnalignedLMatrix4d_get_data_385, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_data_385_comment},
  {"getData", &Dtool_PointerToArray_UnalignedLMatrix4d_get_data_385, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_data_385_comment},
  {"set_data", &Dtool_PointerToArray_UnalignedLMatrix4d_set_data_386, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_data_386_comment},
  {"setData", &Dtool_PointerToArray_UnalignedLMatrix4d_set_data_386, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_data_386_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_387, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_387_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_387, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_387_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_388, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_388_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_388, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_388_comment},
  {"get_ref_count", &Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_389, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_389_comment},
  {"getRefCount", &Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_389, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_389_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_390, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_390_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_390, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_390_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_UnalignedLMatrix4d_getbuffer_391_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_UnalignedLMatrix4d.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_UnalignedLMatrix4d_releasebuffer_392_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< UnalignedLMatrix4d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4d slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_UnalignedLMatrix4d_setitem_384_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLMatrix4d index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< UnalignedLMatrix4d >::__setitem__(unsigned long int n, UnalignedLMatrix4d const &value)
      UnalignedLMatrix4d arg_local;
      UnalignedLMatrix4d const *arg_this = Dtool_Coerce_UnalignedLMatrix4d(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "UnalignedLMatrix4d");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const UnalignedLMatrix4d value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_getitem_383_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLMatrix4d index out of range");
    return NULL;
  }
  // 1-UnalignedLMatrix4d const &PointerToArray< UnalignedLMatrix4d >::__getitem__(unsigned long int n) const
  UnalignedLMatrix4d const *return_value = &(invoke_extension((const PointerToArray< UnalignedLMatrix4d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_UnalignedLMatrix4d_size_378_sq_length(PyObject *self) {
  PointerToArray< UnalignedLMatrix4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_UnalignedLMatrix4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_UnalignedLMatrix4d = {
  &Dtool_PointerToArray_UnalignedLMatrix4d_size_378_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_UnalignedLMatrix4d_getitem_383_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_UnalignedLMatrix4d_setitem_384_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_UnalignedLMatrix4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_UnalignedLMatrix4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_UnalignedLMatrix4d_getbuffer_391_bf_getbuffer,
  &Dtool_PointerToArray_UnalignedLMatrix4d_releasebuffer_392_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLMatrix4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_UnalignedLMatrix4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_UnalignedLMatrix4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_UnalignedLMatrix4d,
    &Dtool_SequenceMethods_PointerToArray_UnalignedLMatrix4d,
    &Dtool_MappingMethods_PointerToArray_UnalignedLMatrix4d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_UnalignedLMatrix4d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_UnalignedLMatrix4d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_UnalignedLMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_UnalignedLMatrix4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d,
  Dtool_UpcastInterface_PointerToArray_UnalignedLMatrix4d,
  Dtool_DowncastInterface_PointerToArray_UnalignedLMatrix4d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_UnalignedLMatrix4d,
};

static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d(NULL);
    Dtool_PointerToArray_UnalignedLMatrix4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_UnalignedLMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_UnalignedLMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_UnalignedLMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  }
}

/**
 * Python method tables for PointerToArray_UnalignedLMatrix4f (PointerToArray_UnalignedLMatrix4f)
 */
static PyMethodDef Dtool_Methods_PointerToArray_UnalignedLMatrix4f[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_396, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_396_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_396, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_396_comment},
  {"push_back", &Dtool_PointerToArray_UnalignedLMatrix4f_push_back_398, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_push_back_398_comment},
  {"pushBack", &Dtool_PointerToArray_UnalignedLMatrix4f_push_back_398, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_push_back_398_comment},
  {"pop_back", &Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_399, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_399_comment},
  {"popBack", &Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_399, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_399_comment},
  {"get_element", &Dtool_PointerToArray_UnalignedLMatrix4f_get_element_400, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_element_400_comment},
  {"getElement", &Dtool_PointerToArray_UnalignedLMatrix4f_get_element_400, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_element_400_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_set_element_401, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_element_401_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_set_element_401, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_element_401_comment},
  {"get_data", &Dtool_PointerToArray_UnalignedLMatrix4f_get_data_404, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_data_404_comment},
  {"getData", &Dtool_PointerToArray_UnalignedLMatrix4f_get_data_404, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_data_404_comment},
  {"set_data", &Dtool_PointerToArray_UnalignedLMatrix4f_set_data_405, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_data_405_comment},
  {"setData", &Dtool_PointerToArray_UnalignedLMatrix4f_set_data_405, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_data_405_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_406, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_406_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_406, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_406_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_407, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_407_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_407, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_407_comment},
  {"get_ref_count", &Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_408, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_408_comment},
  {"getRefCount", &Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_408, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_408_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_409, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_409_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_409, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_409_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_UnalignedLMatrix4f_getbuffer_410_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_UnalignedLMatrix4f.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_UnalignedLMatrix4f_releasebuffer_411_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< UnalignedLMatrix4f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4f slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_UnalignedLMatrix4f_setitem_403_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLMatrix4f index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< UnalignedLMatrix4f >::__setitem__(unsigned long int n, UnalignedLMatrix4f const &value)
      UnalignedLMatrix4f arg_local;
      UnalignedLMatrix4f const *arg_this = Dtool_Coerce_UnalignedLMatrix4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "UnalignedLMatrix4f");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const UnalignedLMatrix4f value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_getitem_402_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLMatrix4f index out of range");
    return NULL;
  }
  // 1-UnalignedLMatrix4f const &PointerToArray< UnalignedLMatrix4f >::__getitem__(unsigned long int n) const
  UnalignedLMatrix4f const *return_value = &(invoke_extension((const PointerToArray< UnalignedLMatrix4f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_UnalignedLMatrix4f_size_397_sq_length(PyObject *self) {
  PointerToArray< UnalignedLMatrix4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_UnalignedLMatrix4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_UnalignedLMatrix4f = {
  &Dtool_PointerToArray_UnalignedLMatrix4f_size_397_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_UnalignedLMatrix4f_getitem_402_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_UnalignedLMatrix4f_setitem_403_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_UnalignedLMatrix4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_UnalignedLMatrix4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_UnalignedLMatrix4f_getbuffer_410_bf_getbuffer,
  &Dtool_PointerToArray_UnalignedLMatrix4f_releasebuffer_411_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLMatrix4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_UnalignedLMatrix4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_UnalignedLMatrix4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_UnalignedLMatrix4f,
    &Dtool_SequenceMethods_PointerToArray_UnalignedLMatrix4f,
    &Dtool_MappingMethods_PointerToArray_UnalignedLMatrix4f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_UnalignedLMatrix4f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_UnalignedLMatrix4f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_UnalignedLMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_UnalignedLMatrix4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f,
  Dtool_UpcastInterface_PointerToArray_UnalignedLMatrix4f,
  Dtool_DowncastInterface_PointerToArray_UnalignedLMatrix4f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_UnalignedLMatrix4f,
};

static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f(NULL);
    Dtool_PointerToArray_UnalignedLMatrix4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_UnalignedLMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_UnalignedLMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_UnalignedLMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  }
}

/**
 * Python method tables for PointerToArray_UnalignedLVecBase4d (PointerToArray_UnalignedLVecBase4d)
 */
static PyMethodDef Dtool_Methods_PointerToArray_UnalignedLVecBase4d[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_415, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_415_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_415, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_415_comment},
  {"push_back", &Dtool_PointerToArray_UnalignedLVecBase4d_push_back_417, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_push_back_417_comment},
  {"pushBack", &Dtool_PointerToArray_UnalignedLVecBase4d_push_back_417, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_push_back_417_comment},
  {"pop_back", &Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_418, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_418_comment},
  {"popBack", &Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_418, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_418_comment},
  {"get_element", &Dtool_PointerToArray_UnalignedLVecBase4d_get_element_419, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_element_419_comment},
  {"getElement", &Dtool_PointerToArray_UnalignedLVecBase4d_get_element_419, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_element_419_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_set_element_420, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_element_420_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_set_element_420, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_element_420_comment},
  {"get_data", &Dtool_PointerToArray_UnalignedLVecBase4d_get_data_423, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_data_423_comment},
  {"getData", &Dtool_PointerToArray_UnalignedLVecBase4d_get_data_423, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_data_423_comment},
  {"set_data", &Dtool_PointerToArray_UnalignedLVecBase4d_set_data_424, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_data_424_comment},
  {"setData", &Dtool_PointerToArray_UnalignedLVecBase4d_set_data_424, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_data_424_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_425, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_425_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_425, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_425_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_426, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_426_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_426, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_426_comment},
  {"get_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_427, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_427_comment},
  {"getRefCount", &Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_427, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_427_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_428, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_428_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_428, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_428_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4d_getbuffer_429_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_UnalignedLVecBase4d.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_UnalignedLVecBase4d_releasebuffer_430_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< UnalignedLVecBase4d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4d slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4d_setitem_422_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4d index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< UnalignedLVecBase4d >::__setitem__(unsigned long int n, UnalignedLVecBase4d const &value)
      UnalignedLVecBase4d arg_local;
      UnalignedLVecBase4d const *arg_this = Dtool_Coerce_UnalignedLVecBase4d(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "UnalignedLVecBase4d");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const UnalignedLVecBase4d value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_getitem_421_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4d index out of range");
    return NULL;
  }
  // 1-UnalignedLVecBase4d const &PointerToArray< UnalignedLVecBase4d >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4d const *return_value = &(invoke_extension((const PointerToArray< UnalignedLVecBase4d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_UnalignedLVecBase4d_size_416_sq_length(PyObject *self) {
  PointerToArray< UnalignedLVecBase4d > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4d = {
  &Dtool_PointerToArray_UnalignedLVecBase4d_size_416_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_UnalignedLVecBase4d_getitem_421_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_UnalignedLVecBase4d_setitem_422_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_UnalignedLVecBase4d_getbuffer_429_bf_getbuffer,
  &Dtool_PointerToArray_UnalignedLVecBase4d_releasebuffer_430_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLVecBase4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_UnalignedLVecBase4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_UnalignedLVecBase4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4d,
    &Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4d,
    &Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_UnalignedLVecBase4d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_UnalignedLVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_UnalignedLVecBase4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d,
  Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4d,
  Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_UnalignedLVecBase4d,
};

static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d(NULL);
    Dtool_PointerToArray_UnalignedLVecBase4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_UnalignedLVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_UnalignedLVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  }
}

/**
 * Python method tables for PointerToArray_UnalignedLVecBase4f (PointerToArray_UnalignedLVecBase4f)
 */
static PyMethodDef Dtool_Methods_PointerToArray_UnalignedLVecBase4f[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_434, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_434_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_434, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_434_comment},
  {"push_back", &Dtool_PointerToArray_UnalignedLVecBase4f_push_back_436, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_push_back_436_comment},
  {"pushBack", &Dtool_PointerToArray_UnalignedLVecBase4f_push_back_436, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_push_back_436_comment},
  {"pop_back", &Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_437, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_437_comment},
  {"popBack", &Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_437, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_437_comment},
  {"get_element", &Dtool_PointerToArray_UnalignedLVecBase4f_get_element_438, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_element_438_comment},
  {"getElement", &Dtool_PointerToArray_UnalignedLVecBase4f_get_element_438, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_element_438_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_set_element_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_element_439_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_set_element_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_element_439_comment},
  {"get_data", &Dtool_PointerToArray_UnalignedLVecBase4f_get_data_442, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_data_442_comment},
  {"getData", &Dtool_PointerToArray_UnalignedLVecBase4f_get_data_442, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_data_442_comment},
  {"set_data", &Dtool_PointerToArray_UnalignedLVecBase4f_set_data_443, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_data_443_comment},
  {"setData", &Dtool_PointerToArray_UnalignedLVecBase4f_set_data_443, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_data_443_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_444, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_444_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_444, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_444_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_445, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_445_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_445, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_445_comment},
  {"get_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_446, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_446_comment},
  {"getRefCount", &Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_446, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_446_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_447, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_447_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_447, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_447_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4f_getbuffer_448_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_UnalignedLVecBase4f.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_UnalignedLVecBase4f_releasebuffer_449_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< UnalignedLVecBase4f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4f slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4f_setitem_441_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4f index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< UnalignedLVecBase4f >::__setitem__(unsigned long int n, UnalignedLVecBase4f const &value)
      UnalignedLVecBase4f arg_local;
      UnalignedLVecBase4f const *arg_this = Dtool_Coerce_UnalignedLVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "UnalignedLVecBase4f");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const UnalignedLVecBase4f value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_getitem_440_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4f index out of range");
    return NULL;
  }
  // 1-UnalignedLVecBase4f const &PointerToArray< UnalignedLVecBase4f >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4f const *return_value = &(invoke_extension((const PointerToArray< UnalignedLVecBase4f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_UnalignedLVecBase4f_size_435_sq_length(PyObject *self) {
  PointerToArray< UnalignedLVecBase4f > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4f = {
  &Dtool_PointerToArray_UnalignedLVecBase4f_size_435_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_UnalignedLVecBase4f_getitem_440_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_UnalignedLVecBase4f_setitem_441_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_UnalignedLVecBase4f_getbuffer_448_bf_getbuffer,
  &Dtool_PointerToArray_UnalignedLVecBase4f_releasebuffer_449_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLVecBase4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_UnalignedLVecBase4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_UnalignedLVecBase4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4f,
    &Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4f,
    &Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_UnalignedLVecBase4f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_UnalignedLVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_UnalignedLVecBase4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f,
  Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4f,
  Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_UnalignedLVecBase4f,
};

static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f(NULL);
    Dtool_PointerToArray_UnalignedLVecBase4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_UnalignedLVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_UnalignedLVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  }
}

/**
 * Python method tables for PointerToArray_UnalignedLVecBase4i (PointerToArray_UnalignedLVecBase4i)
 */
static PyMethodDef Dtool_Methods_PointerToArray_UnalignedLVecBase4i[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_453, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_453_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_453, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_453_comment},
  {"push_back", &Dtool_PointerToArray_UnalignedLVecBase4i_push_back_455, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_push_back_455_comment},
  {"pushBack", &Dtool_PointerToArray_UnalignedLVecBase4i_push_back_455, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_push_back_455_comment},
  {"pop_back", &Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_456, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_456_comment},
  {"popBack", &Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_456, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_456_comment},
  {"get_element", &Dtool_PointerToArray_UnalignedLVecBase4i_get_element_457, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_element_457_comment},
  {"getElement", &Dtool_PointerToArray_UnalignedLVecBase4i_get_element_457, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_element_457_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_set_element_458, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_element_458_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_set_element_458, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_element_458_comment},
  {"get_data", &Dtool_PointerToArray_UnalignedLVecBase4i_get_data_461, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_data_461_comment},
  {"getData", &Dtool_PointerToArray_UnalignedLVecBase4i_get_data_461, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_data_461_comment},
  {"set_data", &Dtool_PointerToArray_UnalignedLVecBase4i_set_data_462, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_data_462_comment},
  {"setData", &Dtool_PointerToArray_UnalignedLVecBase4i_set_data_462, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_data_462_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_463, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_463_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_463, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_463_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_464, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_464_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_464, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_464_comment},
  {"get_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_465, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_465_comment},
  {"getRefCount", &Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_465, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_465_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_466, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_466_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_466, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_466_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4i_getbuffer_467_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_UnalignedLVecBase4i.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_UnalignedLVecBase4i_releasebuffer_468_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< UnalignedLVecBase4i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4i slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4i_setitem_460_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4i index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< UnalignedLVecBase4i >::__setitem__(unsigned long int n, UnalignedLVecBase4i const &value)
      UnalignedLVecBase4i arg_local;
      UnalignedLVecBase4i const *arg_this = Dtool_Coerce_UnalignedLVecBase4i(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "UnalignedLVecBase4i");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const UnalignedLVecBase4i value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_getitem_459_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4i index out of range");
    return NULL;
  }
  // 1-UnalignedLVecBase4i const &PointerToArray< UnalignedLVecBase4i >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4i const *return_value = &(invoke_extension((const PointerToArray< UnalignedLVecBase4i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_UnalignedLVecBase4i_size_454_sq_length(PyObject *self) {
  PointerToArray< UnalignedLVecBase4i > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4i = {
  &Dtool_PointerToArray_UnalignedLVecBase4i_size_454_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_UnalignedLVecBase4i_getitem_459_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_UnalignedLVecBase4i_setitem_460_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_UnalignedLVecBase4i_getbuffer_467_bf_getbuffer,
  &Dtool_PointerToArray_UnalignedLVecBase4i_releasebuffer_468_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLVecBase4i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_UnalignedLVecBase4i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_UnalignedLVecBase4i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4i,
    &Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4i,
    &Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_UnalignedLVecBase4i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_UnalignedLVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_UnalignedLVecBase4i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4i,
  Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4i,
  Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_UnalignedLVecBase4i,
};

static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i(NULL);
    Dtool_PointerToArray_UnalignedLVecBase4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_UnalignedLVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_UnalignedLVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  }
}

/**
 * Python method tables for BoundingVolume (BoundingVolume)
 */
static PyMethodDef Dtool_Methods_BoundingVolume[] = {
  {"make_copy", &Dtool_BoundingVolume_make_copy_472, METH_NOARGS, (const char *)Dtool_BoundingVolume_make_copy_472_comment},
  {"makeCopy", &Dtool_BoundingVolume_make_copy_472, METH_NOARGS, (const char *)Dtool_BoundingVolume_make_copy_472_comment},
  {"is_empty", &Dtool_BoundingVolume_is_empty_473, METH_NOARGS, (const char *)Dtool_BoundingVolume_is_empty_473_comment},
  {"isEmpty", &Dtool_BoundingVolume_is_empty_473, METH_NOARGS, (const char *)Dtool_BoundingVolume_is_empty_473_comment},
  {"is_infinite", &Dtool_BoundingVolume_is_infinite_474, METH_NOARGS, (const char *)Dtool_BoundingVolume_is_infinite_474_comment},
  {"isInfinite", &Dtool_BoundingVolume_is_infinite_474, METH_NOARGS, (const char *)Dtool_BoundingVolume_is_infinite_474_comment},
  {"set_infinite", &Dtool_BoundingVolume_set_infinite_475, METH_NOARGS, (const char *)Dtool_BoundingVolume_set_infinite_475_comment},
  {"setInfinite", &Dtool_BoundingVolume_set_infinite_475, METH_NOARGS, (const char *)Dtool_BoundingVolume_set_infinite_475_comment},
  {"extend_by", &Dtool_BoundingVolume_extend_by_476, METH_O, (const char *)Dtool_BoundingVolume_extend_by_476_comment},
  {"extendBy", &Dtool_BoundingVolume_extend_by_476, METH_O, (const char *)Dtool_BoundingVolume_extend_by_476_comment},
  {"contains", &Dtool_BoundingVolume_contains_478, METH_O, (const char *)Dtool_BoundingVolume_contains_478_comment},
  {"output", &Dtool_BoundingVolume_output_479, METH_O, (const char *)Dtool_BoundingVolume_output_479_comment},
  {"write", (PyCFunction) &Dtool_BoundingVolume_write_480, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BoundingVolume_write_480_comment},
  {"get_class_type", &Dtool_BoundingVolume_get_class_type_482, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingVolume_get_class_type_482_comment},
  {"getClassType", &Dtool_BoundingVolume_get_class_type_482, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingVolume_get_class_type_482_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     BoundingVolume
//////////////////
static PyObject *Dtool_Repr_BoundingVolume(PyObject *self) {
  BoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingVolume, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BoundingVolume
//////////////////
static PyObject *Dtool_Str_BoundingVolume(PyObject *self) {
  BoundingVolume *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingVolume, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_BoundingVolume = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingVolume = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BoundingVolume = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BoundingVolume = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BoundingVolume = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BoundingVolume",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingVolume,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_BoundingVolume,
    &Dtool_NumberMethods_BoundingVolume,
    &Dtool_SequenceMethods_BoundingVolume,
    &Dtool_MappingMethods_BoundingVolume,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_BoundingVolume,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an abstract class for any volume in any sense which can be said to\n"
    " * define the locality of reference of a node in a graph, along with all of\n"
    " * its descendants.  It is not necessarily a geometric volume (although see\n"
    " * GeometricBoundingVolume); this is simply an abstract interface for bounds\n"
    " * of any sort.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BoundingVolume,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_BoundingVolume,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingVolume,
  Dtool_UpcastInterface_BoundingVolume,
  Dtool_DowncastInterface_BoundingVolume,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_BoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_BoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = _PyDict_NewPresized(21);
    Dtool_BoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BoundingVolume::IntersectionFlags;
    PyDict_SetItemString(dict, "IF_no_intersection", Dtool_WrapValue(BoundingVolume::IF_no_intersection));
    PyDict_SetItemString(dict, "IFNoIntersection", Dtool_WrapValue(BoundingVolume::IF_no_intersection));
    PyDict_SetItemString(dict, "IF_possible", Dtool_WrapValue(BoundingVolume::IF_possible));
    PyDict_SetItemString(dict, "IFPossible", Dtool_WrapValue(BoundingVolume::IF_possible));
    PyDict_SetItemString(dict, "IF_some", Dtool_WrapValue(BoundingVolume::IF_some));
    PyDict_SetItemString(dict, "IFSome", Dtool_WrapValue(BoundingVolume::IF_some));
    PyDict_SetItemString(dict, "IF_all", Dtool_WrapValue(BoundingVolume::IF_all));
    PyDict_SetItemString(dict, "IFAll", Dtool_WrapValue(BoundingVolume::IF_all));
    PyDict_SetItemString(dict, "IF_dont_understand", Dtool_WrapValue(BoundingVolume::IF_dont_understand));
    PyDict_SetItemString(dict, "IFDontUnderstand", Dtool_WrapValue(BoundingVolume::IF_dont_understand));
    // enum BoundingVolume::BoundsType;
    PyDict_SetItemString(dict, "BT_default", Dtool_WrapValue(BoundingVolume::BT_default));
    PyDict_SetItemString(dict, "BTDefault", Dtool_WrapValue(BoundingVolume::BT_default));
    PyDict_SetItemString(dict, "BT_best", Dtool_WrapValue(BoundingVolume::BT_best));
    PyDict_SetItemString(dict, "BTBest", Dtool_WrapValue(BoundingVolume::BT_best));
    PyDict_SetItemString(dict, "BT_sphere", Dtool_WrapValue(BoundingVolume::BT_sphere));
    PyDict_SetItemString(dict, "BTSphere", Dtool_WrapValue(BoundingVolume::BT_sphere));
    PyDict_SetItemString(dict, "BT_box", Dtool_WrapValue(BoundingVolume::BT_box));
    PyDict_SetItemString(dict, "BTBox", Dtool_WrapValue(BoundingVolume::BT_box));
    PyDict_SetItemString(dict, "BT_fastest", Dtool_WrapValue(BoundingVolume::BT_fastest));
    PyDict_SetItemString(dict, "BTFastest", Dtool_WrapValue(BoundingVolume::BT_fastest));
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingVolume);
  }
}

/**
 * Python method tables for GeometricBoundingVolume (GeometricBoundingVolume)
 */
static PyMethodDef Dtool_Methods_GeometricBoundingVolume[] = {
  {"extend_by", &Dtool_GeometricBoundingVolume_extend_by_485, METH_O, (const char *)Dtool_GeometricBoundingVolume_extend_by_485_comment},
  {"extendBy", &Dtool_GeometricBoundingVolume_extend_by_485, METH_O, (const char *)Dtool_GeometricBoundingVolume_extend_by_485_comment},
  {"contains", (PyCFunction) &Dtool_GeometricBoundingVolume_contains_486, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeometricBoundingVolume_contains_486_comment},
  {"get_approx_center", &Dtool_GeometricBoundingVolume_get_approx_center_487, METH_NOARGS, (const char *)Dtool_GeometricBoundingVolume_get_approx_center_487_comment},
  {"getApproxCenter", &Dtool_GeometricBoundingVolume_get_approx_center_487, METH_NOARGS, (const char *)Dtool_GeometricBoundingVolume_get_approx_center_487_comment},
  {"xform", &Dtool_GeometricBoundingVolume_xform_488, METH_O, (const char *)Dtool_GeometricBoundingVolume_xform_488_comment},
  {"get_class_type", &Dtool_GeometricBoundingVolume_get_class_type_489, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeometricBoundingVolume_get_class_type_489_comment},
  {"getClassType", &Dtool_GeometricBoundingVolume_get_class_type_489, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeometricBoundingVolume_get_class_type_489_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_GeometricBoundingVolume = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeometricBoundingVolume = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_GeometricBoundingVolume = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_GeometricBoundingVolume = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_GeometricBoundingVolume = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.GeometricBoundingVolume",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_GeometricBoundingVolume,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_GeometricBoundingVolume,
    &Dtool_SequenceMethods_GeometricBoundingVolume,
    &Dtool_MappingMethods_GeometricBoundingVolume,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_GeometricBoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is another abstract class, for a general class of bounding volumes\n"
    " * that actually enclose points in 3-d space, such as BSP's and bounding\n"
    " * spheres.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_GeometricBoundingVolume,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_GeometricBoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_GeometricBoundingVolume,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeometricBoundingVolume,
  Dtool_UpcastInterface_GeometricBoundingVolume,
  Dtool_DowncastInterface_GeometricBoundingVolume,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_GeometricBoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BoundingVolume(NULL);
    Dtool_GeometricBoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BoundingVolume);
    PyObject *dict = PyDict_New();
    Dtool_GeometricBoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeometricBoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeometricBoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeometricBoundingVolume);
  }
}

/**
 * Python method tables for FiniteBoundingVolume (FiniteBoundingVolume)
 */
static PyMethodDef Dtool_Methods_FiniteBoundingVolume[] = {
  {"get_min", &Dtool_FiniteBoundingVolume_get_min_492, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_min_492_comment},
  {"getMin", &Dtool_FiniteBoundingVolume_get_min_492, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_min_492_comment},
  {"get_max", &Dtool_FiniteBoundingVolume_get_max_493, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_max_493_comment},
  {"getMax", &Dtool_FiniteBoundingVolume_get_max_493, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_max_493_comment},
  {"get_volume", &Dtool_FiniteBoundingVolume_get_volume_494, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_volume_494_comment},
  {"getVolume", &Dtool_FiniteBoundingVolume_get_volume_494, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_volume_494_comment},
  {"get_class_type", &Dtool_FiniteBoundingVolume_get_class_type_495, METH_NOARGS | METH_STATIC, (const char *)Dtool_FiniteBoundingVolume_get_class_type_495_comment},
  {"getClassType", &Dtool_FiniteBoundingVolume_get_class_type_495, METH_NOARGS | METH_STATIC, (const char *)Dtool_FiniteBoundingVolume_get_class_type_495_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_FiniteBoundingVolume = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FiniteBoundingVolume = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_FiniteBoundingVolume = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_FiniteBoundingVolume = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_FiniteBoundingVolume = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.FiniteBoundingVolume",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_FiniteBoundingVolume,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_FiniteBoundingVolume,
    &Dtool_SequenceMethods_FiniteBoundingVolume,
    &Dtool_MappingMethods_FiniteBoundingVolume,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_FiniteBoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special kind of GeometricBoundingVolume that is known to be finite.  It\n"
    " * is possible to query this kind of volume for its minimum and maximum\n"
    " * extents.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_FiniteBoundingVolume,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_FiniteBoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_FiniteBoundingVolume,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FiniteBoundingVolume,
  Dtool_UpcastInterface_FiniteBoundingVolume,
  Dtool_DowncastInterface_FiniteBoundingVolume,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_FiniteBoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(NULL);
    Dtool_FiniteBoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    PyObject *dict = PyDict_New();
    Dtool_FiniteBoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FiniteBoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FiniteBoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FiniteBoundingVolume);
  }
}

/**
 * Python method tables for LParabolaf (LParabolaf)
 */
static PyMethodDef Dtool_Methods_LParabolaf[] = {
  {"assign", &Dtool_LParabolaf_operator_499, METH_O, (const char *)Dtool_LParabolaf_operator_499_comment},
  {"xform", &Dtool_LParabolaf_xform_501, METH_O, (const char *)Dtool_LParabolaf_xform_501_comment},
  {"get_a", &Dtool_LParabolaf_get_a_502, METH_NOARGS, (const char *)Dtool_LParabolaf_get_a_502_comment},
  {"getA", &Dtool_LParabolaf_get_a_502, METH_NOARGS, (const char *)Dtool_LParabolaf_get_a_502_comment},
  {"get_b", &Dtool_LParabolaf_get_b_503, METH_NOARGS, (const char *)Dtool_LParabolaf_get_b_503_comment},
  {"getB", &Dtool_LParabolaf_get_b_503, METH_NOARGS, (const char *)Dtool_LParabolaf_get_b_503_comment},
  {"get_c", &Dtool_LParabolaf_get_c_504, METH_NOARGS, (const char *)Dtool_LParabolaf_get_c_504_comment},
  {"getC", &Dtool_LParabolaf_get_c_504, METH_NOARGS, (const char *)Dtool_LParabolaf_get_c_504_comment},
  {"calc_point", &Dtool_LParabolaf_calc_point_505, METH_O, (const char *)Dtool_LParabolaf_calc_point_505_comment},
  {"calcPoint", &Dtool_LParabolaf_calc_point_505, METH_O, (const char *)Dtool_LParabolaf_calc_point_505_comment},
  {"output", &Dtool_LParabolaf_output_506, METH_O, (const char *)Dtool_LParabolaf_output_506_comment},
  {"write", (PyCFunction) &Dtool_LParabolaf_write_507, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LParabolaf_write_507_comment},
  {"write_datagram_fixed", &Dtool_LParabolaf_write_datagram_fixed_508, METH_O, (const char *)Dtool_LParabolaf_write_datagram_fixed_508_comment},
  {"writeDatagramFixed", &Dtool_LParabolaf_write_datagram_fixed_508, METH_O, (const char *)Dtool_LParabolaf_write_datagram_fixed_508_comment},
  {"read_datagram_fixed", &Dtool_LParabolaf_read_datagram_fixed_509, METH_O, (const char *)Dtool_LParabolaf_read_datagram_fixed_509_comment},
  {"readDatagramFixed", &Dtool_LParabolaf_read_datagram_fixed_509, METH_O, (const char *)Dtool_LParabolaf_read_datagram_fixed_509_comment},
  {"write_datagram", &Dtool_LParabolaf_write_datagram_510, METH_O, (const char *)Dtool_LParabolaf_write_datagram_510_comment},
  {"writeDatagram", &Dtool_LParabolaf_write_datagram_510, METH_O, (const char *)Dtool_LParabolaf_write_datagram_510_comment},
  {"read_datagram", &Dtool_LParabolaf_read_datagram_511, METH_O, (const char *)Dtool_LParabolaf_read_datagram_511_comment},
  {"readDatagram", &Dtool_LParabolaf_read_datagram_511, METH_O, (const char *)Dtool_LParabolaf_read_datagram_511_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     LParabolaf
//////////////////
static PyObject *Dtool_Repr_LParabolaf(PyObject *self) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LParabolaf
//////////////////
static PyObject *Dtool_Str_LParabolaf(PyObject *self) {
  LParabolaf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LParabolaf = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_LParabolaf = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LParabolaf",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LParabolaf,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_LParabolaf,
    &Dtool_NumberMethods_LParabolaf,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_LParabolaf,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract mathematical description of a parabola, particularly useful for\n"
    " * describing arcs of projectiles.\n"
    " *\n"
    " * The parabolic equation, given parametrically here, is P = At^2 + Bt + C.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LParabolaf,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LParabolaf,
    PyType_GenericAlloc,
    Dtool_new_LParabolaf,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LParabolaf,
  Dtool_UpcastInterface_LParabolaf,
  Dtool_DowncastInterface_LParabolaf,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LParabolaf,
};

static void Dtool_PyModuleClassInit_LParabolaf(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LParabolaf._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LParabolaf._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LParabolaf) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LParabolaf)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LParabolaf);
  }
}

/**
 * Python method tables for LParabolad (LParabolad)
 */
static PyMethodDef Dtool_Methods_LParabolad[] = {
  {"assign", &Dtool_LParabolad_operator_514, METH_O, (const char *)Dtool_LParabolad_operator_514_comment},
  {"xform", &Dtool_LParabolad_xform_516, METH_O, (const char *)Dtool_LParabolad_xform_516_comment},
  {"get_a", &Dtool_LParabolad_get_a_517, METH_NOARGS, (const char *)Dtool_LParabolad_get_a_517_comment},
  {"getA", &Dtool_LParabolad_get_a_517, METH_NOARGS, (const char *)Dtool_LParabolad_get_a_517_comment},
  {"get_b", &Dtool_LParabolad_get_b_518, METH_NOARGS, (const char *)Dtool_LParabolad_get_b_518_comment},
  {"getB", &Dtool_LParabolad_get_b_518, METH_NOARGS, (const char *)Dtool_LParabolad_get_b_518_comment},
  {"get_c", &Dtool_LParabolad_get_c_519, METH_NOARGS, (const char *)Dtool_LParabolad_get_c_519_comment},
  {"getC", &Dtool_LParabolad_get_c_519, METH_NOARGS, (const char *)Dtool_LParabolad_get_c_519_comment},
  {"calc_point", &Dtool_LParabolad_calc_point_520, METH_O, (const char *)Dtool_LParabolad_calc_point_520_comment},
  {"calcPoint", &Dtool_LParabolad_calc_point_520, METH_O, (const char *)Dtool_LParabolad_calc_point_520_comment},
  {"output", &Dtool_LParabolad_output_521, METH_O, (const char *)Dtool_LParabolad_output_521_comment},
  {"write", (PyCFunction) &Dtool_LParabolad_write_522, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LParabolad_write_522_comment},
  {"write_datagram_fixed", &Dtool_LParabolad_write_datagram_fixed_523, METH_O, (const char *)Dtool_LParabolad_write_datagram_fixed_523_comment},
  {"writeDatagramFixed", &Dtool_LParabolad_write_datagram_fixed_523, METH_O, (const char *)Dtool_LParabolad_write_datagram_fixed_523_comment},
  {"read_datagram_fixed", &Dtool_LParabolad_read_datagram_fixed_524, METH_O, (const char *)Dtool_LParabolad_read_datagram_fixed_524_comment},
  {"readDatagramFixed", &Dtool_LParabolad_read_datagram_fixed_524, METH_O, (const char *)Dtool_LParabolad_read_datagram_fixed_524_comment},
  {"write_datagram", &Dtool_LParabolad_write_datagram_525, METH_O, (const char *)Dtool_LParabolad_write_datagram_525_comment},
  {"writeDatagram", &Dtool_LParabolad_write_datagram_525, METH_O, (const char *)Dtool_LParabolad_write_datagram_525_comment},
  {"read_datagram", &Dtool_LParabolad_read_datagram_526, METH_O, (const char *)Dtool_LParabolad_read_datagram_526_comment},
  {"readDatagram", &Dtool_LParabolad_read_datagram_526, METH_O, (const char *)Dtool_LParabolad_read_datagram_526_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     LParabolad
//////////////////
static PyObject *Dtool_Repr_LParabolad(PyObject *self) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LParabolad
//////////////////
static PyObject *Dtool_Str_LParabolad(PyObject *self) {
  LParabolad *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LParabolad = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_LParabolad = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LParabolad",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LParabolad,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_LParabolad,
    &Dtool_NumberMethods_LParabolad,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_LParabolad,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract mathematical description of a parabola, particularly useful for\n"
    " * describing arcs of projectiles.\n"
    " *\n"
    " * The parabolic equation, given parametrically here, is P = At^2 + Bt + C.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LParabolad,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LParabolad,
    PyType_GenericAlloc,
    Dtool_new_LParabolad,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LParabolad,
  Dtool_UpcastInterface_LParabolad,
  Dtool_DowncastInterface_LParabolad,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LParabolad,
};

static void Dtool_PyModuleClassInit_LParabolad(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LParabolad._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LParabolad._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LParabolad) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LParabolad)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LParabolad);
  }
}

/**
 * Python method tables for LPlanef (LPlanef)
 */
static PyMethodDef Dtool_Methods_LPlanef[] = {
  {"xform", &Dtool_LPlanef_xform_533, METH_O, (const char *)Dtool_LPlanef_xform_533_comment},
  {"get_reflection_mat", &Dtool_LPlanef_get_reflection_mat_535, METH_NOARGS, (const char *)Dtool_LPlanef_get_reflection_mat_535_comment},
  {"getReflectionMat", &Dtool_LPlanef_get_reflection_mat_535, METH_NOARGS, (const char *)Dtool_LPlanef_get_reflection_mat_535_comment},
  {"get_normal", &Dtool_LPlanef_get_normal_536, METH_NOARGS, (const char *)Dtool_LPlanef_get_normal_536_comment},
  {"getNormal", &Dtool_LPlanef_get_normal_536, METH_NOARGS, (const char *)Dtool_LPlanef_get_normal_536_comment},
  {"get_point", &Dtool_LPlanef_get_point_537, METH_NOARGS, (const char *)Dtool_LPlanef_get_point_537_comment},
  {"getPoint", &Dtool_LPlanef_get_point_537, METH_NOARGS, (const char *)Dtool_LPlanef_get_point_537_comment},
  {"dist_to_plane", &Dtool_LPlanef_dist_to_plane_538, METH_O, (const char *)Dtool_LPlanef_dist_to_plane_538_comment},
  {"distToPlane", &Dtool_LPlanef_dist_to_plane_538, METH_O, (const char *)Dtool_LPlanef_dist_to_plane_538_comment},
  {"project", &Dtool_LPlanef_project_539, METH_O, (const char *)Dtool_LPlanef_project_539_comment},
  {"flip", &Dtool_LPlanef_flip_540, METH_NOARGS, (const char *)Dtool_LPlanef_flip_540_comment},
  {"intersects_line", (PyCFunction) &Dtool_LPlanef_intersects_line_541, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlanef_intersects_line_541_comment},
  {"intersectsLine", (PyCFunction) &Dtool_LPlanef_intersects_line_541, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlanef_intersects_line_541_comment},
  {"intersects_plane", (PyCFunction) &Dtool_LPlanef_intersects_plane_542, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlanef_intersects_plane_542_comment},
  {"intersectsPlane", (PyCFunction) &Dtool_LPlanef_intersects_plane_542, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlanef_intersects_plane_542_comment},
  {"output", &Dtool_LPlanef_output_544, METH_O, (const char *)Dtool_LPlanef_output_544_comment},
  {"write", (PyCFunction) &Dtool_LPlanef_write_545, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlanef_write_545_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlanef slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LPlanef_operator_532_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LPlanef *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPlanef, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LPlanef::operator *=(LMatrix4f const &mat)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LPlanef.__imul__", "LMatrix4f");
      return NULL;
    }
    (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LPlanef.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlanef slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPlanef_operator_531_nb_multiply(PyObject *self, PyObject *arg) {
  LPlanef *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPlanef, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPlanef LPlanef::operator *(LMatrix3f const &mat) const
    LMatrix3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LPlanef *return_value = new LPlanef((*(const LPlanef*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
    }
  }

  {
    // -2 inline LPlanef LPlanef::operator *(LMatrix4f const &mat) const
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LPlanef *return_value = new LPlanef((*(const LPlanef*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
    }
  }

  {
    // -2 inline LPlanef LPlanef::operator *(LMatrix3f const &mat) const
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LPlanef *return_value = new LPlanef((*(const LPlanef*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
    }
  }

  {
    // -2 inline LPlanef LPlanef::operator *(LMatrix4f const &mat) const
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LPlanef *return_value = new LPlanef((*(const LPlanef*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlanef slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPlanef_operator_534_nb_negative(PyObject *self) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPlanef LPlanef::operator -(void) const
  LPlanef *return_value = new LPlanef((*(const LPlanef*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPlanef self)\n");
  }
  return NULL;
}

//////////////////
//  A __repr__ function
//     LPlanef
//////////////////
static PyObject *Dtool_Repr_LPlanef(PyObject *self) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LPlanef
//////////////////
static PyObject *Dtool_Str_LPlanef(PyObject *self) {
  LPlanef *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LPlanef = {
  0, // nb_add
  0, // nb_subtract
  &Dtool_LPlanef_operator_531_nb_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LPlanef_operator_534_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  &Dtool_LPlanef_operator_532_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPlanef = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LPlanef = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LPlanef = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LPlanef = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LPlanef",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LPlanef,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_LPlanef,
    &Dtool_NumberMethods_LPlanef,
    &Dtool_SequenceMethods_LPlanef,
    &Dtool_MappingMethods_LPlanef,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_LPlanef,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LPlanef,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract mathematical description of a plane.  A plane is defined by the\n"
    " * equation Ax + By + Cz + D = 0.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LPlanef,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LPlanef,
    PyType_GenericAlloc,
    Dtool_new_LPlanef,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPlanef,
  Dtool_UpcastInterface_LPlanef,
  Dtool_DowncastInterface_LPlanef,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LPlanef,
};

static void Dtool_PyModuleClassInit_LPlanef(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_LVecBase4f != NULL);
    assert(Dtool_Ptr_LVecBase4f->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_LVecBase4f->_Dtool_ModuleClassInit(NULL);
    Dtool_LPlanef._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_LVecBase4f);
    PyObject *dict = PyDict_New();
    Dtool_LPlanef._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPlanef) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPlanef)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPlanef);
  }
}

/**
 * Python method tables for LPlaned (LPlaned)
 */
static PyMethodDef Dtool_Methods_LPlaned[] = {
  {"xform", &Dtool_LPlaned_xform_552, METH_O, (const char *)Dtool_LPlaned_xform_552_comment},
  {"get_reflection_mat", &Dtool_LPlaned_get_reflection_mat_554, METH_NOARGS, (const char *)Dtool_LPlaned_get_reflection_mat_554_comment},
  {"getReflectionMat", &Dtool_LPlaned_get_reflection_mat_554, METH_NOARGS, (const char *)Dtool_LPlaned_get_reflection_mat_554_comment},
  {"get_normal", &Dtool_LPlaned_get_normal_555, METH_NOARGS, (const char *)Dtool_LPlaned_get_normal_555_comment},
  {"getNormal", &Dtool_LPlaned_get_normal_555, METH_NOARGS, (const char *)Dtool_LPlaned_get_normal_555_comment},
  {"get_point", &Dtool_LPlaned_get_point_556, METH_NOARGS, (const char *)Dtool_LPlaned_get_point_556_comment},
  {"getPoint", &Dtool_LPlaned_get_point_556, METH_NOARGS, (const char *)Dtool_LPlaned_get_point_556_comment},
  {"dist_to_plane", &Dtool_LPlaned_dist_to_plane_557, METH_O, (const char *)Dtool_LPlaned_dist_to_plane_557_comment},
  {"distToPlane", &Dtool_LPlaned_dist_to_plane_557, METH_O, (const char *)Dtool_LPlaned_dist_to_plane_557_comment},
  {"project", &Dtool_LPlaned_project_558, METH_O, (const char *)Dtool_LPlaned_project_558_comment},
  {"flip", &Dtool_LPlaned_flip_559, METH_NOARGS, (const char *)Dtool_LPlaned_flip_559_comment},
  {"intersects_line", (PyCFunction) &Dtool_LPlaned_intersects_line_560, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlaned_intersects_line_560_comment},
  {"intersectsLine", (PyCFunction) &Dtool_LPlaned_intersects_line_560, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlaned_intersects_line_560_comment},
  {"intersects_plane", (PyCFunction) &Dtool_LPlaned_intersects_plane_561, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlaned_intersects_plane_561_comment},
  {"intersectsPlane", (PyCFunction) &Dtool_LPlaned_intersects_plane_561, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlaned_intersects_plane_561_comment},
  {"output", &Dtool_LPlaned_output_563, METH_O, (const char *)Dtool_LPlaned_output_563_comment},
  {"write", (PyCFunction) &Dtool_LPlaned_write_564, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlaned_write_564_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlaned slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LPlaned_operator_551_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LPlaned *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPlaned, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LPlaned::operator *=(LMatrix4d const &mat)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LPlaned.__imul__", "LMatrix4d");
      return NULL;
    }
    (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LPlaned.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlaned slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPlaned_operator_550_nb_multiply(PyObject *self, PyObject *arg) {
  LPlaned *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPlaned, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPlaned LPlaned::operator *(LMatrix3d const &mat) const
    LMatrix3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LPlaned *return_value = new LPlaned((*(const LPlaned*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, true, false);
    }
  }

  {
    // -2 inline LPlaned LPlaned::operator *(LMatrix4d const &mat) const
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LPlaned *return_value = new LPlaned((*(const LPlaned*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, true, false);
    }
  }

  {
    // -2 inline LPlaned LPlaned::operator *(LMatrix3d const &mat) const
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LPlaned *return_value = new LPlaned((*(const LPlaned*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, true, false);
    }
  }

  {
    // -2 inline LPlaned LPlaned::operator *(LMatrix4d const &mat) const
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LPlaned *return_value = new LPlaned((*(const LPlaned*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlaned slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPlaned_operator_553_nb_negative(PyObject *self) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPlaned LPlaned::operator -(void) const
  LPlaned *return_value = new LPlaned((*(const LPlaned*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPlaned self)\n");
  }
  return NULL;
}

//////////////////
//  A __repr__ function
//     LPlaned
//////////////////
static PyObject *Dtool_Repr_LPlaned(PyObject *self) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LPlaned
//////////////////
static PyObject *Dtool_Str_LPlaned(PyObject *self) {
  LPlaned *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LPlaned = {
  0, // nb_add
  0, // nb_subtract
  &Dtool_LPlaned_operator_550_nb_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LPlaned_operator_553_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  &Dtool_LPlaned_operator_551_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPlaned = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LPlaned = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LPlaned = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LPlaned = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LPlaned",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LPlaned,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_LPlaned,
    &Dtool_NumberMethods_LPlaned,
    &Dtool_SequenceMethods_LPlaned,
    &Dtool_MappingMethods_LPlaned,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_LPlaned,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LPlaned,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract mathematical description of a plane.  A plane is defined by the\n"
    " * equation Ax + By + Cz + D = 0.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LPlaned,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LPlaned,
    PyType_GenericAlloc,
    Dtool_new_LPlaned,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPlaned,
  Dtool_UpcastInterface_LPlaned,
  Dtool_DowncastInterface_LPlaned,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LPlaned,
};

static void Dtool_PyModuleClassInit_LPlaned(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_LVecBase4d != NULL);
    assert(Dtool_Ptr_LVecBase4d->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_LVecBase4d->_Dtool_ModuleClassInit(NULL);
    Dtool_LPlaned._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_LVecBase4d);
    PyObject *dict = PyDict_New();
    Dtool_LPlaned._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPlaned) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPlaned)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPlaned);
  }
}

/**
 * Python method tables for BoundingBox (BoundingBox)
 */
static PyMethodDef Dtool_Methods_BoundingBox[] = {
  {"get_num_points", &Dtool_BoundingBox_get_num_points_575, METH_NOARGS, (const char *)Dtool_BoundingBox_get_num_points_575_comment},
  {"getNumPoints", &Dtool_BoundingBox_get_num_points_575, METH_NOARGS, (const char *)Dtool_BoundingBox_get_num_points_575_comment},
  {"get_point", &Dtool_BoundingBox_get_point_576, METH_O, (const char *)Dtool_BoundingBox_get_point_576_comment},
  {"getPoint", &Dtool_BoundingBox_get_point_576, METH_O, (const char *)Dtool_BoundingBox_get_point_576_comment},
  {"get_num_planes", &Dtool_BoundingBox_get_num_planes_578, METH_NOARGS, (const char *)Dtool_BoundingBox_get_num_planes_578_comment},
  {"getNumPlanes", &Dtool_BoundingBox_get_num_planes_578, METH_NOARGS, (const char *)Dtool_BoundingBox_get_num_planes_578_comment},
  {"get_plane", &Dtool_BoundingBox_get_plane_579, METH_O, (const char *)Dtool_BoundingBox_get_plane_579_comment},
  {"getPlane", &Dtool_BoundingBox_get_plane_579, METH_O, (const char *)Dtool_BoundingBox_get_plane_579_comment},
  {"set_min_max", (PyCFunction) &Dtool_BoundingBox_set_min_max_585, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BoundingBox_set_min_max_585_comment},
  {"setMinMax", (PyCFunction) &Dtool_BoundingBox_set_min_max_585, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BoundingBox_set_min_max_585_comment},
  {"get_class_type", &Dtool_BoundingBox_get_class_type_586, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingBox_get_class_type_586_comment},
  {"getClassType", &Dtool_BoundingBox_get_class_type_586, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingBox_get_class_type_586_comment},
  {"get_points", (PyCFunction) &MakeSeq_BoundingBox_get_points, METH_NOARGS, NULL},
  { "getPoints", (PyCFunction) &MakeSeq_BoundingBox_get_points, METH_NOARGS, NULL},
  {"get_planes", (PyCFunction) &MakeSeq_BoundingBox_get_planes, METH_NOARGS, NULL},
  { "getPlanes", (PyCFunction) &MakeSeq_BoundingBox_get_planes, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_BoundingBox[] = {
  {(char *)"points", &Dtool_BoundingBox_points_Getter, NULL, NULL, NULL},
  {(char *)"planes", &Dtool_BoundingBox_planes_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_BoundingBox = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingBox = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BoundingBox = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BoundingBox = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BoundingBox = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BoundingBox",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingBox,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BoundingBox,
    &Dtool_SequenceMethods_BoundingBox,
    &Dtool_MappingMethods_BoundingBox,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BoundingBox,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An axis-aligned bounding box; that is, a minimum and maximum coordinate\n"
    " * triple.\n"
    " *\n"
    " * This box is always axis-aligned.  If you need a more general bounding box,\n"
    " * try BoundingHexahedron.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BoundingBox,
    0, // tp_members
    Dtool_Properties_BoundingBox,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BoundingBox,
    PyType_GenericAlloc,
    Dtool_new_BoundingBox,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingBox,
  Dtool_UpcastInterface_BoundingBox,
  Dtool_DowncastInterface_BoundingBox,
  (CoerceFunction)Dtool_ConstCoerce_BoundingBox,
  (CoerceFunction)Dtool_Coerce_BoundingBox,
};

static void Dtool_PyModuleClassInit_BoundingBox(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_FiniteBoundingVolume(NULL);
    Dtool_BoundingBox._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_FiniteBoundingVolume);
    PyObject *dict = PyDict_New();
    Dtool_BoundingBox._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingBox) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingBox)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingBox);
  }
}

/**
 * Python method tables for LFrustumf (LFrustumf)
 */
static PyMethodDef Dtool_Methods_LFrustumf[] = {
  {"make_ortho_2D", (PyCFunction) &Dtool_LFrustumf_make_ortho_2D_590, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_ortho_2D_590_comment},
  {"makeOrtho2D", (PyCFunction) &Dtool_LFrustumf_make_ortho_2D_590, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_ortho_2D_590_comment},
  {"make_ortho", (PyCFunction) &Dtool_LFrustumf_make_ortho_591, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_ortho_591_comment},
  {"makeOrtho", (PyCFunction) &Dtool_LFrustumf_make_ortho_591, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_ortho_591_comment},
  {"make_perspective_hfov", (PyCFunction) &Dtool_LFrustumf_make_perspective_hfov_592, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_hfov_592_comment},
  {"makePerspectiveHfov", (PyCFunction) &Dtool_LFrustumf_make_perspective_hfov_592, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_hfov_592_comment},
  {"make_perspective_vfov", (PyCFunction) &Dtool_LFrustumf_make_perspective_vfov_593, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_vfov_593_comment},
  {"makePerspectiveVfov", (PyCFunction) &Dtool_LFrustumf_make_perspective_vfov_593, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_vfov_593_comment},
  {"make_perspective", (PyCFunction) &Dtool_LFrustumf_make_perspective_594, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_594_comment},
  {"makePerspective", (PyCFunction) &Dtool_LFrustumf_make_perspective_594, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_594_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LFrustumf = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_LFrustumf = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LFrustumf",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LFrustumf,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LFrustumf,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LFrustumf,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LFrustumf,
    PyType_GenericAlloc,
    Dtool_new_LFrustumf,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LFrustumf,
  Dtool_UpcastInterface_LFrustumf,
  Dtool_DowncastInterface_LFrustumf,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LFrustumf(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LFrustumf._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LFrustumf._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LFrustumf) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LFrustumf)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LFrustumf);
  }
}

/**
 * Python method tables for LFrustumd (LFrustumd)
 */
static PyMethodDef Dtool_Methods_LFrustumd[] = {
  {"make_ortho_2D", (PyCFunction) &Dtool_LFrustumd_make_ortho_2D_599, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_ortho_2D_599_comment},
  {"makeOrtho2D", (PyCFunction) &Dtool_LFrustumd_make_ortho_2D_599, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_ortho_2D_599_comment},
  {"make_ortho", (PyCFunction) &Dtool_LFrustumd_make_ortho_600, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_ortho_600_comment},
  {"makeOrtho", (PyCFunction) &Dtool_LFrustumd_make_ortho_600, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_ortho_600_comment},
  {"make_perspective_hfov", (PyCFunction) &Dtool_LFrustumd_make_perspective_hfov_601, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_hfov_601_comment},
  {"makePerspectiveHfov", (PyCFunction) &Dtool_LFrustumd_make_perspective_hfov_601, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_hfov_601_comment},
  {"make_perspective_vfov", (PyCFunction) &Dtool_LFrustumd_make_perspective_vfov_602, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_vfov_602_comment},
  {"makePerspectiveVfov", (PyCFunction) &Dtool_LFrustumd_make_perspective_vfov_602, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_vfov_602_comment},
  {"make_perspective", (PyCFunction) &Dtool_LFrustumd_make_perspective_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_603_comment},
  {"makePerspective", (PyCFunction) &Dtool_LFrustumd_make_perspective_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_603_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LFrustumd = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_LFrustumd = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LFrustumd",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LFrustumd,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LFrustumd,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LFrustumd,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LFrustumd,
    PyType_GenericAlloc,
    Dtool_new_LFrustumd,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LFrustumd,
  Dtool_UpcastInterface_LFrustumd,
  Dtool_DowncastInterface_LFrustumd,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LFrustumd(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LFrustumd._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LFrustumd._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LFrustumd) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LFrustumd)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LFrustumd);
  }
}

/**
 * Python method tables for BoundingHexahedron (BoundingHexahedron)
 */
static PyMethodDef Dtool_Methods_BoundingHexahedron[] = {
  {"get_num_points", &Dtool_BoundingHexahedron_get_num_points_612, METH_NOARGS, (const char *)Dtool_BoundingHexahedron_get_num_points_612_comment},
  {"getNumPoints", &Dtool_BoundingHexahedron_get_num_points_612, METH_NOARGS, (const char *)Dtool_BoundingHexahedron_get_num_points_612_comment},
  {"get_point", &Dtool_BoundingHexahedron_get_point_613, METH_O, (const char *)Dtool_BoundingHexahedron_get_point_613_comment},
  {"getPoint", &Dtool_BoundingHexahedron_get_point_613, METH_O, (const char *)Dtool_BoundingHexahedron_get_point_613_comment},
  {"get_num_planes", &Dtool_BoundingHexahedron_get_num_planes_615, METH_NOARGS, (const char *)Dtool_BoundingHexahedron_get_num_planes_615_comment},
  {"getNumPlanes", &Dtool_BoundingHexahedron_get_num_planes_615, METH_NOARGS, (const char *)Dtool_BoundingHexahedron_get_num_planes_615_comment},
  {"get_plane", &Dtool_BoundingHexahedron_get_plane_616, METH_O, (const char *)Dtool_BoundingHexahedron_get_plane_616_comment},
  {"getPlane", &Dtool_BoundingHexahedron_get_plane_616, METH_O, (const char *)Dtool_BoundingHexahedron_get_plane_616_comment},
  {"get_class_type", &Dtool_BoundingHexahedron_get_class_type_620, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingHexahedron_get_class_type_620_comment},
  {"getClassType", &Dtool_BoundingHexahedron_get_class_type_620, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingHexahedron_get_class_type_620_comment},
  {"get_points", (PyCFunction) &MakeSeq_BoundingHexahedron_get_points, METH_NOARGS, NULL},
  { "getPoints", (PyCFunction) &MakeSeq_BoundingHexahedron_get_points, METH_NOARGS, NULL},
  {"get_planes", (PyCFunction) &MakeSeq_BoundingHexahedron_get_planes, METH_NOARGS, NULL},
  { "getPlanes", (PyCFunction) &MakeSeq_BoundingHexahedron_get_planes, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_BoundingHexahedron[] = {
  {(char *)"points", &Dtool_BoundingHexahedron_points_Getter, NULL, NULL, NULL},
  {(char *)"planes", &Dtool_BoundingHexahedron_planes_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_BoundingHexahedron = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingHexahedron = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BoundingHexahedron = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BoundingHexahedron = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BoundingHexahedron = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BoundingHexahedron",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingHexahedron,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BoundingHexahedron,
    &Dtool_SequenceMethods_BoundingHexahedron,
    &Dtool_MappingMethods_BoundingHexahedron,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BoundingHexahedron,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines a bounding convex hexahedron.  It is typically used to\n"
    " * represent a frustum, but may represent any enclosing convex hexahedron,\n"
    " * including simple boxes.  However, if all you want is an axis-aligned\n"
    " * bounding box, you may be better off with the simpler BoundingBox class.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BoundingHexahedron,
    0, // tp_members
    Dtool_Properties_BoundingHexahedron,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BoundingHexahedron,
    PyType_GenericAlloc,
    Dtool_new_BoundingHexahedron,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingHexahedron,
  Dtool_UpcastInterface_BoundingHexahedron,
  Dtool_DowncastInterface_BoundingHexahedron,
  (CoerceFunction)Dtool_ConstCoerce_BoundingHexahedron,
  (CoerceFunction)Dtool_Coerce_BoundingHexahedron,
};

static void Dtool_PyModuleClassInit_BoundingHexahedron(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_FiniteBoundingVolume(NULL);
    Dtool_BoundingHexahedron._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_FiniteBoundingVolume);
    PyObject *dict = PyDict_New();
    Dtool_BoundingHexahedron._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingHexahedron) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingHexahedron)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingHexahedron);
  }
}

/**
 * Python method tables for BoundingLine (BoundingLine)
 */
static PyMethodDef Dtool_Methods_BoundingLine[] = {
  {"get_point_a", &Dtool_BoundingLine_get_point_a_627, METH_NOARGS, (const char *)Dtool_BoundingLine_get_point_a_627_comment},
  {"getPointA", &Dtool_BoundingLine_get_point_a_627, METH_NOARGS, (const char *)Dtool_BoundingLine_get_point_a_627_comment},
  {"get_point_b", &Dtool_BoundingLine_get_point_b_628, METH_NOARGS, (const char *)Dtool_BoundingLine_get_point_b_628_comment},
  {"getPointB", &Dtool_BoundingLine_get_point_b_628, METH_NOARGS, (const char *)Dtool_BoundingLine_get_point_b_628_comment},
  {"get_class_type", &Dtool_BoundingLine_get_class_type_629, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingLine_get_class_type_629_comment},
  {"getClassType", &Dtool_BoundingLine_get_class_type_629, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingLine_get_class_type_629_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_BoundingLine = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingLine = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BoundingLine = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BoundingLine = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BoundingLine = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BoundingLine",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingLine,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BoundingLine,
    &Dtool_SequenceMethods_BoundingLine,
    &Dtool_MappingMethods_BoundingLine,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BoundingLine,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This funny bounding volume is an infinite line with no thickness and\n"
    " * extending to infinity in both directions.\n"
    " *\n"
    " * Note that it *always* extends in both directions, despite the fact that you\n"
    " * specify two points to the constructor.  These are not endpoints, they are\n"
    " * two arbitrary points on the line.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BoundingLine,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BoundingLine,
    PyType_GenericAlloc,
    Dtool_new_BoundingLine,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingLine,
  Dtool_UpcastInterface_BoundingLine,
  Dtool_DowncastInterface_BoundingLine,
  (CoerceFunction)Dtool_ConstCoerce_BoundingLine,
  (CoerceFunction)Dtool_Coerce_BoundingLine,
};

static void Dtool_PyModuleClassInit_BoundingLine(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(NULL);
    Dtool_BoundingLine._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    PyObject *dict = PyDict_New();
    Dtool_BoundingLine._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingLine) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingLine)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingLine);
  }
}

/**
 * Python method tables for BoundingPlane (BoundingPlane)
 */
static PyMethodDef Dtool_Methods_BoundingPlane[] = {
  {"get_plane", &Dtool_BoundingPlane_get_plane_636, METH_NOARGS, (const char *)Dtool_BoundingPlane_get_plane_636_comment},
  {"getPlane", &Dtool_BoundingPlane_get_plane_636, METH_NOARGS, (const char *)Dtool_BoundingPlane_get_plane_636_comment},
  {"get_class_type", &Dtool_BoundingPlane_get_class_type_637, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingPlane_get_class_type_637_comment},
  {"getClassType", &Dtool_BoundingPlane_get_class_type_637, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingPlane_get_class_type_637_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_BoundingPlane = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingPlane = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BoundingPlane = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BoundingPlane = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BoundingPlane = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BoundingPlane",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingPlane,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BoundingPlane,
    &Dtool_SequenceMethods_BoundingPlane,
    &Dtool_MappingMethods_BoundingPlane,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BoundingPlane,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This funny bounding volume is an infinite plane that divides space into two\n"
    " * regions: the part behind the normal, which is \"inside\" the bounding volume,\n"
    " * and the part in front of the normal, which is \"outside\" the bounding\n"
    " * volume.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BoundingPlane,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BoundingPlane,
    PyType_GenericAlloc,
    Dtool_new_BoundingPlane,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingPlane,
  Dtool_UpcastInterface_BoundingPlane,
  Dtool_DowncastInterface_BoundingPlane,
  (CoerceFunction)Dtool_ConstCoerce_BoundingPlane,
  (CoerceFunction)Dtool_Coerce_BoundingPlane,
};

static void Dtool_PyModuleClassInit_BoundingPlane(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(NULL);
    Dtool_BoundingPlane._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    PyObject *dict = PyDict_New();
    Dtool_BoundingPlane._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingPlane) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingPlane)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingPlane);
  }
}

/**
 * Python method tables for BoundingSphere (BoundingSphere)
 */
static PyMethodDef Dtool_Methods_BoundingSphere[] = {
  {"get_center", &Dtool_BoundingSphere_get_center_644, METH_NOARGS, (const char *)Dtool_BoundingSphere_get_center_644_comment},
  {"getCenter", &Dtool_BoundingSphere_get_center_644, METH_NOARGS, (const char *)Dtool_BoundingSphere_get_center_644_comment},
  {"get_radius", &Dtool_BoundingSphere_get_radius_645, METH_NOARGS, (const char *)Dtool_BoundingSphere_get_radius_645_comment},
  {"getRadius", &Dtool_BoundingSphere_get_radius_645, METH_NOARGS, (const char *)Dtool_BoundingSphere_get_radius_645_comment},
  {"set_center", &Dtool_BoundingSphere_set_center_646, METH_O, (const char *)Dtool_BoundingSphere_set_center_646_comment},
  {"setCenter", &Dtool_BoundingSphere_set_center_646, METH_O, (const char *)Dtool_BoundingSphere_set_center_646_comment},
  {"set_radius", &Dtool_BoundingSphere_set_radius_647, METH_O, (const char *)Dtool_BoundingSphere_set_radius_647_comment},
  {"setRadius", &Dtool_BoundingSphere_set_radius_647, METH_O, (const char *)Dtool_BoundingSphere_set_radius_647_comment},
  {"get_class_type", &Dtool_BoundingSphere_get_class_type_648, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingSphere_get_class_type_648_comment},
  {"getClassType", &Dtool_BoundingSphere_get_class_type_648, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingSphere_get_class_type_648_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_BoundingSphere = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingSphere = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_BoundingSphere = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_BoundingSphere = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_BoundingSphere = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.BoundingSphere",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingSphere,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BoundingSphere,
    &Dtool_SequenceMethods_BoundingSphere,
    &Dtool_MappingMethods_BoundingSphere,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_BoundingSphere,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines a bounding sphere, consisting of a center and a radius.  It is\n"
    " * always a sphere, and never an ellipsoid or other quadric.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BoundingSphere,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BoundingSphere,
    PyType_GenericAlloc,
    Dtool_new_BoundingSphere,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingSphere,
  Dtool_UpcastInterface_BoundingSphere,
  Dtool_DowncastInterface_BoundingSphere,
  (CoerceFunction)Dtool_ConstCoerce_BoundingSphere,
  (CoerceFunction)Dtool_Coerce_BoundingSphere,
};

static void Dtool_PyModuleClassInit_BoundingSphere(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_FiniteBoundingVolume(NULL);
    Dtool_BoundingSphere._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_FiniteBoundingVolume);
    PyObject *dict = PyDict_New();
    Dtool_BoundingSphere._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingSphere) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingSphere)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingSphere);
  }
}

/**
 * Python method tables for IntersectionBoundingVolume (IntersectionBoundingVolume)
 */
static PyMethodDef Dtool_Methods_IntersectionBoundingVolume[] = {
  {"get_num_components", &Dtool_IntersectionBoundingVolume_get_num_components_655, METH_NOARGS, (const char *)Dtool_IntersectionBoundingVolume_get_num_components_655_comment},
  {"getNumComponents", &Dtool_IntersectionBoundingVolume_get_num_components_655, METH_NOARGS, (const char *)Dtool_IntersectionBoundingVolume_get_num_components_655_comment},
  {"get_component", &Dtool_IntersectionBoundingVolume_get_component_656, METH_O, (const char *)Dtool_IntersectionBoundingVolume_get_component_656_comment},
  {"getComponent", &Dtool_IntersectionBoundingVolume_get_component_656, METH_O, (const char *)Dtool_IntersectionBoundingVolume_get_component_656_comment},
  {"clear_components", &Dtool_IntersectionBoundingVolume_clear_components_661, METH_NOARGS, (const char *)Dtool_IntersectionBoundingVolume_clear_components_661_comment},
  {"clearComponents", &Dtool_IntersectionBoundingVolume_clear_components_661, METH_NOARGS, (const char *)Dtool_IntersectionBoundingVolume_clear_components_661_comment},
  {"add_component", &Dtool_IntersectionBoundingVolume_add_component_662, METH_O, (const char *)Dtool_IntersectionBoundingVolume_add_component_662_comment},
  {"addComponent", &Dtool_IntersectionBoundingVolume_add_component_662, METH_O, (const char *)Dtool_IntersectionBoundingVolume_add_component_662_comment},
  {"get_class_type", &Dtool_IntersectionBoundingVolume_get_class_type_663, METH_NOARGS | METH_STATIC, (const char *)Dtool_IntersectionBoundingVolume_get_class_type_663_comment},
  {"getClassType", &Dtool_IntersectionBoundingVolume_get_class_type_663, METH_NOARGS | METH_STATIC, (const char *)Dtool_IntersectionBoundingVolume_get_class_type_663_comment},
  {"get_components", (PyCFunction) &MakeSeq_IntersectionBoundingVolume_get_components, METH_NOARGS, NULL},
  { "getComponents", (PyCFunction) &MakeSeq_IntersectionBoundingVolume_get_components, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_IntersectionBoundingVolume[] = {
  {(char *)"components", &Dtool_IntersectionBoundingVolume_components_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_IntersectionBoundingVolume = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_IntersectionBoundingVolume = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_IntersectionBoundingVolume = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_IntersectionBoundingVolume = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_IntersectionBoundingVolume = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.IntersectionBoundingVolume",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_IntersectionBoundingVolume,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_IntersectionBoundingVolume,
    &Dtool_SequenceMethods_IntersectionBoundingVolume,
    &Dtool_MappingMethods_IntersectionBoundingVolume,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_IntersectionBoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This special bounding volume is the intersection of all of its constituent\n"
    " * bounding volumes.\n"
    " *\n"
    " * A point is defined to be within an IntersectionBoundingVolume if it is\n"
    " * within all of its component bounding volumes.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_IntersectionBoundingVolume,
    0, // tp_members
    Dtool_Properties_IntersectionBoundingVolume,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_IntersectionBoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_IntersectionBoundingVolume,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IntersectionBoundingVolume,
  Dtool_UpcastInterface_IntersectionBoundingVolume,
  Dtool_DowncastInterface_IntersectionBoundingVolume,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_IntersectionBoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(NULL);
    Dtool_IntersectionBoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    PyObject *dict = PyDict_New();
    Dtool_IntersectionBoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IntersectionBoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IntersectionBoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IntersectionBoundingVolume);
  }
}

/**
 * Python method tables for Mersenne (Mersenne)
 */
static PyMethodDef Dtool_Methods_Mersenne[] = {
  {"get_uint31", &Dtool_Mersenne_get_uint31_669, METH_NOARGS, (const char *)Dtool_Mersenne_get_uint31_669_comment},
  {"getUint31", &Dtool_Mersenne_get_uint31_669, METH_NOARGS, (const char *)Dtool_Mersenne_get_uint31_669_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Mersenne = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Mersenne = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Mersenne",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Mersenne,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Mersenne,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Mersenne,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Mersenne,
    PyType_GenericAlloc,
    Dtool_new_Mersenne,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Mersenne,
  Dtool_UpcastInterface_Mersenne,
  Dtool_DowncastInterface_Mersenne,
  (CoerceFunction)Dtool_ConstCoerce_Mersenne,
  (CoerceFunction)Dtool_Coerce_Mersenne,
};

static void Dtool_PyModuleClassInit_Mersenne(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Mersenne._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Mersenne._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum Mersenne::;
    PyDict_SetItemString(dict, "max_value", Dtool_WrapValue(Mersenne::max_value));
    if (PyType_Ready((PyTypeObject *)&Dtool_Mersenne) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Mersenne)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Mersenne);
  }
}

/**
 * Python method tables for OmniBoundingVolume (OmniBoundingVolume)
 */
static PyMethodDef Dtool_Methods_OmniBoundingVolume[] = {
  {"get_class_type", &Dtool_OmniBoundingVolume_get_class_type_674, METH_NOARGS | METH_STATIC, (const char *)Dtool_OmniBoundingVolume_get_class_type_674_comment},
  {"getClassType", &Dtool_OmniBoundingVolume_get_class_type_674, METH_NOARGS | METH_STATIC, (const char *)Dtool_OmniBoundingVolume_get_class_type_674_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OmniBoundingVolume = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OmniBoundingVolume = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OmniBoundingVolume = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OmniBoundingVolume = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OmniBoundingVolume = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.OmniBoundingVolume",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OmniBoundingVolume,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OmniBoundingVolume,
    &Dtool_SequenceMethods_OmniBoundingVolume,
    &Dtool_MappingMethods_OmniBoundingVolume,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OmniBoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special kind of GeometricBoundingVolume that fills all of space.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OmniBoundingVolume,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OmniBoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_OmniBoundingVolume,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OmniBoundingVolume,
  Dtool_UpcastInterface_OmniBoundingVolume,
  Dtool_DowncastInterface_OmniBoundingVolume,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OmniBoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(NULL);
    Dtool_OmniBoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    PyObject *dict = PyDict_New();
    Dtool_OmniBoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OmniBoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OmniBoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OmniBoundingVolume);
  }
}

/**
 * Python method tables for UnionBoundingVolume (UnionBoundingVolume)
 */
static PyMethodDef Dtool_Methods_UnionBoundingVolume[] = {
  {"get_num_components", &Dtool_UnionBoundingVolume_get_num_components_681, METH_NOARGS, (const char *)Dtool_UnionBoundingVolume_get_num_components_681_comment},
  {"getNumComponents", &Dtool_UnionBoundingVolume_get_num_components_681, METH_NOARGS, (const char *)Dtool_UnionBoundingVolume_get_num_components_681_comment},
  {"get_component", &Dtool_UnionBoundingVolume_get_component_682, METH_O, (const char *)Dtool_UnionBoundingVolume_get_component_682_comment},
  {"getComponent", &Dtool_UnionBoundingVolume_get_component_682, METH_O, (const char *)Dtool_UnionBoundingVolume_get_component_682_comment},
  {"clear_components", &Dtool_UnionBoundingVolume_clear_components_685, METH_NOARGS, (const char *)Dtool_UnionBoundingVolume_clear_components_685_comment},
  {"clearComponents", &Dtool_UnionBoundingVolume_clear_components_685, METH_NOARGS, (const char *)Dtool_UnionBoundingVolume_clear_components_685_comment},
  {"add_component", &Dtool_UnionBoundingVolume_add_component_686, METH_O, (const char *)Dtool_UnionBoundingVolume_add_component_686_comment},
  {"addComponent", &Dtool_UnionBoundingVolume_add_component_686, METH_O, (const char *)Dtool_UnionBoundingVolume_add_component_686_comment},
  {"filter_intersection", &Dtool_UnionBoundingVolume_filter_intersection_687, METH_O, (const char *)Dtool_UnionBoundingVolume_filter_intersection_687_comment},
  {"filterIntersection", &Dtool_UnionBoundingVolume_filter_intersection_687, METH_O, (const char *)Dtool_UnionBoundingVolume_filter_intersection_687_comment},
  {"get_class_type", &Dtool_UnionBoundingVolume_get_class_type_688, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnionBoundingVolume_get_class_type_688_comment},
  {"getClassType", &Dtool_UnionBoundingVolume_get_class_type_688, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnionBoundingVolume_get_class_type_688_comment},
  {"get_components", (PyCFunction) &MakeSeq_UnionBoundingVolume_get_components, METH_NOARGS, NULL},
  { "getComponents", (PyCFunction) &MakeSeq_UnionBoundingVolume_get_components, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_UnionBoundingVolume[] = {
  {(char *)"components", &Dtool_UnionBoundingVolume_components_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_UnionBoundingVolume = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UnionBoundingVolume = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_UnionBoundingVolume = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_UnionBoundingVolume = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_UnionBoundingVolume = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.UnionBoundingVolume",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_UnionBoundingVolume,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_UnionBoundingVolume,
    &Dtool_SequenceMethods_UnionBoundingVolume,
    &Dtool_MappingMethods_UnionBoundingVolume,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_UnionBoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This special bounding volume is the union of all of its constituent\n"
    " * bounding volumes.\n"
    " *\n"
    " * A point is defined to be within a UnionBoundingVolume if it is within any\n"
    " * one or more of its component bounding volumes.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_UnionBoundingVolume,
    0, // tp_members
    Dtool_Properties_UnionBoundingVolume,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_UnionBoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_UnionBoundingVolume,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UnionBoundingVolume,
  Dtool_UpcastInterface_UnionBoundingVolume,
  Dtool_DowncastInterface_UnionBoundingVolume,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_UnionBoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(NULL);
    Dtool_UnionBoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    PyObject *dict = PyDict_New();
    Dtool_UnionBoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UnionBoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UnionBoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UnionBoundingVolume);
  }
}

/**
 * Python method tables for Randomizer (Randomizer)
 */
static PyMethodDef Dtool_Methods_Randomizer[] = {
  {"assign", &Dtool_Randomizer_operator_692, METH_O, (const char *)Dtool_Randomizer_operator_692_comment},
  {"random_int", &Dtool_Randomizer_random_int_693, METH_O, (const char *)Dtool_Randomizer_random_int_693_comment},
  {"randomInt", &Dtool_Randomizer_random_int_693, METH_O, (const char *)Dtool_Randomizer_random_int_693_comment},
  {"random_real", &Dtool_Randomizer_random_real_694, METH_O, (const char *)Dtool_Randomizer_random_real_694_comment},
  {"randomReal", &Dtool_Randomizer_random_real_694, METH_O, (const char *)Dtool_Randomizer_random_real_694_comment},
  {"random_real_unit", &Dtool_Randomizer_random_real_unit_695, METH_NOARGS, (const char *)Dtool_Randomizer_random_real_unit_695_comment},
  {"randomRealUnit", &Dtool_Randomizer_random_real_unit_695, METH_NOARGS, (const char *)Dtool_Randomizer_random_real_unit_695_comment},
  {"get_next_seed", &Dtool_Randomizer_get_next_seed_696, METH_NOARGS | METH_STATIC, (const char *)Dtool_Randomizer_get_next_seed_696_comment},
  {"getNextSeed", &Dtool_Randomizer_get_next_seed_696, METH_NOARGS | METH_STATIC, (const char *)Dtool_Randomizer_get_next_seed_696_comment},
  {"get_seed", &Dtool_Randomizer_get_seed_697, METH_NOARGS, (const char *)Dtool_Randomizer_get_seed_697_comment},
  {"getSeed", &Dtool_Randomizer_get_seed_697, METH_NOARGS, (const char *)Dtool_Randomizer_get_seed_697_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Randomizer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Randomizer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Randomizer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Randomizer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Randomizer,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A handy class to return random numbers.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Randomizer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Randomizer,
    PyType_GenericAlloc,
    Dtool_new_Randomizer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Randomizer,
  Dtool_UpcastInterface_Randomizer,
  Dtool_DowncastInterface_Randomizer,
  (CoerceFunction)Dtool_ConstCoerce_Randomizer,
  (CoerceFunction)Dtool_Coerce_Randomizer,
};

static void Dtool_PyModuleClassInit_Randomizer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Randomizer._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Randomizer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Randomizer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Randomizer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Randomizer);
  }
}

/**
 * Python method tables for PerlinNoise (PerlinNoise)
 */
static PyMethodDef Dtool_Methods_PerlinNoise[] = {
  {"get_seed", &Dtool_PerlinNoise_get_seed_700, METH_NOARGS, (const char *)Dtool_PerlinNoise_get_seed_700_comment},
  {"getSeed", &Dtool_PerlinNoise_get_seed_700, METH_NOARGS, (const char *)Dtool_PerlinNoise_get_seed_700_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PerlinNoise = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_PerlinNoise = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PerlinNoise",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PerlinNoise,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PerlinNoise,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for PerlinNoise2 and PerlinNoise3, different\n"
    " * dimensions of Perlin noise implementation.  The base class just collects\n"
    " * the common functionality.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PerlinNoise,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PerlinNoise,
    PyType_GenericAlloc,
    Dtool_new_PerlinNoise,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PerlinNoise,
  Dtool_UpcastInterface_PerlinNoise,
  Dtool_DowncastInterface_PerlinNoise,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PerlinNoise(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PerlinNoise._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PerlinNoise._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PerlinNoise) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PerlinNoise)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PerlinNoise);
  }
}

/**
 * Python method tables for PerlinNoise2 (PerlinNoise2)
 */
static PyMethodDef Dtool_Methods_PerlinNoise2[] = {
  {"assign", &Dtool_PerlinNoise2_operator_704, METH_O, (const char *)Dtool_PerlinNoise2_operator_704_comment},
  {"set_scale", (PyCFunction) &Dtool_PerlinNoise2_set_scale_705, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise2_set_scale_705_comment},
  {"setScale", (PyCFunction) &Dtool_PerlinNoise2_set_scale_705, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise2_set_scale_705_comment},
  {"noise", (PyCFunction) &Dtool_PerlinNoise2_noise_706, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise2_noise_706_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

/**
 * Python function wrapper for:
 * inline double PerlinNoise2::operator ()(LVecBase2d const &value) const
 * inline float PerlinNoise2::operator ()(LVecBase2f const &value) const
 * inline double PerlinNoise2::operator ()(double x, double y) const
 */
static PyObject *Dtool_PerlinNoise2_operator_707(PyObject *self, PyObject *args, PyObject *kwds)
 {
  PerlinNoise2 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PerlinNoise2, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "value");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
      }
      {
        // -2 inline double PerlinNoise2::operator ()(LVecBase2d const &value) const
        LVecBase2d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
        if (arg_this != NULL) {
          double return_value = (*(const PerlinNoise2*)local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline float PerlinNoise2::operator ()(LVecBase2f const &value) const
        LVecBase2f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
        if (arg_this != NULL) {
          float return_value = (*(const PerlinNoise2*)local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline double PerlinNoise2::operator ()(LVecBase2d const &value) const
        LVecBase2d arg_local;
        LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
        if ((arg_this != NULL)) {
          double return_value = (*(const PerlinNoise2*)local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline float PerlinNoise2::operator ()(LVecBase2f const &value) const
        LVecBase2f arg_local;
        LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if ((arg_this != NULL)) {
          float return_value = (*(const PerlinNoise2*)local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

    }
    break;
  case 2:
    {
      // 1-inline double PerlinNoise2::operator ()(double x, double y) const
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:__call__", (char **)keyword_list, &param1, &param2)) {
        double return_value = (*(const PerlinNoise2*)local_this).operator ()((double)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "__call__() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(PerlinNoise2 self, const LVecBase2d value)\n"
      "__call__(PerlinNoise2 self, const LVecBase2f value)\n"
      "__call__(PerlinNoise2 self, double x, double y)\n");
  }
  return NULL;
}

static PyNumberMethods Dtool_NumberMethods_PerlinNoise2 = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PerlinNoise2 = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PerlinNoise2 = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PerlinNoise2 = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PerlinNoise2 = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PerlinNoise2",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PerlinNoise2,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PerlinNoise2,
    &Dtool_SequenceMethods_PerlinNoise2,
    &Dtool_MappingMethods_PerlinNoise2,
    0, // tp_hash
    &Dtool_PerlinNoise2_operator_707,
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PerlinNoise2,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides an implementation of Perlin noise for 2 variables.\n"
    " * This code is loosely based on the reference implementation at\n"
    " * http://mrl.nyu.edu/~perlin/noise/ .\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PerlinNoise2,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PerlinNoise2,
    PyType_GenericAlloc,
    Dtool_new_PerlinNoise2,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PerlinNoise2,
  Dtool_UpcastInterface_PerlinNoise2,
  Dtool_DowncastInterface_PerlinNoise2,
  (CoerceFunction)Dtool_ConstCoerce_PerlinNoise2,
  (CoerceFunction)Dtool_Coerce_PerlinNoise2,
};

static void Dtool_PyModuleClassInit_PerlinNoise2(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PerlinNoise(NULL);
    Dtool_PerlinNoise2._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PerlinNoise);
    PyObject *dict = PyDict_New();
    Dtool_PerlinNoise2._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PerlinNoise2) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PerlinNoise2)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PerlinNoise2);
  }
}

/**
 * Python method tables for PerlinNoise3 (PerlinNoise3)
 */
static PyMethodDef Dtool_Methods_PerlinNoise3[] = {
  {"assign", &Dtool_PerlinNoise3_operator_711, METH_O, (const char *)Dtool_PerlinNoise3_operator_711_comment},
  {"set_scale", (PyCFunction) &Dtool_PerlinNoise3_set_scale_712, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise3_set_scale_712_comment},
  {"setScale", (PyCFunction) &Dtool_PerlinNoise3_set_scale_712, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise3_set_scale_712_comment},
  {"noise", (PyCFunction) &Dtool_PerlinNoise3_noise_713, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise3_noise_713_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

/**
 * Python function wrapper for:
 * inline float PerlinNoise3::operator ()(LVecBase3f const &value) const
 * inline double PerlinNoise3::operator ()(double x, double y, double z) const
 * inline double PerlinNoise3::operator ()(LVecBase3d const &value) const
 */
static PyObject *Dtool_PerlinNoise3_operator_714(PyObject *self, PyObject *args, PyObject *kwds)
 {
  PerlinNoise3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PerlinNoise3, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "value");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
      }
      {
        // -2 inline float PerlinNoise3::operator ()(LVecBase3f const &value) const
        LVecBase3f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
        if (arg_this != NULL) {
          float return_value = (*(const PerlinNoise3*)local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline double PerlinNoise3::operator ()(LVecBase3d const &value) const
        LVecBase3d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
        if (arg_this != NULL) {
          double return_value = (*(const PerlinNoise3*)local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline float PerlinNoise3::operator ()(LVecBase3f const &value) const
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if ((arg_this != NULL)) {
          float return_value = (*(const PerlinNoise3*)local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline double PerlinNoise3::operator ()(LVecBase3d const &value) const
        LVecBase3d arg_local;
        LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
        if ((arg_this != NULL)) {
          double return_value = (*(const PerlinNoise3*)local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

    }
    break;
  case 3:
    {
      // 1-inline double PerlinNoise3::operator ()(double x, double y, double z) const
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:__call__", (char **)keyword_list, &param1, &param2, &param3)) {
        double return_value = (*(const PerlinNoise3*)local_this).operator ()((double)param1, (double)param2, (double)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "__call__() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(PerlinNoise3 self, const LVecBase3f value)\n"
      "__call__(PerlinNoise3 self, const LVecBase3d value)\n"
      "__call__(PerlinNoise3 self, double x, double y, double z)\n");
  }
  return NULL;
}

static PyNumberMethods Dtool_NumberMethods_PerlinNoise3 = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PerlinNoise3 = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PerlinNoise3 = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PerlinNoise3 = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PerlinNoise3 = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PerlinNoise3",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PerlinNoise3,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PerlinNoise3,
    &Dtool_SequenceMethods_PerlinNoise3,
    &Dtool_MappingMethods_PerlinNoise3,
    0, // tp_hash
    &Dtool_PerlinNoise3_operator_714,
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PerlinNoise3,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides an implementation of Perlin noise for 3 variables.\n"
    " * This code is loosely based on the reference implementation at\n"
    " * http://mrl.nyu.edu/~perlin/noise/ .\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PerlinNoise3,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PerlinNoise3,
    PyType_GenericAlloc,
    Dtool_new_PerlinNoise3,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PerlinNoise3,
  Dtool_UpcastInterface_PerlinNoise3,
  Dtool_DowncastInterface_PerlinNoise3,
  (CoerceFunction)Dtool_ConstCoerce_PerlinNoise3,
  (CoerceFunction)Dtool_Coerce_PerlinNoise3,
};

static void Dtool_PyModuleClassInit_PerlinNoise3(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PerlinNoise(NULL);
    Dtool_PerlinNoise3._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PerlinNoise);
    PyObject *dict = PyDict_New();
    Dtool_PerlinNoise3._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PerlinNoise3) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PerlinNoise3)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PerlinNoise3);
  }
}

/**
 * Python method tables for StackedPerlinNoise2 (StackedPerlinNoise2)
 */
static PyMethodDef Dtool_Methods_StackedPerlinNoise2[] = {
  {"assign", &Dtool_StackedPerlinNoise2_operator_775, METH_O, (const char *)Dtool_StackedPerlinNoise2_operator_775_comment},
  {"add_level", (PyCFunction) &Dtool_StackedPerlinNoise2_add_level_776, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise2_add_level_776_comment},
  {"addLevel", (PyCFunction) &Dtool_StackedPerlinNoise2_add_level_776, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise2_add_level_776_comment},
  {"clear", &Dtool_StackedPerlinNoise2_clear_777, METH_NOARGS, (const char *)Dtool_StackedPerlinNoise2_clear_777_comment},
  {"noise", (PyCFunction) &Dtool_StackedPerlinNoise2_noise_778, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise2_noise_778_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

/**
 * Python function wrapper for:
 * inline double StackedPerlinNoise2::operator ()(double x, double y)
 * inline float StackedPerlinNoise2::operator ()(LVecBase2f const &value)
 * inline double StackedPerlinNoise2::operator ()(LVecBase2d const &value)
 */
static PyObject *Dtool_StackedPerlinNoise2_operator_779(PyObject *self, PyObject *args, PyObject *kwds)
 {
  StackedPerlinNoise2 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise2, (void **)&local_this, "StackedPerlinNoise2.__call__")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "value");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
      }
      {
        // -2 inline float StackedPerlinNoise2::operator ()(LVecBase2f const &value)
        LVecBase2f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
        if (arg_this != NULL) {
          float return_value = (*local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline double StackedPerlinNoise2::operator ()(LVecBase2d const &value)
        LVecBase2d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
        if (arg_this != NULL) {
          double return_value = (*local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline float StackedPerlinNoise2::operator ()(LVecBase2f const &value)
        LVecBase2f arg_local;
        LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if ((arg_this != NULL)) {
          float return_value = (*local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline double StackedPerlinNoise2::operator ()(LVecBase2d const &value)
        LVecBase2d arg_local;
        LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
        if ((arg_this != NULL)) {
          double return_value = (*local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

    }
    break;
  case 2:
    {
      // 1-inline double StackedPerlinNoise2::operator ()(double x, double y)
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:__call__", (char **)keyword_list, &param1, &param2)) {
        double return_value = (*local_this).operator ()((double)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "__call__() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(const StackedPerlinNoise2 self, const LVecBase2f value)\n"
      "__call__(const StackedPerlinNoise2 self, const LVecBase2d value)\n"
      "__call__(const StackedPerlinNoise2 self, double x, double y)\n");
  }
  return NULL;
}

static PyNumberMethods Dtool_NumberMethods_StackedPerlinNoise2 = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_StackedPerlinNoise2 = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.StackedPerlinNoise2",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_StackedPerlinNoise2,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_StackedPerlinNoise2,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    &Dtool_StackedPerlinNoise2_operator_779,
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Implements a multi-layer PerlinNoise, with one or more high-frequency noise\n"
    " * functions added to a lower-frequency base noise function.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_StackedPerlinNoise2,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_StackedPerlinNoise2,
    PyType_GenericAlloc,
    Dtool_new_StackedPerlinNoise2,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StackedPerlinNoise2,
  Dtool_UpcastInterface_StackedPerlinNoise2,
  Dtool_DowncastInterface_StackedPerlinNoise2,
  (CoerceFunction)Dtool_ConstCoerce_StackedPerlinNoise2,
  (CoerceFunction)Dtool_Coerce_StackedPerlinNoise2,
};

static void Dtool_PyModuleClassInit_StackedPerlinNoise2(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_StackedPerlinNoise2._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_StackedPerlinNoise2._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StackedPerlinNoise2) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StackedPerlinNoise2)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StackedPerlinNoise2);
  }
}

/**
 * Python method tables for StackedPerlinNoise3 (StackedPerlinNoise3)
 */
static PyMethodDef Dtool_Methods_StackedPerlinNoise3[] = {
  {"assign", &Dtool_StackedPerlinNoise3_operator_783, METH_O, (const char *)Dtool_StackedPerlinNoise3_operator_783_comment},
  {"add_level", (PyCFunction) &Dtool_StackedPerlinNoise3_add_level_784, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise3_add_level_784_comment},
  {"addLevel", (PyCFunction) &Dtool_StackedPerlinNoise3_add_level_784, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise3_add_level_784_comment},
  {"clear", &Dtool_StackedPerlinNoise3_clear_785, METH_NOARGS, (const char *)Dtool_StackedPerlinNoise3_clear_785_comment},
  {"noise", (PyCFunction) &Dtool_StackedPerlinNoise3_noise_786, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise3_noise_786_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

/**
 * Python function wrapper for:
 * inline double StackedPerlinNoise3::operator ()(LVecBase3d const &value)
 * inline double StackedPerlinNoise3::operator ()(double x, double y, double z)
 * inline float StackedPerlinNoise3::operator ()(LVecBase3f const &value)
 */
static PyObject *Dtool_StackedPerlinNoise3_operator_787(PyObject *self, PyObject *args, PyObject *kwds)
 {
  StackedPerlinNoise3 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise3, (void **)&local_this, "StackedPerlinNoise3.__call__")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "value");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'value' (pos 1) not found");
      }
      {
        // -2 inline double StackedPerlinNoise3::operator ()(LVecBase3d const &value)
        LVecBase3d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
        if (arg_this != NULL) {
          double return_value = (*local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline float StackedPerlinNoise3::operator ()(LVecBase3f const &value)
        LVecBase3f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
        if (arg_this != NULL) {
          float return_value = (*local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline double StackedPerlinNoise3::operator ()(LVecBase3d const &value)
        LVecBase3d arg_local;
        LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
        if ((arg_this != NULL)) {
          double return_value = (*local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      {
        // -2 inline float StackedPerlinNoise3::operator ()(LVecBase3f const &value)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if ((arg_this != NULL)) {
          float return_value = (*local_this).operator ()(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }

    }
    break;
  case 3:
    {
      // 1-inline double StackedPerlinNoise3::operator ()(double x, double y, double z)
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:__call__", (char **)keyword_list, &param1, &param2, &param3)) {
        double return_value = (*local_this).operator ()((double)param1, (double)param2, (double)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "__call__() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(const StackedPerlinNoise3 self, const LVecBase3d value)\n"
      "__call__(const StackedPerlinNoise3 self, const LVecBase3f value)\n"
      "__call__(const StackedPerlinNoise3 self, double x, double y, double z)\n");
  }
  return NULL;
}

static PyNumberMethods Dtool_NumberMethods_StackedPerlinNoise3 = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_StackedPerlinNoise3 = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.StackedPerlinNoise3",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_StackedPerlinNoise3,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_StackedPerlinNoise3,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    &Dtool_StackedPerlinNoise3_operator_787,
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Implements a multi-layer PerlinNoise, with one or more high-frequency noise\n"
    " * functions added to a lower-frequency base noise function.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_StackedPerlinNoise3,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_StackedPerlinNoise3,
    PyType_GenericAlloc,
    Dtool_new_StackedPerlinNoise3,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StackedPerlinNoise3,
  Dtool_UpcastInterface_StackedPerlinNoise3,
  Dtool_DowncastInterface_StackedPerlinNoise3,
  (CoerceFunction)Dtool_ConstCoerce_StackedPerlinNoise3,
  (CoerceFunction)Dtool_Coerce_StackedPerlinNoise3,
};

static void Dtool_PyModuleClassInit_StackedPerlinNoise3(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_StackedPerlinNoise3._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_StackedPerlinNoise3._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StackedPerlinNoise3) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StackedPerlinNoise3)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StackedPerlinNoise3);
  }
}

/**
 * Python method tables for Triangulator (Triangulator)
 */
static PyMethodDef Dtool_Methods_Triangulator[] = {
  {"clear", &Dtool_Triangulator_clear_791, METH_NOARGS, (const char *)Dtool_Triangulator_clear_791_comment},
  {"add_vertex", (PyCFunction) &Dtool_Triangulator_add_vertex_792, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Triangulator_add_vertex_792_comment},
  {"addVertex", (PyCFunction) &Dtool_Triangulator_add_vertex_792, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Triangulator_add_vertex_792_comment},
  {"get_num_vertices", &Dtool_Triangulator_get_num_vertices_793, METH_NOARGS, (const char *)Dtool_Triangulator_get_num_vertices_793_comment},
  {"getNumVertices", &Dtool_Triangulator_get_num_vertices_793, METH_NOARGS, (const char *)Dtool_Triangulator_get_num_vertices_793_comment},
  {"get_vertex", &Dtool_Triangulator_get_vertex_794, METH_O, (const char *)Dtool_Triangulator_get_vertex_794_comment},
  {"getVertex", &Dtool_Triangulator_get_vertex_794, METH_O, (const char *)Dtool_Triangulator_get_vertex_794_comment},
  {"clear_polygon", &Dtool_Triangulator_clear_polygon_799, METH_NOARGS, (const char *)Dtool_Triangulator_clear_polygon_799_comment},
  {"clearPolygon", &Dtool_Triangulator_clear_polygon_799, METH_NOARGS, (const char *)Dtool_Triangulator_clear_polygon_799_comment},
  {"add_polygon_vertex", &Dtool_Triangulator_add_polygon_vertex_800, METH_O, (const char *)Dtool_Triangulator_add_polygon_vertex_800_comment},
  {"addPolygonVertex", &Dtool_Triangulator_add_polygon_vertex_800, METH_O, (const char *)Dtool_Triangulator_add_polygon_vertex_800_comment},
  {"is_left_winding", &Dtool_Triangulator_is_left_winding_801, METH_NOARGS, (const char *)Dtool_Triangulator_is_left_winding_801_comment},
  {"isLeftWinding", &Dtool_Triangulator_is_left_winding_801, METH_NOARGS, (const char *)Dtool_Triangulator_is_left_winding_801_comment},
  {"begin_hole", &Dtool_Triangulator_begin_hole_802, METH_NOARGS, (const char *)Dtool_Triangulator_begin_hole_802_comment},
  {"beginHole", &Dtool_Triangulator_begin_hole_802, METH_NOARGS, (const char *)Dtool_Triangulator_begin_hole_802_comment},
  {"add_hole_vertex", &Dtool_Triangulator_add_hole_vertex_803, METH_O, (const char *)Dtool_Triangulator_add_hole_vertex_803_comment},
  {"addHoleVertex", &Dtool_Triangulator_add_hole_vertex_803, METH_O, (const char *)Dtool_Triangulator_add_hole_vertex_803_comment},
  {"triangulate", &Dtool_Triangulator_triangulate_804, METH_NOARGS, (const char *)Dtool_Triangulator_triangulate_804_comment},
  {"get_num_triangles", &Dtool_Triangulator_get_num_triangles_805, METH_NOARGS, (const char *)Dtool_Triangulator_get_num_triangles_805_comment},
  {"getNumTriangles", &Dtool_Triangulator_get_num_triangles_805, METH_NOARGS, (const char *)Dtool_Triangulator_get_num_triangles_805_comment},
  {"get_triangle_v0", &Dtool_Triangulator_get_triangle_v0_806, METH_O, (const char *)Dtool_Triangulator_get_triangle_v0_806_comment},
  {"getTriangleV0", &Dtool_Triangulator_get_triangle_v0_806, METH_O, (const char *)Dtool_Triangulator_get_triangle_v0_806_comment},
  {"get_triangle_v1", &Dtool_Triangulator_get_triangle_v1_807, METH_O, (const char *)Dtool_Triangulator_get_triangle_v1_807_comment},
  {"getTriangleV1", &Dtool_Triangulator_get_triangle_v1_807, METH_O, (const char *)Dtool_Triangulator_get_triangle_v1_807_comment},
  {"get_triangle_v2", &Dtool_Triangulator_get_triangle_v2_808, METH_O, (const char *)Dtool_Triangulator_get_triangle_v2_808_comment},
  {"getTriangleV2", &Dtool_Triangulator_get_triangle_v2_808, METH_O, (const char *)Dtool_Triangulator_get_triangle_v2_808_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_vertices", (PyCFunction) &MakeSeq_Triangulator_get_vertices, METH_NOARGS, NULL},
  { "getVertices", (PyCFunction) &MakeSeq_Triangulator_get_vertices, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_Triangulator[] = {
  {(char *)"vertices", &Dtool_Triangulator_vertices_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_Triangulator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Triangulator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Triangulator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Triangulator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Triangulator,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can triangulate a convex or concave polygon, even one with\n"
    " * holes.  It is adapted from an algorithm published as:\n"
    " *\n"
    " * Narkhede A. and Manocha D., Fast polygon triangulation algorithm based on\n"
    " * Seidel's Algorithm, UNC-CH, 1994.\n"
    " *\n"
    " * http://www.cs.unc.edu/~dm/CODE/GEM/chapter.html\n"
    " *\n"
    " * It works strictly on 2-d points.  See Triangulator3 for 3-d points.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Triangulator,
    0, // tp_members
    Dtool_Properties_Triangulator,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Triangulator,
    PyType_GenericAlloc,
    Dtool_new_Triangulator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Triangulator,
  Dtool_UpcastInterface_Triangulator,
  Dtool_DowncastInterface_Triangulator,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Triangulator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Triangulator._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Triangulator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Triangulator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Triangulator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Triangulator);
  }
}

/**
 * Python method tables for Triangulator3 (Triangulator3)
 */
static PyMethodDef Dtool_Methods_Triangulator3[] = {
  {"clear", &Dtool_Triangulator3_clear_812, METH_NOARGS, (const char *)Dtool_Triangulator3_clear_812_comment},
  {"add_vertex", (PyCFunction) &Dtool_Triangulator3_add_vertex_813, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Triangulator3_add_vertex_813_comment},
  {"addVertex", (PyCFunction) &Dtool_Triangulator3_add_vertex_813, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Triangulator3_add_vertex_813_comment},
  {"get_num_vertices", &Dtool_Triangulator3_get_num_vertices_814, METH_NOARGS, (const char *)Dtool_Triangulator3_get_num_vertices_814_comment},
  {"getNumVertices", &Dtool_Triangulator3_get_num_vertices_814, METH_NOARGS, (const char *)Dtool_Triangulator3_get_num_vertices_814_comment},
  {"get_vertex", &Dtool_Triangulator3_get_vertex_815, METH_O, (const char *)Dtool_Triangulator3_get_vertex_815_comment},
  {"getVertex", &Dtool_Triangulator3_get_vertex_815, METH_O, (const char *)Dtool_Triangulator3_get_vertex_815_comment},
  {"triangulate", &Dtool_Triangulator3_triangulate_817, METH_NOARGS, (const char *)Dtool_Triangulator3_triangulate_817_comment},
  {"get_plane", &Dtool_Triangulator3_get_plane_818, METH_NOARGS, (const char *)Dtool_Triangulator3_get_plane_818_comment},
  {"getPlane", &Dtool_Triangulator3_get_plane_818, METH_NOARGS, (const char *)Dtool_Triangulator3_get_plane_818_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_vertices", (PyCFunction) &MakeSeq_Triangulator3_get_vertices, METH_NOARGS, NULL},
  { "getVertices", (PyCFunction) &MakeSeq_Triangulator3_get_vertices, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_Triangulator3[] = {
  {(char *)"vertices", &Dtool_Triangulator3_vertices_Getter, NULL, NULL, NULL},
  {(char *)"plane", &Dtool_Triangulator3_plane_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_Triangulator3 = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Triangulator3 = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Triangulator3 = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Triangulator3 = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Triangulator3 = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Triangulator3",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Triangulator3,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Triangulator3,
    &Dtool_SequenceMethods_Triangulator3,
    &Dtool_MappingMethods_Triangulator3,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Triangulator3,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an extension of Triangulator to handle polygons with three-\n"
    " * dimensional points.  It assumes all of the points lie in a single plane,\n"
    " * and internally projects the supplied points into 2-D for passing to the\n"
    " * underlying Triangulator object.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Triangulator3,
    0, // tp_members
    Dtool_Properties_Triangulator3,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Triangulator3,
    PyType_GenericAlloc,
    Dtool_new_Triangulator3,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Triangulator3,
  Dtool_UpcastInterface_Triangulator3,
  Dtool_DowncastInterface_Triangulator3,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Triangulator3(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Triangulator(NULL);
    Dtool_Triangulator3._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Triangulator);
    PyObject *dict = PyDict_New();
    Dtool_Triangulator3._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Triangulator3) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Triangulator3)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Triangulator3);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3mathutil_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< LMatrix3d >", Dtool_ConstPointerToArray_LMatrix3d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< LMatrix3d >", Dtool_PointerToArrayBase_LMatrix3d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< LMatrix3d > >", Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< LMatrix3f >", Dtool_ConstPointerToArray_LMatrix3f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< LMatrix3f >", Dtool_PointerToArrayBase_LMatrix3f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< LMatrix3f > >", Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< LVecBase2d >", Dtool_ConstPointerToArray_LVecBase2d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< LVecBase2d >", Dtool_PointerToArrayBase_LVecBase2d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< LVecBase2d > >", Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< LVecBase2f >", Dtool_ConstPointerToArray_LVecBase2f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< LVecBase2f >", Dtool_PointerToArrayBase_LVecBase2f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< LVecBase2f > >", Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< LVecBase2i >", Dtool_ConstPointerToArray_LVecBase2i);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< LVecBase2i >", Dtool_PointerToArrayBase_LVecBase2i);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< LVecBase2i > >", Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< LVecBase3d >", Dtool_ConstPointerToArray_LVecBase3d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< LVecBase3d >", Dtool_PointerToArrayBase_LVecBase3d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< LVecBase3d > >", Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< LVecBase3f >", Dtool_ConstPointerToArray_LVecBase3f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< LVecBase3f >", Dtool_PointerToArrayBase_LVecBase3f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< LVecBase3f > >", Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< LVecBase3i >", Dtool_ConstPointerToArray_LVecBase3i);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< LVecBase3i >", Dtool_PointerToArrayBase_LVecBase3i);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< LVecBase3i > >", Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< UnalignedLMatrix4d >", Dtool_ConstPointerToArray_UnalignedLMatrix4d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< UnalignedLMatrix4d >", Dtool_PointerToArrayBase_UnalignedLMatrix4d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >", Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< UnalignedLMatrix4f >", Dtool_ConstPointerToArray_UnalignedLMatrix4f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< UnalignedLMatrix4f >", Dtool_PointerToArrayBase_UnalignedLMatrix4f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >", Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< UnalignedLVecBase4d >", Dtool_ConstPointerToArray_UnalignedLVecBase4d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< UnalignedLVecBase4d >", Dtool_PointerToArrayBase_UnalignedLVecBase4d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >", Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< UnalignedLVecBase4f >", Dtool_ConstPointerToArray_UnalignedLVecBase4f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< UnalignedLVecBase4f >", Dtool_PointerToArrayBase_UnalignedLVecBase4f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >", Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< UnalignedLVecBase4i >", Dtool_ConstPointerToArray_UnalignedLVecBase4i);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< UnalignedLVecBase4i >", Dtool_PointerToArrayBase_UnalignedLVecBase4i);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >", Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< LMatrix3d >", Dtool_PointerToArray_LMatrix3d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< LMatrix3f >", Dtool_PointerToArray_LMatrix3f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< LVecBase2d >", Dtool_PointerToArray_LVecBase2d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< LVecBase2f >", Dtool_PointerToArray_LVecBase2f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< LVecBase2i >", Dtool_PointerToArray_LVecBase2i);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< LVecBase3d >", Dtool_PointerToArray_LVecBase3d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< LVecBase3f >", Dtool_PointerToArray_LVecBase3f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< LVecBase3i >", Dtool_PointerToArray_LVecBase3i);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< UnalignedLMatrix4d >", Dtool_PointerToArray_UnalignedLMatrix4d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< UnalignedLMatrix4f >", Dtool_PointerToArray_UnalignedLMatrix4f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< UnalignedLVecBase4d >", Dtool_PointerToArray_UnalignedLVecBase4d);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< UnalignedLVecBase4f >", Dtool_PointerToArray_UnalignedLVecBase4f);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< UnalignedLVecBase4i >", Dtool_PointerToArray_UnalignedLVecBase4i);
#endif
  Dtool_BoundingVolume._type = BoundingVolume::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BoundingVolume);
  Dtool_GeometricBoundingVolume._type = GeometricBoundingVolume::get_class_type();
  RegisterRuntimeTypedClass(Dtool_GeometricBoundingVolume);
  Dtool_FiniteBoundingVolume._type = FiniteBoundingVolume::get_class_type();
  RegisterRuntimeTypedClass(Dtool_FiniteBoundingVolume);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LParabolaf", Dtool_LParabolaf);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LParabolad", Dtool_LParabolad);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LPlanef", Dtool_LPlanef);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LPlaned", Dtool_LPlaned);
#endif
  Dtool_BoundingBox._type = BoundingBox::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BoundingBox);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LFrustumf", Dtool_LFrustumf);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LFrustumd", Dtool_LFrustumd);
#endif
  Dtool_BoundingHexahedron._type = BoundingHexahedron::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BoundingHexahedron);
  Dtool_BoundingLine._type = BoundingLine::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BoundingLine);
  Dtool_BoundingPlane._type = BoundingPlane::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BoundingPlane);
  Dtool_BoundingSphere._type = BoundingSphere::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BoundingSphere);
  Dtool_IntersectionBoundingVolume._type = IntersectionBoundingVolume::get_class_type();
  RegisterRuntimeTypedClass(Dtool_IntersectionBoundingVolume);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Mersenne", Dtool_Mersenne);
#endif
  Dtool_OmniBoundingVolume._type = OmniBoundingVolume::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OmniBoundingVolume);
  Dtool_UnionBoundingVolume._type = UnionBoundingVolume::get_class_type();
  RegisterRuntimeTypedClass(Dtool_UnionBoundingVolume);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Randomizer", Dtool_Randomizer);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PerlinNoise", Dtool_PerlinNoise);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PerlinNoise2", Dtool_PerlinNoise2);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PerlinNoise3", Dtool_PerlinNoise3);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("StackedPerlinNoise2", Dtool_StackedPerlinNoise2);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("StackedPerlinNoise3", Dtool_StackedPerlinNoise3);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Triangulator", Dtool_Triangulator);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Triangulator3", Dtool_Triangulator3);
#endif
}

void Dtool_libp3mathutil_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_PointerToVoid = LookupNamedClass("PointerToVoid");
  Dtool_Ptr_DatagramIterator = LookupRuntimeTypedClass(DatagramIterator::get_class_type());
  Dtool_Ptr_Datagram = LookupRuntimeTypedClass(Datagram::get_class_type());
  Dtool_Ptr_LVecBase2d = LookupRuntimeTypedClass(LVecBase2d::get_class_type());
  Dtool_Ptr_LVecBase2f = LookupRuntimeTypedClass(LVecBase2f::get_class_type());
  Dtool_Ptr_LMatrix3f = LookupRuntimeTypedClass(LMatrix3f::get_class_type());
  Dtool_Ptr_LMatrix4d = LookupRuntimeTypedClass(LMatrix4d::get_class_type());
  Dtool_Ptr_UnalignedLVecBase4i = LookupRuntimeTypedClass(UnalignedLVecBase4i::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_LMatrix3d = LookupRuntimeTypedClass(LMatrix3d::get_class_type());
  Dtool_Ptr_UnalignedLMatrix4f = LookupRuntimeTypedClass(UnalignedLMatrix4f::get_class_type());
  Dtool_Ptr_UnalignedLMatrix4d = LookupRuntimeTypedClass(UnalignedLMatrix4d::get_class_type());
  Dtool_Ptr_LQuaternionf = LookupRuntimeTypedClass(LQuaternionf::get_class_type());
  Dtool_Ptr_LQuaterniond = LookupRuntimeTypedClass(LQuaterniond::get_class_type());
  Dtool_Ptr_LVecBase3d = LookupRuntimeTypedClass(LVecBase3d::get_class_type());
  Dtool_Ptr_LVecBase2i = LookupRuntimeTypedClass(LVecBase2i::get_class_type());
  Dtool_Ptr_LVecBase3i = LookupRuntimeTypedClass(LVecBase3i::get_class_type());
  Dtool_Ptr_LVector3d = LookupRuntimeTypedClass(LVector3d::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LPoint3d = LookupRuntimeTypedClass(LPoint3d::get_class_type());
  Dtool_Ptr_LPoint2d = LookupRuntimeTypedClass(LPoint2d::get_class_type());
  Dtool_Ptr_LVector3f = LookupRuntimeTypedClass(LVector3f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_UnalignedLVecBase4d = LookupRuntimeTypedClass(UnalignedLVecBase4d::get_class_type());
  Dtool_Ptr_UnalignedLVecBase4f = LookupRuntimeTypedClass(UnalignedLVecBase4f::get_class_type());
  Dtool_Ptr_LVecBase4d = LookupRuntimeTypedClass(LVecBase4d::get_class_type());
#endif
}

void Dtool_libp3mathutil_BuildInstants(PyObject *module) {
  (void) module;
  // ConstPointerToArray< LMatrix3d >
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d(module);
  PyModule_AddObject(module, "ConstPointerToArray_LMatrix3d", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LMatrix3d);
  PyModule_AddObject(module, "ConstPointerToArrayLMatrix3d", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  // PointerToArrayBase< LMatrix3d >
  Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d(module);
  PyModule_AddObject(module, "PointerToArrayBase_LMatrix3d", (PyObject *)&Dtool_PointerToArrayBase_LMatrix3d);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LMatrix3d);
  PyModule_AddObject(module, "PointerToArrayBaseLMatrix3d", (PyObject *)&Dtool_PointerToArrayBase_LMatrix3d);
  // PointerToBase< ReferenceCountedVector< LMatrix3d > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3d(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LMatrix3d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLMatrix3d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d);
  // ConstPointerToArray< LMatrix3f >
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(module);
  PyModule_AddObject(module, "ConstPointerToArray_LMatrix3f", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "ConstPointerToArrayLMatrix3f", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  // PointerToArrayBase< LMatrix3f >
  Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(module);
  PyModule_AddObject(module, "PointerToArrayBase_LMatrix3f", (PyObject *)&Dtool_PointerToArrayBase_LMatrix3f);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LMatrix3f);
  PyModule_AddObject(module, "PointerToArrayBaseLMatrix3f", (PyObject *)&Dtool_PointerToArrayBase_LMatrix3f);
  // PointerToBase< ReferenceCountedVector< LMatrix3f > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LMatrix3f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLMatrix3f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f);
  // ConstPointerToArray< LVecBase2d >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase2d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2d);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase2d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  // PointerToArrayBase< LVecBase2d >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase2d", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2d);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase2d);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase2d", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2d);
  // PointerToBase< ReferenceCountedVector< LVecBase2d > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2d(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase2d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase2d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d);
  // ConstPointerToArray< LVecBase2f >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase2f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase2f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  // PointerToArrayBase< LVecBase2f >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase2f", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2f);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase2f);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase2f", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2f);
  // PointerToBase< ReferenceCountedVector< LVecBase2f > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase2f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase2f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f);
  // ConstPointerToArray< LVecBase2i >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2i(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase2i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2i);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase2i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  // PointerToArrayBase< LVecBase2i >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase2i", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2i);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase2i);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase2i", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2i);
  // PointerToBase< ReferenceCountedVector< LVecBase2i > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2i(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase2i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase2i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i);
  // ConstPointerToArray< LVecBase3d >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase3d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3d);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase3d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  // PointerToArrayBase< LVecBase3d >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase3d", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3d);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase3d);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase3d", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3d);
  // PointerToBase< ReferenceCountedVector< LVecBase3d > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3d(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase3d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase3d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d);
  // ConstPointerToArray< LVecBase3f >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase3f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase3f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  // PointerToArrayBase< LVecBase3f >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase3f", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3f);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase3f);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase3f", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3f);
  // PointerToBase< ReferenceCountedVector< LVecBase3f > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase3f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase3f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f);
  // ConstPointerToArray< LVecBase3i >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3i(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase3i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3i);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase3i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  // PointerToArrayBase< LVecBase3i >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase3i", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3i);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase3i);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase3i", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3i);
  // PointerToBase< ReferenceCountedVector< LVecBase3i > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3i(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase3i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase3i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i);
  // ConstPointerToArray< UnalignedLMatrix4d >
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d(module);
  PyModule_AddObject(module, "ConstPointerToArray_UnalignedLMatrix4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "ConstPointerToArrayUnalignedLMatrix4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  // PointerToArrayBase< UnalignedLMatrix4d >
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d(module);
  PyModule_AddObject(module, "PointerToArrayBase_UnalignedLMatrix4d", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PointerToArrayBaseUnalignedLMatrix4d", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d);
  // PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnalignedLMatrix4d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
  // ConstPointerToArray< UnalignedLMatrix4f >
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(module);
  PyModule_AddObject(module, "ConstPointerToArray_UnalignedLMatrix4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "ConstPointerToArrayUnalignedLMatrix4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  // PointerToArrayBase< UnalignedLMatrix4f >
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f(module);
  PyModule_AddObject(module, "PointerToArrayBase_UnalignedLMatrix4f", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PointerToArrayBaseUnalignedLMatrix4f", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f);
  // PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnalignedLMatrix4f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
  // ConstPointerToArray< UnalignedLVecBase4d >
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d(module);
  PyModule_AddObject(module, "ConstPointerToArray_UnalignedLVecBase4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "ConstPointerToArrayUnalignedLVecBase4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  // PointerToArrayBase< UnalignedLVecBase4d >
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d(module);
  PyModule_AddObject(module, "PointerToArrayBase_UnalignedLVecBase4d", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PointerToArrayBaseUnalignedLVecBase4d", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d);
  // PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnalignedLVecBase4d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
  // ConstPointerToArray< UnalignedLVecBase4f >
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(module);
  PyModule_AddObject(module, "ConstPointerToArray_UnalignedLVecBase4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "ConstPointerToArrayUnalignedLVecBase4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  // PointerToArrayBase< UnalignedLVecBase4f >
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f(module);
  PyModule_AddObject(module, "PointerToArrayBase_UnalignedLVecBase4f", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PointerToArrayBaseUnalignedLVecBase4f", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f);
  // PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnalignedLVecBase4f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
  // ConstPointerToArray< UnalignedLVecBase4i >
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4i(module);
  PyModule_AddObject(module, "ConstPointerToArray_UnalignedLVecBase4i", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "ConstPointerToArrayUnalignedLVecBase4i", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  // PointerToArrayBase< UnalignedLVecBase4i >
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i(module);
  PyModule_AddObject(module, "PointerToArrayBase_UnalignedLVecBase4i", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i);
  PyModule_AddObject(module, "PointerToArrayBaseUnalignedLVecBase4i", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i);
  // PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnalignedLVecBase4i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
  // PointerToArray< LMatrix3d >
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3d(module);
  PyModule_AddObject(module, "PointerToArray_LMatrix3d", (PyObject *)&Dtool_PointerToArray_LMatrix3d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LMatrix3d);
  PyModule_AddObject(module, "PointerToArrayLMatrix3d", (PyObject *)&Dtool_PointerToArray_LMatrix3d);
  // PointerToArray< LMatrix3f >
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(module);
  PyModule_AddObject(module, "PointerToArray_LMatrix3f", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PointerToArrayLMatrix3f", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  // PointerToArray< LVecBase2d >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2d(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase2d", (PyObject *)&Dtool_PointerToArray_LVecBase2d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2d);
  PyModule_AddObject(module, "PointerToArrayLVecBase2d", (PyObject *)&Dtool_PointerToArray_LVecBase2d);
  // PointerToArray< LVecBase2f >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase2f", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PointerToArrayLVecBase2f", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  // PointerToArray< LVecBase2i >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2i(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase2i", (PyObject *)&Dtool_PointerToArray_LVecBase2i);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2i);
  PyModule_AddObject(module, "PointerToArrayLVecBase2i", (PyObject *)&Dtool_PointerToArray_LVecBase2i);
  // PointerToArray< LVecBase3d >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3d(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase3d", (PyObject *)&Dtool_PointerToArray_LVecBase3d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3d);
  PyModule_AddObject(module, "PointerToArrayLVecBase3d", (PyObject *)&Dtool_PointerToArray_LVecBase3d);
  // PointerToArray< LVecBase3f >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase3f", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PointerToArrayLVecBase3f", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  // PointerToArray< LVecBase3i >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3i(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase3i", (PyObject *)&Dtool_PointerToArray_LVecBase3i);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3i);
  PyModule_AddObject(module, "PointerToArrayLVecBase3i", (PyObject *)&Dtool_PointerToArray_LVecBase3i);
  // PointerToArray< UnalignedLMatrix4d >
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d(module);
  PyModule_AddObject(module, "PointerToArray_UnalignedLMatrix4d", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PointerToArrayUnalignedLMatrix4d", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  // PointerToArray< UnalignedLMatrix4f >
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(module);
  PyModule_AddObject(module, "PointerToArray_UnalignedLMatrix4f", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PointerToArrayUnalignedLMatrix4f", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  // PointerToArray< UnalignedLVecBase4d >
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d(module);
  PyModule_AddObject(module, "PointerToArray_UnalignedLVecBase4d", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PointerToArrayUnalignedLVecBase4d", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  // PointerToArray< UnalignedLVecBase4f >
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(module);
  PyModule_AddObject(module, "PointerToArray_UnalignedLVecBase4f", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PointerToArrayUnalignedLVecBase4f", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  // PointerToArray< UnalignedLVecBase4i >
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4i(module);
  PyModule_AddObject(module, "PointerToArray_UnalignedLVecBase4i", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "PointerToArrayUnalignedLVecBase4i", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  // BoundingVolume
  Dtool_PyModuleClassInit_BoundingVolume(module);
  PyModule_AddObject(module, "BoundingVolume", (PyObject *)&Dtool_BoundingVolume);
  // GeometricBoundingVolume
  Dtool_PyModuleClassInit_GeometricBoundingVolume(module);
  PyModule_AddObject(module, "GeometricBoundingVolume", (PyObject *)&Dtool_GeometricBoundingVolume);
  // FiniteBoundingVolume
  Dtool_PyModuleClassInit_FiniteBoundingVolume(module);
  PyModule_AddObject(module, "FiniteBoundingVolume", (PyObject *)&Dtool_FiniteBoundingVolume);
  // LParabolaf
  Dtool_PyModuleClassInit_LParabolaf(module);
  PyModule_AddObject(module, "LParabolaf", (PyObject *)&Dtool_LParabolaf);
  // LParabolad
  Dtool_PyModuleClassInit_LParabolad(module);
  PyModule_AddObject(module, "LParabolad", (PyObject *)&Dtool_LParabolad);
  // typedef LParabolaf LParabola
  Dtool_PyModuleClassInit_LParabolaf(module);
  Py_INCREF((PyObject *)&Dtool_LParabolaf);
  PyModule_AddObject(module, "LParabola", (PyObject *)&Dtool_LParabolaf);
  // LPlanef
  Dtool_PyModuleClassInit_LPlanef(module);
  PyModule_AddObject(module, "LPlanef", (PyObject *)&Dtool_LPlanef);
  // LPlaned
  Dtool_PyModuleClassInit_LPlaned(module);
  PyModule_AddObject(module, "LPlaned", (PyObject *)&Dtool_LPlaned);
  // typedef LPlanef LPlane
  Dtool_PyModuleClassInit_LPlanef(module);
  Py_INCREF((PyObject *)&Dtool_LPlanef);
  PyModule_AddObject(module, "LPlane", (PyObject *)&Dtool_LPlanef);
  // typedef LPlanef PlaneF
  Dtool_PyModuleClassInit_LPlanef(module);
  Py_INCREF((PyObject *)&Dtool_LPlanef);
  PyModule_AddObject(module, "PlaneF", (PyObject *)&Dtool_LPlanef);
  // typedef LPlaned PlaneD
  Dtool_PyModuleClassInit_LPlaned(module);
  Py_INCREF((PyObject *)&Dtool_LPlaned);
  PyModule_AddObject(module, "PlaneD", (PyObject *)&Dtool_LPlaned);
  // typedef LPlanef Plane
  Dtool_PyModuleClassInit_LPlanef(module);
  Py_INCREF((PyObject *)&Dtool_LPlanef);
  PyModule_AddObject(module, "Plane", (PyObject *)&Dtool_LPlanef);
  // BoundingBox
  Dtool_PyModuleClassInit_BoundingBox(module);
  PyModule_AddObject(module, "BoundingBox", (PyObject *)&Dtool_BoundingBox);
  // LFrustumf
  Dtool_PyModuleClassInit_LFrustumf(module);
  PyModule_AddObject(module, "LFrustumf", (PyObject *)&Dtool_LFrustumf);
  // LFrustumd
  Dtool_PyModuleClassInit_LFrustumd(module);
  PyModule_AddObject(module, "LFrustumd", (PyObject *)&Dtool_LFrustumd);
  // typedef LFrustumf LFrustum
  Dtool_PyModuleClassInit_LFrustumf(module);
  Py_INCREF((PyObject *)&Dtool_LFrustumf);
  PyModule_AddObject(module, "LFrustum", (PyObject *)&Dtool_LFrustumf);
  // typedef LFrustumf FrustumF
  Dtool_PyModuleClassInit_LFrustumf(module);
  Py_INCREF((PyObject *)&Dtool_LFrustumf);
  PyModule_AddObject(module, "FrustumF", (PyObject *)&Dtool_LFrustumf);
  // typedef LFrustumd FrustumD
  Dtool_PyModuleClassInit_LFrustumd(module);
  Py_INCREF((PyObject *)&Dtool_LFrustumd);
  PyModule_AddObject(module, "FrustumD", (PyObject *)&Dtool_LFrustumd);
  // typedef LFrustumf Frustum
  Dtool_PyModuleClassInit_LFrustumf(module);
  Py_INCREF((PyObject *)&Dtool_LFrustumf);
  PyModule_AddObject(module, "Frustum", (PyObject *)&Dtool_LFrustumf);
  // BoundingHexahedron
  Dtool_PyModuleClassInit_BoundingHexahedron(module);
  PyModule_AddObject(module, "BoundingHexahedron", (PyObject *)&Dtool_BoundingHexahedron);
  // BoundingLine
  Dtool_PyModuleClassInit_BoundingLine(module);
  PyModule_AddObject(module, "BoundingLine", (PyObject *)&Dtool_BoundingLine);
  // BoundingPlane
  Dtool_PyModuleClassInit_BoundingPlane(module);
  PyModule_AddObject(module, "BoundingPlane", (PyObject *)&Dtool_BoundingPlane);
  // BoundingSphere
  Dtool_PyModuleClassInit_BoundingSphere(module);
  PyModule_AddObject(module, "BoundingSphere", (PyObject *)&Dtool_BoundingSphere);
  // IntersectionBoundingVolume
  Dtool_PyModuleClassInit_IntersectionBoundingVolume(module);
  PyModule_AddObject(module, "IntersectionBoundingVolume", (PyObject *)&Dtool_IntersectionBoundingVolume);
  // Mersenne
  Dtool_PyModuleClassInit_Mersenne(module);
  PyModule_AddObject(module, "Mersenne", (PyObject *)&Dtool_Mersenne);
  // OmniBoundingVolume
  Dtool_PyModuleClassInit_OmniBoundingVolume(module);
  PyModule_AddObject(module, "OmniBoundingVolume", (PyObject *)&Dtool_OmniBoundingVolume);
  // UnionBoundingVolume
  Dtool_PyModuleClassInit_UnionBoundingVolume(module);
  PyModule_AddObject(module, "UnionBoundingVolume", (PyObject *)&Dtool_UnionBoundingVolume);
  // Randomizer
  Dtool_PyModuleClassInit_Randomizer(module);
  PyModule_AddObject(module, "Randomizer", (PyObject *)&Dtool_Randomizer);
  // PerlinNoise
  Dtool_PyModuleClassInit_PerlinNoise(module);
  PyModule_AddObject(module, "PerlinNoise", (PyObject *)&Dtool_PerlinNoise);
  // PerlinNoise2
  Dtool_PyModuleClassInit_PerlinNoise2(module);
  PyModule_AddObject(module, "PerlinNoise2", (PyObject *)&Dtool_PerlinNoise2);
  // PerlinNoise3
  Dtool_PyModuleClassInit_PerlinNoise3(module);
  PyModule_AddObject(module, "PerlinNoise3", (PyObject *)&Dtool_PerlinNoise3);
  // typedef PointerToArray< UnalignedLMatrix4f > PTA_LMatrix4f
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PTA_LMatrix4f", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PTALMatrix4f", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  // typedef ConstPointerToArray< UnalignedLMatrix4f > CPTA_LMatrix4f
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "CPTA_LMatrix4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "CPTALMatrix4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  // typedef PointerToArray< UnalignedLMatrix4d > PTA_LMatrix4d
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PTA_LMatrix4d", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PTALMatrix4d", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  // typedef ConstPointerToArray< UnalignedLMatrix4d > CPTA_LMatrix4d
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "CPTA_LMatrix4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "CPTALMatrix4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  // typedef PointerToArray< UnalignedLMatrix4f > PTA_LMatrix4
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PTA_LMatrix4", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PTALMatrix4", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  // typedef ConstPointerToArray< UnalignedLMatrix4f > CPTA_LMatrix4
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "CPTA_LMatrix4", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "CPTALMatrix4", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  // typedef PointerToArray< UnalignedLMatrix4f > PTAMat4
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PTAMat4", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  // typedef ConstPointerToArray< UnalignedLMatrix4f > CPTAMat4
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "CPTAMat4", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  // typedef PointerToArray< UnalignedLMatrix4d > PTAMat4d
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PTAMat4d", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  // typedef ConstPointerToArray< UnalignedLMatrix4d > CPTAMat4d
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "CPTAMat4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  // typedef PointerToArray< LMatrix3f > PTA_LMatrix3f
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PTA_LMatrix3f", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PTALMatrix3f", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  // typedef ConstPointerToArray< LMatrix3f > CPTA_LMatrix3f
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "CPTA_LMatrix3f", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "CPTALMatrix3f", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  // typedef PointerToArray< LMatrix3d > PTA_LMatrix3d
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LMatrix3d);
  PyModule_AddObject(module, "PTA_LMatrix3d", (PyObject *)&Dtool_PointerToArray_LMatrix3d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LMatrix3d);
  PyModule_AddObject(module, "PTALMatrix3d", (PyObject *)&Dtool_PointerToArray_LMatrix3d);
  // typedef ConstPointerToArray< LMatrix3d > CPTA_LMatrix3d
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  PyModule_AddObject(module, "CPTA_LMatrix3d", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LMatrix3d);
  PyModule_AddObject(module, "CPTALMatrix3d", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  // typedef PointerToArray< LMatrix3f > PTA_LMatrix3
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PTA_LMatrix3", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PTALMatrix3", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  // typedef ConstPointerToArray< LMatrix3f > CPTA_LMatrix3
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "CPTA_LMatrix3", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "CPTALMatrix3", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  // typedef PointerToArray< LMatrix3f > PTAMat3
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PTAMat3", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  // typedef ConstPointerToArray< LMatrix3f > CPTAMat3
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "CPTAMat3", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  // typedef PointerToArray< LMatrix3d > PTAMat3d
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LMatrix3d);
  PyModule_AddObject(module, "PTAMat3d", (PyObject *)&Dtool_PointerToArray_LMatrix3d);
  // typedef ConstPointerToArray< LMatrix3d > CPTAMat3d
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  PyModule_AddObject(module, "CPTAMat3d", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  // typedef PointerToArray< UnalignedLVecBase4f > PTA_LVecBase4f
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PTA_LVecBase4f", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PTALVecBase4f", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  // typedef ConstPointerToArray< UnalignedLVecBase4f > CPTA_LVecBase4f
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "CPTA_LVecBase4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "CPTALVecBase4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  // typedef PointerToArray< UnalignedLVecBase4d > PTA_LVecBase4d
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PTA_LVecBase4d", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PTALVecBase4d", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  // typedef ConstPointerToArray< UnalignedLVecBase4d > CPTA_LVecBase4d
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "CPTA_LVecBase4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "CPTALVecBase4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  // typedef PointerToArray< UnalignedLVecBase4i > PTA_LVecBase4i
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4i(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "PTA_LVecBase4i", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "PTALVecBase4i", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  // typedef ConstPointerToArray< UnalignedLVecBase4i > CPTA_LVecBase4i
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4i(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "CPTA_LVecBase4i", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "CPTALVecBase4i", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  // typedef PointerToArray< UnalignedLVecBase4f > PTA_LVecBase4
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PTA_LVecBase4", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PTALVecBase4", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  // typedef ConstPointerToArray< UnalignedLVecBase4f > CPTA_LVecBase4
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "CPTA_LVecBase4", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "CPTALVecBase4", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  // typedef PointerToArray< UnalignedLVecBase4f > PTAVecBase4f
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PTAVecBase4f", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  // typedef ConstPointerToArray< UnalignedLVecBase4f > CPTAVecBase4f
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "CPTAVecBase4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  // typedef PointerToArray< UnalignedLVecBase4d > PTAVecBase4d
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PTAVecBase4d", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  // typedef ConstPointerToArray< UnalignedLVecBase4d > CPTAVecBase4d
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "CPTAVecBase4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  // typedef PointerToArray< LVecBase3f > PTA_LVecBase3f
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PTA_LVecBase3f", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PTALVecBase3f", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  // typedef ConstPointerToArray< LVecBase3f > CPTA_LVecBase3f
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "CPTA_LVecBase3f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "CPTALVecBase3f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  // typedef PointerToArray< LVecBase3d > PTA_LVecBase3d
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3d);
  PyModule_AddObject(module, "PTA_LVecBase3d", (PyObject *)&Dtool_PointerToArray_LVecBase3d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3d);
  PyModule_AddObject(module, "PTALVecBase3d", (PyObject *)&Dtool_PointerToArray_LVecBase3d);
  // typedef ConstPointerToArray< LVecBase3d > CPTA_LVecBase3d
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  PyModule_AddObject(module, "CPTA_LVecBase3d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3d);
  PyModule_AddObject(module, "CPTALVecBase3d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  // typedef PointerToArray< LVecBase3i > PTA_LVecBase3i
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3i(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3i);
  PyModule_AddObject(module, "PTA_LVecBase3i", (PyObject *)&Dtool_PointerToArray_LVecBase3i);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3i);
  PyModule_AddObject(module, "PTALVecBase3i", (PyObject *)&Dtool_PointerToArray_LVecBase3i);
  // typedef ConstPointerToArray< LVecBase3i > CPTA_LVecBase3i
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3i(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  PyModule_AddObject(module, "CPTA_LVecBase3i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3i);
  PyModule_AddObject(module, "CPTALVecBase3i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  // typedef PointerToArray< LVecBase3f > PTA_LVecBase3
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PTA_LVecBase3", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PTALVecBase3", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  // typedef ConstPointerToArray< LVecBase3f > CPTA_LVecBase3
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "CPTA_LVecBase3", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "CPTALVecBase3", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  // typedef PointerToArray< LVecBase3f > PTAVecBase3f
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PTAVecBase3f", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  // typedef ConstPointerToArray< LVecBase3f > CPTAVecBase3f
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "CPTAVecBase3f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  // typedef PointerToArray< LVecBase3d > PTAVecBase3d
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3d);
  PyModule_AddObject(module, "PTAVecBase3d", (PyObject *)&Dtool_PointerToArray_LVecBase3d);
  // typedef ConstPointerToArray< LVecBase3d > CPTAVecBase3d
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  PyModule_AddObject(module, "CPTAVecBase3d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  // typedef PointerToArray< LVecBase2f > PTA_LVecBase2f
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PTA_LVecBase2f", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PTALVecBase2f", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  // typedef ConstPointerToArray< LVecBase2f > CPTA_LVecBase2f
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "CPTA_LVecBase2f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "CPTALVecBase2f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  // typedef PointerToArray< LVecBase2d > PTA_LVecBase2d
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2d);
  PyModule_AddObject(module, "PTA_LVecBase2d", (PyObject *)&Dtool_PointerToArray_LVecBase2d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2d);
  PyModule_AddObject(module, "PTALVecBase2d", (PyObject *)&Dtool_PointerToArray_LVecBase2d);
  // typedef ConstPointerToArray< LVecBase2d > CPTA_LVecBase2d
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  PyModule_AddObject(module, "CPTA_LVecBase2d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2d);
  PyModule_AddObject(module, "CPTALVecBase2d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  // typedef PointerToArray< LVecBase2i > PTA_LVecBase2i
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2i(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2i);
  PyModule_AddObject(module, "PTA_LVecBase2i", (PyObject *)&Dtool_PointerToArray_LVecBase2i);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2i);
  PyModule_AddObject(module, "PTALVecBase2i", (PyObject *)&Dtool_PointerToArray_LVecBase2i);
  // typedef ConstPointerToArray< LVecBase2i > CPTA_LVecBase2i
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2i(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  PyModule_AddObject(module, "CPTA_LVecBase2i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2i);
  PyModule_AddObject(module, "CPTALVecBase2i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  // typedef PointerToArray< LVecBase2f > PTA_LVecBase2
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PTA_LVecBase2", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PTALVecBase2", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  // typedef ConstPointerToArray< LVecBase2f > CPTA_LVecBase2
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "CPTA_LVecBase2", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "CPTALVecBase2", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  // typedef PointerToArray< LVecBase2f > PTAVecBase2f
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PTAVecBase2f", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  // typedef ConstPointerToArray< LVecBase2f > CPTAVecBase2f
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "CPTAVecBase2f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  // typedef PointerToArray< LVecBase2d > PTAVecBase2d
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2d);
  PyModule_AddObject(module, "PTAVecBase2d", (PyObject *)&Dtool_PointerToArray_LVecBase2d);
  // typedef ConstPointerToArray< LVecBase2d > CPTAVecBase2d
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  PyModule_AddObject(module, "CPTAVecBase2d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  // StackedPerlinNoise2
  Dtool_PyModuleClassInit_StackedPerlinNoise2(module);
  PyModule_AddObject(module, "StackedPerlinNoise2", (PyObject *)&Dtool_StackedPerlinNoise2);
  // StackedPerlinNoise3
  Dtool_PyModuleClassInit_StackedPerlinNoise3(module);
  PyModule_AddObject(module, "StackedPerlinNoise3", (PyObject *)&Dtool_StackedPerlinNoise3);
  // Triangulator
  Dtool_PyModuleClassInit_Triangulator(module);
  PyModule_AddObject(module, "Triangulator", (PyObject *)&Dtool_Triangulator);
  // Triangulator3
  Dtool_PyModuleClassInit_Triangulator3(module);
  PyModule_AddObject(module, "Triangulator3", (PyObject *)&Dtool_Triangulator3);
}

static PyMethodDef python_simple_funcs[] = {
  {"heads_up", (PyCFunction) &Dtool_heads_up_665, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_heads_up_665_comment},
  {"headsUp", (PyCFunction) &Dtool_heads_up_665, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_heads_up_665_comment},
  {"look_at", (PyCFunction) &Dtool_look_at_666, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_look_at_666_comment},
  {"lookAt", (PyCFunction) &Dtool_look_at_666, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_look_at_666_comment},
  {"rotate_to", (PyCFunction) &Dtool_rotate_to_772, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_rotate_to_772_comment},
  {"rotateTo", (PyCFunction) &Dtool_rotate_to_772, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_rotate_to_772_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3mathutil_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478210281,  /* file_identifier */
  "libp3mathutil",  /* library_name */
  "LL_p",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3mathutil.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1823  /* next_index */
};

Configure(_in_configure_libp3mathutil);
ConfigureFn(_in_configure_libp3mathutil) {
  interrogate_request_module(&_in_module_def);
}

