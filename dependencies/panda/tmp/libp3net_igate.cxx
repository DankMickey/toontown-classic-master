/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/net -Ipanda/src/net -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3net_igate.cxx -od built/pandac/input/libp3net.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/net -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3net config_net.h connection.h connectionListener.h connectionManager.h connectionReader.h connectionWriter.h datagramGeneratorNet.h datagramQueue.h datagramSinkNet.h datagramTCPHeader.h datagramUDPHeader.h netAddress.h netDatagram.h p3net_composite1.cxx p3net_composite2.cxx queuedConnectionListener.h queuedConnectionManager.h queuedConnectionReader.h queuedReturn.h recentConnectionReader.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3net
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "conditionVar.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableInt.h"
#include "config_net.h"
#include "connection.h"
#include "connectionListener.h"
#include "connectionManager.h"
#include "connectionReader.h"
#include "connectionWriter.h"
#include "datagramGenerator.h"
#include "datagramGeneratorNet.h"
#include "datagramIterator.h"
#include "datagramQueue.h"
#include "datagramSink.h"
#include "datagramSinkNet.h"
#include "datagramTCPHeader.h"
#include "datagramUDPHeader.h"
#include "lightMutex.h"
#include "lightReMutex.h"
#include "netAddress.h"
#include "netDatagram.h"
#include "notifyCategoryProxy.h"
#include "numeric_types.h"
#include "pandabase.h"
#include "pmutex.h"
#include "pointerTo.h"
#include "pset.h"
#include "pvector.h"
#include "queuedConnectionListener.h"
#include "queuedConnectionManager.h"
#include "queuedConnectionReader.h"
#include "queuedReturn.h"
#include "recentConnectionReader.h"
#include "referenceCount.h"
#include "thread.h"
#include "threadPriority.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class PointerTo_Connection
 */
typedef PointerTo< Connection > PointerTo_Connection_localtype;
Define_Module_Class(panda3d.core, PointerTo_Connection, PointerTo_Connection_localtype, PointerTo_Connection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerTo_Connection = &Dtool_PointerTo_Connection;
static void Dtool_PyModuleClassInit_PointerTo_Connection(PyObject *module);
bool Dtool_ConstCoerce_PointerTo_Connection(PyObject *args, PointerTo< Connection > const *&coerced, bool &manage);
bool Dtool_Coerce_PointerTo_Connection(PyObject *args, PointerTo< Connection > *&coerced, bool &manage);

/**
 * Forward declarations for top-level class PointerToBase_Connection
 */
typedef PointerToBase< Connection > PointerToBase_Connection_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_Connection, PointerToBase_Connection_localtype, PointerToBase_Connection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_Connection = &Dtool_PointerToBase_Connection;
static void Dtool_PyModuleClassInit_PointerToBase_Connection(PyObject *module);

/**
 * Forward declarations for top-level class NetAddress
 */
typedef NetAddress NetAddress_localtype;
Define_Module_Class(panda3d.core, NetAddress, NetAddress_localtype, NetAddress);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NetAddress = &Dtool_NetAddress;
static void Dtool_PyModuleClassInit_NetAddress(PyObject *module);
bool Dtool_ConstCoerce_NetAddress(PyObject *args, NetAddress const *&coerced, bool &manage);
bool Dtool_Coerce_NetAddress(PyObject *args, NetAddress *&coerced, bool &manage);

/**
 * Forward declarations for top-level class Connection
 */
typedef Connection Connection_localtype;
Define_Module_ClassRef(panda3d.core, Connection, Connection_localtype, Connection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Connection = &Dtool_Connection;
static void Dtool_PyModuleClassInit_Connection(PyObject *module);
bool Dtool_ConstCoerce_Connection(PyObject *args, CPT(Connection) &coerced);
bool Dtool_Coerce_Connection(PyObject *args, PT(Connection) &coerced);

/**
 * Forward declarations for top-level class ConnectionReader
 */
typedef ConnectionReader ConnectionReader_localtype;
Define_Module_Class(panda3d.core, ConnectionReader, ConnectionReader_localtype, ConnectionReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionReader = &Dtool_ConnectionReader;
static void Dtool_PyModuleClassInit_ConnectionReader(PyObject *module);
bool Dtool_ConstCoerce_ConnectionReader(PyObject *args, ConnectionReader const *&coerced, bool &manage);
bool Dtool_Coerce_ConnectionReader(PyObject *args, ConnectionReader *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ConnectionListener
 */
typedef ConnectionListener ConnectionListener_localtype;
Define_Module_Class(panda3d.core, ConnectionListener, ConnectionListener_localtype, ConnectionListener);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionListener = &Dtool_ConnectionListener;
static void Dtool_PyModuleClassInit_ConnectionListener(PyObject *module);
bool Dtool_ConstCoerce_ConnectionListener(PyObject *args, ConnectionListener const *&coerced, bool &manage);
bool Dtool_Coerce_ConnectionListener(PyObject *args, ConnectionListener *&coerced, bool &manage);

/**
 * Forward declarations for top-level class NetDatagram
 */
typedef NetDatagram NetDatagram_localtype;
Define_Module_Class(panda3d.core, NetDatagram, NetDatagram_localtype, NetDatagram);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NetDatagram = &Dtool_NetDatagram;
static void Dtool_PyModuleClassInit_NetDatagram(PyObject *module);
bool Dtool_ConstCoerce_NetDatagram(PyObject *args, NetDatagram const *&coerced, bool &manage);
bool Dtool_Coerce_NetDatagram(PyObject *args, NetDatagram *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ConnectionManager
 */
typedef ConnectionManager ConnectionManager_localtype;
Define_Module_Class(panda3d.core, ConnectionManager, ConnectionManager_localtype, ConnectionManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionManager = &Dtool_ConnectionManager;
static void Dtool_PyModuleClassInit_ConnectionManager(PyObject *module);

/**
 * Forward declarations for top-level class ConnectionManager_Interface
 */
typedef ConnectionManager::Interface ConnectionManager_Interface_localtype;
Define_Module_Class(panda3d.core, ConnectionManager_Interface, ConnectionManager_Interface_localtype, Interface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionManager_Interface = &Dtool_ConnectionManager_Interface;
static void Dtool_PyModuleClassInit_ConnectionManager_Interface(PyObject *module);

/**
 * Forward declarations for top-level class ConnectionWriter
 */
typedef ConnectionWriter ConnectionWriter_localtype;
Define_Module_Class(panda3d.core, ConnectionWriter, ConnectionWriter_localtype, ConnectionWriter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionWriter = &Dtool_ConnectionWriter;
static void Dtool_PyModuleClassInit_ConnectionWriter(PyObject *module);
bool Dtool_ConstCoerce_ConnectionWriter(PyObject *args, ConnectionWriter const *&coerced, bool &manage);
bool Dtool_Coerce_ConnectionWriter(PyObject *args, ConnectionWriter *&coerced, bool &manage);

/**
 * Forward declarations for top-level class DatagramGeneratorNet
 */
typedef DatagramGeneratorNet DatagramGeneratorNet_localtype;
Define_Module_Class(panda3d.core, DatagramGeneratorNet, DatagramGeneratorNet_localtype, DatagramGeneratorNet);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramGeneratorNet = &Dtool_DatagramGeneratorNet;
static void Dtool_PyModuleClassInit_DatagramGeneratorNet(PyObject *module);
bool Dtool_ConstCoerce_DatagramGeneratorNet(PyObject *args, DatagramGeneratorNet const *&coerced, bool &manage);
bool Dtool_Coerce_DatagramGeneratorNet(PyObject *args, DatagramGeneratorNet *&coerced, bool &manage);

/**
 * Forward declarations for top-level class QueuedReturn_Datagram
 */
typedef QueuedReturn< Datagram > QueuedReturn_Datagram_localtype;
Define_Module_Class_Private(panda3d.core, QueuedReturn_Datagram, QueuedReturn_Datagram_localtype, QueuedReturn_Datagram);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedReturn_Datagram = &Dtool_QueuedReturn_Datagram;
static void Dtool_PyModuleClassInit_QueuedReturn_Datagram(PyObject *module);

/**
 * Forward declarations for top-level class DatagramSinkNet
 */
typedef DatagramSinkNet DatagramSinkNet_localtype;
Define_Module_Class(panda3d.core, DatagramSinkNet, DatagramSinkNet_localtype, DatagramSinkNet);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramSinkNet = &Dtool_DatagramSinkNet;
static void Dtool_PyModuleClassInit_DatagramSinkNet(PyObject *module);
bool Dtool_ConstCoerce_DatagramSinkNet(PyObject *args, DatagramSinkNet const *&coerced, bool &manage);
bool Dtool_Coerce_DatagramSinkNet(PyObject *args, DatagramSinkNet *&coerced, bool &manage);

/**
 * Forward declarations for top-level class QueuedConnectionListener
 */
typedef QueuedConnectionListener QueuedConnectionListener_localtype;
Define_Module_Class(panda3d.core, QueuedConnectionListener, QueuedConnectionListener_localtype, QueuedConnectionListener);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedConnectionListener = &Dtool_QueuedConnectionListener;
static void Dtool_PyModuleClassInit_QueuedConnectionListener(PyObject *module);
bool Dtool_ConstCoerce_QueuedConnectionListener(PyObject *args, QueuedConnectionListener const *&coerced, bool &manage);
bool Dtool_Coerce_QueuedConnectionListener(PyObject *args, QueuedConnectionListener *&coerced, bool &manage);

/**
 * Forward declarations for top-level class QueuedReturn_ConnectionListenerData
 */
typedef QueuedReturn< ConnectionListenerData > QueuedReturn_ConnectionListenerData_localtype;
Define_Module_Class_Private(panda3d.core, QueuedReturn_ConnectionListenerData, QueuedReturn_ConnectionListenerData_localtype, QueuedReturn_ConnectionListenerData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedReturn_ConnectionListenerData = &Dtool_QueuedReturn_ConnectionListenerData;
static void Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData(PyObject *module);

/**
 * Forward declarations for top-level class QueuedConnectionManager
 */
typedef QueuedConnectionManager QueuedConnectionManager_localtype;
Define_Module_Class(panda3d.core, QueuedConnectionManager, QueuedConnectionManager_localtype, QueuedConnectionManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedConnectionManager = &Dtool_QueuedConnectionManager;
static void Dtool_PyModuleClassInit_QueuedConnectionManager(PyObject *module);

/**
 * Forward declarations for top-level class QueuedReturn_PointerTo_Connection
 */
typedef QueuedReturn< PointerTo< Connection > > QueuedReturn_PointerTo_Connection_localtype;
Define_Module_Class_Private(panda3d.core, QueuedReturn_PointerTo_Connection, QueuedReturn_PointerTo_Connection_localtype, QueuedReturn_PointerTo_Connection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedReturn_PointerTo_Connection = &Dtool_QueuedReturn_PointerTo_Connection;
static void Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection(PyObject *module);

/**
 * Forward declarations for top-level class QueuedConnectionReader
 */
typedef QueuedConnectionReader QueuedConnectionReader_localtype;
Define_Module_Class(panda3d.core, QueuedConnectionReader, QueuedConnectionReader_localtype, QueuedConnectionReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedConnectionReader = &Dtool_QueuedConnectionReader;
static void Dtool_PyModuleClassInit_QueuedConnectionReader(PyObject *module);
bool Dtool_ConstCoerce_QueuedConnectionReader(PyObject *args, QueuedConnectionReader const *&coerced, bool &manage);
bool Dtool_Coerce_QueuedConnectionReader(PyObject *args, QueuedConnectionReader *&coerced, bool &manage);

/**
 * Forward declarations for top-level class QueuedReturn_NetDatagram
 */
typedef QueuedReturn< NetDatagram > QueuedReturn_NetDatagram_localtype;
Define_Module_Class_Private(panda3d.core, QueuedReturn_NetDatagram, QueuedReturn_NetDatagram_localtype, QueuedReturn_NetDatagram);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedReturn_NetDatagram = &Dtool_QueuedReturn_NetDatagram;
static void Dtool_PyModuleClassInit_QueuedReturn_NetDatagram(PyObject *module);

/**
 * Forward declarations for top-level class RecentConnectionReader
 */
typedef RecentConnectionReader RecentConnectionReader_localtype;
Define_Module_Class(panda3d.core, RecentConnectionReader, RecentConnectionReader_localtype, RecentConnectionReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RecentConnectionReader = &Dtool_RecentConnectionReader;
static void Dtool_PyModuleClassInit_RecentConnectionReader(PyObject *module);
bool Dtool_ConstCoerce_RecentConnectionReader(PyObject *args, RecentConnectionReader const *&coerced, bool &manage);
bool Dtool_Coerce_RecentConnectionReader(PyObject *args, RecentConnectionReader *&coerced, bool &manage);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Socket_Address
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Socket_Address;
inline static bool Dtool_ConstCoerce_Socket_Address(PyObject *args, Socket_Address const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Socket_Address != NULL, false);
  nassertr(Dtool_Ptr_Socket_Address->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, Socket_Address const *&, bool&))Dtool_Ptr_Socket_Address->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_Socket_Address(PyObject *args, Socket_Address *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Socket_Address != NULL, false);
  nassertr(Dtool_Ptr_Socket_Address->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, Socket_Address *&, bool&))Dtool_Ptr_Socket_Address->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_Socket_Address;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_Address = &Dtool_Socket_Address;
extern bool Dtool_ConstCoerce_Socket_Address(PyObject *args, Socket_Address const *&coerced, bool &manage);
extern bool Dtool_Coerce_Socket_Address(PyObject *args, Socket_Address *&coerced, bool &manage);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// PointerToVoid
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PointerToVoid;
#else
extern struct Dtool_PyTypedObject Dtool_PointerToVoid;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToVoid = &Dtool_PointerToVoid;
#endif
// Socket_IP
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Socket_IP;
inline static bool Dtool_ConstCoerce_Socket_IP(PyObject *args, Socket_IP const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Socket_IP != NULL, false);
  nassertr(Dtool_Ptr_Socket_IP->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, Socket_IP const *&, bool&))Dtool_Ptr_Socket_IP->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_Socket_IP(PyObject *args, Socket_IP *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Socket_IP != NULL, false);
  nassertr(Dtool_Ptr_Socket_IP->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, Socket_IP *&, bool&))Dtool_Ptr_Socket_IP->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_Socket_IP;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_IP = &Dtool_Socket_IP;
extern bool Dtool_ConstCoerce_Socket_IP(PyObject *args, Socket_IP const *&coerced, bool &manage);
extern bool Dtool_Coerce_Socket_IP(PyObject *args, Socket_IP *&coerced, bool &manage);
#endif
// DatagramSink
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DatagramSink;
#else
extern struct Dtool_PyTypedObject Dtool_DatagramSink;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramSink = &Dtool_DatagramSink;
#endif
// Datagram
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Datagram;
inline static bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram const *&, bool&))Dtool_Ptr_Datagram->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram *&, bool&))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage);
extern bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage);
#endif
// DatagramGenerator
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DatagramGenerator;
#else
extern struct Dtool_PyTypedObject Dtool_DatagramGenerator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramGenerator = &Dtool_DatagramGenerator;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class PointerTo< Connection >
 */
/**
 * Python function wrapper for:
 * inline Connection *PointerTo< Connection >::p(void) const
 */
static PyObject *Dtool_PointerTo_Connection_p_8(PyObject *self, PyObject *) {
  PointerTo< Connection > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerTo_Connection, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Connection *PointerTo< Connection >::p(void) const
  Connection *return_value = (*(const PointerTo< Connection >*)local_this).p();
  if (return_value != (Connection *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Connection *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Connection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_Connection_p_8_comment =
  "C++ Interface:\n"
  "p(PointerTo self)\n"
  "\n"
  "// If your base class is a derivative of TypedObject, you might want to use\n"
  "// the DCAST macro defined in typedObject.h instead, e.g.  DCAST(MyType,\n"
  "// ptr).  This provides a clean downcast that doesn't require .p() or any\n"
  "// double-casting, and it can be run-time checked for correctness.";
#else
static const char *Dtool_PointerTo_Connection_p_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Connection > &PointerTo< Connection >::operator =(Connection *ptr)
 * inline PointerTo< Connection > &PointerTo< Connection >::operator =(PointerTo< Connection > const &copy)
 */
static PyObject *Dtool_PointerTo_Connection_operator_9(PyObject *self, PyObject *arg) {
  PointerTo< Connection > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerTo_Connection, (void **)&local_this, "PointerTo_Connection.assign")) {
    return NULL;
  }
  {
    // -2 inline PointerTo< Connection > &PointerTo< Connection >::operator =(PointerTo< Connection > const &copy)
    Connection *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Connection, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(arg_this);
      PointerTo< Connection > *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerTo_Connection, false, false);
    }
  }

  {
    // -2 inline PointerTo< Connection > &PointerTo< Connection >::operator =(Connection *ptr)
    Connection *arg_this = (Connection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Connection, 1, "PointerTo.assign", false, false);
    if (arg_this != NULL) {
      (*local_this).operator =(arg_this);
      PointerTo< Connection > *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerTo_Connection, false, false);
    }
  }

  {
    // -2 inline PointerTo< Connection > &PointerTo< Connection >::operator =(PointerTo< Connection > const &copy)
    PT(Connection) arg_this;
    if (Dtool_Coerce_Connection(arg, arg_this)) {
      (*local_this).operator =(MOVE(arg_this));
      PointerTo< Connection > *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerTo_Connection, false, false);
    }
  }

  {
    // -2 inline PointerTo< Connection > &PointerTo< Connection >::operator =(Connection *ptr)
    PT(Connection) arg_this;
    if (Dtool_Coerce_Connection(arg, arg_this)) {
      (*local_this).operator =(MOVE(arg_this));
      PointerTo< Connection > *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerTo_Connection, false, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PointerTo self, const Connection copy)\n"
      "assign(const PointerTo self, Connection ptr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_Connection_operator_9_comment =
  "C++ Interface:\n"
  "assign(const PointerTo self, const Connection copy)\n"
  "assign(const PointerTo self, Connection ptr)\n";
#else
static const char *Dtool_PointerTo_Connection_operator_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PointerTo< Connection >::is_null(void) const
 */
static PyObject *Dtool_PointerTo_Connection_is_null_10(PyObject *self, PyObject *) {
  PointerTo< Connection > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerTo_Connection, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PointerTo< Connection >::is_null(void) const
  bool return_value = (*(const PointerTo< Connection >*)local_this).is_null();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_Connection_is_null_10_comment =
  "C++ Interface:\n"
  "is_null(PointerTo self)\n"
  "\n"
  "// These functions normally wouldn't need to be redefined here, but we do so\n"
  "// anyway just to help out interrogate (which doesn't seem to want to\n"
  "// automatically export the PointerToBase class).  When this works again in\n"
  "// interrogate, we can remove these.";
#else
static const char *Dtool_PointerTo_Connection_is_null_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerTo< Connection >::clear(void)
 */
static PyObject *Dtool_PointerTo_Connection_clear_11(PyObject *self, PyObject *) {
  PointerTo< Connection > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerTo_Connection, (void **)&local_this, "PointerTo_Connection.clear")) {
    return NULL;
  }
  // 1-inline void PointerTo< Connection >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_Connection_clear_11_comment =
  "C++ Interface:\n"
  "clear(const PointerTo self)\n";
#else
static const char *Dtool_PointerTo_Connection_clear_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Connection >::PointerTo(void) = default
 * inline PointerTo< Connection >::PointerTo(Connection *ptr)
 * inline PointerTo< Connection >::PointerTo(PointerTo< Connection > const &copy)
 */
static int Dtool_Init_PointerTo_Connection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerTo< Connection >::PointerTo(void) = default
      PointerTo< Connection > *return_value = new PointerTo< Connection >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_Connection, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerTo< Connection >::PointerTo(PointerTo< Connection > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerTo", (char **)keyword_list, &param0)) {
          Connection *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Connection, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerTo< Connection > *return_value = new PointerTo< Connection >(param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_Connection, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerTo< Connection >::PointerTo(Connection *ptr)
        PyObject *param0;
        static const char *keyword_list[] = {"ptr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerTo", (char **)keyword_list, &param0)) {
          Connection *param0_this = (Connection *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Connection, 0, "PointerTo.PointerTo", false, false);
          if (param0_this != NULL) {
            PointerTo< Connection > *return_value = new PointerTo< Connection >(param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_Connection, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerTo< Connection >::PointerTo(PointerTo< Connection > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerTo", (char **)keyword_list, &param0)) {
          PT(Connection) param0_this;
          if (Dtool_Coerce_Connection(param0, param0_this)) {
            PointerTo< Connection > *return_value = new PointerTo< Connection >(MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_Connection, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerTo< Connection >::PointerTo(Connection *ptr)
        PyObject *param0;
        static const char *keyword_list[] = {"ptr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerTo", (char **)keyword_list, &param0)) {
          PT(Connection) param0_this;
          if (Dtool_Coerce_Connection(param0, param0_this)) {
            PointerTo< Connection > *return_value = new PointerTo< Connection >(MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_Connection, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerTo() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerTo()\n"
      "PointerTo(const Connection copy)\n"
      "PointerTo(Connection ptr)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PointerTo_Connection(PyObject *args, PointerTo< Connection > const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerTo_Connection, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PointerTo< Connection >::PointerTo(Connection *ptr)
    Connection *arg_this = (Connection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Connection, 0, "PointerTo.PointerTo", false, false);
    if (arg_this != NULL) {
      PointerTo< Connection > *return_value = new PointerTo< Connection >(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_PointerTo_Connection(PyObject *args, PointerTo< Connection > *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerTo_Connection, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PointerTo< Connection >::PointerTo(Connection *ptr)
    Connection *arg_this = (Connection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Connection, 0, "PointerTo.PointerTo", false, false);
    if (arg_this != NULL) {
      PointerTo< Connection > *return_value = new PointerTo< Connection >(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_PointerTo_Connection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerTo_Connection) {
    printf("PointerTo_Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerTo< Connection > *local_this = (PointerTo< Connection > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerTo_Connection) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_Connection) {
    return (PointerToBase< Connection > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< Connection > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerTo_Connection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerTo_Connection) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_Connection) {
    PointerToBase< Connection >* other_this = (PointerToBase< Connection >*)from_this;
    return (PointerTo< Connection >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerTo< Connection >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< Connection >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< Connection >::clear(void)
 */
static PyObject *Dtool_PointerToBase_Connection_clear_4(PyObject *self, PyObject *) {
  PointerToBase< Connection > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_Connection, (void **)&local_this, "PointerToBase_Connection.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< Connection >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_Connection_clear_4_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_Connection_clear_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< Connection >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_Connection_output_5(PyObject *self, PyObject *arg) {
  PointerToBase< Connection > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_Connection, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< Connection >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< Connection >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_Connection_output_5_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_Connection_output_5_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_Connection(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_Connection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_Connection) {
    printf("PointerToBase_Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< Connection > *local_this = (PointerToBase< Connection > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_Connection) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_Connection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_Connection) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< Connection >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NetAddress
 */
/**
 * Python function wrapper for:
 * bool NetAddress::set_any(int port)
 */
static PyObject *Dtool_NetAddress_set_any_14(PyObject *self, PyObject *arg) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.set_any")) {
    return NULL;
  }
  // 1-bool NetAddress::set_any(int port)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*local_this).set_any((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_any(const NetAddress self, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_set_any_14_comment =
  "C++ Interface:\n"
  "set_any(const NetAddress self, int port)\n"
  "\n"
  "/**\n"
  " * Sets the address up to refer to a particular port, but not to any\n"
  " * particular IP.  Returns true if successful, false otherwise (currently,\n"
  " * this only returns true).\n"
  " */";
#else
static const char *Dtool_NetAddress_set_any_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool NetAddress::set_localhost(int port)
 */
static PyObject *Dtool_NetAddress_set_localhost_15(PyObject *self, PyObject *arg) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.set_localhost")) {
    return NULL;
  }
  // 1-bool NetAddress::set_localhost(int port)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*local_this).set_localhost((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_localhost(const NetAddress self, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_set_localhost_15_comment =
  "C++ Interface:\n"
  "set_localhost(const NetAddress self, int port)\n"
  "\n"
  "/**\n"
  " * Sets the address up to refer to a particular port, on this host.\n"
  " */";
#else
static const char *Dtool_NetAddress_set_localhost_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool NetAddress::set_broadcast(int port)
 */
static PyObject *Dtool_NetAddress_set_broadcast_16(PyObject *self, PyObject *arg) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.set_broadcast")) {
    return NULL;
  }
  // 1-bool NetAddress::set_broadcast(int port)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*local_this).set_broadcast((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_broadcast(const NetAddress self, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_set_broadcast_16_comment =
  "C++ Interface:\n"
  "set_broadcast(const NetAddress self, int port)\n"
  "\n"
  "/**\n"
  " * Sets the address to the broadcast address.\n"
  " */";
#else
static const char *Dtool_NetAddress_set_broadcast_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool NetAddress::set_host(std::string const &hostname, int port)
 */
static PyObject *Dtool_NetAddress_set_host_17(PyObject *self, PyObject *args, PyObject *kwds) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.set_host")) {
    return NULL;
  }
  // 1-bool NetAddress::set_host(std::string const &hostname, int port)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2;
  static const char *keyword_list[] = {"hostname", "port", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:set_host", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    bool return_value = (*local_this).set_host(std::string(param1_str, param1_len), (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_host(const NetAddress self, str hostname, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_set_host_17_comment =
  "C++ Interface:\n"
  "set_host(const NetAddress self, str hostname, int port)\n"
  "\n"
  "/**\n"
  " * Sets the address up to refer to a particular port on a particular host.\n"
  " * Returns true if the hostname is known, false otherwise.\n"
  " */";
#else
static const char *Dtool_NetAddress_set_host_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NetAddress::clear(void)
 */
static PyObject *Dtool_NetAddress_clear_18(PyObject *self, PyObject *) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.clear")) {
    return NULL;
  }
  // 1-void NetAddress::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_clear_18_comment =
  "C++ Interface:\n"
  "clear(const NetAddress self)\n"
  "\n"
  "/**\n"
  " * Resets the NetAddress to its initial state.\n"
  " */";
#else
static const char *Dtool_NetAddress_clear_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int NetAddress::get_port(void) const
 */
static PyObject *Dtool_NetAddress_get_port_19(PyObject *self, PyObject *) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return NULL;
  }
  // 1-int NetAddress::get_port(void) const
  int return_value = (*(const NetAddress*)local_this).get_port();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_port_19_comment =
  "C++ Interface:\n"
  "get_port(NetAddress self)\n"
  "\n"
  "/**\n"
  " * Returns the port number to which this address refers.\n"
  " */";
#else
static const char *Dtool_NetAddress_get_port_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NetAddress::set_port(int port)
 */
static PyObject *Dtool_NetAddress_set_port_20(PyObject *self, PyObject *arg) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.set_port")) {
    return NULL;
  }
  // 1-void NetAddress::set_port(int port)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_port((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_port(const NetAddress self, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_set_port_20_comment =
  "C++ Interface:\n"
  "set_port(const NetAddress self, int port)\n"
  "\n"
  "/**\n"
  " * Resets the port number without otherwise changing the address.\n"
  " */";
#else
static const char *Dtool_NetAddress_set_port_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string NetAddress::get_ip_string(void) const
 */
static PyObject *Dtool_NetAddress_get_ip_string_21(PyObject *self, PyObject *) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string NetAddress::get_ip_string(void) const
  std::string return_value = (*(const NetAddress*)local_this).get_ip_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_ip_string_21_comment =
  "C++ Interface:\n"
  "get_ip_string(NetAddress self)\n"
  "\n"
  "/**\n"
  " * Returns the IP address to which this address refers, formatted as a string.\n"
  " */";
#else
static const char *Dtool_NetAddress_get_ip_string_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool NetAddress::is_any(void) const
 */
static PyObject *Dtool_NetAddress_is_any_22(PyObject *self, PyObject *) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool NetAddress::is_any(void) const
  bool return_value = (*(const NetAddress*)local_this).is_any();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_is_any_22_comment =
  "C++ Interface:\n"
  "is_any(NetAddress self)\n"
  "\n"
  "/**\n"
  " * Returns true if the IP address has only zeroes.\n"
  " */";
#else
static const char *Dtool_NetAddress_is_any_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * uint32_t NetAddress::get_ip(void) const
 */
static PyObject *Dtool_NetAddress_get_ip_23(PyObject *self, PyObject *) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return NULL;
  }
  // 1-uint32_t NetAddress::get_ip(void) const
  uint32_t return_value = (*(const NetAddress*)local_this).get_ip();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_ip_23_comment =
  "C++ Interface:\n"
  "get_ip(NetAddress self)\n"
  "\n"
  "/**\n"
  " * Returns the IP address to which this address refers, as a 32-bit integer,\n"
  " * in host byte order.\n"
  " * @deprecated  Does not work with IPv6 addresses.\n"
  " */";
#else
static const char *Dtool_NetAddress_get_ip_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * uint8_t NetAddress::get_ip_component(int n) const
 */
static PyObject *Dtool_NetAddress_get_ip_component_24(PyObject *self, PyObject *arg) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return NULL;
  }
  // 1-uint8_t NetAddress::get_ip_component(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    uint8_t return_value = (*(const NetAddress*)local_this).get_ip_component((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ip_component(NetAddress self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_ip_component_24_comment =
  "C++ Interface:\n"
  "get_ip_component(NetAddress self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth 8-bit component of the IP address.  An IP address has four\n"
  " * components; component 0 is the first (leftmost), and component 3 is the\n"
  " * last (rightmost) in the dotted number convention.\n"
  " */";
#else
static const char *Dtool_NetAddress_get_ip_component_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Socket_Address const &NetAddress::get_addr(void) const
 */
static PyObject *Dtool_NetAddress_get_addr_25(PyObject *self, PyObject *) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return NULL;
  }
  // 1-Socket_Address const &NetAddress::get_addr(void) const
  Socket_Address const *return_value = &((*(const NetAddress*)local_this).get_addr());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Socket_Address, false, true);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_addr_25_comment =
  "C++ Interface:\n"
  "get_addr(NetAddress self)\n"
  "\n"
  "/**\n"
  " * Returns the Socket_Address for this address.\n"
  " */";
#else
static const char *Dtool_NetAddress_get_addr_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NetAddress::output(ostream &out) const
 */
static PyObject *Dtool_NetAddress_output_26(PyObject *self, PyObject *arg) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return NULL;
  }
  // 1-void NetAddress::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "NetAddress.output", false, true);
  if (arg_this != NULL) {
    (*(const NetAddress*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(NetAddress self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_output_26_comment =
  "C++ Interface:\n"
  "output(NetAddress self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NetAddress_output_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t NetAddress::get_hash(void) const
 */
static PyObject *Dtool_NetAddress_get_hash_27(PyObject *self, PyObject *) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t NetAddress::get_hash(void) const
  std::size_t return_value = (*(const NetAddress*)local_this).get_hash();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_hash_27_comment =
  "C++ Interface:\n"
  "get_hash(NetAddress self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NetAddress_get_hash_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NetAddress::NetAddress(void)
 * inline NetAddress::NetAddress(NetAddress const &) = default
 * NetAddress::NetAddress(Socket_Address const &addr)
 */
static int Dtool_Init_NetAddress(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-NetAddress::NetAddress(void)
      NetAddress *return_value = new NetAddress();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetAddress, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 NetAddress::NetAddress(Socket_Address const &addr)
        PyObject *param0;
        static const char *keyword_list[] = {"addr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:NetAddress", (char **)keyword_list, &param0)) {
          Socket_Address const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Socket_Address, (void **)&param0_this);
          if (param0_this != NULL) {
            NetAddress *return_value = new NetAddress(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetAddress, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline NetAddress::NetAddress(NetAddress const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:NetAddress", (char **)keyword_list, &param0)) {
          NetAddress const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NetAddress, (void **)&param0_this);
          if (param0_this != NULL) {
            NetAddress *return_value = new NetAddress(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetAddress, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 NetAddress::NetAddress(Socket_Address const &addr)
        PyObject *param0;
        static const char *keyword_list[] = {"addr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:NetAddress", (char **)keyword_list, &param0)) {
          Socket_Address const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_Socket_Address(param0, param0_this, param0_manage)) {
            NetAddress *return_value = new NetAddress(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetAddress, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline NetAddress::NetAddress(NetAddress const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:NetAddress", (char **)keyword_list, &param0)) {
          NetAddress const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_NetAddress(param0, param0_this, param0_manage)) {
            NetAddress *return_value = new NetAddress(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetAddress, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NetAddress() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NetAddress()\n"
      "NetAddress(const Socket_Address addr)\n"
      "NetAddress(const NetAddress param0)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_NetAddress(PyObject *args, NetAddress const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_NetAddress, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NetAddress::NetAddress(Socket_Address const &addr)
    Socket_Address const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Socket_Address, (void **)&arg_this);
    if (arg_this != NULL) {
      NetAddress *return_value = new NetAddress(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_NetAddress(PyObject *args, NetAddress *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_NetAddress, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NetAddress::NetAddress(Socket_Address const &addr)
    Socket_Address const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Socket_Address, (void **)&arg_this);
    if (arg_this != NULL) {
      NetAddress *return_value = new NetAddress(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_NetAddress(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NetAddress) {
    printf("NetAddress ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NetAddress *local_this = (NetAddress *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NetAddress) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NetAddress(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NetAddress) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Connection
 */
/**
 * Python function wrapper for:
 * NetAddress Connection::get_address(void) const
 */
static PyObject *Dtool_Connection_get_address_34(PyObject *self, PyObject *) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Connection, (void **)&local_this)) {
    return NULL;
  }
  // 1-NetAddress Connection::get_address(void) const
  NetAddress *return_value = new NetAddress((*(const Connection*)local_this).get_address());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Connection_get_address_34_comment =
  "C++ Interface:\n"
  "get_address(Connection self)\n"
  "\n"
  "/**\n"
  " * Returns the address bound to this connection, if it is a TCP connection.\n"
  " */";
#else
static const char *Dtool_Connection_get_address_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConnectionManager *Connection::get_manager(void) const
 */
static PyObject *Dtool_Connection_get_manager_35(PyObject *self, PyObject *) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Connection, (void **)&local_this)) {
    return NULL;
  }
  // 1-ConnectionManager *Connection::get_manager(void) const
  ConnectionManager *return_value = (*(const Connection*)local_this).get_manager();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Connection_get_manager_35_comment =
  "C++ Interface:\n"
  "get_manager(Connection self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the ConnectionManager object that serves this\n"
  " * connection.\n"
  " */";
#else
static const char *Dtool_Connection_get_manager_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Socket_IP *Connection::get_socket(void) const
 */
static PyObject *Dtool_Connection_get_socket_36(PyObject *self, PyObject *) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Connection, (void **)&local_this)) {
    return NULL;
  }
  // 1-Socket_IP *Connection::get_socket(void) const
  Socket_IP *return_value = (*(const Connection*)local_this).get_socket();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Socket_IP, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Connection_get_socket_36_comment =
  "C++ Interface:\n"
  "get_socket(Connection self)\n"
  "\n"
  "/**\n"
  " * Returns the internal Socket_IP that defines the connection.\n"
  " */";
#else
static const char *Dtool_Connection_get_socket_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_collect_tcp(bool collect_tcp)
 */
static PyObject *Dtool_Connection_set_collect_tcp_37(PyObject *self, PyObject *arg) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_collect_tcp")) {
    return NULL;
  }
  // 1-void Connection::set_collect_tcp(bool collect_tcp)
  (*local_this).set_collect_tcp((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collect_tcp(const Connection self, bool collect_tcp)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_collect_tcp_37_comment =
  "C++ Interface:\n"
  "set_collect_tcp(const Connection self, bool collect_tcp)\n"
  "\n"
  "/**\n"
  " * Enables or disables \"collect-tcp\" mode.  In this mode, individual TCP\n"
  " * packets are not sent immediately, but rather they are collected together\n"
  " * and accumulated to be sent periodically as one larger TCP packet.  This\n"
  " * cuts down on overhead from the TCP/IP protocol, especially if many small\n"
  " * packets need to be sent on the same connection, but it introduces\n"
  " * additional latency (since packets must be held before they can be sent).\n"
  " *\n"
  " * See set_collect_tcp_interval() to specify the interval of time for which to\n"
  " * hold packets before sending them.\n"
  " *\n"
  " * If you enable this mode, you may also need to periodically call\n"
  " * consider_flush() to flush the queue if no packets have been sent recently.\n"
  " */";
#else
static const char *Dtool_Connection_set_collect_tcp_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Connection::get_collect_tcp(void) const
 */
static PyObject *Dtool_Connection_get_collect_tcp_38(PyObject *self, PyObject *) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Connection, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Connection::get_collect_tcp(void) const
  bool return_value = (*(const Connection*)local_this).get_collect_tcp();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Connection_get_collect_tcp_38_comment =
  "C++ Interface:\n"
  "get_collect_tcp(Connection self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of \"collect-tcp\" mode.  See set_collect_tcp().\n"
  " */";
#else
static const char *Dtool_Connection_get_collect_tcp_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_collect_tcp_interval(double interval)
 */
static PyObject *Dtool_Connection_set_collect_tcp_interval_39(PyObject *self, PyObject *arg) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_collect_tcp_interval")) {
    return NULL;
  }
  // 1-void Connection::set_collect_tcp_interval(double interval)
  if (PyNumber_Check(arg)) {
    (*local_this).set_collect_tcp_interval(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collect_tcp_interval(const Connection self, double interval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_collect_tcp_interval_39_comment =
  "C++ Interface:\n"
  "set_collect_tcp_interval(const Connection self, double interval)\n"
  "\n"
  "/**\n"
  " * Specifies the interval in time, in seconds, for which to hold TCP packets\n"
  " * before sending all of the recently received packets at once.  This only has\n"
  " * meaning if \"collect-tcp\" mode is enabled; see set_collect_tcp().\n"
  " */";
#else
static const char *Dtool_Connection_set_collect_tcp_interval_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double Connection::get_collect_tcp_interval(void) const
 */
static PyObject *Dtool_Connection_get_collect_tcp_interval_40(PyObject *self, PyObject *) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Connection, (void **)&local_this)) {
    return NULL;
  }
  // 1-double Connection::get_collect_tcp_interval(void) const
  double return_value = (*(const Connection*)local_this).get_collect_tcp_interval();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Connection_get_collect_tcp_interval_40_comment =
  "C++ Interface:\n"
  "get_collect_tcp_interval(Connection self)\n"
  "\n"
  "/**\n"
  " * Returns the interval in time, in seconds, for which to hold TCP packets\n"
  " * before sending all of the recently received packets at once.  This only has\n"
  " * meaning if \"collect-tcp\" mode is enabled; see set_collect_tcp().\n"
  " */";
#else
static const char *Dtool_Connection_get_collect_tcp_interval_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Connection::consider_flush(void)
 */
static PyObject *Dtool_Connection_consider_flush_41(PyObject *self, PyObject *) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.consider_flush")) {
    return NULL;
  }
  // 1-bool Connection::consider_flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).consider_flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Connection_consider_flush_41_comment =
  "C++ Interface:\n"
  "consider_flush(const Connection self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued TCP datagram(s) if enough time has elapsed.\n"
  " * This only has meaning if set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_Connection_consider_flush_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Connection::flush(void)
 */
static PyObject *Dtool_Connection_flush_42(PyObject *self, PyObject *) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.flush")) {
    return NULL;
  }
  // 1-bool Connection::flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Connection_flush_42_comment =
  "C++ Interface:\n"
  "flush(const Connection self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued TCP datagram(s) now.  This only has meaning\n"
  " * if set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_Connection_flush_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_linger(bool flag, double time)
 */
static PyObject *Dtool_Connection_set_linger_43(PyObject *self, PyObject *args, PyObject *kwds) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_linger")) {
    return NULL;
  }
  // 1-void Connection::set_linger(bool flag, double time)
  PyObject *param1;
  double param2;
  static const char *keyword_list[] = {"flag", "time", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:set_linger", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_linger((PyObject_IsTrue(param1) != 0), (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_linger(const Connection self, bool flag, double time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_linger_43_comment =
  "C++ Interface:\n"
  "set_linger(const Connection self, bool flag, double time)\n"
  "\n"
  "// Socket options.  void set_nonblock(bool flag);\n"
  "\n"
  "/**\n"
  " * Sets the time to linger on close if data is present.  If flag is false,\n"
  " * when you close a socket with data available the system attempts to deliver\n"
  " * the data to the peer (the default behavior).  If flag is false but time is\n"
  " * zero, the system discards any undelivered data when you close the socket.\n"
  " * If flag is false but time is nonzero, the system waits up to time seconds\n"
  " * to deliver the data.\n"
  " */";
#else
static const char *Dtool_Connection_set_linger_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_reuse_addr(bool flag)
 */
static PyObject *Dtool_Connection_set_reuse_addr_44(PyObject *self, PyObject *arg) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_reuse_addr")) {
    return NULL;
  }
  // 1-void Connection::set_reuse_addr(bool flag)
  (*local_this).set_reuse_addr((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_reuse_addr(const Connection self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_reuse_addr_44_comment =
  "C++ Interface:\n"
  "set_reuse_addr(const Connection self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets whether local address reuse is allowed.\n"
  " */";
#else
static const char *Dtool_Connection_set_reuse_addr_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_keep_alive(bool flag)
 */
static PyObject *Dtool_Connection_set_keep_alive_45(PyObject *self, PyObject *arg) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_keep_alive")) {
    return NULL;
  }
  // 1-void Connection::set_keep_alive(bool flag)
  (*local_this).set_keep_alive((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_keep_alive(const Connection self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_keep_alive_45_comment =
  "C++ Interface:\n"
  "set_keep_alive(const Connection self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets whether the connection is periodically tested to see if it is still\n"
  " * alive.\n"
  " */";
#else
static const char *Dtool_Connection_set_keep_alive_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_recv_buffer_size(int size)
 */
static PyObject *Dtool_Connection_set_recv_buffer_size_46(PyObject *self, PyObject *arg) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_recv_buffer_size")) {
    return NULL;
  }
  // 1-void Connection::set_recv_buffer_size(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_recv_buffer_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_recv_buffer_size(const Connection self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_recv_buffer_size_46_comment =
  "C++ Interface:\n"
  "set_recv_buffer_size(const Connection self, int size)\n"
  "\n"
  "/**\n"
  " * Sets the size of the receive buffer, in bytes.\n"
  " */";
#else
static const char *Dtool_Connection_set_recv_buffer_size_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_send_buffer_size(int size)
 */
static PyObject *Dtool_Connection_set_send_buffer_size_47(PyObject *self, PyObject *arg) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_send_buffer_size")) {
    return NULL;
  }
  // 1-void Connection::set_send_buffer_size(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_send_buffer_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_send_buffer_size(const Connection self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_send_buffer_size_47_comment =
  "C++ Interface:\n"
  "set_send_buffer_size(const Connection self, int size)\n"
  "\n"
  "/**\n"
  " * Sets the size of the send buffer, in bytes.\n"
  " */";
#else
static const char *Dtool_Connection_set_send_buffer_size_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_ip_time_to_live(int ttl)
 */
static PyObject *Dtool_Connection_set_ip_time_to_live_48(PyObject *self, PyObject *arg) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_ip_time_to_live")) {
    return NULL;
  }
  // 1-void Connection::set_ip_time_to_live(int ttl)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_ip_time_to_live((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ip_time_to_live(const Connection self, int ttl)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_ip_time_to_live_48_comment =
  "C++ Interface:\n"
  "set_ip_time_to_live(const Connection self, int ttl)\n"
  "\n"
  "/**\n"
  " * Sets IP time-to-live.\n"
  " */";
#else
static const char *Dtool_Connection_set_ip_time_to_live_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_ip_type_of_service(int tos)
 */
static PyObject *Dtool_Connection_set_ip_type_of_service_49(PyObject *self, PyObject *arg) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_ip_type_of_service")) {
    return NULL;
  }
  // 1-void Connection::set_ip_type_of_service(int tos)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_ip_type_of_service((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ip_type_of_service(const Connection self, int tos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_ip_type_of_service_49_comment =
  "C++ Interface:\n"
  "set_ip_type_of_service(const Connection self, int tos)\n"
  "\n"
  "/**\n"
  " * Sets IP type-of-service and precedence.\n"
  " */";
#else
static const char *Dtool_Connection_set_ip_type_of_service_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_no_delay(bool flag)
 */
static PyObject *Dtool_Connection_set_no_delay_50(PyObject *self, PyObject *arg) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_no_delay")) {
    return NULL;
  }
  // 1-void Connection::set_no_delay(bool flag)
  (*local_this).set_no_delay((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_no_delay(const Connection self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_no_delay_50_comment =
  "C++ Interface:\n"
  "set_no_delay(const Connection self, bool flag)\n"
  "\n"
  "/**\n"
  " * If flag is true, this disables the Nagle algorithm, and prevents delaying\n"
  " * of send to coalesce packets.\n"
  " */";
#else
static const char *Dtool_Connection_set_no_delay_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_max_segment(int size)
 */
static PyObject *Dtool_Connection_set_max_segment_51(PyObject *self, PyObject *arg) {
  Connection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_max_segment")) {
    return NULL;
  }
  // 1-void Connection::set_max_segment(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_max_segment((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_segment(const Connection self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_max_segment_51_comment =
  "C++ Interface:\n"
  "set_max_segment(const Connection self, int size)\n"
  "\n"
  "/**\n"
  " * Sets the maximum segment size.\n"
  " */";
#else
static const char *Dtool_Connection_set_max_segment_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Connection::Connection(ConnectionManager *manager, Socket_IP *socket)
 */
static int Dtool_Init_Connection(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-Connection::Connection(ConnectionManager *manager, Socket_IP *socket)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"manager", "socket", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:Connection", (char **)keyword_list, &param0, &param1)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "Connection.Connection", false, true);
    Socket_IP *param1_this;
    bool param1_manage = false;
    if (!Dtool_Coerce_Socket_IP(param1, param1_this, param1_manage)) {
      Dtool_Raise_ArgTypeError(param1, 1, "Connection.Connection", "Socket_IP");
      return -1;
    }
    if (param0_this != NULL) {
      Connection *return_value = new Connection(param0_this, param1_this);
      if (param1_manage) {
        delete param1_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Connection, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Connection(ConnectionManager manager, Socket_IP socket)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Connection(PyObject *args, CPT(Connection) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Connection, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-Connection::Connection(ConnectionManager *manager, Socket_IP *socket)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "Connection", 2, 2, &param0, &param1)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "Connection.Connection", false, false);
        Socket_IP *param1_this = (Socket_IP *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Socket_IP, 1, "Connection.Connection", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          Connection *return_value = new Connection(param0_this, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_Connection(PyObject *args, PT(Connection) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Connection, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-Connection::Connection(ConnectionManager *manager, Socket_IP *socket)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "Connection", 2, 2, &param0, &param1)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "Connection.Connection", false, false);
        Socket_IP *param1_this = (Socket_IP *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Socket_IP, 1, "Connection.Connection", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          Connection *return_value = new Connection(param0_this, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_Connection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Connection) {
    printf("Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Connection *local_this = (Connection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Connection) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Connection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Connection) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Connection*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConnectionReader
 */
/**
 * Python function wrapper for:
 * bool ConnectionReader::add_connection(Connection *connection)
 */
static PyObject *Dtool_ConnectionReader_add_connection_54(PyObject *self, PyObject *arg) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.add_connection")) {
    return NULL;
  }
  // 1-bool ConnectionReader::add_connection(Connection *connection)
  PT(Connection) arg_this;
  if (!Dtool_Coerce_Connection(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConnectionReader.add_connection", "Connection");
  }
  bool return_value = (*local_this).add_connection(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_connection(const ConnectionReader self, Connection connection)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_add_connection_54_comment =
  "C++ Interface:\n"
  "add_connection(const ConnectionReader self, Connection connection)\n"
  "\n"
  "/**\n"
  " * Adds a new socket to the list of sockets the ConnectionReader will monitor.\n"
  " * A datagram that comes in on any of the monitored sockets will be reported.\n"
  " * In the case of a ConnectionListener, this adds a new rendezvous socket; any\n"
  " * activity on any of the monitored sockets will cause a connection to be\n"
  " * accepted.\n"
  " *\n"
  " * The return value is true if the connection was added, false if it was\n"
  " * already there.\n"
  " *\n"
  " * add_connection() is thread-safe, and may be called at will by any thread.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_add_connection_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionReader::remove_connection(Connection *connection)
 */
static PyObject *Dtool_ConnectionReader_remove_connection_55(PyObject *self, PyObject *arg) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.remove_connection")) {
    return NULL;
  }
  // 1-bool ConnectionReader::remove_connection(Connection *connection)
  PT(Connection) arg_this;
  if (!Dtool_Coerce_Connection(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConnectionReader.remove_connection", "Connection");
  }
  bool return_value = (*local_this).remove_connection(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_connection(const ConnectionReader self, Connection connection)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_remove_connection_55_comment =
  "C++ Interface:\n"
  "remove_connection(const ConnectionReader self, Connection connection)\n"
  "\n"
  "/**\n"
  " * Removes a socket from the list of sockets being monitored.  Returns true if\n"
  " * the socket was correctly removed, false if it was not on the list in the\n"
  " * first place.\n"
  " *\n"
  " * remove_connection() is thread-safe, and may be called at will by any\n"
  " * thread.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_remove_connection_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionReader::is_connection_ok(Connection *connection)
 */
static PyObject *Dtool_ConnectionReader_is_connection_ok_56(PyObject *self, PyObject *arg) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.is_connection_ok")) {
    return NULL;
  }
  // 1-bool ConnectionReader::is_connection_ok(Connection *connection)
  PT(Connection) arg_this;
  if (!Dtool_Coerce_Connection(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConnectionReader.is_connection_ok", "Connection");
  }
  bool return_value = (*local_this).is_connection_ok(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_connection_ok(const ConnectionReader self, Connection connection)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_is_connection_ok_56_comment =
  "C++ Interface:\n"
  "is_connection_ok(const ConnectionReader self, Connection connection)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated connection has been added to the\n"
  " * ConnectionReader and is being monitored properly, false if it is not known,\n"
  " * or if there was some error condition detected on the connection.  (If there\n"
  " * was an error condition, normally the ConnectionManager would have been\n"
  " * informed and closed the connection.)\n"
  " */";
#else
static const char *Dtool_ConnectionReader_is_connection_ok_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConnectionReader::poll(void)
 */
static PyObject *Dtool_ConnectionReader_poll_57(PyObject *self, PyObject *) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.poll")) {
    return NULL;
  }
  // 1-void ConnectionReader::poll(void)
  (*local_this).poll();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_poll_57_comment =
  "C++ Interface:\n"
  "poll(const ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Explicitly polls the available sockets to see if any of them have any\n"
  " * noise.  This function does nothing unless this is a polling-type\n"
  " * ConnectionReader, i.e.  it was created with zero threads (and is_polling()\n"
  " * will return true).\n"
  " *\n"
  " * It is not necessary to call this explicitly for a QueuedConnectionReader.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_poll_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConnectionManager *ConnectionReader::get_manager(void) const
 */
static PyObject *Dtool_ConnectionReader_get_manager_58(PyObject *self, PyObject *) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-ConnectionManager *ConnectionReader::get_manager(void) const
  ConnectionManager *return_value = (*(const ConnectionReader*)local_this).get_manager();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_get_manager_58_comment =
  "C++ Interface:\n"
  "get_manager(ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the ConnectionManager object that serves this\n"
  " * ConnectionReader.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_get_manager_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConnectionReader::is_polling(void) const
 */
static PyObject *Dtool_ConnectionReader_is_polling_59(PyObject *self, PyObject *) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConnectionReader::is_polling(void) const
  bool return_value = (*(const ConnectionReader*)local_this).is_polling();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_is_polling_59_comment =
  "C++ Interface:\n"
  "is_polling(ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if the reader is a polling reader, i.e.  it has no threads.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_is_polling_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ConnectionReader::get_num_threads(void) const
 */
static PyObject *Dtool_ConnectionReader_get_num_threads_60(PyObject *self, PyObject *) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-int ConnectionReader::get_num_threads(void) const
  int return_value = (*(const ConnectionReader*)local_this).get_num_threads();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_get_num_threads_60_comment =
  "C++ Interface:\n"
  "get_num_threads(ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns the number of threads the ConnectionReader has been created with.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_get_num_threads_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConnectionReader::set_raw_mode(bool mode)
 */
static PyObject *Dtool_ConnectionReader_set_raw_mode_61(PyObject *self, PyObject *arg) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.set_raw_mode")) {
    return NULL;
  }
  // 1-void ConnectionReader::set_raw_mode(bool mode)
  (*local_this).set_raw_mode((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_raw_mode(const ConnectionReader self, bool mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_set_raw_mode_61_comment =
  "C++ Interface:\n"
  "set_raw_mode(const ConnectionReader self, bool mode)\n"
  "\n"
  "/**\n"
  " * Sets the ConnectionReader into raw mode (or turns off raw mode).  In raw\n"
  " * mode, datagram headers are not expected; instead, all the data available on\n"
  " * the pipe is treated as a single datagram.\n"
  " *\n"
  " * This is similar to set_tcp_header_size(0), except that it also turns off\n"
  " * headers for UDP packets.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_set_raw_mode_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionReader::get_raw_mode(void) const
 */
static PyObject *Dtool_ConnectionReader_get_raw_mode_62(PyObject *self, PyObject *) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ConnectionReader::get_raw_mode(void) const
  bool return_value = (*(const ConnectionReader*)local_this).get_raw_mode();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_get_raw_mode_62_comment =
  "C++ Interface:\n"
  "get_raw_mode(ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the raw mode flag.  See set_raw_mode().\n"
  " */";
#else
static const char *Dtool_ConnectionReader_get_raw_mode_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConnectionReader::set_tcp_header_size(int tcp_header_size)
 */
static PyObject *Dtool_ConnectionReader_set_tcp_header_size_63(PyObject *self, PyObject *arg) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.set_tcp_header_size")) {
    return NULL;
  }
  // 1-void ConnectionReader::set_tcp_header_size(int tcp_header_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_tcp_header_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tcp_header_size(const ConnectionReader self, int tcp_header_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_set_tcp_header_size_63_comment =
  "C++ Interface:\n"
  "set_tcp_header_size(const ConnectionReader self, int tcp_header_size)\n"
  "\n"
  "/**\n"
  " * Sets the header size of TCP packets.  At the present, legal values for this\n"
  " * are 0, 2, or 4; this specifies the number of bytes to use encode the\n"
  " * datagram length at the start of each TCP datagram.  Sender and receiver\n"
  " * must independently agree on this.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_set_tcp_header_size_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ConnectionReader::get_tcp_header_size(void) const
 */
static PyObject *Dtool_ConnectionReader_get_tcp_header_size_64(PyObject *self, PyObject *) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-int ConnectionReader::get_tcp_header_size(void) const
  int return_value = (*(const ConnectionReader*)local_this).get_tcp_header_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_get_tcp_header_size_64_comment =
  "C++ Interface:\n"
  "get_tcp_header_size(ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of TCP header size.  See set_tcp_header_size().\n"
  " */";
#else
static const char *Dtool_ConnectionReader_get_tcp_header_size_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConnectionReader::shutdown(void)
 */
static PyObject *Dtool_ConnectionReader_shutdown_65(PyObject *self, PyObject *) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.shutdown")) {
    return NULL;
  }
  // 1-void ConnectionReader::shutdown(void)
  (*local_this).shutdown();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_shutdown_65_comment =
  "C++ Interface:\n"
  "shutdown(const ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Terminates all threads cleanly.  Normally this is only called by the\n"
  " * destructor, but it may be called explicitly before destruction.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_shutdown_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DatagramGeneratorNet *ConnectionReader::downcast_to_DatagramGeneratorNet(void)
 */
static PyObject *Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_131(PyObject *self, PyObject *) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.downcast_to_DatagramGeneratorNet")) {
    return NULL;
  }
  // 1-DatagramGeneratorNet *ConnectionReader::downcast_to_DatagramGeneratorNet(void)
  DatagramGeneratorNet *return_value = (DatagramGeneratorNet *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramGeneratorNet, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_131_comment =
  "C++ Interface:\n"
  "downcast_to_DatagramGeneratorNet(const ConnectionReader self)\n"
  "\n"
  "downcast from ConnectionReader to DatagramGeneratorNet";
#else
static const char *Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedConnectionReader *ConnectionReader::downcast_to_QueuedConnectionReader(void)
 */
static PyObject *Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_190(PyObject *self, PyObject *) {
  ConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.downcast_to_QueuedConnectionReader")) {
    return NULL;
  }
  // 1-QueuedConnectionReader *ConnectionReader::downcast_to_QueuedConnectionReader(void)
  QueuedConnectionReader *return_value = (QueuedConnectionReader *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedConnectionReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_190_comment =
  "C++ Interface:\n"
  "downcast_to_QueuedConnectionReader(const ConnectionReader self)\n"
  "\n"
  "downcast from ConnectionReader to QueuedConnectionReader";
#else
static const char *Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_190_comment = NULL;
#endif

static int Dtool_Init_ConnectionReader(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ConnectionReader(PyObject *args, ConnectionReader const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConnectionReader, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  return false;
}

bool Dtool_Coerce_ConnectionReader(PyObject *args, ConnectionReader *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConnectionReader, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ConnectionReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConnectionReader) {
    printf("ConnectionReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConnectionReader *local_this = (ConnectionReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConnectionReader) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConnectionReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConnectionListener
 */
/**
 * Python function wrapper for:
 * QueuedConnectionListener *ConnectionListener::downcast_to_QueuedConnectionListener(void)
 */
static PyObject *Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_160(PyObject *self, PyObject *) {
  ConnectionListener *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionListener, (void **)&local_this, "ConnectionListener.downcast_to_QueuedConnectionListener")) {
    return NULL;
  }
  // 1-QueuedConnectionListener *ConnectionListener::downcast_to_QueuedConnectionListener(void)
  QueuedConnectionListener *return_value = (QueuedConnectionListener *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedConnectionListener, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_160_comment =
  "C++ Interface:\n"
  "downcast_to_QueuedConnectionListener(const ConnectionListener self)\n"
  "\n"
  "downcast from ConnectionListener to QueuedConnectionListener";
#else
static const char *Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_160_comment = NULL;
#endif

static int Dtool_Init_ConnectionListener(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ConnectionListener(PyObject *args, ConnectionListener const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConnectionListener, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  return false;
}

bool Dtool_Coerce_ConnectionListener(PyObject *args, ConnectionListener *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConnectionListener, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ConnectionListener(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConnectionListener) {
    printf("ConnectionListener ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConnectionListener *local_this = (ConnectionListener *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConnectionListener) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionReader) {
    return (ConnectionReader *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConnectionListener(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConnectionListener) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    ConnectionReader* other_this = (ConnectionReader*)from_this;
    return (ConnectionListener*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NetDatagram
 */
/**
 * Python function wrapper for:
 * void NetDatagram::operator =(Datagram const &copy)
 * void NetDatagram::operator =(NetDatagram const &copy)
 */
static PyObject *Dtool_NetDatagram_operator_71(PyObject *self, PyObject *arg) {
  NetDatagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetDatagram, (void **)&local_this, "NetDatagram.assign")) {
    return NULL;
  }
  {
    // -2 void NetDatagram::operator =(NetDatagram const &copy)
    NetDatagram const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NetDatagram, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      NetDatagram *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_NetDatagram, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 void NetDatagram::operator =(Datagram const &copy)
    Datagram const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Datagram, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      NetDatagram *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_NetDatagram, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 void NetDatagram::operator =(NetDatagram const &copy)
    NetDatagram const *arg_this;
    bool arg_manage = false;
    if (Dtool_ConstCoerce_NetDatagram(arg, arg_this, arg_manage)) {
      (*local_this).operator =(*arg_this);
      NetDatagram *return_value = local_this;
      if (arg_manage) {
        delete arg_this;
      }
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_NetDatagram, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 void NetDatagram::operator =(Datagram const &copy)
    Datagram const *arg_this;
    bool arg_manage = false;
    if (Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
      (*local_this).operator =(*arg_this);
      NetDatagram *return_value = local_this;
      if (arg_manage) {
        delete arg_this;
      }
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_NetDatagram, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const NetDatagram self, const NetDatagram copy)\n"
      "assign(const NetDatagram self, const Datagram copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_operator_71_comment =
  "C++ Interface:\n"
  "assign(const NetDatagram self, const NetDatagram copy)\n"
  "assign(const NetDatagram self, const Datagram copy)\n";
#else
static const char *Dtool_NetDatagram_operator_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NetDatagram::set_connection(PointerTo< Connection > const &connection)
 */
static PyObject *Dtool_NetDatagram_set_connection_72(PyObject *self, PyObject *arg) {
  NetDatagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetDatagram, (void **)&local_this, "NetDatagram.set_connection")) {
    return NULL;
  }
  // 1-void NetDatagram::set_connection(PointerTo< Connection > const &connection)
  PT(Connection) arg_this;
  if (!Dtool_Coerce_Connection(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NetDatagram.set_connection", "Connection");
  }
  (*local_this).set_connection(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_connection(const NetDatagram self, const Connection connection)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_set_connection_72_comment =
  "C++ Interface:\n"
  "set_connection(const NetDatagram self, const Connection connection)\n"
  "\n"
  "/**\n"
  " * Specifies the socket to which the datagram should be written.\n"
  " */";
#else
static const char *Dtool_NetDatagram_set_connection_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< Connection > NetDatagram::get_connection(void) const
 */
static PyObject *Dtool_NetDatagram_get_connection_73(PyObject *self, PyObject *) {
  NetDatagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetDatagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-PointerTo< Connection > NetDatagram::get_connection(void) const
  PointerTo< Connection > return_value = (*(const NetDatagram*)local_this).get_connection();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  Connection *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_get_connection_73_comment =
  "C++ Interface:\n"
  "get_connection(NetDatagram self)\n"
  "\n"
  "/**\n"
  " * Retrieves the socket from which the datagram was read, or to which it is\n"
  " * scheduled to be written.\n"
  " */";
#else
static const char *Dtool_NetDatagram_get_connection_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NetDatagram::set_address(NetAddress const &address)
 */
static PyObject *Dtool_NetDatagram_set_address_74(PyObject *self, PyObject *arg) {
  NetDatagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetDatagram, (void **)&local_this, "NetDatagram.set_address")) {
    return NULL;
  }
  // 1-void NetDatagram::set_address(NetAddress const &address)
  NetAddress const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_NetAddress(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NetDatagram.set_address", "NetAddress");
  }
  (*local_this).set_address(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_address(const NetDatagram self, const NetAddress address)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_set_address_74_comment =
  "C++ Interface:\n"
  "set_address(const NetDatagram self, const NetAddress address)\n"
  "\n"
  "/**\n"
  " * Specifies the host to which the datagram should be sent.\n"
  " */";
#else
static const char *Dtool_NetDatagram_set_address_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NetAddress const &NetDatagram::get_address(void) const
 */
static PyObject *Dtool_NetDatagram_get_address_75(PyObject *self, PyObject *) {
  NetDatagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetDatagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-NetAddress const &NetDatagram::get_address(void) const
  NetAddress const *return_value = &((*(const NetDatagram*)local_this).get_address());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, false, true);
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_get_address_75_comment =
  "C++ Interface:\n"
  "get_address(NetDatagram self)\n"
  "\n"
  "/**\n"
  " * Retrieves the host from which the datagram was read, or to which it is\n"
  " * scheduled to be sent.\n"
  " */";
#else
static const char *Dtool_NetDatagram_get_address_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NetDatagram::get_class_type(void)
 */
static PyObject *Dtool_NetDatagram_get_class_type_76(PyObject *, PyObject *) {
  // 1-static TypeHandle NetDatagram::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(NetDatagram::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_get_class_type_76_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NetDatagram_get_class_type_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NetDatagram::NetDatagram(void)
 * NetDatagram::NetDatagram(Datagram const &copy)
 * NetDatagram::NetDatagram(NetDatagram const &copy)
 */
static int Dtool_Init_NetDatagram(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-NetDatagram::NetDatagram(void)
      NetDatagram *return_value = new NetDatagram();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetDatagram, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      {
        // -2 NetDatagram::NetDatagram(NetDatagram const &copy)
        NetDatagram const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NetDatagram, (void **)&arg_this);
        if (arg_this != NULL) {
          NetDatagram *return_value = new NetDatagram(*arg_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetDatagram, true, false);
        }
      }

      {
        // -2 NetDatagram::NetDatagram(Datagram const &copy)
        Datagram const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Datagram, (void **)&arg_this);
        if (arg_this != NULL) {
          NetDatagram *return_value = new NetDatagram(*arg_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetDatagram, true, false);
        }
      }

      {
        // -2 NetDatagram::NetDatagram(NetDatagram const &copy)
        NetDatagram const *arg_this;
        bool arg_manage = false;
        if (Dtool_ConstCoerce_NetDatagram(arg, arg_this, arg_manage)) {
          NetDatagram *return_value = new NetDatagram(*arg_this);
          if (arg_manage) {
            delete arg_this;
          }
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetDatagram, true, false);
        }
      }

      {
        // -2 NetDatagram::NetDatagram(Datagram const &copy)
        Datagram const *arg_this;
        bool arg_manage = false;
        if (Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
          NetDatagram *return_value = new NetDatagram(*arg_this);
          if (arg_manage) {
            delete arg_this;
          }
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetDatagram, true, false);
        }
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NetDatagram() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NetDatagram()\n"
      "NetDatagram(const NetDatagram copy)\n"
      "NetDatagram(const Datagram copy)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_NetDatagram(PyObject *args, NetDatagram const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_NetDatagram, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NetDatagram::NetDatagram(Datagram const &copy)
    Datagram const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Datagram, (void **)&arg_this);
    if (arg_this != NULL) {
      NetDatagram *return_value = new NetDatagram(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_NetDatagram(PyObject *args, NetDatagram *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_NetDatagram, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NetDatagram::NetDatagram(Datagram const &copy)
    Datagram const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Datagram, (void **)&arg_this);
    if (arg_this != NULL) {
      NetDatagram *return_value = new NetDatagram(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_NetDatagram(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NetDatagram) {
    printf("NetDatagram ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NetDatagram *local_this = (NetDatagram *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NetDatagram) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Datagram) {
    return (Datagram *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Datagram *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NetDatagram(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NetDatagram) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Datagram) {
    Datagram* other_this = (Datagram*)from_this;
    return (NetDatagram*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NetDatagram*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConnectionManager
 */
/**
 * Python function wrapper for:
 * PointerTo< Connection > ConnectionManager::open_UDP_connection(std::string const &hostname, uint16_t port, bool for_broadcast = false)
 * PointerTo< Connection > ConnectionManager::open_UDP_connection(uint16_t port = 0)
 */
static PyObject *Dtool_ConnectionManager_open_UDP_connection_81(PyObject *self, PyObject *args, PyObject *kwds) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.open_UDP_connection")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PointerTo< Connection > ConnectionManager::open_UDP_connection(uint16_t port)
      PointerTo< Connection > return_value = (*local_this).open_UDP_connection();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      Connection *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "port");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'port' (pos 1) not found");
      }
      // 1-PointerTo< Connection > ConnectionManager::open_UDP_connection(uint16_t port)
      if (PyLongOrInt_Check(arg)) {
        long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param1);
        }
#endif
        PointerTo< Connection > return_value = (*local_this).open_UDP_connection((uint16_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        Connection *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
      }
    }
    break;
  case 2:
  case 3:
    {
      // 1-PointerTo< Connection > ConnectionManager::open_UDP_connection(std::string const &hostname, uint16_t port, bool for_broadcast = false)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      long param2;
      PyObject *param3 = Py_False;
      static const char *keyword_list[] = {"hostname", "port", "for_broadcast", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#l|O:open_UDP_connection", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param2);
        }
#endif
        PointerTo< Connection > return_value = (*local_this).open_UDP_connection(std::string(param1_str, param1_len), (uint16_t)param2, (PyObject_IsTrue(param3) != 0));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        Connection *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "open_UDP_connection() takes 1, 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_UDP_connection(const ConnectionManager self)\n"
      "open_UDP_connection(const ConnectionManager self, int port)\n"
      "open_UDP_connection(const ConnectionManager self, str hostname, int port, bool for_broadcast)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_open_UDP_connection_81_comment =
  "C++ Interface:\n"
  "open_UDP_connection(const ConnectionManager self)\n"
  "open_UDP_connection(const ConnectionManager self, int port)\n"
  "open_UDP_connection(const ConnectionManager self, str hostname, int port, bool for_broadcast)\n"
  "\n"
  "/**\n"
  " * Opens a socket for sending and/or receiving UDP packets.  If the port\n"
  " * number is greater than zero, the UDP connection will be opened for\n"
  " * listening on the indicated port; otherwise, it will be useful only for\n"
  " * sending.\n"
  " *\n"
  " * Use a ConnectionReader and ConnectionWriter to handle the actual\n"
  " * communication.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens a socket for sending and/or receiving UDP packets.  If the port\n"
  " * number is greater than zero, the UDP connection will be opened for\n"
  " * listening on the indicated port; otherwise, it will be useful only for\n"
  " * sending.\n"
  " *\n"
  " * This variant accepts both a hostname and port to listen on a particular\n"
  " * interface; if the hostname is empty, all interfaces will be available,\n"
  " * both IPv4 and IPv6.\n"
  " *\n"
  " * If for_broadcast is true, this UDP connection will be configured to send\n"
  " * and/or receive messages on the broadcast address (255.255.255.255);\n"
  " * otherwise, these messages may be automatically filtered by the OS.\n"
  " *\n"
  " * Use a ConnectionReader and ConnectionWriter to handle the actual\n"
  " * communication.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_open_UDP_connection_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(NetAddress const &address, int backlog)
 * PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(std::string const &hostname, uint16_t port, int backlog)
 * PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(uint16_t port, int backlog)
 */
static PyObject *Dtool_ConnectionManager_open_TCP_server_rendezvous_82(PyObject *self, PyObject *args, PyObject *kwds) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.open_TCP_server_rendezvous")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(NetAddress const &address, int backlog)
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"address", "backlog", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:open_TCP_server_rendezvous", (char **)keyword_list, &param1, &param2)) {
          NetAddress const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_NetAddress, (void **)&param1_this);
          if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            PointerTo< Connection > return_value = (*local_this).open_TCP_server_rendezvous(*param1_this, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (Dtool_CheckErrorOccurred()) {
              return NULL;
            }
            // Transfer ownership of return_value.
            Connection *return_ptr = return_value.p();
            return_value.cheat() = NULL;
            return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(uint16_t port, int backlog)
        long param1;
        int param2;
        static const char *keyword_list[] = {"port", "backlog", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "li:open_TCP_server_rendezvous", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for unsigned short integer",
                                param1);
          }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          PointerTo< Connection > return_value = (*local_this).open_TCP_server_rendezvous((uint16_t)param1, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          // Transfer ownership of return_value.
          Connection *return_ptr = return_value.p();
          return_value.cheat() = NULL;
          return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(NetAddress const &address, int backlog)
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"address", "backlog", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:open_TCP_server_rendezvous", (char **)keyword_list, &param1, &param2)) {
          NetAddress const *param1_this;
          bool param1_manage = false;
          if (Dtool_ConstCoerce_NetAddress(param1, param1_this, param1_manage)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            PointerTo< Connection > return_value = (*local_this).open_TCP_server_rendezvous(*param1_this, (int)param2);
            if (param1_manage) {
              delete param1_this;
            }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (Dtool_CheckErrorOccurred()) {
              return NULL;
            }
            // Transfer ownership of return_value.
            Connection *return_ptr = return_value.p();
            return_value.cheat() = NULL;
            return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(uint16_t port, int backlog)
    }
    break;
  case 3:
    {
      // 1-PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(std::string const &hostname, uint16_t port, int backlog)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      long param2;
      int param3;
      static const char *keyword_list[] = {"hostname", "port", "backlog", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#li:open_TCP_server_rendezvous", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param2);
        }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< Connection > return_value = (*local_this).open_TCP_server_rendezvous(std::string(param1_str, param1_len), (uint16_t)param2, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        Connection *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "open_TCP_server_rendezvous() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_TCP_server_rendezvous(const ConnectionManager self, const NetAddress address, int backlog)\n"
      "open_TCP_server_rendezvous(const ConnectionManager self, int port, int backlog)\n"
      "open_TCP_server_rendezvous(const ConnectionManager self, str hostname, int port, int backlog)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_open_TCP_server_rendezvous_82_comment =
  "C++ Interface:\n"
  "open_TCP_server_rendezvous(const ConnectionManager self, const NetAddress address, int backlog)\n"
  "open_TCP_server_rendezvous(const ConnectionManager self, int port, int backlog)\n"
  "open_TCP_server_rendezvous(const ConnectionManager self, str hostname, int port, int backlog)\n"
  "\n"
  "/**\n"
  " * Creates a socket to be used as a rendezvous socket for a server to listen\n"
  " * for TCP connections.  The socket returned by this call should only be added\n"
  " * to a ConnectionListener (not to a generic ConnectionReader).\n"
  " *\n"
  " * This variant of this method accepts a single port, and will listen to that\n"
  " * port on all available interfaces, both IPv4 and IPv6.\n"
  " *\n"
  " * backlog is the maximum length of the queue of pending connections.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Creates a socket to be used as a rendezvous socket for a server to listen\n"
  " * for TCP connections.  The socket returned by this call should only be added\n"
  " * to a ConnectionListener (not to a generic ConnectionReader).\n"
  " *\n"
  " * This variant of this method accepts a \"hostname\", which is usually just an\n"
  " * IP address in dotted notation, and a port number.  It will listen on the\n"
  " * interface indicated by the IP address.  If the IP address is empty string,\n"
  " * it will listen on all interfaces.\n"
  " *\n"
  " * backlog is the maximum length of the queue of pending connections.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Creates a socket to be used as a rendezvous socket for a server to listen\n"
  " * for TCP connections.  The socket returned by this call should only be added\n"
  " * to a ConnectionListener (not to a generic ConnectionReader).\n"
  " *\n"
  " * This variant of this method accepts a NetAddress, which allows you to\n"
  " * specify a specific interface to listen to.\n"
  " *\n"
  " * backlog is the maximum length of the queue of pending connections.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_open_TCP_server_rendezvous_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< Connection > ConnectionManager::open_TCP_client_connection(NetAddress const &address, int timeout_ms)
 * PointerTo< Connection > ConnectionManager::open_TCP_client_connection(std::string const &hostname, uint16_t port, int timeout_ms)
 */
static PyObject *Dtool_ConnectionManager_open_TCP_client_connection_83(PyObject *self, PyObject *args, PyObject *kwds) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.open_TCP_client_connection")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-PointerTo< Connection > ConnectionManager::open_TCP_client_connection(NetAddress const &address, int timeout_ms)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"address", "timeout_ms", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:open_TCP_client_connection", (char **)keyword_list, &param1, &param2)) {
        NetAddress const *param1_this;
        bool param1_manage = false;
        if (!Dtool_ConstCoerce_NetAddress(param1, param1_this, param1_manage)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ConnectionManager.open_TCP_client_connection", "NetAddress");
        }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< Connection > return_value = (*local_this).open_TCP_client_connection(*param1_this, (int)param2);
        if (param1_manage) {
          delete param1_this;
        }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        Connection *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-PointerTo< Connection > ConnectionManager::open_TCP_client_connection(std::string const &hostname, uint16_t port, int timeout_ms)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      long param2;
      int param3;
      static const char *keyword_list[] = {"hostname", "port", "timeout_ms", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#li:open_TCP_client_connection", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param2);
        }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< Connection > return_value = (*local_this).open_TCP_client_connection(std::string(param1_str, param1_len), (uint16_t)param2, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        Connection *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "open_TCP_client_connection() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_TCP_client_connection(const ConnectionManager self, const NetAddress address, int timeout_ms)\n"
      "open_TCP_client_connection(const ConnectionManager self, str hostname, int port, int timeout_ms)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_open_TCP_client_connection_83_comment =
  "C++ Interface:\n"
  "open_TCP_client_connection(const ConnectionManager self, const NetAddress address, int timeout_ms)\n"
  "open_TCP_client_connection(const ConnectionManager self, str hostname, int port, int timeout_ms)\n"
  "\n"
  "/**\n"
  " * Attempts to establish a TCP client connection to a server at the indicated\n"
  " * address.  If the connection is not established within timeout_ms\n"
  " * milliseconds, a null connection is returned.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This is a shorthand version of the function to directly establish\n"
  " * communications to a named host and port.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_open_TCP_client_connection_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::close_connection(PointerTo< Connection > const &connection)
 */
static PyObject *Dtool_ConnectionManager_close_connection_84(PyObject *self, PyObject *arg) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.close_connection")) {
    return NULL;
  }
  // 1-bool ConnectionManager::close_connection(PointerTo< Connection > const &connection)
  PT(Connection) arg_this;
  if (!Dtool_Coerce_Connection(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConnectionManager.close_connection", "Connection");
  }
  bool return_value = (*local_this).close_connection(MOVE(arg_this));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_connection(const ConnectionManager self, const Connection connection)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_close_connection_84_comment =
  "C++ Interface:\n"
  "close_connection(const ConnectionManager self, const Connection connection)\n"
  "\n"
  "/**\n"
  " * Terminates a UDP or TCP socket previously opened.  This also removes it\n"
  " * from any associated ConnectionReader or ConnectionListeners.\n"
  " *\n"
  " * The socket itself may not be immediately closed--it will not be closed\n"
  " * until all outstanding pointers to it are cleared, including any pointers\n"
  " * remaining in NetDatagrams recently received from the socket.\n"
  " *\n"
  " * The return value is true if the connection was marked to be closed, or\n"
  " * false if close_connection() had already been called (or the connection did\n"
  " * not belong to this ConnectionManager).  In neither case can you infer\n"
  " * anything about whether the connection has *actually* been closed yet based\n"
  " * on the return value.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_close_connection_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::wait_for_readers(double timeout)
 */
static PyObject *Dtool_ConnectionManager_wait_for_readers_85(PyObject *self, PyObject *arg) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.wait_for_readers")) {
    return NULL;
  }
  // 1-bool ConnectionManager::wait_for_readers(double timeout)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).wait_for_readers(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wait_for_readers(const ConnectionManager self, double timeout)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_wait_for_readers_85_comment =
  "C++ Interface:\n"
  "wait_for_readers(const ConnectionManager self, double timeout)\n"
  "\n"
  "/**\n"
  " * Blocks the process for timeout number of seconds, or until any data is\n"
  " * available on any of the non-threaded ConnectionReaders or\n"
  " * ConnectionListeners, whichever comes first.  The return value is true if\n"
  " * there is data available (but you have to iterate through all readers to\n"
  " * find it), or false if the timeout occurred without any data.\n"
  " *\n"
  " * If the timeout value is negative, this will block forever or until data is\n"
  " * available.\n"
  " *\n"
  " * This only works if all ConnectionReaders and ConnectionListeners are non-\n"
  " * threaded.  If any threaded ConnectionReaders are part of the\n"
  " * ConnectionManager, the timeout value is implicitly treated as 0.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_wait_for_readers_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string ConnectionManager::get_host_name(void)
 */
static PyObject *Dtool_ConnectionManager_get_host_name_86(PyObject *, PyObject *) {
  // 1-static std::string ConnectionManager::get_host_name(void)
  std::string return_value = ConnectionManager::get_host_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_get_host_name_86_comment =
  "C++ Interface:\n"
  "get_host_name()\n"
  "\n"
  "/**\n"
  " * Returns the name of this particular machine on the network, if available,\n"
  " * or the empty string if the hostname cannot be determined.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_get_host_name_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConnectionManager::scan_interfaces(void)
 */
static PyObject *Dtool_ConnectionManager_scan_interfaces_101(PyObject *self, PyObject *) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.scan_interfaces")) {
    return NULL;
  }
  // 1-void ConnectionManager::scan_interfaces(void)
  (*local_this).scan_interfaces();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_scan_interfaces_101_comment =
  "C++ Interface:\n"
  "scan_interfaces(const ConnectionManager self)\n"
  "\n"
  "/**\n"
  " * Repopulates the list reported by get_num_interface()/get_interface().  It\n"
  " * is not necessary to call this explicitly, unless you want to re-determine\n"
  " * the connected interfaces (for instance, if you suspect the hardware has\n"
  " * recently changed).\n"
  " */";
#else
static const char *Dtool_ConnectionManager_scan_interfaces_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t ConnectionManager::get_num_interfaces(void)
 */
static PyObject *Dtool_ConnectionManager_get_num_interfaces_102(PyObject *self, PyObject *) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.get_num_interfaces")) {
    return NULL;
  }
  // 1-std::size_t ConnectionManager::get_num_interfaces(void)
  std::size_t return_value = (*local_this).get_num_interfaces();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_get_num_interfaces_102_comment =
  "C++ Interface:\n"
  "get_num_interfaces(const ConnectionManager self)\n"
  "\n"
  "/**\n"
  " * This returns the number of usable network interfaces detected on this\n"
  " * machine.  See scan_interfaces() to repopulate this list.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_get_num_interfaces_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConnectionManager::Interface const &ConnectionManager::get_interface(std::size_t n)
 */
static PyObject *Dtool_ConnectionManager_get_interface_103(PyObject *self, PyObject *arg) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.get_interface")) {
    return NULL;
  }
  // 1-ConnectionManager::Interface const &ConnectionManager::get_interface(std::size_t n)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_interface", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ConnectionManager::Interface const *return_value = &((*local_this).get_interface((std::size_t)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager_Interface, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_interface(const ConnectionManager self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_get_interface_103_comment =
  "C++ Interface:\n"
  "get_interface(const ConnectionManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth usable network interface detected on this machine.\n"
  " * See scan_interfaces() to repopulate this list.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_get_interface_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedConnectionManager *ConnectionManager::downcast_to_QueuedConnectionManager(void)
 */
static PyObject *Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_175(PyObject *self, PyObject *) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.downcast_to_QueuedConnectionManager")) {
    return NULL;
  }
  // 1-QueuedConnectionManager *ConnectionManager::downcast_to_QueuedConnectionManager(void)
  QueuedConnectionManager *return_value = (QueuedConnectionManager *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_175_comment =
  "C++ Interface:\n"
  "downcast_to_QueuedConnectionManager(const ConnectionManager self)\n"
  "\n"
  "downcast from ConnectionManager to QueuedConnectionManager";
#else
static const char *Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_175_comment = NULL;
#endif

static PyObject *Dtool_ConnectionManager_host_name_Getter(PyObject *self, void *) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.host_name")) {
    return NULL;
  }

  // 1-static std::string ConnectionManager::get_host_name(void)
  std::string return_value = ConnectionManager::get_host_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property ConnectionManager::interfaces
 */
static Py_ssize_t Dtool_ConnectionManager_interfaces_Len(PyObject *self) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_interfaces();
}

/**
 * sequence getter for property ConnectionManager::interfaces
 */
static PyObject *Dtool_ConnectionManager_interfaces_Getitem(PyObject *self, Py_ssize_t index) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_interfaces()) {
    PyErr_SetString(PyExc_IndexError, "ConnectionManager.interfaces[] index out of range");
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-ConnectionManager::Interface const &ConnectionManager::get_interface(std::size_t n)
    ConnectionManager::Interface const *return_value = &((*local_this).get_interface(index));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager_Interface, false, true);
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call ConnectionManager.get_interface() on a const object.");
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_interface(const ConnectionManager self, index)\n");
  }
}

static PyObject *Dtool_ConnectionManager_interfaces_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ConnectionManager_interfaces_Len;
  wrap->_getitem_func = &Dtool_ConnectionManager_interfaces_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * ConnectionManager::ConnectionManager(void)
 */
static int Dtool_Init_ConnectionManager(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConnectionManager() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-ConnectionManager::ConnectionManager(void)
  ConnectionManager *return_value = new ConnectionManager();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConnectionManager, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConnectionManager()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConnectionManager_get_interfaces(PyObject *self, PyObject *) {
  ConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_interfaces();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConnectionManager_get_interface_103(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ConnectionManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConnectionManager) {
    printf("ConnectionManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConnectionManager *local_this = (ConnectionManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConnectionManager) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConnectionManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConnectionManager) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConnectionManager::Interface
 */
/**
 * Python function wrapper for:
 * std::string const &ConnectionManager::Interface::get_name(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_name_88(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string const &ConnectionManager::Interface::get_name(void) const
  std::string const &return_value = (*(const ConnectionManager::Interface*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_name_88_comment =
  "C++ Interface:\n"
  "get_name(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_name_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string const &ConnectionManager::Interface::get_mac_address(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_mac_address_89(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string const &ConnectionManager::Interface::get_mac_address(void) const
  std::string const &return_value = (*(const ConnectionManager::Interface*)local_this).get_mac_address();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_mac_address_89_comment =
  "C++ Interface:\n"
  "get_mac_address(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_mac_address_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::Interface::has_ip(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_has_ip_90(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ConnectionManager::Interface::has_ip(void) const
  bool return_value = (*(const ConnectionManager::Interface*)local_this).has_ip();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_has_ip_90_comment =
  "C++ Interface:\n"
  "has_ip(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_has_ip_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NetAddress const &ConnectionManager::Interface::get_ip(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_ip_91(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }
  // 1-NetAddress const &ConnectionManager::Interface::get_ip(void) const
  NetAddress const *return_value = &((*(const ConnectionManager::Interface*)local_this).get_ip());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_ip_91_comment =
  "C++ Interface:\n"
  "get_ip(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_ip_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::Interface::has_netmask(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_has_netmask_92(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ConnectionManager::Interface::has_netmask(void) const
  bool return_value = (*(const ConnectionManager::Interface*)local_this).has_netmask();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_has_netmask_92_comment =
  "C++ Interface:\n"
  "has_netmask(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_has_netmask_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NetAddress const &ConnectionManager::Interface::get_netmask(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_netmask_93(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }
  // 1-NetAddress const &ConnectionManager::Interface::get_netmask(void) const
  NetAddress const *return_value = &((*(const ConnectionManager::Interface*)local_this).get_netmask());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_netmask_93_comment =
  "C++ Interface:\n"
  "get_netmask(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_netmask_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::Interface::has_broadcast(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_has_broadcast_94(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ConnectionManager::Interface::has_broadcast(void) const
  bool return_value = (*(const ConnectionManager::Interface*)local_this).has_broadcast();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_has_broadcast_94_comment =
  "C++ Interface:\n"
  "has_broadcast(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_has_broadcast_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NetAddress const &ConnectionManager::Interface::get_broadcast(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_broadcast_95(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }
  // 1-NetAddress const &ConnectionManager::Interface::get_broadcast(void) const
  NetAddress const *return_value = &((*(const ConnectionManager::Interface*)local_this).get_broadcast());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_broadcast_95_comment =
  "C++ Interface:\n"
  "get_broadcast(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_broadcast_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::Interface::has_p2p(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_has_p2p_96(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ConnectionManager::Interface::has_p2p(void) const
  bool return_value = (*(const ConnectionManager::Interface*)local_this).has_p2p();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_has_p2p_96_comment =
  "C++ Interface:\n"
  "has_p2p(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_has_p2p_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NetAddress const &ConnectionManager::Interface::get_p2p(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_p2p_97(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }
  // 1-NetAddress const &ConnectionManager::Interface::get_p2p(void) const
  NetAddress const *return_value = &((*(const ConnectionManager::Interface*)local_this).get_p2p());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_p2p_97_comment =
  "C++ Interface:\n"
  "get_p2p(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_p2p_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConnectionManager::Interface::output(ostream &out) const
 */
static PyObject *Dtool_ConnectionManager_Interface_output_98(PyObject *self, PyObject *arg) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConnectionManager::Interface::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Interface.output", false, true);
  if (arg_this != NULL) {
    (*(const ConnectionManager::Interface*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Interface self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_output_98_comment =
  "C++ Interface:\n"
  "output(Interface self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConnectionManager_Interface_output_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConnectionManager::Interface::Interface(ConnectionManager::Interface const &) = default
 */
static int Dtool_Init_ConnectionManager_Interface(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Interface() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline ConnectionManager::Interface::Interface(ConnectionManager::Interface const &) = default
  ConnectionManager::Interface const *arg_this = (ConnectionManager::Interface *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConnectionManager_Interface, 0, "Interface.Interface", true, true);
  if (arg_this != NULL) {
    ConnectionManager::Interface *return_value = new ConnectionManager::Interface(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConnectionManager_Interface, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Interface(const Interface param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConnectionManager_Interface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConnectionManager_Interface) {
    printf("ConnectionManager_Interface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConnectionManager::Interface *local_this = (ConnectionManager::Interface *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConnectionManager_Interface) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConnectionManager_Interface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConnectionManager_Interface) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConnectionWriter
 */
/**
 * Python function wrapper for:
 * void ConnectionWriter::set_max_queue_size(int max_size)
 */
static PyObject *Dtool_ConnectionWriter_set_max_queue_size_113(PyObject *self, PyObject *arg) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionWriter, (void **)&local_this, "ConnectionWriter.set_max_queue_size")) {
    return NULL;
  }
  // 1-void ConnectionWriter::set_max_queue_size(int max_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_max_queue_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_queue_size(const ConnectionWriter self, int max_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_set_max_queue_size_113_comment =
  "C++ Interface:\n"
  "set_max_queue_size(const ConnectionWriter self, int max_size)\n"
  "\n"
  "/**\n"
  " * Limits the number of packets that may be pending on the outbound queue.\n"
  " * This only has an effect when using threads; if num_threads is 0, then all\n"
  " * packets are sent immediately.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_set_max_queue_size_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ConnectionWriter::get_max_queue_size(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_max_queue_size_114(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-int ConnectionWriter::get_max_queue_size(void) const
  int return_value = (*(const ConnectionWriter*)local_this).get_max_queue_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_max_queue_size_114_comment =
  "C++ Interface:\n"
  "get_max_queue_size(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum size the queue is allowed to grow to.  See\n"
  " * set_max_queue_size().\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_max_queue_size_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ConnectionWriter::get_current_queue_size(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_current_queue_size_115(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-int ConnectionWriter::get_current_queue_size(void) const
  int return_value = (*(const ConnectionWriter*)local_this).get_current_queue_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_current_queue_size_115_comment =
  "C++ Interface:\n"
  "get_current_queue_size(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of things in the queue.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_current_queue_size_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, NetAddress const &address, bool block = false)
 * bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block = false)
 */
static PyObject *Dtool_ConnectionWriter_send_116(PyObject *self, PyObject *args, PyObject *kwds) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionWriter, (void **)&local_this, "ConnectionWriter.send")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"datagram", "connection", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:send", (char **)keyword_list, &param1, &param2)) {
        Datagram const *param1_this;
        bool param1_manage = false;
        if (!Dtool_ConstCoerce_Datagram(param1, param1_this, param1_manage)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ConnectionWriter.send", "Datagram");
        }
        PT(Connection) param2_this;
        if (!Dtool_Coerce_Connection(param2, param2_this)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ConnectionWriter.send", "Connection");
        }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).send(*param1_this, MOVE(param2_this));
        if (param1_manage) {
          delete param1_this;
        }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, NetAddress const &address, bool block = false)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4 = Py_False;
        static const char *keyword_list[] = {"datagram", "connection", "address", "block", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|O:send", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          Datagram const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Datagram, (void **)&param1_this);
          Connection *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_Connection, (void **)&param2_this);
          NetAddress const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_NetAddress, (void **)&param3_this);
          if (param1_this != NULL && param2_this != NULL && param3_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).send(*param1_this, param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block = false)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"datagram", "connection", "block", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:send", (char **)keyword_list, &param1, &param2, &param3)) {
          Datagram const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Datagram, (void **)&param1_this);
          Connection *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_Connection, (void **)&param2_this);
          if (param1_this != NULL && param2_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).send(*param1_this, param2_this, (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, NetAddress const &address, bool block = false)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4 = Py_False;
        static const char *keyword_list[] = {"datagram", "connection", "address", "block", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|O:send", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          Datagram const *param1_this;
          bool param1_manage = false;
          PT(Connection) param2_this;
          NetAddress const *param3_this;
          bool param3_manage = false;
          if (Dtool_ConstCoerce_Datagram(param1, param1_this, param1_manage) && Dtool_Coerce_Connection(param2, param2_this) && Dtool_ConstCoerce_NetAddress(param3, param3_this, param3_manage)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).send(*param1_this, MOVE(param2_this), *param3_this, (PyObject_IsTrue(param4) != 0));
            if (param1_manage) {
              delete param1_this;
            }
            if (param3_manage) {
              delete param3_this;
            }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block = false)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"datagram", "connection", "block", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:send", (char **)keyword_list, &param1, &param2, &param3)) {
          Datagram const *param1_this;
          bool param1_manage = false;
          PT(Connection) param2_this;
          if (Dtool_ConstCoerce_Datagram(param1, param1_this, param1_manage) && Dtool_Coerce_Connection(param2, param2_this)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (*local_this).send(*param1_this, MOVE(param2_this), (PyObject_IsTrue(param3) != 0));
            if (param1_manage) {
              delete param1_this;
            }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "send() takes 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send(const ConnectionWriter self, const Datagram datagram, const Connection connection)\n"
      "send(const ConnectionWriter self, const Datagram datagram, const Connection connection, const NetAddress address, bool block)\n"
      "send(const ConnectionWriter self, const Datagram datagram, const Connection connection, bool block)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_send_116_comment =
  "C++ Interface:\n"
  "send(const ConnectionWriter self, const Datagram datagram, const Connection connection)\n"
  "send(const ConnectionWriter self, const Datagram datagram, const Connection connection, const NetAddress address, bool block)\n"
  "send(const ConnectionWriter self, const Datagram datagram, const Connection connection, bool block)\n"
  "\n"
  "/**\n"
  " * Enqueues a datagram for transmittal on the indicated socket.  Since the\n"
  " * host address is not specified with this form, this function should only be\n"
  " * used for sending TCP packets.  Use the other send() method for sending UDP\n"
  " * packets.\n"
  " *\n"
  " * Returns true if successful, false if there was an error.  In the normal,\n"
  " * threaded case, this function only returns false if the send queue is\n"
  " * filled; it's impossible to detect a transmission error at this point.\n"
  " *\n"
  " * If block is true, this will not return false if the send queue is filled;\n"
  " * instead, it will wait until there is space available.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Enqueues a datagram for transmittal on the indicated socket.  This form of\n"
  " * the function allows the specification of a destination host address, and so\n"
  " * is appropriate for UDP packets.  Use the other send() method for sending\n"
  " * TCP packets.\n"
  " *\n"
  " * Returns true if successful, false if there was an error.  In the normal,\n"
  " * threaded case, this function only returns false if the send queue is\n"
  " * filled; it's impossible to detect a transmission error at this point.\n"
  " *\n"
  " * If block is true, this will not return false if the send queue is filled;\n"
  " * instead, it will wait until there is space available.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_send_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionWriter::is_valid_for_udp(Datagram const &datagram) const
 */
static PyObject *Dtool_ConnectionWriter_is_valid_for_udp_117(PyObject *self, PyObject *arg) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ConnectionWriter::is_valid_for_udp(Datagram const &datagram) const
  Datagram const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConnectionWriter.is_valid_for_udp", "Datagram");
  }
  bool return_value = (*(const ConnectionWriter*)local_this).is_valid_for_udp(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_valid_for_udp(ConnectionWriter self, const Datagram datagram)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_is_valid_for_udp_117_comment =
  "C++ Interface:\n"
  "is_valid_for_udp(ConnectionWriter self, const Datagram datagram)\n"
  "\n"
  "/**\n"
  " * Returns true if the datagram is small enough to be sent over a UDP packet,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_is_valid_for_udp_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConnectionManager *ConnectionWriter::get_manager(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_manager_118(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-ConnectionManager *ConnectionWriter::get_manager(void) const
  ConnectionManager *return_value = (*(const ConnectionWriter*)local_this).get_manager();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_manager_118_comment =
  "C++ Interface:\n"
  "get_manager(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the ConnectionManager object that serves this\n"
  " * ConnectionWriter.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_manager_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionWriter::is_immediate(void) const
 */
static PyObject *Dtool_ConnectionWriter_is_immediate_119(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ConnectionWriter::is_immediate(void) const
  bool return_value = (*(const ConnectionWriter*)local_this).is_immediate();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_is_immediate_119_comment =
  "C++ Interface:\n"
  "is_immediate(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the writer is an immediate writer, i.e.  it has no threads.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_is_immediate_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ConnectionWriter::get_num_threads(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_num_threads_120(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-int ConnectionWriter::get_num_threads(void) const
  int return_value = (*(const ConnectionWriter*)local_this).get_num_threads();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_num_threads_120_comment =
  "C++ Interface:\n"
  "get_num_threads(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the number of threads the ConnectionWriter has been created with.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_num_threads_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConnectionWriter::set_raw_mode(bool mode)
 */
static PyObject *Dtool_ConnectionWriter_set_raw_mode_121(PyObject *self, PyObject *arg) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionWriter, (void **)&local_this, "ConnectionWriter.set_raw_mode")) {
    return NULL;
  }
  // 1-void ConnectionWriter::set_raw_mode(bool mode)
  (*local_this).set_raw_mode((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_raw_mode(const ConnectionWriter self, bool mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_set_raw_mode_121_comment =
  "C++ Interface:\n"
  "set_raw_mode(const ConnectionWriter self, bool mode)\n"
  "\n"
  "/**\n"
  " * Sets the ConnectionWriter into raw mode (or turns off raw mode).  In raw\n"
  " * mode, datagrams are not sent along with their headers; the bytes in the\n"
  " * datagram are simply sent down the pipe.\n"
  " *\n"
  " * Setting the ConnectionWriter to raw mode must be done with care.  This can\n"
  " * only be done when the matching ConnectionReader is also set to raw mode, or\n"
  " * when the ConnectionWriter is communicating to a process that does not\n"
  " * expect datagrams.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_set_raw_mode_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionWriter::get_raw_mode(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_raw_mode_122(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ConnectionWriter::get_raw_mode(void) const
  bool return_value = (*(const ConnectionWriter*)local_this).get_raw_mode();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_raw_mode_122_comment =
  "C++ Interface:\n"
  "get_raw_mode(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the raw mode flag.  See set_raw_mode().\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_raw_mode_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConnectionWriter::set_tcp_header_size(int tcp_header_size)
 */
static PyObject *Dtool_ConnectionWriter_set_tcp_header_size_123(PyObject *self, PyObject *arg) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionWriter, (void **)&local_this, "ConnectionWriter.set_tcp_header_size")) {
    return NULL;
  }
  // 1-void ConnectionWriter::set_tcp_header_size(int tcp_header_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_tcp_header_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tcp_header_size(const ConnectionWriter self, int tcp_header_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_set_tcp_header_size_123_comment =
  "C++ Interface:\n"
  "set_tcp_header_size(const ConnectionWriter self, int tcp_header_size)\n"
  "\n"
  "/**\n"
  " * Sets the header size of TCP packets.  At the present, legal values for this\n"
  " * are 0, 2, or 4; this specifies the number of bytes to use encode the\n"
  " * datagram length at the start of each TCP datagram.  Sender and receiver\n"
  " * must independently agree on this.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_set_tcp_header_size_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int ConnectionWriter::get_tcp_header_size(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_tcp_header_size_124(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-int ConnectionWriter::get_tcp_header_size(void) const
  int return_value = (*(const ConnectionWriter*)local_this).get_tcp_header_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_tcp_header_size_124_comment =
  "C++ Interface:\n"
  "get_tcp_header_size(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of TCP header size.  See set_tcp_header_size().\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_tcp_header_size_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConnectionWriter::shutdown(void)
 */
static PyObject *Dtool_ConnectionWriter_shutdown_125(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionWriter, (void **)&local_this, "ConnectionWriter.shutdown")) {
    return NULL;
  }
  // 1-void ConnectionWriter::shutdown(void)
  (*local_this).shutdown();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_shutdown_125_comment =
  "C++ Interface:\n"
  "shutdown(const ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Stops all the threads and cleans them up.  This is called automatically by\n"
  " * the destructor, but it may be called explicitly before destruction.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_shutdown_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DatagramSinkNet *ConnectionWriter::downcast_to_DatagramSinkNet(void)
 */
static PyObject *Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_150(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionWriter, (void **)&local_this, "ConnectionWriter.downcast_to_DatagramSinkNet")) {
    return NULL;
  }
  // 1-DatagramSinkNet *ConnectionWriter::downcast_to_DatagramSinkNet(void)
  DatagramSinkNet *return_value = (DatagramSinkNet *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramSinkNet, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_150_comment =
  "C++ Interface:\n"
  "downcast_to_DatagramSinkNet(const ConnectionWriter self)\n"
  "\n"
  "downcast from ConnectionWriter to DatagramSinkNet";
#else
static const char *Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, std::string const &thread_name = string())
 */
static int Dtool_Init_ConnectionWriter(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, std::string const &thread_name = string())
  PyObject *param0;
  int param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"manager", "num_threads", "thread_name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi|s#:ConnectionWriter", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "ConnectionWriter.ConnectionWriter", false, true);
    if (param0_this != NULL) {
      ConnectionWriter *return_value = new ConnectionWriter(param0_this, (int)param1, std::string(param2_str, param2_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConnectionWriter, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConnectionWriter(ConnectionManager manager, int num_threads, str thread_name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConnectionWriter(PyObject *args, ConnectionWriter const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConnectionWriter, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, std::string const &thread_name = string())
      PyObject *param0;
      int param1;
      const char *param2_str = "";
      Py_ssize_t param2_len = 0;
      if (PyArg_ParseTuple(args, "Oi|s#:ConnectionWriter", &param0, &param1, &param2_str, &param2_len)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "ConnectionWriter.ConnectionWriter", false, false);
        if (param0_this != NULL) {
          ConnectionWriter *return_value = new ConnectionWriter(param0_this, (int)param1, std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ConnectionWriter(PyObject *args, ConnectionWriter *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConnectionWriter, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, std::string const &thread_name = string())
      PyObject *param0;
      int param1;
      const char *param2_str = "";
      Py_ssize_t param2_len = 0;
      if (PyArg_ParseTuple(args, "Oi|s#:ConnectionWriter", &param0, &param1, &param2_str, &param2_len)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "ConnectionWriter.ConnectionWriter", false, false);
        if (param0_this != NULL) {
          ConnectionWriter *return_value = new ConnectionWriter(param0_this, (int)param1, std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ConnectionWriter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConnectionWriter) {
    printf("ConnectionWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConnectionWriter *local_this = (ConnectionWriter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConnectionWriter) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConnectionWriter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConnectionWriter) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DatagramGeneratorNet
 */
/**
 * Python function wrapper for:
 * virtual bool DatagramGeneratorNet::get_datagram(Datagram &data)
 */
static PyObject *Dtool_DatagramGeneratorNet_get_datagram_142(PyObject *self, PyObject *arg) {
  DatagramGeneratorNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.get_datagram")) {
    return NULL;
  }
  // 1-virtual bool DatagramGeneratorNet::get_datagram(Datagram &data)
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DatagramGeneratorNet.get_datagram", "Datagram");
  }
  bool return_value = (*local_this).get_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_datagram(const DatagramGeneratorNet self, Datagram data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_get_datagram_142_comment =
  "C++ Interface:\n"
  "get_datagram(const DatagramGeneratorNet self, Datagram data)\n"
  "\n"
  "// Inherited from DatagramGenerator\n"
  "\n"
  "/**\n"
  " * Reads the next datagram from the stream.  Blocks until a datagram is\n"
  " * available.  Returns true on success, false on stream closed or error.\n"
  " */";
#else
static const char *Dtool_DatagramGeneratorNet_get_datagram_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramGeneratorNet::is_eof(void)
 */
static PyObject *Dtool_DatagramGeneratorNet_is_eof_143(PyObject *self, PyObject *) {
  DatagramGeneratorNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.is_eof")) {
    return NULL;
  }
  // 1-virtual bool DatagramGeneratorNet::is_eof(void)
  bool return_value = (*local_this).is_eof();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_is_eof_143_comment =
  "C++ Interface:\n"
  "is_eof(const DatagramGeneratorNet self)\n"
  "\n"
  "/**\n"
  " * Returns true if the stream has been closed normally.  This test may only be\n"
  " * made after a call to get_datagram() has failed.\n"
  " */";
#else
static const char *Dtool_DatagramGeneratorNet_is_eof_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramGeneratorNet::is_error(void)
 */
static PyObject *Dtool_DatagramGeneratorNet_is_error_144(PyObject *self, PyObject *) {
  DatagramGeneratorNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.is_error")) {
    return NULL;
  }
  // 1-virtual bool DatagramGeneratorNet::is_error(void)
  bool return_value = (*local_this).is_error();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_is_error_144_comment =
  "C++ Interface:\n"
  "is_error(const DatagramGeneratorNet self)\n"
  "\n"
  "/**\n"
  " * Returns true if the stream has an error condition.\n"
  " */";
#else
static const char *Dtool_DatagramGeneratorNet_is_error_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DatagramGenerator *DatagramGeneratorNet::upcast_to_DatagramGenerator(void)
 */
static PyObject *Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128(PyObject *self, PyObject *) {
  DatagramGeneratorNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.upcast_to_DatagramGenerator")) {
    return NULL;
  }
  // 1-DatagramGenerator *DatagramGeneratorNet::upcast_to_DatagramGenerator(void)
  DatagramGenerator *return_value = (DatagramGenerator *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramGenerator, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128_comment =
  "C++ Interface:\n"
  "upcast_to_DatagramGenerator(const DatagramGeneratorNet self)\n"
  "\n"
  "upcast from DatagramGeneratorNet to DatagramGenerator";
#else
static const char *Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConnectionReader *DatagramGeneratorNet::upcast_to_ConnectionReader(void)
 */
static PyObject *Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130(PyObject *self, PyObject *) {
  DatagramGeneratorNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.upcast_to_ConnectionReader")) {
    return NULL;
  }
  // 1-ConnectionReader *DatagramGeneratorNet::upcast_to_ConnectionReader(void)
  ConnectionReader *return_value = (ConnectionReader *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130_comment =
  "C++ Interface:\n"
  "upcast_to_ConnectionReader(const DatagramGeneratorNet self)\n"
  "\n"
  "upcast from DatagramGeneratorNet to ConnectionReader";
#else
static const char *Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedReturn< Datagram > *DatagramGeneratorNet::upcast_to_QueuedReturn_Datagram(void)
 */
static PyObject *Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138(PyObject *self, PyObject *) {
  DatagramGeneratorNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.upcast_to_QueuedReturn_Datagram")) {
    return NULL;
  }
  // 1-QueuedReturn< Datagram > *DatagramGeneratorNet::upcast_to_QueuedReturn_Datagram(void)
  QueuedReturn< Datagram > *return_value = (QueuedReturn< Datagram > *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedReturn_Datagram, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138_comment =
  "C++ Interface:\n"
  "upcast_to_QueuedReturn_Datagram(const DatagramGeneratorNet self)\n"
  "\n"
  "upcast from DatagramGeneratorNet to QueuedReturn< Datagram >";
#else
static const char *Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DatagramGeneratorNet::DatagramGeneratorNet(ConnectionManager *manager, int num_threads)
 */
static int Dtool_Init_DatagramGeneratorNet(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-DatagramGeneratorNet::DatagramGeneratorNet(ConnectionManager *manager, int num_threads)
  PyObject *param0;
  int param1;
  static const char *keyword_list[] = {"manager", "num_threads", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:DatagramGeneratorNet", (char **)keyword_list, &param0, &param1)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "DatagramGeneratorNet.DatagramGeneratorNet", false, true);
    if (param0_this != NULL) {
      DatagramGeneratorNet *return_value = new DatagramGeneratorNet(param0_this, (int)param1);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramGeneratorNet, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DatagramGeneratorNet(ConnectionManager manager, int num_threads)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_DatagramGeneratorNet(PyObject *args, DatagramGeneratorNet const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DatagramGeneratorNet, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-DatagramGeneratorNet::DatagramGeneratorNet(ConnectionManager *manager, int num_threads)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:DatagramGeneratorNet", &param0, &param1)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "DatagramGeneratorNet.DatagramGeneratorNet", false, false);
        if (param0_this != NULL) {
          DatagramGeneratorNet *return_value = new DatagramGeneratorNet(param0_this, (int)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_DatagramGeneratorNet(PyObject *args, DatagramGeneratorNet *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DatagramGeneratorNet, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-DatagramGeneratorNet::DatagramGeneratorNet(ConnectionManager *manager, int num_threads)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:DatagramGeneratorNet", &param0, &param1)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "DatagramGeneratorNet.DatagramGeneratorNet", false, false);
        if (param0_this != NULL) {
          DatagramGeneratorNet *return_value = new DatagramGeneratorNet(param0_this, (int)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_DatagramGeneratorNet(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DatagramGeneratorNet) {
    printf("DatagramGeneratorNet ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DatagramGeneratorNet *local_this = (DatagramGeneratorNet *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DatagramGeneratorNet) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionReader) {
    return (ConnectionReader *) local_this;
  }
  if (requested_type == Dtool_Ptr_DatagramGenerator) {
    return (DatagramGenerator *) local_this;
  }
  if (requested_type == Dtool_Ptr_QueuedReturn_Datagram) {
    return (QueuedReturn< Datagram > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DatagramGeneratorNet(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DatagramGeneratorNet) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    ConnectionReader* other_this = (ConnectionReader*)from_this;
    return (DatagramGeneratorNet*)other_this;
  }
  if (from_type == Dtool_Ptr_DatagramGenerator) {
    DatagramGenerator* other_this = (DatagramGenerator*)from_this;
    return (DatagramGeneratorNet*)other_this;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_Datagram) {
    QueuedReturn< Datagram >* other_this = (QueuedReturn< Datagram >*)from_this;
    return (DatagramGeneratorNet*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class QueuedReturn< Datagram >
 */
/**
 * Python function wrapper for:
 * void QueuedReturn< Datagram >::set_max_queue_size(int max_size)
 */
static PyObject *Dtool_QueuedReturn_Datagram_set_max_queue_size_133(PyObject *self, PyObject *arg) {
  QueuedReturn< Datagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_Datagram, (void **)&local_this, "QueuedReturn_Datagram.set_max_queue_size")) {
    return NULL;
  }
  // 1-void QueuedReturn< Datagram >::set_max_queue_size(int max_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_max_queue_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_queue_size(const QueuedReturn self, int max_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_Datagram_set_max_queue_size_133_comment =
  "C++ Interface:\n"
  "set_max_queue_size(const QueuedReturn self, int max_size)\n";
#else
static const char *Dtool_QueuedReturn_Datagram_set_max_queue_size_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< Datagram >::get_max_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_Datagram_get_max_queue_size_134(PyObject *self, PyObject *) {
  QueuedReturn< Datagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_Datagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-int QueuedReturn< Datagram >::get_max_queue_size(void) const
  int return_value = (*(const QueuedReturn< Datagram >*)local_this).get_max_queue_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_Datagram_get_max_queue_size_134_comment =
  "C++ Interface:\n"
  "get_max_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_Datagram_get_max_queue_size_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< Datagram >::get_current_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_Datagram_get_current_queue_size_135(PyObject *self, PyObject *) {
  QueuedReturn< Datagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_Datagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-int QueuedReturn< Datagram >::get_current_queue_size(void) const
  int return_value = (*(const QueuedReturn< Datagram >*)local_this).get_current_queue_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_Datagram_get_current_queue_size_135_comment =
  "C++ Interface:\n"
  "get_current_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_Datagram_get_current_queue_size_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool QueuedReturn< Datagram >::get_overflow_flag(void) const
 */
static PyObject *Dtool_QueuedReturn_Datagram_get_overflow_flag_136(PyObject *self, PyObject *) {
  QueuedReturn< Datagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_Datagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool QueuedReturn< Datagram >::get_overflow_flag(void) const
  bool return_value = (*(const QueuedReturn< Datagram >*)local_this).get_overflow_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_Datagram_get_overflow_flag_136_comment =
  "C++ Interface:\n"
  "get_overflow_flag(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_Datagram_get_overflow_flag_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void QueuedReturn< Datagram >::reset_overflow_flag(void)
 */
static PyObject *Dtool_QueuedReturn_Datagram_reset_overflow_flag_137(PyObject *self, PyObject *) {
  QueuedReturn< Datagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_Datagram, (void **)&local_this, "QueuedReturn_Datagram.reset_overflow_flag")) {
    return NULL;
  }
  // 1-void QueuedReturn< Datagram >::reset_overflow_flag(void)
  (*local_this).reset_overflow_flag();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_Datagram_reset_overflow_flag_137_comment =
  "C++ Interface:\n"
  "reset_overflow_flag(const QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_Datagram_reset_overflow_flag_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DatagramGeneratorNet *QueuedReturn< Datagram >::downcast_to_DatagramGeneratorNet(void)
 */
static PyObject *Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_139(PyObject *self, PyObject *) {
  QueuedReturn< Datagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_Datagram, (void **)&local_this, "QueuedReturn_Datagram.downcast_to_DatagramGeneratorNet")) {
    return NULL;
  }
  // 1-DatagramGeneratorNet *QueuedReturn< Datagram >::downcast_to_DatagramGeneratorNet(void)
  DatagramGeneratorNet *return_value = (DatagramGeneratorNet *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramGeneratorNet, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_139_comment =
  "C++ Interface:\n"
  "downcast_to_DatagramGeneratorNet(const QueuedReturn self)\n"
  "\n"
  "downcast from QueuedReturn< Datagram > to DatagramGeneratorNet";
#else
static const char *Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_139_comment = NULL;
#endif

static int Dtool_Init_QueuedReturn_Datagram(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_QueuedReturn_Datagram(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_QueuedReturn_Datagram) {
    printf("QueuedReturn_Datagram ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  QueuedReturn< Datagram > *local_this = (QueuedReturn< Datagram > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_QueuedReturn_Datagram) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_QueuedReturn_Datagram(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_Datagram) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DatagramSinkNet
 */
/**
 * Python function wrapper for:
 * inline void DatagramSinkNet::set_target(Connection *connection)
 */
static PyObject *Dtool_DatagramSinkNet_set_target_152(PyObject *self, PyObject *arg) {
  DatagramSinkNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.set_target")) {
    return NULL;
  }
  // 1-inline void DatagramSinkNet::set_target(Connection *connection)
  PT(Connection) arg_this;
  if (!Dtool_Coerce_Connection(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DatagramSinkNet.set_target", "Connection");
  }
  (*local_this).set_target(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_target(const DatagramSinkNet self, Connection connection)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_set_target_152_comment =
  "C++ Interface:\n"
  "set_target(const DatagramSinkNet self, Connection connection)\n"
  "\n"
  "/**\n"
  " * Specifies the Connection that will receive all future Datagrams sent.\n"
  " */";
#else
static const char *Dtool_DatagramSinkNet_set_target_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Connection *DatagramSinkNet::get_target(void) const
 */
static PyObject *Dtool_DatagramSinkNet_get_target_153(PyObject *self, PyObject *) {
  DatagramSinkNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramSinkNet, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Connection *DatagramSinkNet::get_target(void) const
  Connection *return_value = (*(const DatagramSinkNet*)local_this).get_target();
  if (return_value != (Connection *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Connection *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Connection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_get_target_153_comment =
  "C++ Interface:\n"
  "get_target(DatagramSinkNet self)\n"
  "\n"
  "/**\n"
  " * Returns the current target Connection, or NULL if the target has not yet\n"
  " * been set.  See set_target().\n"
  " */";
#else
static const char *Dtool_DatagramSinkNet_get_target_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramSinkNet::put_datagram(Datagram const &data)
 */
static PyObject *Dtool_DatagramSinkNet_put_datagram_154(PyObject *self, PyObject *arg) {
  DatagramSinkNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.put_datagram")) {
    return NULL;
  }
  // 1-virtual bool DatagramSinkNet::put_datagram(Datagram const &data)
  Datagram const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DatagramSinkNet.put_datagram", "Datagram");
  }
  bool return_value = (*local_this).put_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "put_datagram(const DatagramSinkNet self, const Datagram data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_put_datagram_154_comment =
  "C++ Interface:\n"
  "put_datagram(const DatagramSinkNet self, const Datagram data)\n"
  "\n"
  "// Inherited from DatagramSink\n"
  "\n"
  "/**\n"
  " * Sends the given datagram to the target.  Returns true on success, false if\n"
  " * there is an error.  Blocks if necessary until the target is ready.\n"
  " */";
#else
static const char *Dtool_DatagramSinkNet_put_datagram_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramSinkNet::is_error(void)
 */
static PyObject *Dtool_DatagramSinkNet_is_error_155(PyObject *self, PyObject *) {
  DatagramSinkNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.is_error")) {
    return NULL;
  }
  // 1-virtual bool DatagramSinkNet::is_error(void)
  bool return_value = (*local_this).is_error();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_is_error_155_comment =
  "C++ Interface:\n"
  "is_error(const DatagramSinkNet self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is an error on the target connection, or if the\n"
  " * target has never been set.\n"
  " */";
#else
static const char *Dtool_DatagramSinkNet_is_error_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void DatagramSinkNet::flush(void)
 */
static PyObject *Dtool_DatagramSinkNet_flush_156(PyObject *self, PyObject *) {
  DatagramSinkNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.flush")) {
    return NULL;
  }
  // 1-virtual void DatagramSinkNet::flush(void)
  (*local_this).flush();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_flush_156_comment =
  "C++ Interface:\n"
  "flush(const DatagramSinkNet self)\n"
  "\n"
  "/**\n"
  " * Ensures that all datagrams previously written will be visible on the\n"
  " * stream.\n"
  " */";
#else
static const char *Dtool_DatagramSinkNet_flush_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DatagramSink *DatagramSinkNet::upcast_to_DatagramSink(void)
 */
static PyObject *Dtool_DatagramSinkNet_upcast_to_DatagramSink_147(PyObject *self, PyObject *) {
  DatagramSinkNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.upcast_to_DatagramSink")) {
    return NULL;
  }
  // 1-DatagramSink *DatagramSinkNet::upcast_to_DatagramSink(void)
  DatagramSink *return_value = (DatagramSink *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramSink, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_upcast_to_DatagramSink_147_comment =
  "C++ Interface:\n"
  "upcast_to_DatagramSink(const DatagramSinkNet self)\n"
  "\n"
  "upcast from DatagramSinkNet to DatagramSink";
#else
static const char *Dtool_DatagramSinkNet_upcast_to_DatagramSink_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConnectionWriter *DatagramSinkNet::upcast_to_ConnectionWriter(void)
 */
static PyObject *Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149(PyObject *self, PyObject *) {
  DatagramSinkNet *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.upcast_to_ConnectionWriter")) {
    return NULL;
  }
  // 1-ConnectionWriter *DatagramSinkNet::upcast_to_ConnectionWriter(void)
  ConnectionWriter *return_value = (ConnectionWriter *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionWriter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149_comment =
  "C++ Interface:\n"
  "upcast_to_ConnectionWriter(const DatagramSinkNet self)\n"
  "\n"
  "upcast from DatagramSinkNet to ConnectionWriter";
#else
static const char *Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DatagramSinkNet::DatagramSinkNet(ConnectionManager *manager, int num_threads)
 */
static int Dtool_Init_DatagramSinkNet(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-DatagramSinkNet::DatagramSinkNet(ConnectionManager *manager, int num_threads)
  PyObject *param0;
  int param1;
  static const char *keyword_list[] = {"manager", "num_threads", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:DatagramSinkNet", (char **)keyword_list, &param0, &param1)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "DatagramSinkNet.DatagramSinkNet", false, true);
    if (param0_this != NULL) {
      DatagramSinkNet *return_value = new DatagramSinkNet(param0_this, (int)param1);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramSinkNet, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DatagramSinkNet(ConnectionManager manager, int num_threads)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_DatagramSinkNet(PyObject *args, DatagramSinkNet const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DatagramSinkNet, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-DatagramSinkNet::DatagramSinkNet(ConnectionManager *manager, int num_threads)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:DatagramSinkNet", &param0, &param1)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "DatagramSinkNet.DatagramSinkNet", false, false);
        if (param0_this != NULL) {
          DatagramSinkNet *return_value = new DatagramSinkNet(param0_this, (int)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_DatagramSinkNet(PyObject *args, DatagramSinkNet *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DatagramSinkNet, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-DatagramSinkNet::DatagramSinkNet(ConnectionManager *manager, int num_threads)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:DatagramSinkNet", &param0, &param1)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "DatagramSinkNet.DatagramSinkNet", false, false);
        if (param0_this != NULL) {
          DatagramSinkNet *return_value = new DatagramSinkNet(param0_this, (int)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_DatagramSinkNet(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DatagramSinkNet) {
    printf("DatagramSinkNet ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DatagramSinkNet *local_this = (DatagramSinkNet *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DatagramSinkNet) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionWriter) {
    return (ConnectionWriter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DatagramSink) {
    return (DatagramSink *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DatagramSinkNet(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DatagramSinkNet) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionWriter) {
    ConnectionWriter* other_this = (ConnectionWriter*)from_this;
    return (DatagramSinkNet*)other_this;
  }
  if (from_type == Dtool_Ptr_DatagramSink) {
    DatagramSink* other_this = (DatagramSink*)from_this;
    return (DatagramSinkNet*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class QueuedConnectionListener
 */
/**
 * Python function wrapper for:
 * bool QueuedConnectionListener::new_connection_available(void)
 */
static PyObject *Dtool_QueuedConnectionListener_new_connection_available_171(PyObject *self, PyObject *) {
  QueuedConnectionListener *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionListener, (void **)&local_this, "QueuedConnectionListener.new_connection_available")) {
    return NULL;
  }
  // 1-bool QueuedConnectionListener::new_connection_available(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).new_connection_available();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionListener_new_connection_available_171_comment =
  "C++ Interface:\n"
  "new_connection_available(const QueuedConnectionListener self)\n"
  "\n"
  "/**\n"
  " * Returns true if a new connection was recently established; the connection\n"
  " * information may then be retrieved via get_new_connection().\n"
  " */";
#else
static const char *Dtool_QueuedConnectionListener_new_connection_available_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &new_connection)
 * bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &rendezvous, NetAddress &address, PointerTo< Connection > &new_connection)
 */
static PyObject *Dtool_QueuedConnectionListener_get_new_connection_172(PyObject *self, PyObject *args, PyObject *kwds) {
  QueuedConnectionListener *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionListener, (void **)&local_this, "QueuedConnectionListener.get_new_connection")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "new_connection");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'new_connection' (pos 1) not found");
      }
      // 1-bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &new_connection)
      PointerTo< Connection > *arg_this;
      bool arg_manage = false;
      if (!Dtool_Coerce_PointerTo_Connection(arg, arg_this, arg_manage)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "QueuedConnectionListener.get_new_connection", "PointerTo");
      }
      bool return_value = (*local_this).get_new_connection(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 3:
    {
      // 1-bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &rendezvous, NetAddress &address, PointerTo< Connection > &new_connection)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"rendezvous", "address", "new_connection", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:get_new_connection", (char **)keyword_list, &param1, &param2, &param3)) {
        PointerTo< Connection > *param1_this;
        bool param1_manage = false;
        if (!Dtool_Coerce_PointerTo_Connection(param1, param1_this, param1_manage)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "QueuedConnectionListener.get_new_connection", "PointerTo");
        }
        NetAddress *param2_this;
        bool param2_manage = false;
        if (!Dtool_Coerce_NetAddress(param2, param2_this, param2_manage)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "QueuedConnectionListener.get_new_connection", "NetAddress");
        }
        PointerTo< Connection > *param3_this;
        bool param3_manage = false;
        if (!Dtool_Coerce_PointerTo_Connection(param3, param3_this, param3_manage)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "QueuedConnectionListener.get_new_connection", "PointerTo");
        }
        bool return_value = (*local_this).get_new_connection(*param1_this, *param2_this, *param3_this);
        if (param1_manage) {
          delete param1_this;
        }
        if (param2_manage) {
          delete param2_this;
        }
        if (param3_manage) {
          delete param3_this;
        }
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_new_connection() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_new_connection(const QueuedConnectionListener self, PointerTo new_connection)\n"
      "get_new_connection(const QueuedConnectionListener self, PointerTo rendezvous, NetAddress address, PointerTo new_connection)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionListener_get_new_connection_172_comment =
  "C++ Interface:\n"
  "get_new_connection(const QueuedConnectionListener self, PointerTo new_connection)\n"
  "get_new_connection(const QueuedConnectionListener self, PointerTo rendezvous, NetAddress address, PointerTo new_connection)\n"
  "\n"
  "/**\n"
  " * If a previous call to new_connection_available() returned true, this\n"
  " * function will return information about the newly established connection.\n"
  " *\n"
  " * The rendezvous parameter is the particular rendezvous socket this new\n"
  " * connection originally communicated with; it is provided in case the\n"
  " * ConnectionListener was monitorind more than one and you care which one it\n"
  " * was.  The address parameter is the net address of the new client, and\n"
  " * new_connection is the socket of the newly established connection.\n"
  " *\n"
  " * The return value is true if a connection was successfully returned, or\n"
  " * false if there was, in fact, no new connection.  (This may happen if there\n"
  " * are multiple threads accessing the QueuedConnectionListener).\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of get_new_connection() simply returns a new connection,\n"
  " * assuming the user doesn't care about the rendezvous socket that originated\n"
  " * it or the address it came from.\n"
  " */";
#else
static const char *Dtool_QueuedConnectionListener_get_new_connection_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConnectionListener *QueuedConnectionListener::upcast_to_ConnectionListener(void)
 */
static PyObject *Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159(PyObject *self, PyObject *) {
  QueuedConnectionListener *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionListener, (void **)&local_this, "QueuedConnectionListener.upcast_to_ConnectionListener")) {
    return NULL;
  }
  // 1-ConnectionListener *QueuedConnectionListener::upcast_to_ConnectionListener(void)
  ConnectionListener *return_value = (ConnectionListener *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionListener, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159_comment =
  "C++ Interface:\n"
  "upcast_to_ConnectionListener(const QueuedConnectionListener self)\n"
  "\n"
  "upcast from QueuedConnectionListener to ConnectionListener";
#else
static const char *Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedReturn< ConnectionListenerData > *QueuedConnectionListener::upcast_to_QueuedReturn_ConnectionListenerData(void)
 */
static PyObject *Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167(PyObject *self, PyObject *) {
  QueuedConnectionListener *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionListener, (void **)&local_this, "QueuedConnectionListener.upcast_to_QueuedReturn_ConnectionListenerData")) {
    return NULL;
  }
  // 1-QueuedReturn< ConnectionListenerData > *QueuedConnectionListener::upcast_to_QueuedReturn_ConnectionListenerData(void)
  QueuedReturn< ConnectionListenerData > *return_value = (QueuedReturn< ConnectionListenerData > *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedReturn_ConnectionListenerData, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167_comment =
  "C++ Interface:\n"
  "upcast_to_QueuedReturn_ConnectionListenerData(const QueuedConnectionListener self)\n"
  "\n"
  "upcast from QueuedConnectionListener to QueuedReturn< ConnectionListenerData >";
#else
static const char *Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedConnectionListener::QueuedConnectionListener(ConnectionManager *manager, int num_threads)
 */
static int Dtool_Init_QueuedConnectionListener(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-QueuedConnectionListener::QueuedConnectionListener(ConnectionManager *manager, int num_threads)
  PyObject *param0;
  int param1;
  static const char *keyword_list[] = {"manager", "num_threads", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:QueuedConnectionListener", (char **)keyword_list, &param0, &param1)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "QueuedConnectionListener.QueuedConnectionListener", false, true);
    if (param0_this != NULL) {
      QueuedConnectionListener *return_value = new QueuedConnectionListener(param0_this, (int)param1);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_QueuedConnectionListener, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "QueuedConnectionListener(ConnectionManager manager, int num_threads)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_QueuedConnectionListener(PyObject *args, QueuedConnectionListener const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_QueuedConnectionListener, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-QueuedConnectionListener::QueuedConnectionListener(ConnectionManager *manager, int num_threads)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:QueuedConnectionListener", &param0, &param1)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "QueuedConnectionListener.QueuedConnectionListener", false, false);
        if (param0_this != NULL) {
          QueuedConnectionListener *return_value = new QueuedConnectionListener(param0_this, (int)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_QueuedConnectionListener(PyObject *args, QueuedConnectionListener *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_QueuedConnectionListener, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-QueuedConnectionListener::QueuedConnectionListener(ConnectionManager *manager, int num_threads)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:QueuedConnectionListener", &param0, &param1)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "QueuedConnectionListener.QueuedConnectionListener", false, false);
        if (param0_this != NULL) {
          QueuedConnectionListener *return_value = new QueuedConnectionListener(param0_this, (int)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_QueuedConnectionListener(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_QueuedConnectionListener) {
    printf("QueuedConnectionListener ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  QueuedConnectionListener *local_this = (QueuedConnectionListener *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_QueuedConnectionListener) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionListener) {
    return (ConnectionListener *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionReader) {
    return (ConnectionReader *)(ConnectionListener *) local_this;
  }
  if (requested_type == Dtool_Ptr_QueuedReturn_ConnectionListenerData) {
    return (QueuedReturn< ConnectionListenerData > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_QueuedConnectionListener(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_QueuedConnectionListener) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionListener) {
    ConnectionListener* other_this = (ConnectionListener*)from_this;
    return (QueuedConnectionListener*)other_this;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    ConnectionReader* other_this = (ConnectionReader*)from_this;
    return (QueuedConnectionListener*)other_this;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_ConnectionListenerData) {
    QueuedReturn< ConnectionListenerData >* other_this = (QueuedReturn< ConnectionListenerData >*)from_this;
    return (QueuedConnectionListener*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class QueuedReturn< ConnectionListenerData >
 */
/**
 * Python function wrapper for:
 * void QueuedReturn< ConnectionListenerData >::set_max_queue_size(int max_size)
 */
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162(PyObject *self, PyObject *arg) {
  QueuedReturn< ConnectionListenerData > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_ConnectionListenerData, (void **)&local_this, "QueuedReturn_ConnectionListenerData.set_max_queue_size")) {
    return NULL;
  }
  // 1-void QueuedReturn< ConnectionListenerData >::set_max_queue_size(int max_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_max_queue_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_queue_size(const QueuedReturn self, int max_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162_comment =
  "C++ Interface:\n"
  "set_max_queue_size(const QueuedReturn self, int max_size)\n";
#else
static const char *Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< ConnectionListenerData >::get_max_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163(PyObject *self, PyObject *) {
  QueuedReturn< ConnectionListenerData > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_ConnectionListenerData, (void **)&local_this)) {
    return NULL;
  }
  // 1-int QueuedReturn< ConnectionListenerData >::get_max_queue_size(void) const
  int return_value = (*(const QueuedReturn< ConnectionListenerData >*)local_this).get_max_queue_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163_comment =
  "C++ Interface:\n"
  "get_max_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< ConnectionListenerData >::get_current_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164(PyObject *self, PyObject *) {
  QueuedReturn< ConnectionListenerData > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_ConnectionListenerData, (void **)&local_this)) {
    return NULL;
  }
  // 1-int QueuedReturn< ConnectionListenerData >::get_current_queue_size(void) const
  int return_value = (*(const QueuedReturn< ConnectionListenerData >*)local_this).get_current_queue_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164_comment =
  "C++ Interface:\n"
  "get_current_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool QueuedReturn< ConnectionListenerData >::get_overflow_flag(void) const
 */
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165(PyObject *self, PyObject *) {
  QueuedReturn< ConnectionListenerData > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_ConnectionListenerData, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool QueuedReturn< ConnectionListenerData >::get_overflow_flag(void) const
  bool return_value = (*(const QueuedReturn< ConnectionListenerData >*)local_this).get_overflow_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165_comment =
  "C++ Interface:\n"
  "get_overflow_flag(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void QueuedReturn< ConnectionListenerData >::reset_overflow_flag(void)
 */
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166(PyObject *self, PyObject *) {
  QueuedReturn< ConnectionListenerData > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_ConnectionListenerData, (void **)&local_this, "QueuedReturn_ConnectionListenerData.reset_overflow_flag")) {
    return NULL;
  }
  // 1-void QueuedReturn< ConnectionListenerData >::reset_overflow_flag(void)
  (*local_this).reset_overflow_flag();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166_comment =
  "C++ Interface:\n"
  "reset_overflow_flag(const QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedConnectionListener *QueuedReturn< ConnectionListenerData >::downcast_to_QueuedConnectionListener(void)
 */
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_168(PyObject *self, PyObject *) {
  QueuedReturn< ConnectionListenerData > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_ConnectionListenerData, (void **)&local_this, "QueuedReturn_ConnectionListenerData.downcast_to_QueuedConnectionListener")) {
    return NULL;
  }
  // 1-QueuedConnectionListener *QueuedReturn< ConnectionListenerData >::downcast_to_QueuedConnectionListener(void)
  QueuedConnectionListener *return_value = (QueuedConnectionListener *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedConnectionListener, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_168_comment =
  "C++ Interface:\n"
  "downcast_to_QueuedConnectionListener(const QueuedReturn self)\n"
  "\n"
  "downcast from QueuedReturn< ConnectionListenerData > to QueuedConnectionListener";
#else
static const char *Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_168_comment = NULL;
#endif

static int Dtool_Init_QueuedReturn_ConnectionListenerData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_QueuedReturn_ConnectionListenerData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_QueuedReturn_ConnectionListenerData) {
    printf("QueuedReturn_ConnectionListenerData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  QueuedReturn< ConnectionListenerData > *local_this = (QueuedReturn< ConnectionListenerData > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_QueuedReturn_ConnectionListenerData) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_QueuedReturn_ConnectionListenerData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_ConnectionListenerData) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class QueuedConnectionManager
 */
/**
 * Python function wrapper for:
 * bool QueuedConnectionManager::reset_connection_available(void) const
 */
static PyObject *Dtool_QueuedConnectionManager_reset_connection_available_186(PyObject *self, PyObject *) {
  QueuedConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedConnectionManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool QueuedConnectionManager::reset_connection_available(void) const
  bool return_value = (*(const QueuedConnectionManager*)local_this).reset_connection_available();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionManager_reset_connection_available_186_comment =
  "C++ Interface:\n"
  "reset_connection_available(QueuedConnectionManager self)\n"
  "\n"
  "/**\n"
  " * Returns true if one of the readers/writers/listeners reported a connection\n"
  " * reset recently.  If so, the particular connection that has been reset can\n"
  " * be extracted via get_reset_connection().\n"
  " *\n"
  " * Only connections which were externally reset are certain to appear in this\n"
  " * list.  Those which were explicitly closed via a call to close_connection()\n"
  " * may or may not be reported.  Furthermore, it is the responsibility of the\n"
  " * caller to subsequently call close_connection() with any connection reported\n"
  " * reset by this call.  (There is no harm in calling close_connection() more\n"
  " * than once on a given socket.)\n"
  " */";
#else
static const char *Dtool_QueuedConnectionManager_reset_connection_available_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool QueuedConnectionManager::get_reset_connection(PointerTo< Connection > &connection)
 */
static PyObject *Dtool_QueuedConnectionManager_get_reset_connection_187(PyObject *self, PyObject *arg) {
  QueuedConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionManager, (void **)&local_this, "QueuedConnectionManager.get_reset_connection")) {
    return NULL;
  }
  // 1-bool QueuedConnectionManager::get_reset_connection(PointerTo< Connection > &connection)
  PointerTo< Connection > *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_PointerTo_Connection(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "QueuedConnectionManager.get_reset_connection", "PointerTo");
  }
  bool return_value = (*local_this).get_reset_connection(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_reset_connection(const QueuedConnectionManager self, PointerTo connection)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionManager_get_reset_connection_187_comment =
  "C++ Interface:\n"
  "get_reset_connection(const QueuedConnectionManager self, PointerTo connection)\n"
  "\n"
  "/**\n"
  " * If a previous call to reset_connection_available() returned true, this\n"
  " * function will return information about the newly reset connection.\n"
  " *\n"
  " * Only connections which were externally reset are certain to appear in this\n"
  " * list.  Those which were explicitly closed via a call to close_connection()\n"
  " * may or may not be reported.  Furthermore, it is the responsibility of the\n"
  " * caller to subsequently call close_connection() with any connection reported\n"
  " * reset by this call.  (There is no harm in calling close_connection() more\n"
  " * than once on a given socket.)\n"
  " *\n"
  " * The return value is true if a connection was successfully returned, or\n"
  " * false if there was, in fact, no reset connection.  (This may happen if\n"
  " * there are multiple threads accessing the QueuedConnectionManager).\n"
  " */";
#else
static const char *Dtool_QueuedConnectionManager_get_reset_connection_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConnectionManager *QueuedConnectionManager::upcast_to_ConnectionManager(void)
 */
static PyObject *Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174(PyObject *self, PyObject *) {
  QueuedConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionManager, (void **)&local_this, "QueuedConnectionManager.upcast_to_ConnectionManager")) {
    return NULL;
  }
  // 1-ConnectionManager *QueuedConnectionManager::upcast_to_ConnectionManager(void)
  ConnectionManager *return_value = (ConnectionManager *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174_comment =
  "C++ Interface:\n"
  "upcast_to_ConnectionManager(const QueuedConnectionManager self)\n"
  "\n"
  "upcast from QueuedConnectionManager to ConnectionManager";
#else
static const char *Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedReturn< PointerTo< Connection > > *QueuedConnectionManager::upcast_to_QueuedReturn_PointerTo_Connection(void)
 */
static PyObject *Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182(PyObject *self, PyObject *) {
  QueuedConnectionManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionManager, (void **)&local_this, "QueuedConnectionManager.upcast_to_QueuedReturn_PointerTo_Connection")) {
    return NULL;
  }
  // 1-QueuedReturn< PointerTo< Connection > > *QueuedConnectionManager::upcast_to_QueuedReturn_PointerTo_Connection(void)
  QueuedReturn< PointerTo< Connection > > *return_value = (QueuedReturn< PointerTo< Connection > > *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedReturn_PointerTo_Connection, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182_comment =
  "C++ Interface:\n"
  "upcast_to_QueuedReturn_PointerTo_Connection(const QueuedConnectionManager self)\n"
  "\n"
  "upcast from QueuedConnectionManager to QueuedReturn< PointerTo< Connection > >";
#else
static const char *Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedConnectionManager::QueuedConnectionManager(void)
 */
static int Dtool_Init_QueuedConnectionManager(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "QueuedConnectionManager() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-QueuedConnectionManager::QueuedConnectionManager(void)
  QueuedConnectionManager *return_value = new QueuedConnectionManager();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_QueuedConnectionManager, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "QueuedConnectionManager()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_QueuedConnectionManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_QueuedConnectionManager) {
    printf("QueuedConnectionManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  QueuedConnectionManager *local_this = (QueuedConnectionManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_QueuedConnectionManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionManager) {
    return (ConnectionManager *) local_this;
  }
  if (requested_type == Dtool_Ptr_QueuedReturn_PointerTo_Connection) {
    return (QueuedReturn< PointerTo< Connection > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_QueuedConnectionManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_QueuedConnectionManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionManager) {
    ConnectionManager* other_this = (ConnectionManager*)from_this;
    return (QueuedConnectionManager*)other_this;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_PointerTo_Connection) {
    QueuedReturn< PointerTo< Connection > >* other_this = (QueuedReturn< PointerTo< Connection > >*)from_this;
    return (QueuedConnectionManager*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class QueuedReturn< PointerTo< Connection > >
 */
/**
 * Python function wrapper for:
 * void QueuedReturn< PointerTo< Connection > >::set_max_queue_size(int max_size)
 */
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177(PyObject *self, PyObject *arg) {
  QueuedReturn< PointerTo< Connection > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_PointerTo_Connection, (void **)&local_this, "QueuedReturn_PointerTo_Connection.set_max_queue_size")) {
    return NULL;
  }
  // 1-void QueuedReturn< PointerTo< Connection > >::set_max_queue_size(int max_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_max_queue_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_queue_size(const QueuedReturn self, int max_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177_comment =
  "C++ Interface:\n"
  "set_max_queue_size(const QueuedReturn self, int max_size)\n";
#else
static const char *Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< PointerTo< Connection > >::get_max_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178(PyObject *self, PyObject *) {
  QueuedReturn< PointerTo< Connection > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_PointerTo_Connection, (void **)&local_this)) {
    return NULL;
  }
  // 1-int QueuedReturn< PointerTo< Connection > >::get_max_queue_size(void) const
  int return_value = (*(const QueuedReturn< PointerTo< Connection > >*)local_this).get_max_queue_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178_comment =
  "C++ Interface:\n"
  "get_max_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< PointerTo< Connection > >::get_current_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179(PyObject *self, PyObject *) {
  QueuedReturn< PointerTo< Connection > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_PointerTo_Connection, (void **)&local_this)) {
    return NULL;
  }
  // 1-int QueuedReturn< PointerTo< Connection > >::get_current_queue_size(void) const
  int return_value = (*(const QueuedReturn< PointerTo< Connection > >*)local_this).get_current_queue_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179_comment =
  "C++ Interface:\n"
  "get_current_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool QueuedReturn< PointerTo< Connection > >::get_overflow_flag(void) const
 */
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180(PyObject *self, PyObject *) {
  QueuedReturn< PointerTo< Connection > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_PointerTo_Connection, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool QueuedReturn< PointerTo< Connection > >::get_overflow_flag(void) const
  bool return_value = (*(const QueuedReturn< PointerTo< Connection > >*)local_this).get_overflow_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180_comment =
  "C++ Interface:\n"
  "get_overflow_flag(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void QueuedReturn< PointerTo< Connection > >::reset_overflow_flag(void)
 */
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181(PyObject *self, PyObject *) {
  QueuedReturn< PointerTo< Connection > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_PointerTo_Connection, (void **)&local_this, "QueuedReturn_PointerTo_Connection.reset_overflow_flag")) {
    return NULL;
  }
  // 1-void QueuedReturn< PointerTo< Connection > >::reset_overflow_flag(void)
  (*local_this).reset_overflow_flag();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181_comment =
  "C++ Interface:\n"
  "reset_overflow_flag(const QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedConnectionManager *QueuedReturn< PointerTo< Connection > >::downcast_to_QueuedConnectionManager(void)
 */
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_183(PyObject *self, PyObject *) {
  QueuedReturn< PointerTo< Connection > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_PointerTo_Connection, (void **)&local_this, "QueuedReturn_PointerTo_Connection.downcast_to_QueuedConnectionManager")) {
    return NULL;
  }
  // 1-QueuedConnectionManager *QueuedReturn< PointerTo< Connection > >::downcast_to_QueuedConnectionManager(void)
  QueuedConnectionManager *return_value = (QueuedConnectionManager *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_183_comment =
  "C++ Interface:\n"
  "downcast_to_QueuedConnectionManager(const QueuedReturn self)\n"
  "\n"
  "downcast from QueuedReturn< PointerTo< Connection > > to QueuedConnectionManager";
#else
static const char *Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_183_comment = NULL;
#endif

static int Dtool_Init_QueuedReturn_PointerTo_Connection(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_QueuedReturn_PointerTo_Connection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_QueuedReturn_PointerTo_Connection) {
    printf("QueuedReturn_PointerTo_Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  QueuedReturn< PointerTo< Connection > > *local_this = (QueuedReturn< PointerTo< Connection > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_QueuedReturn_PointerTo_Connection) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_QueuedReturn_PointerTo_Connection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_PointerTo_Connection) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class QueuedConnectionReader
 */
/**
 * Python function wrapper for:
 * bool QueuedConnectionReader::data_available(void)
 */
static PyObject *Dtool_QueuedConnectionReader_data_available_201(PyObject *self, PyObject *) {
  QueuedConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionReader, (void **)&local_this, "QueuedConnectionReader.data_available")) {
    return NULL;
  }
  // 1-bool QueuedConnectionReader::data_available(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).data_available();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionReader_data_available_201_comment =
  "C++ Interface:\n"
  "data_available(const QueuedConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if a datagram is available on the queue; call get_data() to\n"
  " * extract the datagram.\n"
  " */";
#else
static const char *Dtool_QueuedConnectionReader_data_available_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool QueuedConnectionReader::get_data(Datagram &result)
 * bool QueuedConnectionReader::get_data(NetDatagram &result)
 */
static PyObject *Dtool_QueuedConnectionReader_get_data_202(PyObject *self, PyObject *arg) {
  QueuedConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionReader, (void **)&local_this, "QueuedConnectionReader.get_data")) {
    return NULL;
  }
  {
    // -2 bool QueuedConnectionReader::get_data(NetDatagram &result)
    NetDatagram *arg_this = (NetDatagram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NetDatagram, 1, "QueuedConnectionReader.get_data", false, false);
    if (arg_this != NULL) {
      bool return_value = (*local_this).get_data(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool QueuedConnectionReader::get_data(Datagram &result)
    Datagram *arg_this = (Datagram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Datagram, 1, "QueuedConnectionReader.get_data", false, false);
    if (arg_this != NULL) {
      bool return_value = (*local_this).get_data(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool QueuedConnectionReader::get_data(NetDatagram &result)
    NetDatagram *arg_this;
    bool arg_manage = false;
    if (Dtool_Coerce_NetDatagram(arg, arg_this, arg_manage)) {
      bool return_value = (*local_this).get_data(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool QueuedConnectionReader::get_data(Datagram &result)
    Datagram *arg_this;
    bool arg_manage = false;
    if (Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
      bool return_value = (*local_this).get_data(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_data(const QueuedConnectionReader self, NetDatagram result)\n"
      "get_data(const QueuedConnectionReader self, Datagram result)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionReader_get_data_202_comment =
  "C++ Interface:\n"
  "get_data(const QueuedConnectionReader self, NetDatagram result)\n"
  "get_data(const QueuedConnectionReader self, Datagram result)\n"
  "\n"
  "/**\n"
  " * If a previous call to data_available() returned true, this function will\n"
  " * return the datagram that has become available.\n"
  " *\n"
  " * The return value is true if a datagram was successfully returned, or false\n"
  " * if there was, in fact, no datagram available.  (This may happen if there\n"
  " * are multiple threads accessing the QueuedConnectionReader).\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of QueuedConnectionReader::get_data(), works like the other,\n"
  " * except that it only fills a Datagram object, not a NetDatagram object.\n"
  " * This means that the Datagram cannot be queried for its source Connection\n"
  " * and/or NetAddress, but it is useful in all other respects.\n"
  " */";
#else
static const char *Dtool_QueuedConnectionReader_get_data_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConnectionReader *QueuedConnectionReader::upcast_to_ConnectionReader(void)
 */
static PyObject *Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189(PyObject *self, PyObject *) {
  QueuedConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionReader, (void **)&local_this, "QueuedConnectionReader.upcast_to_ConnectionReader")) {
    return NULL;
  }
  // 1-ConnectionReader *QueuedConnectionReader::upcast_to_ConnectionReader(void)
  ConnectionReader *return_value = (ConnectionReader *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189_comment =
  "C++ Interface:\n"
  "upcast_to_ConnectionReader(const QueuedConnectionReader self)\n"
  "\n"
  "upcast from QueuedConnectionReader to ConnectionReader";
#else
static const char *Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedReturn< NetDatagram > *QueuedConnectionReader::upcast_to_QueuedReturn_NetDatagram(void)
 */
static PyObject *Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197(PyObject *self, PyObject *) {
  QueuedConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionReader, (void **)&local_this, "QueuedConnectionReader.upcast_to_QueuedReturn_NetDatagram")) {
    return NULL;
  }
  // 1-QueuedReturn< NetDatagram > *QueuedConnectionReader::upcast_to_QueuedReturn_NetDatagram(void)
  QueuedReturn< NetDatagram > *return_value = (QueuedReturn< NetDatagram > *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedReturn_NetDatagram, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197_comment =
  "C++ Interface:\n"
  "upcast_to_QueuedReturn_NetDatagram(const QueuedConnectionReader self)\n"
  "\n"
  "upcast from QueuedConnectionReader to QueuedReturn< NetDatagram >";
#else
static const char *Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedConnectionReader::QueuedConnectionReader(ConnectionManager *manager, int num_threads)
 */
static int Dtool_Init_QueuedConnectionReader(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-QueuedConnectionReader::QueuedConnectionReader(ConnectionManager *manager, int num_threads)
  PyObject *param0;
  int param1;
  static const char *keyword_list[] = {"manager", "num_threads", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:QueuedConnectionReader", (char **)keyword_list, &param0, &param1)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "QueuedConnectionReader.QueuedConnectionReader", false, true);
    if (param0_this != NULL) {
      QueuedConnectionReader *return_value = new QueuedConnectionReader(param0_this, (int)param1);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_QueuedConnectionReader, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "QueuedConnectionReader(ConnectionManager manager, int num_threads)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_QueuedConnectionReader(PyObject *args, QueuedConnectionReader const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_QueuedConnectionReader, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-QueuedConnectionReader::QueuedConnectionReader(ConnectionManager *manager, int num_threads)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:QueuedConnectionReader", &param0, &param1)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "QueuedConnectionReader.QueuedConnectionReader", false, false);
        if (param0_this != NULL) {
          QueuedConnectionReader *return_value = new QueuedConnectionReader(param0_this, (int)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_QueuedConnectionReader(PyObject *args, QueuedConnectionReader *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_QueuedConnectionReader, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-QueuedConnectionReader::QueuedConnectionReader(ConnectionManager *manager, int num_threads)
      PyObject *param0;
      int param1;
      if (PyArg_ParseTuple(args, "Oi:QueuedConnectionReader", &param0, &param1)) {
        ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "QueuedConnectionReader.QueuedConnectionReader", false, false);
        if (param0_this != NULL) {
          QueuedConnectionReader *return_value = new QueuedConnectionReader(param0_this, (int)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_QueuedConnectionReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_QueuedConnectionReader) {
    printf("QueuedConnectionReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  QueuedConnectionReader *local_this = (QueuedConnectionReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_QueuedConnectionReader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionReader) {
    return (ConnectionReader *) local_this;
  }
  if (requested_type == Dtool_Ptr_QueuedReturn_NetDatagram) {
    return (QueuedReturn< NetDatagram > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_QueuedConnectionReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_QueuedConnectionReader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    ConnectionReader* other_this = (ConnectionReader*)from_this;
    return (QueuedConnectionReader*)other_this;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_NetDatagram) {
    QueuedReturn< NetDatagram >* other_this = (QueuedReturn< NetDatagram >*)from_this;
    return (QueuedConnectionReader*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class QueuedReturn< NetDatagram >
 */
/**
 * Python function wrapper for:
 * void QueuedReturn< NetDatagram >::set_max_queue_size(int max_size)
 */
static PyObject *Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192(PyObject *self, PyObject *arg) {
  QueuedReturn< NetDatagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_NetDatagram, (void **)&local_this, "QueuedReturn_NetDatagram.set_max_queue_size")) {
    return NULL;
  }
  // 1-void QueuedReturn< NetDatagram >::set_max_queue_size(int max_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_max_queue_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_queue_size(const QueuedReturn self, int max_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192_comment =
  "C++ Interface:\n"
  "set_max_queue_size(const QueuedReturn self, int max_size)\n";
#else
static const char *Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< NetDatagram >::get_max_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193(PyObject *self, PyObject *) {
  QueuedReturn< NetDatagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_NetDatagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-int QueuedReturn< NetDatagram >::get_max_queue_size(void) const
  int return_value = (*(const QueuedReturn< NetDatagram >*)local_this).get_max_queue_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193_comment =
  "C++ Interface:\n"
  "get_max_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< NetDatagram >::get_current_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194(PyObject *self, PyObject *) {
  QueuedReturn< NetDatagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_NetDatagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-int QueuedReturn< NetDatagram >::get_current_queue_size(void) const
  int return_value = (*(const QueuedReturn< NetDatagram >*)local_this).get_current_queue_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194_comment =
  "C++ Interface:\n"
  "get_current_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool QueuedReturn< NetDatagram >::get_overflow_flag(void) const
 */
static PyObject *Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195(PyObject *self, PyObject *) {
  QueuedReturn< NetDatagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_QueuedReturn_NetDatagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool QueuedReturn< NetDatagram >::get_overflow_flag(void) const
  bool return_value = (*(const QueuedReturn< NetDatagram >*)local_this).get_overflow_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195_comment =
  "C++ Interface:\n"
  "get_overflow_flag(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void QueuedReturn< NetDatagram >::reset_overflow_flag(void)
 */
static PyObject *Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196(PyObject *self, PyObject *) {
  QueuedReturn< NetDatagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_NetDatagram, (void **)&local_this, "QueuedReturn_NetDatagram.reset_overflow_flag")) {
    return NULL;
  }
  // 1-void QueuedReturn< NetDatagram >::reset_overflow_flag(void)
  (*local_this).reset_overflow_flag();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196_comment =
  "C++ Interface:\n"
  "reset_overflow_flag(const QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * QueuedConnectionReader *QueuedReturn< NetDatagram >::downcast_to_QueuedConnectionReader(void)
 */
static PyObject *Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_198(PyObject *self, PyObject *) {
  QueuedReturn< NetDatagram > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_NetDatagram, (void **)&local_this, "QueuedReturn_NetDatagram.downcast_to_QueuedConnectionReader")) {
    return NULL;
  }
  // 1-QueuedConnectionReader *QueuedReturn< NetDatagram >::downcast_to_QueuedConnectionReader(void)
  QueuedConnectionReader *return_value = (QueuedConnectionReader *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedConnectionReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_198_comment =
  "C++ Interface:\n"
  "downcast_to_QueuedConnectionReader(const QueuedReturn self)\n"
  "\n"
  "downcast from QueuedReturn< NetDatagram > to QueuedConnectionReader";
#else
static const char *Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_198_comment = NULL;
#endif

static int Dtool_Init_QueuedReturn_NetDatagram(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_QueuedReturn_NetDatagram(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_QueuedReturn_NetDatagram) {
    printf("QueuedReturn_NetDatagram ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  QueuedReturn< NetDatagram > *local_this = (QueuedReturn< NetDatagram > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_QueuedReturn_NetDatagram) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_QueuedReturn_NetDatagram(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_NetDatagram) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class RecentConnectionReader
 */
/**
 * Python function wrapper for:
 * bool RecentConnectionReader::data_available(void)
 */
static PyObject *Dtool_RecentConnectionReader_data_available_205(PyObject *self, PyObject *) {
  RecentConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecentConnectionReader, (void **)&local_this, "RecentConnectionReader.data_available")) {
    return NULL;
  }
  // 1-bool RecentConnectionReader::data_available(void)
  bool return_value = (*local_this).data_available();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecentConnectionReader_data_available_205_comment =
  "C++ Interface:\n"
  "data_available(const RecentConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if a datagram is available on the queue; call get_data() to\n"
  " * extract the datagram.\n"
  " */";
#else
static const char *Dtool_RecentConnectionReader_data_available_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool RecentConnectionReader::get_data(Datagram &result)
 * bool RecentConnectionReader::get_data(NetDatagram &result)
 */
static PyObject *Dtool_RecentConnectionReader_get_data_206(PyObject *self, PyObject *arg) {
  RecentConnectionReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecentConnectionReader, (void **)&local_this, "RecentConnectionReader.get_data")) {
    return NULL;
  }
  {
    // -2 bool RecentConnectionReader::get_data(NetDatagram &result)
    NetDatagram *arg_this = (NetDatagram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NetDatagram, 1, "RecentConnectionReader.get_data", false, false);
    if (arg_this != NULL) {
      bool return_value = (*local_this).get_data(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool RecentConnectionReader::get_data(Datagram &result)
    Datagram *arg_this = (Datagram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Datagram, 1, "RecentConnectionReader.get_data", false, false);
    if (arg_this != NULL) {
      bool return_value = (*local_this).get_data(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool RecentConnectionReader::get_data(NetDatagram &result)
    NetDatagram *arg_this;
    bool arg_manage = false;
    if (Dtool_Coerce_NetDatagram(arg, arg_this, arg_manage)) {
      bool return_value = (*local_this).get_data(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool RecentConnectionReader::get_data(Datagram &result)
    Datagram *arg_this;
    bool arg_manage = false;
    if (Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
      bool return_value = (*local_this).get_data(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_data(const RecentConnectionReader self, NetDatagram result)\n"
      "get_data(const RecentConnectionReader self, Datagram result)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RecentConnectionReader_get_data_206_comment =
  "C++ Interface:\n"
  "get_data(const RecentConnectionReader self, NetDatagram result)\n"
  "get_data(const RecentConnectionReader self, Datagram result)\n"
  "\n"
  "/**\n"
  " * If a previous call to data_available() returned true, this function will\n"
  " * return the datagram that has become available.\n"
  " *\n"
  " * The return value is true if a datagram was successfully returned, or false\n"
  " * if there was, in fact, no datagram available.  (This may happen if there\n"
  " * are multiple threads accessing the RecentConnectionReader).\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of RecentConnectionReader::get_data(), works like the other,\n"
  " * except that it only fills a Datagram object, not a NetDatagram object.\n"
  " * This means that the Datagram cannot be queried for its source Connection\n"
  " * and/or NetAddress, but it is useful in all other respects.\n"
  " */";
#else
static const char *Dtool_RecentConnectionReader_get_data_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * RecentConnectionReader::RecentConnectionReader(ConnectionManager *manager)
 */
static int Dtool_Init_RecentConnectionReader(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RecentConnectionReader() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "manager");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'manager' (pos 1) not found");
    return -1;
  }
  // 1-RecentConnectionReader::RecentConnectionReader(ConnectionManager *manager)
  ConnectionManager *arg_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConnectionManager, 0, "RecentConnectionReader.RecentConnectionReader", false, true);
  if (arg_this != NULL) {
    RecentConnectionReader *return_value = new RecentConnectionReader(arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RecentConnectionReader, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RecentConnectionReader(ConnectionManager manager)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_RecentConnectionReader(PyObject *args, RecentConnectionReader const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_RecentConnectionReader, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-RecentConnectionReader::RecentConnectionReader(ConnectionManager *manager)
    ConnectionManager *arg_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConnectionManager, 0, "RecentConnectionReader.RecentConnectionReader", false, false);
    if (arg_this != NULL) {
      RecentConnectionReader *return_value = new RecentConnectionReader(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_RecentConnectionReader(PyObject *args, RecentConnectionReader *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_RecentConnectionReader, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-RecentConnectionReader::RecentConnectionReader(ConnectionManager *manager)
    ConnectionManager *arg_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConnectionManager, 0, "RecentConnectionReader.RecentConnectionReader", false, false);
    if (arg_this != NULL) {
      RecentConnectionReader *return_value = new RecentConnectionReader(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_RecentConnectionReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_RecentConnectionReader) {
    printf("RecentConnectionReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  RecentConnectionReader *local_this = (RecentConnectionReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_RecentConnectionReader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionReader) {
    return (ConnectionReader *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_RecentConnectionReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_RecentConnectionReader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    ConnectionReader* other_this = (ConnectionReader*)from_this;
    return (RecentConnectionReader*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for PointerTo_Connection (PointerTo_Connection)
 */
static PyMethodDef Dtool_Methods_PointerTo_Connection[] = {
  {"p", &Dtool_PointerTo_Connection_p_8, METH_NOARGS, (const char *)Dtool_PointerTo_Connection_p_8_comment},
  {"assign", &Dtool_PointerTo_Connection_operator_9, METH_O, (const char *)Dtool_PointerTo_Connection_operator_9_comment},
  {"is_null", &Dtool_PointerTo_Connection_is_null_10, METH_NOARGS, (const char *)Dtool_PointerTo_Connection_is_null_10_comment},
  {"isNull", &Dtool_PointerTo_Connection_is_null_10, METH_NOARGS, (const char *)Dtool_PointerTo_Connection_is_null_10_comment},
  {"clear", &Dtool_PointerTo_Connection_clear_11, METH_NOARGS, (const char *)Dtool_PointerTo_Connection_clear_11_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerTo_Connection = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerTo_Connection = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerTo_Connection = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerTo_Connection = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerTo_Connection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerTo_Connection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerTo_Connection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerTo_Connection,
    &Dtool_SequenceMethods_PointerTo_Connection,
    &Dtool_MappingMethods_PointerTo_Connection,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerTo_Connection,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerTo_Connection,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerTo_Connection,
    PyType_GenericAlloc,
    Dtool_new_PointerTo_Connection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerTo_Connection,
  Dtool_UpcastInterface_PointerTo_Connection,
  Dtool_DowncastInterface_PointerTo_Connection,
  (CoerceFunction)Dtool_ConstCoerce_PointerTo_Connection,
  (CoerceFunction)Dtool_Coerce_PointerTo_Connection,
};

static void Dtool_PyModuleClassInit_PointerTo_Connection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_Connection(NULL);
    Dtool_PointerTo_Connection._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_Connection);
    PyObject *dict = PyDict_New();
    Dtool_PointerTo_Connection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerTo_Connection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerTo_Connection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerTo_Connection);
  }
}

/**
 * Python method tables for PointerToBase_Connection (PointerToBase_Connection)
 */
static PyMethodDef Dtool_Methods_PointerToBase_Connection[] = {
  {"clear", &Dtool_PointerToBase_Connection_clear_4, METH_NOARGS, (const char *)Dtool_PointerToBase_Connection_clear_4_comment},
  {"output", &Dtool_PointerToBase_Connection_output_5, METH_O, (const char *)Dtool_PointerToBase_Connection_output_5_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_Connection
//////////////////
static PyObject *Dtool_Repr_PointerToBase_Connection(PyObject *self) {
  PointerToBase< Connection > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_Connection, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_Connection = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_Connection = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_Connection = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_Connection = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_Connection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_Connection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_Connection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_Connection,
    &Dtool_NumberMethods_PointerToBase_Connection,
    &Dtool_SequenceMethods_PointerToBase_Connection,
    &Dtool_MappingMethods_PointerToBase_Connection,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_Connection,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_Connection,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_Connection,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_Connection,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_Connection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_Connection,
  Dtool_UpcastInterface_PointerToBase_Connection,
  Dtool_DowncastInterface_PointerToBase_Connection,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_Connection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != NULL);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerToBase_Connection._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_Connection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_Connection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_Connection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_Connection);
  }
}

/**
 * Python method tables for NetAddress (NetAddress)
 */
static PyMethodDef Dtool_Methods_NetAddress[] = {
  {"set_any", &Dtool_NetAddress_set_any_14, METH_O, (const char *)Dtool_NetAddress_set_any_14_comment},
  {"setAny", &Dtool_NetAddress_set_any_14, METH_O, (const char *)Dtool_NetAddress_set_any_14_comment},
  {"set_localhost", &Dtool_NetAddress_set_localhost_15, METH_O, (const char *)Dtool_NetAddress_set_localhost_15_comment},
  {"setLocalhost", &Dtool_NetAddress_set_localhost_15, METH_O, (const char *)Dtool_NetAddress_set_localhost_15_comment},
  {"set_broadcast", &Dtool_NetAddress_set_broadcast_16, METH_O, (const char *)Dtool_NetAddress_set_broadcast_16_comment},
  {"setBroadcast", &Dtool_NetAddress_set_broadcast_16, METH_O, (const char *)Dtool_NetAddress_set_broadcast_16_comment},
  {"set_host", (PyCFunction) &Dtool_NetAddress_set_host_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetAddress_set_host_17_comment},
  {"setHost", (PyCFunction) &Dtool_NetAddress_set_host_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetAddress_set_host_17_comment},
  {"clear", &Dtool_NetAddress_clear_18, METH_NOARGS, (const char *)Dtool_NetAddress_clear_18_comment},
  {"get_port", &Dtool_NetAddress_get_port_19, METH_NOARGS, (const char *)Dtool_NetAddress_get_port_19_comment},
  {"getPort", &Dtool_NetAddress_get_port_19, METH_NOARGS, (const char *)Dtool_NetAddress_get_port_19_comment},
  {"set_port", &Dtool_NetAddress_set_port_20, METH_O, (const char *)Dtool_NetAddress_set_port_20_comment},
  {"setPort", &Dtool_NetAddress_set_port_20, METH_O, (const char *)Dtool_NetAddress_set_port_20_comment},
  {"get_ip_string", &Dtool_NetAddress_get_ip_string_21, METH_NOARGS, (const char *)Dtool_NetAddress_get_ip_string_21_comment},
  {"getIpString", &Dtool_NetAddress_get_ip_string_21, METH_NOARGS, (const char *)Dtool_NetAddress_get_ip_string_21_comment},
  {"is_any", &Dtool_NetAddress_is_any_22, METH_NOARGS, (const char *)Dtool_NetAddress_is_any_22_comment},
  {"isAny", &Dtool_NetAddress_is_any_22, METH_NOARGS, (const char *)Dtool_NetAddress_is_any_22_comment},
  {"get_ip", &Dtool_NetAddress_get_ip_23, METH_NOARGS, (const char *)Dtool_NetAddress_get_ip_23_comment},
  {"getIp", &Dtool_NetAddress_get_ip_23, METH_NOARGS, (const char *)Dtool_NetAddress_get_ip_23_comment},
  {"get_ip_component", &Dtool_NetAddress_get_ip_component_24, METH_O, (const char *)Dtool_NetAddress_get_ip_component_24_comment},
  {"getIpComponent", &Dtool_NetAddress_get_ip_component_24, METH_O, (const char *)Dtool_NetAddress_get_ip_component_24_comment},
  {"get_addr", &Dtool_NetAddress_get_addr_25, METH_NOARGS, (const char *)Dtool_NetAddress_get_addr_25_comment},
  {"getAddr", &Dtool_NetAddress_get_addr_25, METH_NOARGS, (const char *)Dtool_NetAddress_get_addr_25_comment},
  {"output", &Dtool_NetAddress_output_26, METH_O, (const char *)Dtool_NetAddress_output_26_comment},
  {"get_hash", &Dtool_NetAddress_get_hash_27, METH_NOARGS, (const char *)Dtool_NetAddress_get_hash_27_comment},
  {"getHash", &Dtool_NetAddress_get_hash_27, METH_NOARGS, (const char *)Dtool_NetAddress_get_hash_27_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// NetAddress slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_NetAddress_get_hash_27_tp_hash(PyObject *self) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
//  A __repr__ function
//     NetAddress
//////////////////
static PyObject *Dtool_Repr_NetAddress(PyObject *self) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     NetAddress
//////////////////
static PyObject *Dtool_RichCompare_NetAddress(PyObject *self, PyObject *arg, int op) {
  NetAddress *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-bool NetAddress::operator ==(NetAddress const &other) const
      NetAddress const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_NetAddress(arg, arg_this, arg_manage)) {
        bool return_value = (*(const NetAddress*)local_this).operator ==(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-bool NetAddress::operator !=(NetAddress const &other) const
      NetAddress const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_NetAddress(arg, arg_this, arg_manage)) {
        bool return_value = (*(const NetAddress*)local_this).operator !=(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_NetAddress = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_NetAddress = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NetAddress",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NetAddress,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    &Dtool_Repr_NetAddress,
    &Dtool_NumberMethods_NetAddress,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &Dtool_NetAddress_get_hash_27_tp_hash,
    0, // tp_call
    &Dtool_Repr_NetAddress,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents a network address to which UDP packets may be sent or to which a\n"
    " * TCP socket may be bound.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_NetAddress,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NetAddress,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NetAddress,
    PyType_GenericAlloc,
    Dtool_new_NetAddress,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NetAddress,
  Dtool_UpcastInterface_NetAddress,
  Dtool_DowncastInterface_NetAddress,
  (CoerceFunction)Dtool_ConstCoerce_NetAddress,
  (CoerceFunction)Dtool_Coerce_NetAddress,
};

static void Dtool_PyModuleClassInit_NetAddress(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NetAddress._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_NetAddress._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NetAddress) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NetAddress)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NetAddress);
  }
}

/**
 * Python method tables for Connection (Connection)
 */
static PyMethodDef Dtool_Methods_Connection[] = {
  {"get_address", &Dtool_Connection_get_address_34, METH_NOARGS, (const char *)Dtool_Connection_get_address_34_comment},
  {"getAddress", &Dtool_Connection_get_address_34, METH_NOARGS, (const char *)Dtool_Connection_get_address_34_comment},
  {"get_manager", &Dtool_Connection_get_manager_35, METH_NOARGS, (const char *)Dtool_Connection_get_manager_35_comment},
  {"getManager", &Dtool_Connection_get_manager_35, METH_NOARGS, (const char *)Dtool_Connection_get_manager_35_comment},
  {"get_socket", &Dtool_Connection_get_socket_36, METH_NOARGS, (const char *)Dtool_Connection_get_socket_36_comment},
  {"getSocket", &Dtool_Connection_get_socket_36, METH_NOARGS, (const char *)Dtool_Connection_get_socket_36_comment},
  {"set_collect_tcp", &Dtool_Connection_set_collect_tcp_37, METH_O, (const char *)Dtool_Connection_set_collect_tcp_37_comment},
  {"setCollectTcp", &Dtool_Connection_set_collect_tcp_37, METH_O, (const char *)Dtool_Connection_set_collect_tcp_37_comment},
  {"get_collect_tcp", &Dtool_Connection_get_collect_tcp_38, METH_NOARGS, (const char *)Dtool_Connection_get_collect_tcp_38_comment},
  {"getCollectTcp", &Dtool_Connection_get_collect_tcp_38, METH_NOARGS, (const char *)Dtool_Connection_get_collect_tcp_38_comment},
  {"set_collect_tcp_interval", &Dtool_Connection_set_collect_tcp_interval_39, METH_O, (const char *)Dtool_Connection_set_collect_tcp_interval_39_comment},
  {"setCollectTcpInterval", &Dtool_Connection_set_collect_tcp_interval_39, METH_O, (const char *)Dtool_Connection_set_collect_tcp_interval_39_comment},
  {"get_collect_tcp_interval", &Dtool_Connection_get_collect_tcp_interval_40, METH_NOARGS, (const char *)Dtool_Connection_get_collect_tcp_interval_40_comment},
  {"getCollectTcpInterval", &Dtool_Connection_get_collect_tcp_interval_40, METH_NOARGS, (const char *)Dtool_Connection_get_collect_tcp_interval_40_comment},
  {"consider_flush", &Dtool_Connection_consider_flush_41, METH_NOARGS, (const char *)Dtool_Connection_consider_flush_41_comment},
  {"considerFlush", &Dtool_Connection_consider_flush_41, METH_NOARGS, (const char *)Dtool_Connection_consider_flush_41_comment},
  {"flush", &Dtool_Connection_flush_42, METH_NOARGS, (const char *)Dtool_Connection_flush_42_comment},
  {"set_linger", (PyCFunction) &Dtool_Connection_set_linger_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Connection_set_linger_43_comment},
  {"setLinger", (PyCFunction) &Dtool_Connection_set_linger_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Connection_set_linger_43_comment},
  {"set_reuse_addr", &Dtool_Connection_set_reuse_addr_44, METH_O, (const char *)Dtool_Connection_set_reuse_addr_44_comment},
  {"setReuseAddr", &Dtool_Connection_set_reuse_addr_44, METH_O, (const char *)Dtool_Connection_set_reuse_addr_44_comment},
  {"set_keep_alive", &Dtool_Connection_set_keep_alive_45, METH_O, (const char *)Dtool_Connection_set_keep_alive_45_comment},
  {"setKeepAlive", &Dtool_Connection_set_keep_alive_45, METH_O, (const char *)Dtool_Connection_set_keep_alive_45_comment},
  {"set_recv_buffer_size", &Dtool_Connection_set_recv_buffer_size_46, METH_O, (const char *)Dtool_Connection_set_recv_buffer_size_46_comment},
  {"setRecvBufferSize", &Dtool_Connection_set_recv_buffer_size_46, METH_O, (const char *)Dtool_Connection_set_recv_buffer_size_46_comment},
  {"set_send_buffer_size", &Dtool_Connection_set_send_buffer_size_47, METH_O, (const char *)Dtool_Connection_set_send_buffer_size_47_comment},
  {"setSendBufferSize", &Dtool_Connection_set_send_buffer_size_47, METH_O, (const char *)Dtool_Connection_set_send_buffer_size_47_comment},
  {"set_ip_time_to_live", &Dtool_Connection_set_ip_time_to_live_48, METH_O, (const char *)Dtool_Connection_set_ip_time_to_live_48_comment},
  {"setIpTimeToLive", &Dtool_Connection_set_ip_time_to_live_48, METH_O, (const char *)Dtool_Connection_set_ip_time_to_live_48_comment},
  {"set_ip_type_of_service", &Dtool_Connection_set_ip_type_of_service_49, METH_O, (const char *)Dtool_Connection_set_ip_type_of_service_49_comment},
  {"setIpTypeOfService", &Dtool_Connection_set_ip_type_of_service_49, METH_O, (const char *)Dtool_Connection_set_ip_type_of_service_49_comment},
  {"set_no_delay", &Dtool_Connection_set_no_delay_50, METH_O, (const char *)Dtool_Connection_set_no_delay_50_comment},
  {"setNoDelay", &Dtool_Connection_set_no_delay_50, METH_O, (const char *)Dtool_Connection_set_no_delay_50_comment},
  {"set_max_segment", &Dtool_Connection_set_max_segment_51, METH_O, (const char *)Dtool_Connection_set_max_segment_51_comment},
  {"setMaxSegment", &Dtool_Connection_set_max_segment_51, METH_O, (const char *)Dtool_Connection_set_max_segment_51_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Connection = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Connection = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Connection = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Connection = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Connection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Connection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Connection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Connection,
    &Dtool_SequenceMethods_Connection,
    &Dtool_MappingMethods_Connection,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Connection,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents a single TCP or UDP socket for input or output.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Connection,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Connection,
    PyType_GenericAlloc,
    Dtool_new_Connection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Connection,
  Dtool_UpcastInterface_Connection,
  Dtool_DowncastInterface_Connection,
  (CoerceFunction)Dtool_ConstCoerce_Connection,
  (CoerceFunction)Dtool_Coerce_Connection,
};

static void Dtool_PyModuleClassInit_Connection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_Connection._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_Connection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Connection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Connection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Connection);
  }
}

/**
 * Python method tables for ConnectionReader (ConnectionReader)
 */
static PyMethodDef Dtool_Methods_ConnectionReader[] = {
  {"add_connection", &Dtool_ConnectionReader_add_connection_54, METH_O, (const char *)Dtool_ConnectionReader_add_connection_54_comment},
  {"addConnection", &Dtool_ConnectionReader_add_connection_54, METH_O, (const char *)Dtool_ConnectionReader_add_connection_54_comment},
  {"remove_connection", &Dtool_ConnectionReader_remove_connection_55, METH_O, (const char *)Dtool_ConnectionReader_remove_connection_55_comment},
  {"removeConnection", &Dtool_ConnectionReader_remove_connection_55, METH_O, (const char *)Dtool_ConnectionReader_remove_connection_55_comment},
  {"is_connection_ok", &Dtool_ConnectionReader_is_connection_ok_56, METH_O, (const char *)Dtool_ConnectionReader_is_connection_ok_56_comment},
  {"isConnectionOk", &Dtool_ConnectionReader_is_connection_ok_56, METH_O, (const char *)Dtool_ConnectionReader_is_connection_ok_56_comment},
  {"poll", &Dtool_ConnectionReader_poll_57, METH_NOARGS, (const char *)Dtool_ConnectionReader_poll_57_comment},
  {"get_manager", &Dtool_ConnectionReader_get_manager_58, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_manager_58_comment},
  {"getManager", &Dtool_ConnectionReader_get_manager_58, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_manager_58_comment},
  {"is_polling", &Dtool_ConnectionReader_is_polling_59, METH_NOARGS, (const char *)Dtool_ConnectionReader_is_polling_59_comment},
  {"isPolling", &Dtool_ConnectionReader_is_polling_59, METH_NOARGS, (const char *)Dtool_ConnectionReader_is_polling_59_comment},
  {"get_num_threads", &Dtool_ConnectionReader_get_num_threads_60, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_num_threads_60_comment},
  {"getNumThreads", &Dtool_ConnectionReader_get_num_threads_60, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_num_threads_60_comment},
  {"set_raw_mode", &Dtool_ConnectionReader_set_raw_mode_61, METH_O, (const char *)Dtool_ConnectionReader_set_raw_mode_61_comment},
  {"setRawMode", &Dtool_ConnectionReader_set_raw_mode_61, METH_O, (const char *)Dtool_ConnectionReader_set_raw_mode_61_comment},
  {"get_raw_mode", &Dtool_ConnectionReader_get_raw_mode_62, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_raw_mode_62_comment},
  {"getRawMode", &Dtool_ConnectionReader_get_raw_mode_62, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_raw_mode_62_comment},
  {"set_tcp_header_size", &Dtool_ConnectionReader_set_tcp_header_size_63, METH_O, (const char *)Dtool_ConnectionReader_set_tcp_header_size_63_comment},
  {"setTcpHeaderSize", &Dtool_ConnectionReader_set_tcp_header_size_63, METH_O, (const char *)Dtool_ConnectionReader_set_tcp_header_size_63_comment},
  {"get_tcp_header_size", &Dtool_ConnectionReader_get_tcp_header_size_64, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_tcp_header_size_64_comment},
  {"getTcpHeaderSize", &Dtool_ConnectionReader_get_tcp_header_size_64, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_tcp_header_size_64_comment},
  {"shutdown", &Dtool_ConnectionReader_shutdown_65, METH_NOARGS, (const char *)Dtool_ConnectionReader_shutdown_65_comment},
  {"downcast_to_DatagramGeneratorNet", &Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_131, METH_NOARGS, (const char *)Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_131_comment},
  {"downcastToDatagramGeneratorNet", &Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_131, METH_NOARGS, (const char *)Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_131_comment},
  {"downcast_to_QueuedConnectionReader", &Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_190, METH_NOARGS, (const char *)Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_190_comment},
  {"downcastToQueuedConnectionReader", &Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_190, METH_NOARGS, (const char *)Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_190_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ConnectionReader = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ConnectionReader = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConnectionReader",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConnectionReader,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConnectionReader,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an abstract base class for a family of classes that listen for\n"
    " * activity on a socket and respond to it, for instance by reading a datagram\n"
    " * and serving it (or queueing it up for later service).\n"
    " *\n"
    " * A ConnectionReader may define an arbitrary number of threads (at least one)\n"
    " * to process datagrams coming in from an arbitrary number of sockets that it\n"
    " * is monitoring.  The number of threads is specified at construction time and\n"
    " * cannot be changed, but the set of sockets that is to be monitored may be\n"
    " * constantly modified at will.\n"
    " *\n"
    " * This is an abstract class because it doesn't define how to process each\n"
    " * received datagram.  See QueuedConnectionReader.  Also note that\n"
    " * ConnectionListener derives from this class, extending it to accept\n"
    " * connections on a rendezvous socket rather than read datagrams.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConnectionReader,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConnectionReader,
    PyType_GenericAlloc,
    Dtool_new_ConnectionReader,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConnectionReader,
  Dtool_UpcastInterface_ConnectionReader,
  Dtool_DowncastInterface_ConnectionReader,
  (CoerceFunction)Dtool_ConstCoerce_ConnectionReader,
  (CoerceFunction)Dtool_Coerce_ConnectionReader,
};

static void Dtool_PyModuleClassInit_ConnectionReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConnectionReader._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ConnectionReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConnectionReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConnectionReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConnectionReader);
  }
}

/**
 * Python method tables for ConnectionListener (ConnectionListener)
 */
static PyMethodDef Dtool_Methods_ConnectionListener[] = {
  {"downcast_to_QueuedConnectionListener", &Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_160, METH_NOARGS, (const char *)Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_160_comment},
  {"downcastToQueuedConnectionListener", &Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_160, METH_NOARGS, (const char *)Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_160_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ConnectionListener = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConnectionListener = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConnectionListener = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConnectionListener = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConnectionListener = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConnectionListener",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConnectionListener,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConnectionListener,
    &Dtool_SequenceMethods_ConnectionListener,
    &Dtool_MappingMethods_ConnectionListener,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConnectionListener,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special kind of ConnectionReader that waits for activity on a\n"
    " * rendezvous port and accepts a TCP connection (instead of attempting to read\n"
    " * a datagram from the rendezvous port).\n"
    " *\n"
    " * It is itself an abstract class, as it doesn't define what to do with the\n"
    " * established connection.  See QueuedConnectionListener.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConnectionListener,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConnectionListener,
    PyType_GenericAlloc,
    Dtool_new_ConnectionListener,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConnectionListener,
  Dtool_UpcastInterface_ConnectionListener,
  Dtool_DowncastInterface_ConnectionListener,
  (CoerceFunction)Dtool_ConstCoerce_ConnectionListener,
  (CoerceFunction)Dtool_Coerce_ConnectionListener,
};

static void Dtool_PyModuleClassInit_ConnectionListener(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConnectionReader(NULL);
    Dtool_ConnectionListener._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConnectionReader);
    PyObject *dict = PyDict_New();
    Dtool_ConnectionListener._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConnectionListener) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConnectionListener)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConnectionListener);
  }
}

/**
 * Python method tables for NetDatagram (NetDatagram)
 */
static PyMethodDef Dtool_Methods_NetDatagram[] = {
  {"assign", &Dtool_NetDatagram_operator_71, METH_O, (const char *)Dtool_NetDatagram_operator_71_comment},
  {"set_connection", &Dtool_NetDatagram_set_connection_72, METH_O, (const char *)Dtool_NetDatagram_set_connection_72_comment},
  {"setConnection", &Dtool_NetDatagram_set_connection_72, METH_O, (const char *)Dtool_NetDatagram_set_connection_72_comment},
  {"get_connection", &Dtool_NetDatagram_get_connection_73, METH_NOARGS, (const char *)Dtool_NetDatagram_get_connection_73_comment},
  {"getConnection", &Dtool_NetDatagram_get_connection_73, METH_NOARGS, (const char *)Dtool_NetDatagram_get_connection_73_comment},
  {"set_address", &Dtool_NetDatagram_set_address_74, METH_O, (const char *)Dtool_NetDatagram_set_address_74_comment},
  {"setAddress", &Dtool_NetDatagram_set_address_74, METH_O, (const char *)Dtool_NetDatagram_set_address_74_comment},
  {"get_address", &Dtool_NetDatagram_get_address_75, METH_NOARGS, (const char *)Dtool_NetDatagram_get_address_75_comment},
  {"getAddress", &Dtool_NetDatagram_get_address_75, METH_NOARGS, (const char *)Dtool_NetDatagram_get_address_75_comment},
  {"get_class_type", &Dtool_NetDatagram_get_class_type_76, METH_NOARGS | METH_STATIC, (const char *)Dtool_NetDatagram_get_class_type_76_comment},
  {"getClassType", &Dtool_NetDatagram_get_class_type_76, METH_NOARGS | METH_STATIC, (const char *)Dtool_NetDatagram_get_class_type_76_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_NetDatagram = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NetDatagram = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NetDatagram = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NetDatagram = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NetDatagram = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NetDatagram",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NetDatagram,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NetDatagram,
    &Dtool_SequenceMethods_NetDatagram,
    &Dtool_MappingMethods_NetDatagram,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NetDatagram,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specific kind of Datagram, especially for sending across or receiving\n"
    " * from a network.  It's different only in that it knows which Connection\n"
    " * and/or NetAddress it is to be sent to or was received from.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NetDatagram,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NetDatagram,
    PyType_GenericAlloc,
    Dtool_new_NetDatagram,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NetDatagram,
  Dtool_UpcastInterface_NetDatagram,
  Dtool_DowncastInterface_NetDatagram,
  (CoerceFunction)Dtool_ConstCoerce_NetDatagram,
  (CoerceFunction)Dtool_Coerce_NetDatagram,
};

static void Dtool_PyModuleClassInit_NetDatagram(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Datagram != NULL);
    assert(Dtool_Ptr_Datagram->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Datagram->_Dtool_ModuleClassInit(NULL);
    Dtool_NetDatagram._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Datagram);
    PyObject *dict = PyDict_New();
    Dtool_NetDatagram._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NetDatagram) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NetDatagram)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NetDatagram);
  }
}

/**
 * Python method tables for ConnectionManager_Interface (Interface)
 */
static PyMethodDef Dtool_Methods_ConnectionManager_Interface[] = {
  {"get_name", &Dtool_ConnectionManager_Interface_get_name_88, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_name_88_comment},
  {"getName", &Dtool_ConnectionManager_Interface_get_name_88, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_name_88_comment},
  {"get_mac_address", &Dtool_ConnectionManager_Interface_get_mac_address_89, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_mac_address_89_comment},
  {"getMacAddress", &Dtool_ConnectionManager_Interface_get_mac_address_89, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_mac_address_89_comment},
  {"has_ip", &Dtool_ConnectionManager_Interface_has_ip_90, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_ip_90_comment},
  {"hasIp", &Dtool_ConnectionManager_Interface_has_ip_90, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_ip_90_comment},
  {"get_ip", &Dtool_ConnectionManager_Interface_get_ip_91, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_ip_91_comment},
  {"getIp", &Dtool_ConnectionManager_Interface_get_ip_91, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_ip_91_comment},
  {"has_netmask", &Dtool_ConnectionManager_Interface_has_netmask_92, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_netmask_92_comment},
  {"hasNetmask", &Dtool_ConnectionManager_Interface_has_netmask_92, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_netmask_92_comment},
  {"get_netmask", &Dtool_ConnectionManager_Interface_get_netmask_93, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_netmask_93_comment},
  {"getNetmask", &Dtool_ConnectionManager_Interface_get_netmask_93, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_netmask_93_comment},
  {"has_broadcast", &Dtool_ConnectionManager_Interface_has_broadcast_94, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_broadcast_94_comment},
  {"hasBroadcast", &Dtool_ConnectionManager_Interface_has_broadcast_94, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_broadcast_94_comment},
  {"get_broadcast", &Dtool_ConnectionManager_Interface_get_broadcast_95, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_broadcast_95_comment},
  {"getBroadcast", &Dtool_ConnectionManager_Interface_get_broadcast_95, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_broadcast_95_comment},
  {"has_p2p", &Dtool_ConnectionManager_Interface_has_p2p_96, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_p2p_96_comment},
  {"hasP2p", &Dtool_ConnectionManager_Interface_has_p2p_96, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_p2p_96_comment},
  {"get_p2p", &Dtool_ConnectionManager_Interface_get_p2p_97, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_p2p_97_comment},
  {"getP2p", &Dtool_ConnectionManager_Interface_get_p2p_97, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_p2p_97_comment},
  {"output", &Dtool_ConnectionManager_Interface_output_98, METH_O, (const char *)Dtool_ConnectionManager_Interface_output_98_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ConnectionManager_Interface
//////////////////
static PyObject *Dtool_Repr_ConnectionManager_Interface(PyObject *self) {
  ConnectionManager::Interface *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ConnectionManager_Interface = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ConnectionManager_Interface = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Interface",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConnectionManager_Interface,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ConnectionManager_Interface,
    &Dtool_NumberMethods_ConnectionManager_Interface,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_ConnectionManager_Interface,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConnectionManager_Interface,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConnectionManager_Interface,
    PyType_GenericAlloc,
    Dtool_new_ConnectionManager_Interface,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConnectionManager_Interface,
  Dtool_UpcastInterface_ConnectionManager_Interface,
  Dtool_DowncastInterface_ConnectionManager_Interface,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ConnectionManager_Interface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConnectionManager_Interface._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ConnectionManager_Interface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConnectionManager_Interface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConnectionManager_Interface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConnectionManager_Interface);
  }
}

/**
 * Python method tables for ConnectionManager (ConnectionManager)
 */
static PyMethodDef Dtool_Methods_ConnectionManager[] = {
  {"open_UDP_connection", (PyCFunction) &Dtool_ConnectionManager_open_UDP_connection_81, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_UDP_connection_81_comment},
  {"openUDPConnection", (PyCFunction) &Dtool_ConnectionManager_open_UDP_connection_81, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_UDP_connection_81_comment},
  {"open_TCP_server_rendezvous", (PyCFunction) &Dtool_ConnectionManager_open_TCP_server_rendezvous_82, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_TCP_server_rendezvous_82_comment},
  {"openTCPServerRendezvous", (PyCFunction) &Dtool_ConnectionManager_open_TCP_server_rendezvous_82, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_TCP_server_rendezvous_82_comment},
  {"open_TCP_client_connection", (PyCFunction) &Dtool_ConnectionManager_open_TCP_client_connection_83, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_TCP_client_connection_83_comment},
  {"openTCPClientConnection", (PyCFunction) &Dtool_ConnectionManager_open_TCP_client_connection_83, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_TCP_client_connection_83_comment},
  {"close_connection", &Dtool_ConnectionManager_close_connection_84, METH_O, (const char *)Dtool_ConnectionManager_close_connection_84_comment},
  {"closeConnection", &Dtool_ConnectionManager_close_connection_84, METH_O, (const char *)Dtool_ConnectionManager_close_connection_84_comment},
  {"wait_for_readers", &Dtool_ConnectionManager_wait_for_readers_85, METH_O, (const char *)Dtool_ConnectionManager_wait_for_readers_85_comment},
  {"waitForReaders", &Dtool_ConnectionManager_wait_for_readers_85, METH_O, (const char *)Dtool_ConnectionManager_wait_for_readers_85_comment},
  {"get_host_name", &Dtool_ConnectionManager_get_host_name_86, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConnectionManager_get_host_name_86_comment},
  {"getHostName", &Dtool_ConnectionManager_get_host_name_86, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConnectionManager_get_host_name_86_comment},
  {"scan_interfaces", &Dtool_ConnectionManager_scan_interfaces_101, METH_NOARGS, (const char *)Dtool_ConnectionManager_scan_interfaces_101_comment},
  {"scanInterfaces", &Dtool_ConnectionManager_scan_interfaces_101, METH_NOARGS, (const char *)Dtool_ConnectionManager_scan_interfaces_101_comment},
  {"get_num_interfaces", &Dtool_ConnectionManager_get_num_interfaces_102, METH_NOARGS, (const char *)Dtool_ConnectionManager_get_num_interfaces_102_comment},
  {"getNumInterfaces", &Dtool_ConnectionManager_get_num_interfaces_102, METH_NOARGS, (const char *)Dtool_ConnectionManager_get_num_interfaces_102_comment},
  {"get_interface", &Dtool_ConnectionManager_get_interface_103, METH_O, (const char *)Dtool_ConnectionManager_get_interface_103_comment},
  {"getInterface", &Dtool_ConnectionManager_get_interface_103, METH_O, (const char *)Dtool_ConnectionManager_get_interface_103_comment},
  {"downcast_to_QueuedConnectionManager", &Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_175, METH_NOARGS, (const char *)Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_175_comment},
  {"downcastToQueuedConnectionManager", &Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_175, METH_NOARGS, (const char *)Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_175_comment},
  {"get_interfaces", (PyCFunction) &MakeSeq_ConnectionManager_get_interfaces, METH_NOARGS, NULL},
  { "getInterfaces", (PyCFunction) &MakeSeq_ConnectionManager_get_interfaces, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ConnectionManager[] = {
  {(char *)"host_name", &Dtool_ConnectionManager_host_name_Getter, NULL, NULL, NULL},
  {(char *)"interfaces", &Dtool_ConnectionManager_interfaces_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConnectionManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ConnectionManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConnectionManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConnectionManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConnectionManager,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The primary interface to the low-level networking layer in this package.  A\n"
    " * ConnectionManager is used to establish and destroy TCP and UDP connections.\n"
    " * Communication on these connections, once established, is handled via\n"
    " * ConnectionReader, ConnectionWriter, and ConnectionListener.\n"
    " *\n"
    " * You may use this class directly if you don't care about tracking which\n"
    " * connections have been unexpectedly closed; otherwise, you should use\n"
    " * QueuedConnectionManager to get reports about these events (or derive your\n"
    " * own class to handle these events properly).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConnectionManager,
    0, // tp_members
    Dtool_Properties_ConnectionManager,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConnectionManager,
    PyType_GenericAlloc,
    Dtool_new_ConnectionManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConnectionManager,
  Dtool_UpcastInterface_ConnectionManager,
  Dtool_DowncastInterface_ConnectionManager,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ConnectionManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConnectionManager._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ConnectionManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Nested Object   ConnectionManager_Interface;
    Dtool_PyModuleClassInit_ConnectionManager_Interface(NULL);
    PyDict_SetItemString(dict, "Interface", (PyObject *)&Dtool_ConnectionManager_Interface);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConnectionManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConnectionManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConnectionManager);
  }
}

/**
 * Python method tables for ConnectionWriter (ConnectionWriter)
 */
static PyMethodDef Dtool_Methods_ConnectionWriter[] = {
  {"set_max_queue_size", &Dtool_ConnectionWriter_set_max_queue_size_113, METH_O, (const char *)Dtool_ConnectionWriter_set_max_queue_size_113_comment},
  {"setMaxQueueSize", &Dtool_ConnectionWriter_set_max_queue_size_113, METH_O, (const char *)Dtool_ConnectionWriter_set_max_queue_size_113_comment},
  {"get_max_queue_size", &Dtool_ConnectionWriter_get_max_queue_size_114, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_max_queue_size_114_comment},
  {"getMaxQueueSize", &Dtool_ConnectionWriter_get_max_queue_size_114, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_max_queue_size_114_comment},
  {"get_current_queue_size", &Dtool_ConnectionWriter_get_current_queue_size_115, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_current_queue_size_115_comment},
  {"getCurrentQueueSize", &Dtool_ConnectionWriter_get_current_queue_size_115, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_current_queue_size_115_comment},
  {"send", (PyCFunction) &Dtool_ConnectionWriter_send_116, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionWriter_send_116_comment},
  {"is_valid_for_udp", &Dtool_ConnectionWriter_is_valid_for_udp_117, METH_O, (const char *)Dtool_ConnectionWriter_is_valid_for_udp_117_comment},
  {"isValidForUdp", &Dtool_ConnectionWriter_is_valid_for_udp_117, METH_O, (const char *)Dtool_ConnectionWriter_is_valid_for_udp_117_comment},
  {"get_manager", &Dtool_ConnectionWriter_get_manager_118, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_manager_118_comment},
  {"getManager", &Dtool_ConnectionWriter_get_manager_118, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_manager_118_comment},
  {"is_immediate", &Dtool_ConnectionWriter_is_immediate_119, METH_NOARGS, (const char *)Dtool_ConnectionWriter_is_immediate_119_comment},
  {"isImmediate", &Dtool_ConnectionWriter_is_immediate_119, METH_NOARGS, (const char *)Dtool_ConnectionWriter_is_immediate_119_comment},
  {"get_num_threads", &Dtool_ConnectionWriter_get_num_threads_120, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_num_threads_120_comment},
  {"getNumThreads", &Dtool_ConnectionWriter_get_num_threads_120, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_num_threads_120_comment},
  {"set_raw_mode", &Dtool_ConnectionWriter_set_raw_mode_121, METH_O, (const char *)Dtool_ConnectionWriter_set_raw_mode_121_comment},
  {"setRawMode", &Dtool_ConnectionWriter_set_raw_mode_121, METH_O, (const char *)Dtool_ConnectionWriter_set_raw_mode_121_comment},
  {"get_raw_mode", &Dtool_ConnectionWriter_get_raw_mode_122, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_raw_mode_122_comment},
  {"getRawMode", &Dtool_ConnectionWriter_get_raw_mode_122, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_raw_mode_122_comment},
  {"set_tcp_header_size", &Dtool_ConnectionWriter_set_tcp_header_size_123, METH_O, (const char *)Dtool_ConnectionWriter_set_tcp_header_size_123_comment},
  {"setTcpHeaderSize", &Dtool_ConnectionWriter_set_tcp_header_size_123, METH_O, (const char *)Dtool_ConnectionWriter_set_tcp_header_size_123_comment},
  {"get_tcp_header_size", &Dtool_ConnectionWriter_get_tcp_header_size_124, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_tcp_header_size_124_comment},
  {"getTcpHeaderSize", &Dtool_ConnectionWriter_get_tcp_header_size_124, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_tcp_header_size_124_comment},
  {"shutdown", &Dtool_ConnectionWriter_shutdown_125, METH_NOARGS, (const char *)Dtool_ConnectionWriter_shutdown_125_comment},
  {"downcast_to_DatagramSinkNet", &Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_150, METH_NOARGS, (const char *)Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_150_comment},
  {"downcastToDatagramSinkNet", &Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_150, METH_NOARGS, (const char *)Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_150_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ConnectionWriter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ConnectionWriter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConnectionWriter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConnectionWriter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConnectionWriter,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class handles threaded delivery of datagrams to various TCP or UDP\n"
    " * sockets.\n"
    " *\n"
    " * A ConnectionWriter may define an arbitrary number of threads (0 or more) to\n"
    " * write its datagrams to sockets.  The number of threads is specified at\n"
    " * construction time and cannot be changed.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConnectionWriter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConnectionWriter,
    PyType_GenericAlloc,
    Dtool_new_ConnectionWriter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConnectionWriter,
  Dtool_UpcastInterface_ConnectionWriter,
  Dtool_DowncastInterface_ConnectionWriter,
  (CoerceFunction)Dtool_ConstCoerce_ConnectionWriter,
  (CoerceFunction)Dtool_Coerce_ConnectionWriter,
};

static void Dtool_PyModuleClassInit_ConnectionWriter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConnectionWriter._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ConnectionWriter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConnectionWriter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConnectionWriter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConnectionWriter);
  }
}

/**
 * Python method tables for DatagramGeneratorNet (DatagramGeneratorNet)
 */
static PyMethodDef Dtool_Methods_DatagramGeneratorNet[] = {
  {"get_datagram", &Dtool_DatagramGeneratorNet_get_datagram_142, METH_O, (const char *)Dtool_DatagramGeneratorNet_get_datagram_142_comment},
  {"getDatagram", &Dtool_DatagramGeneratorNet_get_datagram_142, METH_O, (const char *)Dtool_DatagramGeneratorNet_get_datagram_142_comment},
  {"is_eof", &Dtool_DatagramGeneratorNet_is_eof_143, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_is_eof_143_comment},
  {"isEof", &Dtool_DatagramGeneratorNet_is_eof_143, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_is_eof_143_comment},
  {"is_error", &Dtool_DatagramGeneratorNet_is_error_144, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_is_error_144_comment},
  {"isError", &Dtool_DatagramGeneratorNet_is_error_144, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_is_error_144_comment},
  {"upcast_to_DatagramGenerator", &Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128_comment},
  {"upcastToDatagramGenerator", &Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128_comment},
  {"upcast_to_ConnectionReader", &Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130_comment},
  {"upcastToConnectionReader", &Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130_comment},
  {"upcast_to_QueuedReturn_Datagram", &Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138_comment},
  {"upcastToQueuedReturnDatagram", &Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DatagramGeneratorNet = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DatagramGeneratorNet = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DatagramGeneratorNet = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DatagramGeneratorNet = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DatagramGeneratorNet = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DatagramGeneratorNet",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramGeneratorNet,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DatagramGeneratorNet,
    &Dtool_SequenceMethods_DatagramGeneratorNet,
    &Dtool_MappingMethods_DatagramGeneratorNet,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DatagramGeneratorNet,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides datagrams one-at-a-time as read directly from the net,\n"
    " * via a TCP connection.  If a datagram is not available, get_datagram() will\n"
    " * block until one is.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DatagramGeneratorNet,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DatagramGeneratorNet,
    PyType_GenericAlloc,
    Dtool_new_DatagramGeneratorNet,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramGeneratorNet,
  Dtool_UpcastInterface_DatagramGeneratorNet,
  Dtool_DowncastInterface_DatagramGeneratorNet,
  (CoerceFunction)Dtool_ConstCoerce_DatagramGeneratorNet,
  (CoerceFunction)Dtool_Coerce_DatagramGeneratorNet,
};

static void Dtool_PyModuleClassInit_DatagramGeneratorNet(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DatagramGenerator != NULL);
    assert(Dtool_Ptr_DatagramGenerator->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DatagramGenerator->_Dtool_ModuleClassInit(NULL);
    Dtool_PyModuleClassInit_ConnectionReader(NULL);
    Dtool_PyModuleClassInit_QueuedReturn_Datagram(NULL);
    Dtool_DatagramGeneratorNet._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)Dtool_Ptr_DatagramGenerator, (PyTypeObject *)&Dtool_ConnectionReader, (PyTypeObject *)&Dtool_QueuedReturn_Datagram);
    PyObject *dict = PyDict_New();
    Dtool_DatagramGeneratorNet._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramGeneratorNet) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramGeneratorNet)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramGeneratorNet);
  }
}

/**
 * Python method tables for QueuedReturn_Datagram (QueuedReturn_Datagram)
 */
static PyMethodDef Dtool_Methods_QueuedReturn_Datagram[] = {
  {"set_max_queue_size", &Dtool_QueuedReturn_Datagram_set_max_queue_size_133, METH_O, (const char *)Dtool_QueuedReturn_Datagram_set_max_queue_size_133_comment},
  {"setMaxQueueSize", &Dtool_QueuedReturn_Datagram_set_max_queue_size_133, METH_O, (const char *)Dtool_QueuedReturn_Datagram_set_max_queue_size_133_comment},
  {"get_max_queue_size", &Dtool_QueuedReturn_Datagram_get_max_queue_size_134, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_max_queue_size_134_comment},
  {"getMaxQueueSize", &Dtool_QueuedReturn_Datagram_get_max_queue_size_134, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_max_queue_size_134_comment},
  {"get_current_queue_size", &Dtool_QueuedReturn_Datagram_get_current_queue_size_135, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_current_queue_size_135_comment},
  {"getCurrentQueueSize", &Dtool_QueuedReturn_Datagram_get_current_queue_size_135, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_current_queue_size_135_comment},
  {"get_overflow_flag", &Dtool_QueuedReturn_Datagram_get_overflow_flag_136, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_overflow_flag_136_comment},
  {"getOverflowFlag", &Dtool_QueuedReturn_Datagram_get_overflow_flag_136, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_overflow_flag_136_comment},
  {"reset_overflow_flag", &Dtool_QueuedReturn_Datagram_reset_overflow_flag_137, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_reset_overflow_flag_137_comment},
  {"resetOverflowFlag", &Dtool_QueuedReturn_Datagram_reset_overflow_flag_137, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_reset_overflow_flag_137_comment},
  {"downcast_to_DatagramGeneratorNet", &Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_139, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_139_comment},
  {"downcastToDatagramGeneratorNet", &Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_139, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_139_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_QueuedReturn_Datagram = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_QueuedReturn_Datagram = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.QueuedReturn_Datagram",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedReturn_Datagram,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_QueuedReturn_Datagram,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_QueuedReturn_Datagram,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_QueuedReturn_Datagram,
    PyType_GenericAlloc,
    Dtool_new_QueuedReturn_Datagram,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedReturn_Datagram,
  Dtool_UpcastInterface_QueuedReturn_Datagram,
  Dtool_DowncastInterface_QueuedReturn_Datagram,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_QueuedReturn_Datagram(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_QueuedReturn_Datagram._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_QueuedReturn_Datagram._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedReturn_Datagram) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedReturn_Datagram)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedReturn_Datagram);
  }
}

/**
 * Python method tables for DatagramSinkNet (DatagramSinkNet)
 */
static PyMethodDef Dtool_Methods_DatagramSinkNet[] = {
  {"set_target", &Dtool_DatagramSinkNet_set_target_152, METH_O, (const char *)Dtool_DatagramSinkNet_set_target_152_comment},
  {"setTarget", &Dtool_DatagramSinkNet_set_target_152, METH_O, (const char *)Dtool_DatagramSinkNet_set_target_152_comment},
  {"get_target", &Dtool_DatagramSinkNet_get_target_153, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_get_target_153_comment},
  {"getTarget", &Dtool_DatagramSinkNet_get_target_153, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_get_target_153_comment},
  {"put_datagram", &Dtool_DatagramSinkNet_put_datagram_154, METH_O, (const char *)Dtool_DatagramSinkNet_put_datagram_154_comment},
  {"putDatagram", &Dtool_DatagramSinkNet_put_datagram_154, METH_O, (const char *)Dtool_DatagramSinkNet_put_datagram_154_comment},
  {"is_error", &Dtool_DatagramSinkNet_is_error_155, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_is_error_155_comment},
  {"isError", &Dtool_DatagramSinkNet_is_error_155, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_is_error_155_comment},
  {"flush", &Dtool_DatagramSinkNet_flush_156, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_flush_156_comment},
  {"upcast_to_DatagramSink", &Dtool_DatagramSinkNet_upcast_to_DatagramSink_147, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_upcast_to_DatagramSink_147_comment},
  {"upcastToDatagramSink", &Dtool_DatagramSinkNet_upcast_to_DatagramSink_147, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_upcast_to_DatagramSink_147_comment},
  {"upcast_to_ConnectionWriter", &Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149_comment},
  {"upcastToConnectionWriter", &Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DatagramSinkNet = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DatagramSinkNet = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_DatagramSinkNet = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_DatagramSinkNet = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_DatagramSinkNet = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DatagramSinkNet",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramSinkNet,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DatagramSinkNet,
    &Dtool_SequenceMethods_DatagramSinkNet,
    &Dtool_MappingMethods_DatagramSinkNet,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_DatagramSinkNet,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class accepts datagrams one-at-a-time and sends them over the net, via\n"
    " * a TCP connection.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DatagramSinkNet,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DatagramSinkNet,
    PyType_GenericAlloc,
    Dtool_new_DatagramSinkNet,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramSinkNet,
  Dtool_UpcastInterface_DatagramSinkNet,
  Dtool_DowncastInterface_DatagramSinkNet,
  (CoerceFunction)Dtool_ConstCoerce_DatagramSinkNet,
  (CoerceFunction)Dtool_Coerce_DatagramSinkNet,
};

static void Dtool_PyModuleClassInit_DatagramSinkNet(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DatagramSink != NULL);
    assert(Dtool_Ptr_DatagramSink->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DatagramSink->_Dtool_ModuleClassInit(NULL);
    Dtool_PyModuleClassInit_ConnectionWriter(NULL);
    Dtool_DatagramSinkNet._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_DatagramSink, (PyTypeObject *)&Dtool_ConnectionWriter);
    PyObject *dict = PyDict_New();
    Dtool_DatagramSinkNet._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramSinkNet) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramSinkNet)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramSinkNet);
  }
}

/**
 * Python method tables for QueuedConnectionListener (QueuedConnectionListener)
 */
static PyMethodDef Dtool_Methods_QueuedConnectionListener[] = {
  {"new_connection_available", &Dtool_QueuedConnectionListener_new_connection_available_171, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_new_connection_available_171_comment},
  {"newConnectionAvailable", &Dtool_QueuedConnectionListener_new_connection_available_171, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_new_connection_available_171_comment},
  {"get_new_connection", (PyCFunction) &Dtool_QueuedConnectionListener_get_new_connection_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_QueuedConnectionListener_get_new_connection_172_comment},
  {"getNewConnection", (PyCFunction) &Dtool_QueuedConnectionListener_get_new_connection_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_QueuedConnectionListener_get_new_connection_172_comment},
  {"upcast_to_ConnectionListener", &Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159_comment},
  {"upcastToConnectionListener", &Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159_comment},
  {"upcast_to_QueuedReturn_ConnectionListenerData", &Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167_comment},
  {"upcastToQueuedReturnConnectionListenerData", &Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_QueuedConnectionListener = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_QueuedConnectionListener = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_QueuedConnectionListener = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_QueuedConnectionListener = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_QueuedConnectionListener = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.QueuedConnectionListener",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedConnectionListener,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_QueuedConnectionListener,
    &Dtool_SequenceMethods_QueuedConnectionListener,
    &Dtool_MappingMethods_QueuedConnectionListener,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_QueuedConnectionListener,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This flavor of ConnectionListener will queue up all of the TCP connections\n"
    " * it established for later detection by the client code.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_QueuedConnectionListener,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_QueuedConnectionListener,
    PyType_GenericAlloc,
    Dtool_new_QueuedConnectionListener,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedConnectionListener,
  Dtool_UpcastInterface_QueuedConnectionListener,
  Dtool_DowncastInterface_QueuedConnectionListener,
  (CoerceFunction)Dtool_ConstCoerce_QueuedConnectionListener,
  (CoerceFunction)Dtool_Coerce_QueuedConnectionListener,
};

static void Dtool_PyModuleClassInit_QueuedConnectionListener(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConnectionListener(NULL);
    Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData(NULL);
    Dtool_QueuedConnectionListener._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_ConnectionListener, (PyTypeObject *)&Dtool_QueuedReturn_ConnectionListenerData);
    PyObject *dict = PyDict_New();
    Dtool_QueuedConnectionListener._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedConnectionListener) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedConnectionListener)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedConnectionListener);
  }
}

/**
 * Python method tables for QueuedReturn_ConnectionListenerData (QueuedReturn_ConnectionListenerData)
 */
static PyMethodDef Dtool_Methods_QueuedReturn_ConnectionListenerData[] = {
  {"set_max_queue_size", &Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162, METH_O, (const char *)Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162_comment},
  {"setMaxQueueSize", &Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162, METH_O, (const char *)Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162_comment},
  {"get_max_queue_size", &Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163_comment},
  {"getMaxQueueSize", &Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163_comment},
  {"get_current_queue_size", &Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164_comment},
  {"getCurrentQueueSize", &Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164_comment},
  {"get_overflow_flag", &Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165_comment},
  {"getOverflowFlag", &Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165_comment},
  {"reset_overflow_flag", &Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166_comment},
  {"resetOverflowFlag", &Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166_comment},
  {"downcast_to_QueuedConnectionListener", &Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_168, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_168_comment},
  {"downcastToQueuedConnectionListener", &Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_168, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_168_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_QueuedReturn_ConnectionListenerData = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_QueuedReturn_ConnectionListenerData = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.QueuedReturn_ConnectionListenerData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedReturn_ConnectionListenerData,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_QueuedReturn_ConnectionListenerData,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_QueuedReturn_ConnectionListenerData,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_QueuedReturn_ConnectionListenerData,
    PyType_GenericAlloc,
    Dtool_new_QueuedReturn_ConnectionListenerData,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData,
  Dtool_UpcastInterface_QueuedReturn_ConnectionListenerData,
  Dtool_DowncastInterface_QueuedReturn_ConnectionListenerData,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_QueuedReturn_ConnectionListenerData._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_QueuedReturn_ConnectionListenerData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedReturn_ConnectionListenerData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedReturn_ConnectionListenerData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedReturn_ConnectionListenerData);
  }
}

/**
 * Python method tables for QueuedConnectionManager (QueuedConnectionManager)
 */
static PyMethodDef Dtool_Methods_QueuedConnectionManager[] = {
  {"reset_connection_available", &Dtool_QueuedConnectionManager_reset_connection_available_186, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_reset_connection_available_186_comment},
  {"resetConnectionAvailable", &Dtool_QueuedConnectionManager_reset_connection_available_186, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_reset_connection_available_186_comment},
  {"get_reset_connection", &Dtool_QueuedConnectionManager_get_reset_connection_187, METH_O, (const char *)Dtool_QueuedConnectionManager_get_reset_connection_187_comment},
  {"getResetConnection", &Dtool_QueuedConnectionManager_get_reset_connection_187, METH_O, (const char *)Dtool_QueuedConnectionManager_get_reset_connection_187_comment},
  {"upcast_to_ConnectionManager", &Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174_comment},
  {"upcastToConnectionManager", &Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174_comment},
  {"upcast_to_QueuedReturn_PointerTo_Connection", &Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182_comment},
  {"upcastToQueuedReturnPointerToConnection", &Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_QueuedConnectionManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_QueuedConnectionManager = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_QueuedConnectionManager = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_QueuedConnectionManager = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_QueuedConnectionManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.QueuedConnectionManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedConnectionManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_QueuedConnectionManager,
    &Dtool_SequenceMethods_QueuedConnectionManager,
    &Dtool_MappingMethods_QueuedConnectionManager,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_QueuedConnectionManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This flavor of ConnectionManager will queue up all of the reset-connection\n"
    " * messages from the ConnectionReaders and ConnectionWriters and report them\n"
    " * to the client on demand.\n"
    " *\n"
    " * When a reset connection has been discovered via\n"
    " * reset_connection_available()/get_reset_connection(), it is still the\n"
    " * responsibility of the client to call close_connection() on that connection\n"
    " * to free up its resources.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_QueuedConnectionManager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_QueuedConnectionManager,
    PyType_GenericAlloc,
    Dtool_new_QueuedConnectionManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedConnectionManager,
  Dtool_UpcastInterface_QueuedConnectionManager,
  Dtool_DowncastInterface_QueuedConnectionManager,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_QueuedConnectionManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConnectionManager(NULL);
    Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection(NULL);
    Dtool_QueuedConnectionManager._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_ConnectionManager, (PyTypeObject *)&Dtool_QueuedReturn_PointerTo_Connection);
    PyObject *dict = PyDict_New();
    Dtool_QueuedConnectionManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedConnectionManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedConnectionManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedConnectionManager);
  }
}

/**
 * Python method tables for QueuedReturn_PointerTo_Connection (QueuedReturn_PointerTo_Connection)
 */
static PyMethodDef Dtool_Methods_QueuedReturn_PointerTo_Connection[] = {
  {"set_max_queue_size", &Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177, METH_O, (const char *)Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177_comment},
  {"setMaxQueueSize", &Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177, METH_O, (const char *)Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177_comment},
  {"get_max_queue_size", &Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178_comment},
  {"getMaxQueueSize", &Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178_comment},
  {"get_current_queue_size", &Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179_comment},
  {"getCurrentQueueSize", &Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179_comment},
  {"get_overflow_flag", &Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180_comment},
  {"getOverflowFlag", &Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180_comment},
  {"reset_overflow_flag", &Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181_comment},
  {"resetOverflowFlag", &Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181_comment},
  {"downcast_to_QueuedConnectionManager", &Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_183, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_183_comment},
  {"downcastToQueuedConnectionManager", &Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_183, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_183_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_QueuedReturn_PointerTo_Connection = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_QueuedReturn_PointerTo_Connection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.QueuedReturn_PointerTo_Connection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedReturn_PointerTo_Connection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_QueuedReturn_PointerTo_Connection,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_QueuedReturn_PointerTo_Connection,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_QueuedReturn_PointerTo_Connection,
    PyType_GenericAlloc,
    Dtool_new_QueuedReturn_PointerTo_Connection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection,
  Dtool_UpcastInterface_QueuedReturn_PointerTo_Connection,
  Dtool_DowncastInterface_QueuedReturn_PointerTo_Connection,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_QueuedReturn_PointerTo_Connection._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_QueuedReturn_PointerTo_Connection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedReturn_PointerTo_Connection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedReturn_PointerTo_Connection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedReturn_PointerTo_Connection);
  }
}

/**
 * Python method tables for QueuedConnectionReader (QueuedConnectionReader)
 */
static PyMethodDef Dtool_Methods_QueuedConnectionReader[] = {
  {"data_available", &Dtool_QueuedConnectionReader_data_available_201, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_data_available_201_comment},
  {"dataAvailable", &Dtool_QueuedConnectionReader_data_available_201, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_data_available_201_comment},
  {"get_data", &Dtool_QueuedConnectionReader_get_data_202, METH_O, (const char *)Dtool_QueuedConnectionReader_get_data_202_comment},
  {"getData", &Dtool_QueuedConnectionReader_get_data_202, METH_O, (const char *)Dtool_QueuedConnectionReader_get_data_202_comment},
  {"upcast_to_ConnectionReader", &Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189_comment},
  {"upcastToConnectionReader", &Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189_comment},
  {"upcast_to_QueuedReturn_NetDatagram", &Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197_comment},
  {"upcastToQueuedReturnNetDatagram", &Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_QueuedConnectionReader = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_QueuedConnectionReader = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_QueuedConnectionReader = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_QueuedConnectionReader = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_QueuedConnectionReader = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.QueuedConnectionReader",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedConnectionReader,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_QueuedConnectionReader,
    &Dtool_SequenceMethods_QueuedConnectionReader,
    &Dtool_MappingMethods_QueuedConnectionReader,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_QueuedConnectionReader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This flavor of ConnectionReader will read from its sockets and queue up all\n"
    " * of the datagrams read for later receipt by the client code.  This class is\n"
    " * useful for client code that doesn't want to deal with threading and is\n"
    " * willing to poll for datagrams at its convenience.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_QueuedConnectionReader,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_QueuedConnectionReader,
    PyType_GenericAlloc,
    Dtool_new_QueuedConnectionReader,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedConnectionReader,
  Dtool_UpcastInterface_QueuedConnectionReader,
  Dtool_DowncastInterface_QueuedConnectionReader,
  (CoerceFunction)Dtool_ConstCoerce_QueuedConnectionReader,
  (CoerceFunction)Dtool_Coerce_QueuedConnectionReader,
};

static void Dtool_PyModuleClassInit_QueuedConnectionReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConnectionReader(NULL);
    Dtool_PyModuleClassInit_QueuedReturn_NetDatagram(NULL);
    Dtool_QueuedConnectionReader._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_ConnectionReader, (PyTypeObject *)&Dtool_QueuedReturn_NetDatagram);
    PyObject *dict = PyDict_New();
    Dtool_QueuedConnectionReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedConnectionReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedConnectionReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedConnectionReader);
  }
}

/**
 * Python method tables for QueuedReturn_NetDatagram (QueuedReturn_NetDatagram)
 */
static PyMethodDef Dtool_Methods_QueuedReturn_NetDatagram[] = {
  {"set_max_queue_size", &Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192, METH_O, (const char *)Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192_comment},
  {"setMaxQueueSize", &Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192, METH_O, (const char *)Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192_comment},
  {"get_max_queue_size", &Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193_comment},
  {"getMaxQueueSize", &Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193_comment},
  {"get_current_queue_size", &Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194_comment},
  {"getCurrentQueueSize", &Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194_comment},
  {"get_overflow_flag", &Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195_comment},
  {"getOverflowFlag", &Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195_comment},
  {"reset_overflow_flag", &Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196_comment},
  {"resetOverflowFlag", &Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196_comment},
  {"downcast_to_QueuedConnectionReader", &Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_198, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_198_comment},
  {"downcastToQueuedConnectionReader", &Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_198, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_198_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_QueuedReturn_NetDatagram = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_QueuedReturn_NetDatagram = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.QueuedReturn_NetDatagram",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedReturn_NetDatagram,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_QueuedReturn_NetDatagram,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_QueuedReturn_NetDatagram,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_QueuedReturn_NetDatagram,
    PyType_GenericAlloc,
    Dtool_new_QueuedReturn_NetDatagram,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedReturn_NetDatagram,
  Dtool_UpcastInterface_QueuedReturn_NetDatagram,
  Dtool_DowncastInterface_QueuedReturn_NetDatagram,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_QueuedReturn_NetDatagram(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_QueuedReturn_NetDatagram._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_QueuedReturn_NetDatagram._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedReturn_NetDatagram) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedReturn_NetDatagram)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedReturn_NetDatagram);
  }
}

/**
 * Python method tables for RecentConnectionReader (RecentConnectionReader)
 */
static PyMethodDef Dtool_Methods_RecentConnectionReader[] = {
  {"data_available", &Dtool_RecentConnectionReader_data_available_205, METH_NOARGS, (const char *)Dtool_RecentConnectionReader_data_available_205_comment},
  {"dataAvailable", &Dtool_RecentConnectionReader_data_available_205, METH_NOARGS, (const char *)Dtool_RecentConnectionReader_data_available_205_comment},
  {"get_data", &Dtool_RecentConnectionReader_get_data_206, METH_O, (const char *)Dtool_RecentConnectionReader_get_data_206_comment},
  {"getData", &Dtool_RecentConnectionReader_get_data_206, METH_O, (const char *)Dtool_RecentConnectionReader_get_data_206_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_RecentConnectionReader = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RecentConnectionReader = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_RecentConnectionReader = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_RecentConnectionReader = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_RecentConnectionReader = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.RecentConnectionReader",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_RecentConnectionReader,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_RecentConnectionReader,
    &Dtool_SequenceMethods_RecentConnectionReader,
    &Dtool_MappingMethods_RecentConnectionReader,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_RecentConnectionReader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This flavor of ConnectionReader will read from its sockets and retain only\n"
    " * the single most recent datagram for inspection by client code.  It's useful\n"
    " * particularly for reading telemetry-type data from UDP sockets where you\n"
    " * don't care about getting every last socket, and in fact if the sockets are\n"
    " * coming too fast you'd prefer to skip some of them.\n"
    " *\n"
    " * This class will always create one thread for itself.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_RecentConnectionReader,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_RecentConnectionReader,
    PyType_GenericAlloc,
    Dtool_new_RecentConnectionReader,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RecentConnectionReader,
  Dtool_UpcastInterface_RecentConnectionReader,
  Dtool_DowncastInterface_RecentConnectionReader,
  (CoerceFunction)Dtool_ConstCoerce_RecentConnectionReader,
  (CoerceFunction)Dtool_Coerce_RecentConnectionReader,
};

static void Dtool_PyModuleClassInit_RecentConnectionReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConnectionReader(NULL);
    Dtool_RecentConnectionReader._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConnectionReader);
    PyObject *dict = PyDict_New();
    Dtool_RecentConnectionReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RecentConnectionReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RecentConnectionReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RecentConnectionReader);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3net_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerTo< Connection >", Dtool_PointerTo_Connection);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< Connection >", Dtool_PointerToBase_Connection);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("NetAddress", Dtool_NetAddress);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Connection", Dtool_Connection);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConnectionReader", Dtool_ConnectionReader);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConnectionListener", Dtool_ConnectionListener);
#endif
  Dtool_NetDatagram._type = NetDatagram::get_class_type();
  RegisterRuntimeTypedClass(Dtool_NetDatagram);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConnectionManager", Dtool_ConnectionManager);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConnectionManager::Interface", Dtool_ConnectionManager_Interface);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConnectionWriter", Dtool_ConnectionWriter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DatagramGeneratorNet", Dtool_DatagramGeneratorNet);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("QueuedReturn< Datagram >", Dtool_QueuedReturn_Datagram);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DatagramSinkNet", Dtool_DatagramSinkNet);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("QueuedConnectionListener", Dtool_QueuedConnectionListener);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("QueuedReturn< ConnectionListenerData >", Dtool_QueuedReturn_ConnectionListenerData);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("QueuedConnectionManager", Dtool_QueuedConnectionManager);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("QueuedReturn< PointerTo< Connection > >", Dtool_QueuedReturn_PointerTo_Connection);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("QueuedConnectionReader", Dtool_QueuedConnectionReader);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("QueuedReturn< NetDatagram >", Dtool_QueuedReturn_NetDatagram);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("RecentConnectionReader", Dtool_RecentConnectionReader);
#endif
}

void Dtool_libp3net_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_Socket_Address = LookupNamedClass("Socket_Address");
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_PointerToVoid = LookupNamedClass("PointerToVoid");
  Dtool_Ptr_Socket_IP = LookupRuntimeTypedClass(Socket_IP::get_class_type());
  Dtool_Ptr_DatagramSink = LookupNamedClass("DatagramSink");
  Dtool_Ptr_Datagram = LookupRuntimeTypedClass(Datagram::get_class_type());
  Dtool_Ptr_DatagramGenerator = LookupNamedClass("DatagramGenerator");
#endif
}

void Dtool_libp3net_BuildInstants(PyObject *module) {
  (void) module;
  // PointerTo< Connection >
  Dtool_PyModuleClassInit_PointerTo_Connection(module);
  PyModule_AddObject(module, "PointerTo_Connection", (PyObject *)&Dtool_PointerTo_Connection);
  Py_INCREF(Dtool_Ptr_PointerTo_Connection);
  PyModule_AddObject(module, "PointerToConnection", (PyObject *)&Dtool_PointerTo_Connection);
  // PointerToBase< Connection >
  Dtool_PyModuleClassInit_PointerToBase_Connection(module);
  PyModule_AddObject(module, "PointerToBase_Connection", (PyObject *)&Dtool_PointerToBase_Connection);
  Py_INCREF(Dtool_Ptr_PointerToBase_Connection);
  PyModule_AddObject(module, "PointerToBaseConnection", (PyObject *)&Dtool_PointerToBase_Connection);
  // NetAddress
  Dtool_PyModuleClassInit_NetAddress(module);
  PyModule_AddObject(module, "NetAddress", (PyObject *)&Dtool_NetAddress);
  // Connection
  Dtool_PyModuleClassInit_Connection(module);
  PyModule_AddObject(module, "Connection", (PyObject *)&Dtool_Connection);
  // ConnectionReader
  Dtool_PyModuleClassInit_ConnectionReader(module);
  PyModule_AddObject(module, "ConnectionReader", (PyObject *)&Dtool_ConnectionReader);
  // ConnectionListener
  Dtool_PyModuleClassInit_ConnectionListener(module);
  PyModule_AddObject(module, "ConnectionListener", (PyObject *)&Dtool_ConnectionListener);
  // NetDatagram
  Dtool_PyModuleClassInit_NetDatagram(module);
  PyModule_AddObject(module, "NetDatagram", (PyObject *)&Dtool_NetDatagram);
  // ConnectionManager
  Dtool_PyModuleClassInit_ConnectionManager(module);
  PyModule_AddObject(module, "ConnectionManager", (PyObject *)&Dtool_ConnectionManager);
  // ConnectionWriter
  Dtool_PyModuleClassInit_ConnectionWriter(module);
  PyModule_AddObject(module, "ConnectionWriter", (PyObject *)&Dtool_ConnectionWriter);
  // DatagramGeneratorNet
  Dtool_PyModuleClassInit_DatagramGeneratorNet(module);
  PyModule_AddObject(module, "DatagramGeneratorNet", (PyObject *)&Dtool_DatagramGeneratorNet);
  // QueuedReturn< Datagram >
  Dtool_PyModuleClassInit_QueuedReturn_Datagram(module);
  PyModule_AddObject(module, "QueuedReturn_Datagram", (PyObject *)&Dtool_QueuedReturn_Datagram);
  Py_INCREF(Dtool_Ptr_QueuedReturn_Datagram);
  PyModule_AddObject(module, "QueuedReturnDatagram", (PyObject *)&Dtool_QueuedReturn_Datagram);
  // DatagramSinkNet
  Dtool_PyModuleClassInit_DatagramSinkNet(module);
  PyModule_AddObject(module, "DatagramSinkNet", (PyObject *)&Dtool_DatagramSinkNet);
  // QueuedConnectionListener
  Dtool_PyModuleClassInit_QueuedConnectionListener(module);
  PyModule_AddObject(module, "QueuedConnectionListener", (PyObject *)&Dtool_QueuedConnectionListener);
  // QueuedReturn< ConnectionListenerData >
  Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData(module);
  PyModule_AddObject(module, "QueuedReturn_ConnectionListenerData", (PyObject *)&Dtool_QueuedReturn_ConnectionListenerData);
  Py_INCREF(Dtool_Ptr_QueuedReturn_ConnectionListenerData);
  PyModule_AddObject(module, "QueuedReturnConnectionListenerData", (PyObject *)&Dtool_QueuedReturn_ConnectionListenerData);
  // QueuedConnectionManager
  Dtool_PyModuleClassInit_QueuedConnectionManager(module);
  PyModule_AddObject(module, "QueuedConnectionManager", (PyObject *)&Dtool_QueuedConnectionManager);
  // QueuedReturn< PointerTo< Connection > >
  Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection(module);
  PyModule_AddObject(module, "QueuedReturn_PointerTo_Connection", (PyObject *)&Dtool_QueuedReturn_PointerTo_Connection);
  Py_INCREF(Dtool_Ptr_QueuedReturn_PointerTo_Connection);
  PyModule_AddObject(module, "QueuedReturnPointerToConnection", (PyObject *)&Dtool_QueuedReturn_PointerTo_Connection);
  // QueuedConnectionReader
  Dtool_PyModuleClassInit_QueuedConnectionReader(module);
  PyModule_AddObject(module, "QueuedConnectionReader", (PyObject *)&Dtool_QueuedConnectionReader);
  // QueuedReturn< NetDatagram >
  Dtool_PyModuleClassInit_QueuedReturn_NetDatagram(module);
  PyModule_AddObject(module, "QueuedReturn_NetDatagram", (PyObject *)&Dtool_QueuedReturn_NetDatagram);
  Py_INCREF(Dtool_Ptr_QueuedReturn_NetDatagram);
  PyModule_AddObject(module, "QueuedReturnNetDatagram", (PyObject *)&Dtool_QueuedReturn_NetDatagram);
  // RecentConnectionReader
  Dtool_PyModuleClassInit_RecentConnectionReader(module);
  PyModule_AddObject(module, "RecentConnectionReader", (PyObject *)&Dtool_RecentConnectionReader);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3net_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478210458,  /* file_identifier */
  "libp3net",  /* library_name */
  "7xrj",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3net.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  459  /* next_index */
};

Configure(_in_configure_libp3net);
ConfigureFn(_in_configure_libp3net) {
  interrogate_request_module(&_in_module_def);
}

