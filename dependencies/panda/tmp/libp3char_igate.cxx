/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/char -Ipanda/src/char -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3char_igate.cxx -od built/pandac/input/libp3char.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/char -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3char character.h characterJoint.h characterJointBundle.h characterJointEffect.h characterSlider.h characterVertexSlider.h config_char.h jointVertexTransform.h p3char_composite1.cxx p3char_composite2.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3char
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "character.h"
#include "characterJoint.h"
#include "characterJointBundle.h"
#include "characterJointEffect.h"
#include "characterSlider.h"
#include "characterVertexSlider.h"
#include "configVariableBool.h"
#include "config_char.h"
#include "geom.h"
#include "jointVertexTransform.h"
#include "luse.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "pStatCollector.h"
#include "pandabase.h"
#include "partBundleNode.h"
#include "pointerTo.h"
#include "renderEffect.h"
#include "sliderTable.h"
#include "transformBlendTable.h"
#include "transformTable.h"
#include "vector_PartGroupStar.h"
#include "weakPointerTo.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class CharacterJoint
 */
typedef CharacterJoint CharacterJoint_localtype;
Define_Module_ClassRef(panda3d.core, CharacterJoint, CharacterJoint_localtype, CharacterJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CharacterJoint = &Dtool_CharacterJoint;
static void Dtool_PyModuleClassInit_CharacterJoint(PyObject *module);
bool Dtool_ConstCoerce_CharacterJoint(PyObject *args, CPT(CharacterJoint) &coerced);
bool Dtool_Coerce_CharacterJoint(PyObject *args, PT(CharacterJoint) &coerced);

/**
 * Forward declarations for top-level class CharacterSlider
 */
typedef CharacterSlider CharacterSlider_localtype;
Define_Module_ClassRef(panda3d.core, CharacterSlider, CharacterSlider_localtype, CharacterSlider);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CharacterSlider = &Dtool_CharacterSlider;
static void Dtool_PyModuleClassInit_CharacterSlider(PyObject *module);
bool Dtool_ConstCoerce_CharacterSlider(PyObject *args, CPT(CharacterSlider) &coerced);
bool Dtool_Coerce_CharacterSlider(PyObject *args, PT(CharacterSlider) &coerced);

/**
 * Forward declarations for top-level class CharacterVertexSlider
 */
typedef CharacterVertexSlider CharacterVertexSlider_localtype;
Define_Module_ClassRef(panda3d.core, CharacterVertexSlider, CharacterVertexSlider_localtype, CharacterVertexSlider);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CharacterVertexSlider = &Dtool_CharacterVertexSlider;
static void Dtool_PyModuleClassInit_CharacterVertexSlider(PyObject *module);
bool Dtool_ConstCoerce_CharacterVertexSlider(PyObject *args, CPT(CharacterVertexSlider) &coerced);
bool Dtool_Coerce_CharacterVertexSlider(PyObject *args, PT(CharacterVertexSlider) &coerced);

/**
 * Forward declarations for top-level class JointVertexTransform
 */
typedef JointVertexTransform JointVertexTransform_localtype;
Define_Module_ClassRef(panda3d.core, JointVertexTransform, JointVertexTransform_localtype, JointVertexTransform);
static struct Dtool_PyTypedObject *const Dtool_Ptr_JointVertexTransform = &Dtool_JointVertexTransform;
static void Dtool_PyModuleClassInit_JointVertexTransform(PyObject *module);
bool Dtool_ConstCoerce_JointVertexTransform(PyObject *args, CPT(JointVertexTransform) &coerced);
bool Dtool_Coerce_JointVertexTransform(PyObject *args, PT(JointVertexTransform) &coerced);

/**
 * Forward declarations for top-level class Character
 */
typedef Character Character_localtype;
Define_Module_ClassRef(panda3d.core, Character, Character_localtype, Character);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Character = &Dtool_Character;
static void Dtool_PyModuleClassInit_Character(PyObject *module);
bool Dtool_ConstCoerce_Character(PyObject *args, CPT(Character) &coerced);
bool Dtool_Coerce_Character(PyObject *args, PT(Character) &coerced);

/**
 * Forward declarations for top-level class CharacterJointBundle
 */
typedef CharacterJointBundle CharacterJointBundle_localtype;
Define_Module_ClassRef(panda3d.core, CharacterJointBundle, CharacterJointBundle_localtype, CharacterJointBundle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CharacterJointBundle = &Dtool_CharacterJointBundle;
static void Dtool_PyModuleClassInit_CharacterJointBundle(PyObject *module);
bool Dtool_ConstCoerce_CharacterJointBundle(PyObject *args, CPT(CharacterJointBundle) &coerced);
bool Dtool_Coerce_CharacterJointBundle(PyObject *args, PT(CharacterJointBundle) &coerced);

/**
 * Forward declarations for top-level class CharacterJointEffect
 */
typedef CharacterJointEffect CharacterJointEffect_localtype;
Define_Module_ClassRef(panda3d.core, CharacterJointEffect, CharacterJointEffect_localtype, CharacterJointEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CharacterJointEffect = &Dtool_CharacterJointEffect;
static void Dtool_PyModuleClassInit_CharacterJointEffect(PyObject *module);
bool Dtool_ConstCoerce_CharacterJointEffect(PyObject *args, CPT(CharacterJointEffect) &coerced);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// Thread
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Thread;
#else
extern struct Dtool_PyTypedObject Dtool_Thread;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Thread = &Dtool_Thread;
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != NULL, NULL);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != NULL, NULL);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// TransformState
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TransformState;
#else
extern struct Dtool_PyTypedObject Dtool_TransformState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformState = &Dtool_TransformState;
#endif
// PartGroup
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PartGroup;
inline static bool Dtool_ConstCoerce_PartGroup(PyObject *args, CPT(PartGroup) &coerced) {
  nassertr(Dtool_Ptr_PartGroup != NULL, false);
  nassertr(Dtool_Ptr_PartGroup->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(PartGroup) &))Dtool_Ptr_PartGroup->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_PartGroup(PyObject *args, PT(PartGroup) &coerced) {
  nassertr(Dtool_Ptr_PartGroup != NULL, false);
  nassertr(Dtool_Ptr_PartGroup->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(PartGroup) &))Dtool_Ptr_PartGroup->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PartGroup;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartGroup = &Dtool_PartGroup;
extern bool Dtool_ConstCoerce_PartGroup(PyObject *args, CPT(PartGroup) &coerced);
extern bool Dtool_Coerce_PartGroup(PyObject *args, PT(PartGroup) &coerced);
#endif
// VertexSlider
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_VertexSlider;
inline static bool Dtool_ConstCoerce_VertexSlider(PyObject *args, CPT(VertexSlider) &coerced) {
  nassertr(Dtool_Ptr_VertexSlider != NULL, false);
  nassertr(Dtool_Ptr_VertexSlider->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(VertexSlider) &))Dtool_Ptr_VertexSlider->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_VertexSlider(PyObject *args, PT(VertexSlider) &coerced) {
  nassertr(Dtool_Ptr_VertexSlider != NULL, false);
  nassertr(Dtool_Ptr_VertexSlider->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(VertexSlider) &))Dtool_Ptr_VertexSlider->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_VertexSlider;
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexSlider = &Dtool_VertexSlider;
extern bool Dtool_ConstCoerce_VertexSlider(PyObject *args, CPT(VertexSlider) &coerced);
extern bool Dtool_Coerce_VertexSlider(PyObject *args, PT(VertexSlider) &coerced);
#endif
// VertexTransform
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_VertexTransform;
#else
extern struct Dtool_PyTypedObject Dtool_VertexTransform;
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexTransform = &Dtool_VertexTransform;
#endif
// PartBundle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PartBundle;
inline static bool Dtool_ConstCoerce_PartBundle(PyObject *args, CPT(PartBundle) &coerced) {
  nassertr(Dtool_Ptr_PartBundle != NULL, false);
  nassertr(Dtool_Ptr_PartBundle->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(PartBundle) &))Dtool_Ptr_PartBundle->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_PartBundle(PyObject *args, PT(PartBundle) &coerced) {
  nassertr(Dtool_Ptr_PartBundle != NULL, false);
  nassertr(Dtool_Ptr_PartBundle->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(PartBundle) &))Dtool_Ptr_PartBundle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PartBundle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundle = &Dtool_PartBundle;
extern bool Dtool_ConstCoerce_PartBundle(PyObject *args, CPT(PartBundle) &coerced);
extern bool Dtool_Coerce_PartBundle(PyObject *args, PT(PartBundle) &coerced);
#endif
// RenderEffect
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_RenderEffect;
#else
extern struct Dtool_PyTypedObject Dtool_RenderEffect;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderEffect = &Dtool_RenderEffect;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// MovingPart< ACMatrixSwitchType >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MovingPart_ACMatrixSwitchType;
#else
extern struct Dtool_PyTypedObject Dtool_MovingPart_ACMatrixSwitchType;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPart_ACMatrixSwitchType = &Dtool_MovingPart_ACMatrixSwitchType;
#endif
// MovingPartMatrix
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MovingPartMatrix;
#else
extern struct Dtool_PyTypedObject Dtool_MovingPartMatrix;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartMatrix = &Dtool_MovingPartMatrix;
#endif
// MovingPartBase
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MovingPartBase;
#else
extern struct Dtool_PyTypedObject Dtool_MovingPartBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartBase = &Dtool_MovingPartBase;
#endif
// NodePathCollection
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePathCollection;
inline static bool Dtool_ConstCoerce_NodePathCollection(PyObject *args, NodePathCollection const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_NodePathCollection != NULL, false);
  nassertr(Dtool_Ptr_NodePathCollection->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, NodePathCollection const *&, bool&))Dtool_Ptr_NodePathCollection->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_NodePathCollection(PyObject *args, NodePathCollection *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_NodePathCollection != NULL, false);
  nassertr(Dtool_Ptr_NodePathCollection->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, NodePathCollection *&, bool&))Dtool_Ptr_NodePathCollection->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_NodePathCollection;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePathCollection = &Dtool_NodePathCollection;
extern bool Dtool_ConstCoerce_NodePathCollection(PyObject *args, NodePathCollection const *&coerced, bool &manage);
extern bool Dtool_Coerce_NodePathCollection(PyObject *args, NodePathCollection *&coerced, bool &manage);
#endif
// MovingPart< ACScalarSwitchType >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MovingPart_ACScalarSwitchType;
#else
extern struct Dtool_PyTypedObject Dtool_MovingPart_ACScalarSwitchType;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPart_ACScalarSwitchType = &Dtool_MovingPart_ACScalarSwitchType;
#endif
// MovingPartScalar
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MovingPartScalar;
#else
extern struct Dtool_PyTypedObject Dtool_MovingPartScalar;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartScalar = &Dtool_MovingPartScalar;
#endif
// PartBundleNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PartBundleNode;
inline static bool Dtool_ConstCoerce_PartBundleNode(PyObject *args, CPT(PartBundleNode) &coerced) {
  nassertr(Dtool_Ptr_PartBundleNode != NULL, false);
  nassertr(Dtool_Ptr_PartBundleNode->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(PartBundleNode) &))Dtool_Ptr_PartBundleNode->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_PartBundleNode(PyObject *args, PT(PartBundleNode) &coerced) {
  nassertr(Dtool_Ptr_PartBundleNode != NULL, false);
  nassertr(Dtool_Ptr_PartBundleNode->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(PartBundleNode) &))Dtool_Ptr_PartBundleNode->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PartBundleNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundleNode = &Dtool_PartBundleNode;
extern bool Dtool_ConstCoerce_PartBundleNode(PyObject *args, CPT(PartBundleNode) &coerced);
extern bool Dtool_Coerce_PartBundleNode(PyObject *args, PT(PartBundleNode) &coerced);
#endif
// PartBundleHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PartBundleHandle;
inline static bool Dtool_ConstCoerce_PartBundleHandle(PyObject *args, CPT(PartBundleHandle) &coerced) {
  nassertr(Dtool_Ptr_PartBundleHandle != NULL, false);
  nassertr(Dtool_Ptr_PartBundleHandle->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(PartBundleHandle) &))Dtool_Ptr_PartBundleHandle->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_PartBundleHandle(PyObject *args, PT(PartBundleHandle) &coerced) {
  nassertr(Dtool_Ptr_PartBundleHandle != NULL, false);
  nassertr(Dtool_Ptr_PartBundleHandle->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(PartBundleHandle) &))Dtool_Ptr_PartBundleHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PartBundleHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundleHandle = &Dtool_PartBundleHandle;
extern bool Dtool_ConstCoerce_PartBundleHandle(PyObject *args, CPT(PartBundleHandle) &coerced);
extern bool Dtool_Coerce_PartBundleHandle(PyObject *args, PT(PartBundleHandle) &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class CharacterJoint
 */
/**
 * Python function wrapper for:
 * bool CharacterJoint::add_net_transform(PandaNode *node)
 */
static PyObject *Dtool_CharacterJoint_add_net_transform_4(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.add_net_transform")) {
    return NULL;
  }
  // 1-bool CharacterJoint::add_net_transform(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.add_net_transform", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).add_net_transform(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_net_transform(const CharacterJoint self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_add_net_transform_4_comment =
  "C++ Interface:\n"
  "add_net_transform(const CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Adds the indicated node to the list of nodes that will be updated each\n"
  " * frame with the joint's net transform from the root.  Returns true if the\n"
  " * node is successfully added, false if it had already been added.\n"
  " *\n"
  " * A CharacterJointEffect for this joint's Character will automatically be\n"
  " * added to the specified node.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_add_net_transform_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CharacterJoint::remove_net_transform(PandaNode *node)
 */
static PyObject *Dtool_CharacterJoint_remove_net_transform_5(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.remove_net_transform")) {
    return NULL;
  }
  // 1-bool CharacterJoint::remove_net_transform(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.remove_net_transform", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).remove_net_transform(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_net_transform(const CharacterJoint self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_remove_net_transform_5_comment =
  "C++ Interface:\n"
  "remove_net_transform(const CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Removes the indicated node from the list of nodes that will be updated each\n"
  " * frame with the joint's net transform from the root.  Returns true if the\n"
  " * node is successfully removed, false if it was not on the list.\n"
  " *\n"
  " * If the node has a CharacterJointEffect that matches this joint's Character,\n"
  " * it will be cleared.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_remove_net_transform_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CharacterJoint::has_net_transform(PandaNode *node) const
 */
static PyObject *Dtool_CharacterJoint_has_net_transform_6(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CharacterJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool CharacterJoint::has_net_transform(PandaNode *node) const
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.has_net_transform", false, true);
  if (arg_this != NULL) {
    bool return_value = (*(const CharacterJoint*)local_this).has_net_transform(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_net_transform(CharacterJoint self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_has_net_transform_6_comment =
  "C++ Interface:\n"
  "has_net_transform(CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Returns true if the node is on the list of nodes that will be updated each\n"
  " * frame with the joint's net transform from the root, false otherwise.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_has_net_transform_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CharacterJoint::clear_net_transforms(void)
 */
static PyObject *Dtool_CharacterJoint_clear_net_transforms_7(PyObject *self, PyObject *) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.clear_net_transforms")) {
    return NULL;
  }
  // 1-void CharacterJoint::clear_net_transforms(void)
  (*local_this).clear_net_transforms();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_clear_net_transforms_7_comment =
  "C++ Interface:\n"
  "clear_net_transforms(const CharacterJoint self)\n"
  "\n"
  "/**\n"
  " * Removes all nodes from the list of nodes that will be updated each frame\n"
  " * with the joint's net transform from the root.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_clear_net_transforms_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePathCollection CharacterJoint::get_net_transforms(void)
 */
static PyObject *Dtool_CharacterJoint_get_net_transforms_8(PyObject *self, PyObject *) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.get_net_transforms")) {
    return NULL;
  }
  // 1-NodePathCollection CharacterJoint::get_net_transforms(void)
  NodePathCollection *return_value = new NodePathCollection((*local_this).get_net_transforms());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_net_transforms_8_comment =
  "C++ Interface:\n"
  "get_net_transforms(const CharacterJoint self)\n"
  "\n"
  "/**\n"
  " * Returns a list of the net transforms set for this node.  Note that this\n"
  " * returns a list of NodePaths, even though the net transforms are actually a\n"
  " * list of PandaNodes.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_get_net_transforms_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CharacterJoint::add_local_transform(PandaNode *node)
 */
static PyObject *Dtool_CharacterJoint_add_local_transform_9(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.add_local_transform")) {
    return NULL;
  }
  // 1-bool CharacterJoint::add_local_transform(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.add_local_transform", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).add_local_transform(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_local_transform(const CharacterJoint self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_add_local_transform_9_comment =
  "C++ Interface:\n"
  "add_local_transform(const CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Adds the indicated node to the list of nodes that will be updated each\n"
  " * frame with the joint's local transform from its parent.  Returns true if\n"
  " * the node is successfully added, false if it had already been added.\n"
  " *\n"
  " * The Character pointer should be the Character object that owns this joint;\n"
  " * this will be used to create a CharacterJointEffect for this node.  If it is\n"
  " * NULL, no such effect will be created.\n"
  " *\n"
  " * A CharacterJointEffect for this joint's Character will automatically be\n"
  " * added to the specified node.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_add_local_transform_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CharacterJoint::remove_local_transform(PandaNode *node)
 */
static PyObject *Dtool_CharacterJoint_remove_local_transform_10(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.remove_local_transform")) {
    return NULL;
  }
  // 1-bool CharacterJoint::remove_local_transform(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.remove_local_transform", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).remove_local_transform(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_local_transform(const CharacterJoint self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_remove_local_transform_10_comment =
  "C++ Interface:\n"
  "remove_local_transform(const CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Removes the indicated node from the list of nodes that will be updated each\n"
  " * frame with the joint's local transform from its parent.  Returns true if\n"
  " * the node is successfully removed, false if it was not on the list.\n"
  " *\n"
  " * If the node has a CharacterJointEffect that matches this joint's Character,\n"
  " * it will be cleared.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_remove_local_transform_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CharacterJoint::has_local_transform(PandaNode *node) const
 */
static PyObject *Dtool_CharacterJoint_has_local_transform_11(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CharacterJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool CharacterJoint::has_local_transform(PandaNode *node) const
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.has_local_transform", false, true);
  if (arg_this != NULL) {
    bool return_value = (*(const CharacterJoint*)local_this).has_local_transform(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_local_transform(CharacterJoint self, PandaNode node)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_has_local_transform_11_comment =
  "C++ Interface:\n"
  "has_local_transform(CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Returns true if the node is on the list of nodes that will be updated each\n"
  " * frame with the joint's local transform from its parent, false otherwise.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_has_local_transform_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CharacterJoint::clear_local_transforms(void)
 */
static PyObject *Dtool_CharacterJoint_clear_local_transforms_12(PyObject *self, PyObject *) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.clear_local_transforms")) {
    return NULL;
  }
  // 1-void CharacterJoint::clear_local_transforms(void)
  (*local_this).clear_local_transforms();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_clear_local_transforms_12_comment =
  "C++ Interface:\n"
  "clear_local_transforms(const CharacterJoint self)\n"
  "\n"
  "/**\n"
  " * Removes all nodes from the list of nodes that will be updated each frame\n"
  " * with the joint's local transform from its parent.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_clear_local_transforms_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePathCollection CharacterJoint::get_local_transforms(void)
 */
static PyObject *Dtool_CharacterJoint_get_local_transforms_13(PyObject *self, PyObject *) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.get_local_transforms")) {
    return NULL;
  }
  // 1-NodePathCollection CharacterJoint::get_local_transforms(void)
  NodePathCollection *return_value = new NodePathCollection((*local_this).get_local_transforms());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_local_transforms_13_comment =
  "C++ Interface:\n"
  "get_local_transforms(const CharacterJoint self)\n"
  "\n"
  "/**\n"
  " * Returns a list of the local transforms set for this node.  Note that this\n"
  " * returns a list of NodePaths, even though the local transforms are actually\n"
  " * a list of PandaNodes.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_get_local_transforms_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &CharacterJoint::get_transform(void) const
 * void CharacterJoint::get_transform(LMatrix4 &transform) const
 */
static PyObject *Dtool_CharacterJoint_get_transform_14(PyObject *self, PyObject *args) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CharacterJoint, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LMatrix4 const &CharacterJoint::get_transform(void) const
      LMatrix4 const *return_value = &((*(const CharacterJoint*)local_this).get_transform());
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void CharacterJoint::get_transform(LMatrix4 &transform) const
      LMatrix4f arg_local;
      LMatrix4 *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CharacterJoint.get_transform", "LMatrix4f");
      }
      (*(const CharacterJoint*)local_this).get_transform(*arg_this);
      return Dtool_Return_None();
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_transform() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_transform(CharacterJoint self)\n"
      "get_transform(CharacterJoint self, LMatrix4f transform)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_transform_14_comment =
  "C++ Interface:\n"
  "get_transform(CharacterJoint self)\n"
  "get_transform(CharacterJoint self, LMatrix4f transform)\n"
  "\n"
  "/**\n"
  " * Returns the transform matrix of the joint\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies the joint's current transform into the indicated matrix.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_get_transform_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > CharacterJoint::get_transform_state(void) const
 */
static PyObject *Dtool_CharacterJoint_get_transform_state_15(PyObject *self, PyObject *) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CharacterJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-ConstPointerTo< TransformState > CharacterJoint::get_transform_state(void) const
  ConstPointerTo< TransformState > return_value = (*(const CharacterJoint*)local_this).get_transform_state();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TransformState, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_transform_state_15_comment =
  "C++ Interface:\n"
  "get_transform_state(CharacterJoint self)\n";
#else
static const char *Dtool_CharacterJoint_get_transform_state_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CharacterJoint::get_net_transform(LMatrix4 &transform) const
 */
static PyObject *Dtool_CharacterJoint_get_net_transform_16(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CharacterJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-void CharacterJoint::get_net_transform(LMatrix4 &transform) const
  LMatrix4f arg_local;
  LMatrix4 *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CharacterJoint.get_net_transform", "LMatrix4f");
  }
  (*(const CharacterJoint*)local_this).get_net_transform(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_transform(CharacterJoint self, LMatrix4f transform)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_net_transform_16_comment =
  "C++ Interface:\n"
  "get_net_transform(CharacterJoint self, LMatrix4f transform)\n"
  "\n"
  "/**\n"
  " * Copies the joint's current net transform (composed from the root of the\n"
  " * character joint hierarchy) into the indicated matrix.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_get_net_transform_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Character *CharacterJoint::get_character(void) const
 */
static PyObject *Dtool_CharacterJoint_get_character_17(PyObject *self, PyObject *) {
  CharacterJoint *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CharacterJoint, (void **)&local_this)) {
    return NULL;
  }
  // 1-Character *CharacterJoint::get_character(void) const
  Character *return_value = (*(const CharacterJoint*)local_this).get_character();
  if (return_value != (Character *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Character *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Character, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_character_17_comment =
  "C++ Interface:\n"
  "get_character(CharacterJoint self)\n"
  "\n"
  "/**\n"
  " * Returns the Character that owns this joint.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_get_character_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CharacterJoint::get_class_type(void)
 */
static PyObject *Dtool_CharacterJoint_get_class_type_18(PyObject *, PyObject *) {
  // 1-static TypeHandle CharacterJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CharacterJoint::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_class_type_18_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CharacterJoint_get_class_type_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CharacterJoint::CharacterJoint(Character *character, PartBundle *root, PartGroup *parent, std::string const &name, LMatrix4 const &default_value)
 */
static int Dtool_Init_CharacterJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CharacterJoint::CharacterJoint(Character *character, PartBundle *root, PartGroup *parent, std::string const &name, LMatrix4 const &default_value)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  PyObject *param4;
  static const char *keyword_list[] = {"character", "root", "parent", "name", "default_value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOs#O:CharacterJoint", (char **)keyword_list, &param0, &param1, &param2, &param3_str, &param3_len, &param4)) {
    PT(Character) param0_this;
    if (!Dtool_Coerce_Character(param0, param0_this)) {
      Dtool_Raise_ArgTypeError(param0, 0, "CharacterJoint.CharacterJoint", "Character");
      return -1;
    }
    PT(PartBundle) param1_this;
    if (!Dtool_Coerce_PartBundle(param1, param1_this)) {
      Dtool_Raise_ArgTypeError(param1, 1, "CharacterJoint.CharacterJoint", "PartBundle");
      return -1;
    }
    PT(PartGroup) param2_this;
    if (!Dtool_Coerce_PartGroup(param2, param2_this)) {
      Dtool_Raise_ArgTypeError(param2, 2, "CharacterJoint.CharacterJoint", "PartGroup");
      return -1;
    }
    LMatrix4f param4_local;
    LMatrix4 const *param4_this = Dtool_Coerce_LMatrix4f(param4, param4_local);
    if (!(param4_this != NULL)) {
      Dtool_Raise_ArgTypeError(param4, 4, "CharacterJoint.CharacterJoint", "LMatrix4f");
      return -1;
    }
    CharacterJoint *return_value = new CharacterJoint(MOVE(param0_this), MOVE(param1_this), MOVE(param2_this), std::string(param3_str, param3_len), *param4_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CharacterJoint, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CharacterJoint(Character character, PartBundle root, PartGroup parent, str name, const LMatrix4f default_value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CharacterJoint(PyObject *args, CPT(CharacterJoint) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CharacterJoint, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 5) {
      // 1-CharacterJoint::CharacterJoint(Character *character, PartBundle *root, PartGroup *parent, std::string const &name, LMatrix4 const &default_value)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      char *param3_str = NULL;
      Py_ssize_t param3_len;
      PyObject *param4;
      if (PyArg_ParseTuple(args, "OOOs#O:CharacterJoint", &param0, &param1, &param2, &param3_str, &param3_len, &param4)) {
        Character *param0_this = (Character *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Character, 0, "CharacterJoint.CharacterJoint", false, false);
        PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PartBundle, 1, "CharacterJoint.CharacterJoint", false, false);
        PartGroup *param2_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PartGroup, 2, "CharacterJoint.CharacterJoint", false, false);
        LMatrix4 const *param4_this;
        DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LMatrix4f, (void **)&param4_this);
        if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param4_this != NULL) {
          CharacterJoint *return_value = new CharacterJoint(param0_this, param1_this, param2_this, std::string(param3_str, param3_len), *param4_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_CharacterJoint(PyObject *args, PT(CharacterJoint) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CharacterJoint, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 5) {
      // 1-CharacterJoint::CharacterJoint(Character *character, PartBundle *root, PartGroup *parent, std::string const &name, LMatrix4 const &default_value)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      char *param3_str = NULL;
      Py_ssize_t param3_len;
      PyObject *param4;
      if (PyArg_ParseTuple(args, "OOOs#O:CharacterJoint", &param0, &param1, &param2, &param3_str, &param3_len, &param4)) {
        Character *param0_this = (Character *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Character, 0, "CharacterJoint.CharacterJoint", false, false);
        PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PartBundle, 1, "CharacterJoint.CharacterJoint", false, false);
        PartGroup *param2_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PartGroup, 2, "CharacterJoint.CharacterJoint", false, false);
        LMatrix4 const *param4_this;
        DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LMatrix4f, (void **)&param4_this);
        if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param4_this != NULL) {
          CharacterJoint *return_value = new CharacterJoint(param0_this, param1_this, param2_this, std::string(param3_str, param3_len), *param4_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CharacterJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CharacterJoint) {
    printf("CharacterJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CharacterJoint *local_this = (CharacterJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CharacterJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    return (MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartMatrix) {
    return (MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CharacterJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CharacterJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    MovingPart< ACMatrixSwitchType >* other_this = (MovingPart< ACMatrixSwitchType >*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartMatrix) {
    MovingPartMatrix* other_this = (MovingPartMatrix*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CharacterJoint*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CharacterSlider
 */
/**
 * Python function wrapper for:
 * virtual bool CharacterSlider::update_internals(PartBundle *root, PartGroup *parent, bool self_changed, bool parent_changed, Thread *current_thread)
 */
static PyObject *Dtool_CharacterSlider_update_internals_22(PyObject *self, PyObject *args, PyObject *kwds) {
  CharacterSlider *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterSlider, (void **)&local_this, "CharacterSlider.update_internals")) {
    return NULL;
  }
  // 1-virtual bool CharacterSlider::update_internals(PartBundle *root, PartGroup *parent, bool self_changed, bool parent_changed, Thread *current_thread)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  PyObject *param4;
  PyObject *param5;
  static const char *keyword_list[] = {"root", "parent", "self_changed", "parent_changed", "current_thread", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO:update_internals", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    PT(PartBundle) param1_this;
    if (!Dtool_Coerce_PartBundle(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CharacterSlider.update_internals", "PartBundle");
    }
    PT(PartGroup) param2_this;
    if (!Dtool_Coerce_PartGroup(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CharacterSlider.update_internals", "PartGroup");
    }
    Thread *param5_this = (Thread *)DTOOL_Call_GetPointerThisClass(param5, Dtool_Ptr_Thread, 5, "CharacterSlider.update_internals", false, true);
    if (param5_this != NULL) {
      bool return_value = (*local_this).update_internals(MOVE(param1_this), MOVE(param2_this), (PyObject_IsTrue(param3) != 0), (PyObject_IsTrue(param4) != 0), param5_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update_internals(const CharacterSlider self, PartBundle root, PartGroup parent, bool self_changed, bool parent_changed, Thread current_thread)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CharacterSlider_update_internals_22_comment =
  "C++ Interface:\n"
  "update_internals(const CharacterSlider self, PartBundle root, PartGroup parent, bool self_changed, bool parent_changed, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * This is called by do_update() whenever the part or some ancestor has\n"
  " * changed values.  It is a hook for derived classes to update whatever cache\n"
  " * they may have that depends on these.\n"
  " *\n"
  " * The return value is true if the part has changed as a result of the update,\n"
  " * or false otherwise.\n"
  " */";
#else
static const char *Dtool_CharacterSlider_update_internals_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CharacterSlider::get_class_type(void)
 */
static PyObject *Dtool_CharacterSlider_get_class_type_23(PyObject *, PyObject *) {
  // 1-static TypeHandle CharacterSlider::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CharacterSlider::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterSlider_get_class_type_23_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CharacterSlider_get_class_type_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CharacterSlider::CharacterSlider(PartGroup *parent, std::string const &name)
 */
static int Dtool_Init_CharacterSlider(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CharacterSlider::CharacterSlider(PartGroup *parent, std::string const &name)
  PyObject *param0;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"parent", "name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:CharacterSlider", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    PT(PartGroup) param0_this;
    if (!Dtool_Coerce_PartGroup(param0, param0_this)) {
      Dtool_Raise_ArgTypeError(param0, 0, "CharacterSlider.CharacterSlider", "PartGroup");
      return -1;
    }
    CharacterSlider *return_value = new CharacterSlider(MOVE(param0_this), std::string(param1_str, param1_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CharacterSlider, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CharacterSlider(PartGroup parent, str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CharacterSlider(PyObject *args, CPT(CharacterSlider) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CharacterSlider, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-CharacterSlider::CharacterSlider(PartGroup *parent, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:CharacterSlider", &param0, &param1_str, &param1_len)) {
        PartGroup *param0_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PartGroup, 0, "CharacterSlider.CharacterSlider", false, false);
        if (param0_this != NULL) {
          CharacterSlider *return_value = new CharacterSlider(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_CharacterSlider(PyObject *args, PT(CharacterSlider) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CharacterSlider, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-CharacterSlider::CharacterSlider(PartGroup *parent, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:CharacterSlider", &param0, &param1_str, &param1_len)) {
        PartGroup *param0_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PartGroup, 0, "CharacterSlider.CharacterSlider", false, false);
        if (param0_this != NULL) {
          CharacterSlider *return_value = new CharacterSlider(param0_this, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CharacterSlider(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CharacterSlider) {
    printf("CharacterSlider ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CharacterSlider *local_this = (CharacterSlider *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CharacterSlider) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    return (MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartScalar) {
    return (MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CharacterSlider(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CharacterSlider) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    MovingPart< ACScalarSwitchType >* other_this = (MovingPart< ACScalarSwitchType >*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartScalar) {
    MovingPartScalar* other_this = (MovingPartScalar*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CharacterSlider*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CharacterVertexSlider
 */
/**
 * Python function wrapper for:
 * inline CharacterSlider const *CharacterVertexSlider::get_char_slider(void) const
 */
static PyObject *Dtool_CharacterVertexSlider_get_char_slider_27(PyObject *self, PyObject *) {
  CharacterVertexSlider *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CharacterVertexSlider, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CharacterSlider const *CharacterVertexSlider::get_char_slider(void) const
  CharacterSlider const *return_value = (*(const CharacterVertexSlider*)local_this).get_char_slider();
  if (return_value != (CharacterSlider const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (CharacterSlider const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CharacterSlider, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CharacterVertexSlider_get_char_slider_27_comment =
  "C++ Interface:\n"
  "get_char_slider(CharacterVertexSlider self)\n"
  "\n"
  "/**\n"
  " * Returns the CharacterSlider object for which this object returns the slider\n"
  " * value.\n"
  " */";
#else
static const char *Dtool_CharacterVertexSlider_get_char_slider_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CharacterVertexSlider::get_class_type(void)
 */
static PyObject *Dtool_CharacterVertexSlider_get_class_type_28(PyObject *, PyObject *) {
  // 1-static TypeHandle CharacterVertexSlider::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CharacterVertexSlider::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterVertexSlider_get_class_type_28_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CharacterVertexSlider_get_class_type_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CharacterVertexSlider::CharacterVertexSlider(CharacterSlider *char_slider)
 */
static int Dtool_Init_CharacterVertexSlider(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CharacterVertexSlider() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "char_slider");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'char_slider' (pos 1) not found");
    return -1;
  }
  // 1-CharacterVertexSlider::CharacterVertexSlider(CharacterSlider *char_slider)
  PT(CharacterSlider) arg_this;
  if (!Dtool_Coerce_CharacterSlider(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 0, "CharacterVertexSlider.CharacterVertexSlider", "CharacterSlider");
    return -1;
  }
  CharacterVertexSlider *return_value = new CharacterVertexSlider(MOVE(arg_this));
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CharacterVertexSlider, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CharacterVertexSlider(CharacterSlider char_slider)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CharacterVertexSlider(PyObject *args, CPT(CharacterVertexSlider) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CharacterVertexSlider, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CharacterVertexSlider::CharacterVertexSlider(CharacterSlider *char_slider)
    CharacterSlider *arg_this = (CharacterSlider *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CharacterSlider, 0, "CharacterVertexSlider.CharacterVertexSlider", false, false);
    if (arg_this != NULL) {
      CharacterVertexSlider *return_value = new CharacterVertexSlider(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_CharacterVertexSlider(PyObject *args, PT(CharacterVertexSlider) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CharacterVertexSlider, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CharacterVertexSlider::CharacterVertexSlider(CharacterSlider *char_slider)
    CharacterSlider *arg_this = (CharacterSlider *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CharacterSlider, 0, "CharacterVertexSlider.CharacterVertexSlider", false, false);
    if (arg_this != NULL) {
      CharacterVertexSlider *return_value = new CharacterVertexSlider(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_CharacterVertexSlider(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CharacterVertexSlider) {
    printf("CharacterVertexSlider ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CharacterVertexSlider *local_this = (CharacterVertexSlider *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CharacterVertexSlider) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_VertexSlider) {
    return (VertexSlider *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CharacterVertexSlider(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CharacterVertexSlider) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CharacterVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CharacterVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CharacterVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CharacterVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_VertexSlider) {
    VertexSlider* other_this = (VertexSlider*)from_this;
    return (CharacterVertexSlider*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class JointVertexTransform
 */
/**
 * Python function wrapper for:
 * inline CharacterJoint const *JointVertexTransform::get_joint(void) const
 */
static PyObject *Dtool_JointVertexTransform_get_joint_32(PyObject *self, PyObject *) {
  JointVertexTransform *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_JointVertexTransform, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CharacterJoint const *JointVertexTransform::get_joint(void) const
  CharacterJoint const *return_value = (*(const JointVertexTransform*)local_this).get_joint();
  if (return_value != (CharacterJoint const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (CharacterJoint const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CharacterJoint, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_JointVertexTransform_get_joint_32_comment =
  "C++ Interface:\n"
  "get_joint(JointVertexTransform self)\n"
  "\n"
  "/**\n"
  " * Returns the joint for which this object returns the transform.\n"
  " */";
#else
static const char *Dtool_JointVertexTransform_get_joint_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle JointVertexTransform::get_class_type(void)
 */
static PyObject *Dtool_JointVertexTransform_get_class_type_33(PyObject *, PyObject *) {
  // 1-static TypeHandle JointVertexTransform::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(JointVertexTransform::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_JointVertexTransform_get_class_type_33_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_JointVertexTransform_get_class_type_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * JointVertexTransform::JointVertexTransform(CharacterJoint *joint)
 */
static int Dtool_Init_JointVertexTransform(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "JointVertexTransform() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "joint");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'joint' (pos 1) not found");
    return -1;
  }
  // 1-JointVertexTransform::JointVertexTransform(CharacterJoint *joint)
  PT(CharacterJoint) arg_this;
  if (!Dtool_Coerce_CharacterJoint(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 0, "JointVertexTransform.JointVertexTransform", "CharacterJoint");
    return -1;
  }
  JointVertexTransform *return_value = new JointVertexTransform(MOVE(arg_this));
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_JointVertexTransform, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "JointVertexTransform(CharacterJoint joint)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_JointVertexTransform(PyObject *args, CPT(JointVertexTransform) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_JointVertexTransform, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-JointVertexTransform::JointVertexTransform(CharacterJoint *joint)
    CharacterJoint *arg_this = (CharacterJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CharacterJoint, 0, "JointVertexTransform.JointVertexTransform", false, false);
    if (arg_this != NULL) {
      JointVertexTransform *return_value = new JointVertexTransform(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_JointVertexTransform(PyObject *args, PT(JointVertexTransform) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_JointVertexTransform, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-JointVertexTransform::JointVertexTransform(CharacterJoint *joint)
    CharacterJoint *arg_this = (CharacterJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CharacterJoint, 0, "JointVertexTransform.JointVertexTransform", false, false);
    if (arg_this != NULL) {
      JointVertexTransform *return_value = new JointVertexTransform(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_JointVertexTransform(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_JointVertexTransform) {
    printf("JointVertexTransform ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  JointVertexTransform *local_this = (JointVertexTransform *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_JointVertexTransform) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_VertexTransform) {
    return (VertexTransform *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_JointVertexTransform(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_JointVertexTransform) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (JointVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (JointVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (JointVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (JointVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_VertexTransform) {
    VertexTransform* other_this = (VertexTransform*)from_this;
    return (JointVertexTransform*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Character
 */
/**
 * Python function wrapper for:
 * inline CharacterJointBundle *Character::get_bundle(int i) const
 */
static PyObject *Dtool_Character_get_bundle_37(PyObject *self, PyObject *arg) {
  Character *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Character, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CharacterJointBundle *Character::get_bundle(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CharacterJointBundle *return_value = (*(const Character*)local_this).get_bundle((int)arg_val);
    if (return_value != (CharacterJointBundle *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (CharacterJointBundle *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CharacterJointBundle, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bundle(Character self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Character_get_bundle_37_comment =
  "C++ Interface:\n"
  "get_bundle(Character self, int i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Character_get_bundle_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Character::merge_bundles(PartBundle *old_bundle, PartBundle *other_bundle)
 * void Character::merge_bundles(PartBundleHandle *old_bundle_handle, PartBundleHandle *other_bundle_handle)
 */
static PyObject *Dtool_Character_merge_bundles_38(PyObject *self, PyObject *args, PyObject *kwds) {
  Character *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.merge_bundles")) {
    return NULL;
  }
  {
    // -2 void Character::merge_bundles(PartBundle *old_bundle, PartBundle *other_bundle)
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"old_bundle", "other_bundle", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:merge_bundles", (char **)keyword_list, &param1, &param2)) {
      PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PartBundle, 1, "Character.merge_bundles", false, false);
      PartBundle *param2_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PartBundle, 2, "Character.merge_bundles", false, false);
      if (param1_this != NULL && param2_this != NULL) {
        (*local_this).merge_bundles(param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void Character::merge_bundles(PartBundleHandle *old_bundle_handle, PartBundleHandle *other_bundle_handle)
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"old_bundle_handle", "other_bundle_handle", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:merge_bundles", (char **)keyword_list, &param1, &param2)) {
      PartBundleHandle *param1_this = (PartBundleHandle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PartBundleHandle, 1, "Character.merge_bundles", false, false);
      PartBundleHandle *param2_this = (PartBundleHandle *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PartBundleHandle, 2, "Character.merge_bundles", false, false);
      if (param1_this != NULL && param2_this != NULL) {
        (*local_this).merge_bundles(param1_this, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void Character::merge_bundles(PartBundle *old_bundle, PartBundle *other_bundle)
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"old_bundle", "other_bundle", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:merge_bundles", (char **)keyword_list, &param1, &param2)) {
      PT(PartBundle) param1_this;
      PT(PartBundle) param2_this;
      if (Dtool_Coerce_PartBundle(param1, param1_this) && Dtool_Coerce_PartBundle(param2, param2_this)) {
        (*local_this).merge_bundles(MOVE(param1_this), MOVE(param2_this));
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void Character::merge_bundles(PartBundleHandle *old_bundle_handle, PartBundleHandle *other_bundle_handle)
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"old_bundle_handle", "other_bundle_handle", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:merge_bundles", (char **)keyword_list, &param1, &param2)) {
      PT(PartBundleHandle) param1_this;
      PT(PartBundleHandle) param2_this;
      if (Dtool_Coerce_PartBundleHandle(param1, param1_this) && Dtool_Coerce_PartBundleHandle(param2, param2_this)) {
        (*local_this).merge_bundles(MOVE(param1_this), MOVE(param2_this));
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "merge_bundles(const Character self, PartBundle old_bundle, PartBundle other_bundle)\n"
      "merge_bundles(const Character self, PartBundleHandle old_bundle_handle, PartBundleHandle other_bundle_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Character_merge_bundles_38_comment =
  "C++ Interface:\n"
  "merge_bundles(const Character self, PartBundle old_bundle, PartBundle other_bundle)\n"
  "merge_bundles(const Character self, PartBundleHandle old_bundle_handle, PartBundleHandle other_bundle_handle)\n"
  "\n"
  "/**\n"
  " * Merges old_bundle with new_bundle.  old_bundle must be one of the\n"
  " * PartBundles within this node.  At the end of this call, the old_bundle\n"
  " * pointer within this node will be replaced with the new_bundle pointer, and\n"
  " * all geometry within this node will be updated to reference new_bundle.\n"
  " *\n"
  " * This method is deprecated.  Use the newer version of this method, below.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Merges old_bundle_handle->get_bundle() with new_bundle.  old_bundle_handle\n"
  " * must be one of the PartBundleHandle within this node.  At the end of this\n"
  " * call, the bundle pointer within the old_bundle_handle will be replaced with\n"
  " * that within the new_bundle_handle pointer, and all geometry within this\n"
  " * node will be updated to reference new_bundle.\n"
  " *\n"
  " * Normally, this is called when the two bundles have the same, or nearly the\n"
  " * same, hierarchies.  In this case, new_bundle will simply be assigned over\n"
  " * the old_bundle position.  However, if any joints are present in one bundle\n"
  " * or the other, new_bundle will be modified to contain the union of all\n"
  " * joints.\n"
  " *\n"
  " * The geometry below this node is also updated to reference new_bundle,\n"
  " * instead of the original old_bundle.\n"
  " *\n"
  " * This method is intended to unify two different models that share a common\n"
  " * skeleton, for instance, different LOD's of the same model.\n"
  " */";
#else
static const char *Dtool_Character_merge_bundles_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Character::set_lod_animation(LPoint3 const &center, PN_stdfloat far_distance, PN_stdfloat near_distance, PN_stdfloat delay_factor)
 */
static PyObject *Dtool_Character_set_lod_animation_39(PyObject *self, PyObject *args, PyObject *kwds) {
  Character *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.set_lod_animation")) {
    return NULL;
  }
  // 1-void Character::set_lod_animation(LPoint3 const &center, PN_stdfloat far_distance, PN_stdfloat near_distance, PN_stdfloat delay_factor)
  PyObject *param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"center", "far_distance", "near_distance", "delay_factor", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:set_lod_animation", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Character.set_lod_animation", "LPoint3f");
    }
    (*local_this).set_lod_animation(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod_animation(const Character self, const LPoint3f center, float far_distance, float near_distance, float delay_factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Character_set_lod_animation_39_comment =
  "C++ Interface:\n"
  "set_lod_animation(const Character self, const LPoint3f center, float far_distance, float near_distance, float delay_factor)\n"
  "\n"
  "/**\n"
  " * Activates a special mode in which the character animates less frequently as\n"
  " * it gets further from the camera.  This is intended as a simple optimization\n"
  " * to minimize the effort of computing animation for lots of characters that\n"
  " * may not necessarily be very important to animate every frame.\n"
  " *\n"
  " * If the character is closer to the camera than near_distance, then it is\n"
  " * animated its normal rate, every frame.  If the character is exactly\n"
  " * far_distance away, it is animated only every delay_factor seconds (which\n"
  " * should be a number greater than 0).  If the character is between\n"
  " * near_distance and far_distance, its animation rate is linearly interpolated\n"
  " * according to its distance between the two.  The interpolation function\n"
  " * continues beyond far_distance, so that the character is animated\n"
  " * increasingly less frequently as it gets farther away.\n"
  " *\n"
  " * The distance calculations are made from center, which is a fixed point\n"
  " * relative to the character node, to the camera's lod center or cull center\n"
  " * node (or to the camera node itself).\n"
  " *\n"
  " * If multiple cameras are viewing the character in any given frame, the\n"
  " * closest one counts.\n"
  " */";
#else
static const char *Dtool_Character_set_lod_animation_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Character::clear_lod_animation(void)
 */
static PyObject *Dtool_Character_clear_lod_animation_40(PyObject *self, PyObject *) {
  Character *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.clear_lod_animation")) {
    return NULL;
  }
  // 1-void Character::clear_lod_animation(void)
  (*local_this).clear_lod_animation();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Character_clear_lod_animation_40_comment =
  "C++ Interface:\n"
  "clear_lod_animation(const Character self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a recent call to set_lod_animation().  Henceforth, the\n"
  " * character will animate every frame, regardless of its distance from the\n"
  " * camera.\n"
  " */";
#else
static const char *Dtool_Character_clear_lod_animation_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CharacterJoint *Character::find_joint(std::string const &name) const
 */
static PyObject *Dtool_Character_find_joint_41(PyObject *self, PyObject *arg) {
  Character *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Character, (void **)&local_this)) {
    return NULL;
  }
  // 1-CharacterJoint *Character::find_joint(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    CharacterJoint *return_value = (*(const Character*)local_this).find_joint(std::string(param1_str, param1_len));
    if (return_value != (CharacterJoint *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (CharacterJoint *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CharacterJoint, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_joint(Character self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Character_find_joint_41_comment =
  "C++ Interface:\n"
  "find_joint(Character self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the joint with the given name, if there is such a\n"
  " * joint, or NULL if there is no such joint.  This will not return a pointer\n"
  " * to a slider.\n"
  " */";
#else
static const char *Dtool_Character_find_joint_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CharacterSlider *Character::find_slider(std::string const &name) const
 */
static PyObject *Dtool_Character_find_slider_42(PyObject *self, PyObject *arg) {
  Character *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Character, (void **)&local_this)) {
    return NULL;
  }
  // 1-CharacterSlider *Character::find_slider(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    CharacterSlider *return_value = (*(const Character*)local_this).find_slider(std::string(param1_str, param1_len));
    if (return_value != (CharacterSlider *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (CharacterSlider *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CharacterSlider, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_slider(Character self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Character_find_slider_42_comment =
  "C++ Interface:\n"
  "find_slider(Character self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the slider with the given name, if there is such a\n"
  " * slider, or NULL if there is no such slider.  This will not return a pointer\n"
  " * to a joint.\n"
  " */";
#else
static const char *Dtool_Character_find_slider_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Character::write_parts(ostream &out) const
 */
static PyObject *Dtool_Character_write_parts_43(PyObject *self, PyObject *arg) {
  Character *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Character, (void **)&local_this)) {
    return NULL;
  }
  // 1-void Character::write_parts(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Character.write_parts", false, true);
  if (arg_this != NULL) {
    (*(const Character*)local_this).write_parts(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_parts(Character self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Character_write_parts_43_comment =
  "C++ Interface:\n"
  "write_parts(Character self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a list of the Character's joints and sliders, in their hierchical\n"
  " * structure, to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_Character_write_parts_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Character::write_part_values(ostream &out) const
 */
static PyObject *Dtool_Character_write_part_values_44(PyObject *self, PyObject *arg) {
  Character *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Character, (void **)&local_this)) {
    return NULL;
  }
  // 1-void Character::write_part_values(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Character.write_part_values", false, true);
  if (arg_this != NULL) {
    (*(const Character*)local_this).write_part_values(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_part_values(Character self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Character_write_part_values_44_comment =
  "C++ Interface:\n"
  "write_part_values(Character self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a list of the Character's joints and sliders, along with each\n"
  " * current position, in their hierchical structure, to the indicated output\n"
  " * stream.\n"
  " */";
#else
static const char *Dtool_Character_write_part_values_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Character::update_to_now(void)
 */
static PyObject *Dtool_Character_update_to_now_45(PyObject *self, PyObject *) {
  Character *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.update_to_now")) {
    return NULL;
  }
  // 1-void Character::update_to_now(void)
  (*local_this).update_to_now();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Character_update_to_now_45_comment =
  "C++ Interface:\n"
  "update_to_now(const Character self)\n"
  "\n"
  "/**\n"
  " * Advances the character's frame to the current time, and then calls\n"
  " * update().  This can be used by show code to force an update of the\n"
  " * character's position to the current frame, regardless of whether the\n"
  " * character is currently onscreen and animating.\n"
  " *\n"
  " * This method is deprecated.  Call update() instead.\n"
  " */";
#else
static const char *Dtool_Character_update_to_now_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Character::update(void)
 */
static PyObject *Dtool_Character_update_46(PyObject *self, PyObject *) {
  Character *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.update")) {
    return NULL;
  }
  // 1-void Character::update(void)
  (*local_this).update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Character_update_46_comment =
  "C++ Interface:\n"
  "update(const Character self)\n"
  "\n"
  "/**\n"
  " * Recalculates the Character's joints and vertices for the current frame.\n"
  " * Normally this is performed automatically during the render and need not be\n"
  " * called explicitly.\n"
  " */";
#else
static const char *Dtool_Character_update_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Character::force_update(void)
 */
static PyObject *Dtool_Character_force_update_47(PyObject *self, PyObject *) {
  Character *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.force_update")) {
    return NULL;
  }
  // 1-void Character::force_update(void)
  (*local_this).force_update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Character_force_update_47_comment =
  "C++ Interface:\n"
  "force_update(const Character self)\n"
  "\n"
  "/**\n"
  " * Recalculates the character even if we think it doesn't need it.\n"
  " */";
#else
static const char *Dtool_Character_force_update_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Character::get_class_type(void)
 */
static PyObject *Dtool_Character_get_class_type_48(PyObject *, PyObject *) {
  // 1-static TypeHandle Character::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Character::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Character_get_class_type_48_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Character_get_class_type_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Character::Character(Character const &) = default
 * Character::Character(std::string const &name)
 */
static int Dtool_Init_Character(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Character() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline Character::Character(Character const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Character", (char **)keyword_list, &param0)) {
      Character const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Character, (void **)&param0_this);
      if (param0_this != NULL) {
        Character *return_value = new Character(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Character, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 Character::Character(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Character", (char **)keyword_list, &param0_str, &param0_len)) {
      Character *return_value = new Character(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Character, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline Character::Character(Character const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Character", (char **)keyword_list, &param0)) {
      CPT(Character) param0_this;
      if (Dtool_ConstCoerce_Character(param0, param0_this)) {
        Character *return_value = new Character(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Character, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: Character::Character(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Character(const Character param0)\n"
      "Character(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Character(PyObject *args, CPT(Character) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Character, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Character::Character(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Character *return_value = new Character(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_Character(PyObject *args, PT(Character) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Character, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Character::Character(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Character *return_value = new Character(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_Character(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Character) {
    printf("Character ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Character *local_this = (Character *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Character) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartBundleNode) {
    return (PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(PartBundleNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Character(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Character) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_PartBundleNode) {
    PartBundleNode* other_this = (PartBundleNode*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Character*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CharacterJointBundle
 */
/**
 * Python function wrapper for:
 * inline Character *CharacterJointBundle::get_node(int n) const
 */
static PyObject *Dtool_CharacterJointBundle_get_node_52(PyObject *self, PyObject *arg) {
  CharacterJointBundle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CharacterJointBundle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Character *CharacterJointBundle::get_node(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Character *return_value = (*(const CharacterJointBundle*)local_this).get_node((int)arg_val);
    if (return_value != (Character *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (Character *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Character, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(CharacterJointBundle self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJointBundle_get_node_52_comment =
  "C++ Interface:\n"
  "get_node(CharacterJointBundle self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth Character associated with this PartBundle.\n"
  " */";
#else
static const char *Dtool_CharacterJointBundle_get_node_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CharacterJointBundle::get_class_type(void)
 */
static PyObject *Dtool_CharacterJointBundle_get_class_type_53(PyObject *, PyObject *) {
  // 1-static TypeHandle CharacterJointBundle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CharacterJointBundle::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterJointBundle_get_class_type_53_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CharacterJointBundle_get_class_type_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CharacterJointBundle::CharacterJointBundle(std::string const &name = "")
 */
static int Dtool_Init_CharacterJointBundle(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CharacterJointBundle::CharacterJointBundle(std::string const &name = "")
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:CharacterJointBundle", (char **)keyword_list, &param0_str, &param0_len)) {
    CharacterJointBundle *return_value = new CharacterJointBundle(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CharacterJointBundle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CharacterJointBundle(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CharacterJointBundle(PyObject *args, CPT(CharacterJointBundle) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CharacterJointBundle, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CharacterJointBundle::CharacterJointBundle(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CharacterJointBundle *return_value = new CharacterJointBundle(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_CharacterJointBundle(PyObject *args, PT(CharacterJointBundle) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CharacterJointBundle, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CharacterJointBundle::CharacterJointBundle(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      CharacterJointBundle *return_value = new CharacterJointBundle(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_CharacterJointBundle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CharacterJointBundle) {
    printf("CharacterJointBundle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CharacterJointBundle *local_this = (CharacterJointBundle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CharacterJointBundle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartBundle) {
    return (PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(PartBundle *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CharacterJointBundle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CharacterJointBundle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_PartBundle) {
    PartBundle* other_this = (PartBundle*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CharacterJointEffect
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > CharacterJointEffect::make(Character *character)
 */
static PyObject *Dtool_CharacterJointEffect_make_56(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderEffect > CharacterJointEffect::make(Character *character)
  PT(Character) arg_this;
  if (!Dtool_Coerce_Character(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "CharacterJointEffect.make", "Character");
  }
  ConstPointerTo< RenderEffect > return_value = CharacterJointEffect::make(MOVE(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  RenderEffect const *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(Character character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJointEffect_make_56_comment =
  "C++ Interface:\n"
  "make(Character character)\n"
  "\n"
  "/**\n"
  " * Constructs a new CharacterJointEffect object that references the indicated\n"
  " * character.  When a relative get_transform() is called on the node that\n"
  " * contains the CharacterJointEffect, it will implicitly call\n"
  " * character->update() first.\n"
  " */";
#else
static const char *Dtool_CharacterJointEffect_make_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Character *CharacterJointEffect::get_character(void) const
 */
static PyObject *Dtool_CharacterJointEffect_get_character_57(PyObject *self, PyObject *) {
  CharacterJointEffect *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CharacterJointEffect, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Character *CharacterJointEffect::get_character(void) const
  Character *return_value = (*(const CharacterJointEffect*)local_this).get_character();
  if (return_value != (Character *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Character *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Character, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CharacterJointEffect_get_character_57_comment =
  "C++ Interface:\n"
  "get_character(CharacterJointEffect self)\n"
  "\n"
  "/**\n"
  " * Returns the Character that will get update() called on it when this node's\n"
  " * relative transform is queried, or NULL if there is no such character.\n"
  " */";
#else
static const char *Dtool_CharacterJointEffect_get_character_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CharacterJointEffect::get_class_type(void)
 */
static PyObject *Dtool_CharacterJointEffect_get_class_type_58(PyObject *, PyObject *) {
  // 1-static TypeHandle CharacterJointEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CharacterJointEffect::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterJointEffect_get_class_type_58_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CharacterJointEffect_get_class_type_58_comment = NULL;
#endif

static int Dtool_Init_CharacterJointEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_CharacterJointEffect(PyObject *args, CPT(CharacterJointEffect) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CharacterJointEffect, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderEffect > CharacterJointEffect::make(Character *character)
    Character *arg_this = (Character *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Character, 0, "CharacterJointEffect.make", false, false);
    if (arg_this != NULL) {
      ConstPointerTo< RenderEffect > return_value = CharacterJointEffect::make(arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = MOVE((CharacterJointEffect const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_CharacterJointEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CharacterJointEffect) {
    printf("CharacterJointEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CharacterJointEffect *local_this = (CharacterJointEffect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CharacterJointEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CharacterJointEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CharacterJointEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CharacterJointEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (CharacterJointEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CharacterJointEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CharacterJointEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CharacterJointEffect*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for CharacterJoint (CharacterJoint)
 */
static PyMethodDef Dtool_Methods_CharacterJoint[] = {
  {"add_net_transform", &Dtool_CharacterJoint_add_net_transform_4, METH_O, (const char *)Dtool_CharacterJoint_add_net_transform_4_comment},
  {"addNetTransform", &Dtool_CharacterJoint_add_net_transform_4, METH_O, (const char *)Dtool_CharacterJoint_add_net_transform_4_comment},
  {"remove_net_transform", &Dtool_CharacterJoint_remove_net_transform_5, METH_O, (const char *)Dtool_CharacterJoint_remove_net_transform_5_comment},
  {"removeNetTransform", &Dtool_CharacterJoint_remove_net_transform_5, METH_O, (const char *)Dtool_CharacterJoint_remove_net_transform_5_comment},
  {"has_net_transform", &Dtool_CharacterJoint_has_net_transform_6, METH_O, (const char *)Dtool_CharacterJoint_has_net_transform_6_comment},
  {"hasNetTransform", &Dtool_CharacterJoint_has_net_transform_6, METH_O, (const char *)Dtool_CharacterJoint_has_net_transform_6_comment},
  {"clear_net_transforms", &Dtool_CharacterJoint_clear_net_transforms_7, METH_NOARGS, (const char *)Dtool_CharacterJoint_clear_net_transforms_7_comment},
  {"clearNetTransforms", &Dtool_CharacterJoint_clear_net_transforms_7, METH_NOARGS, (const char *)Dtool_CharacterJoint_clear_net_transforms_7_comment},
  {"get_net_transforms", &Dtool_CharacterJoint_get_net_transforms_8, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_net_transforms_8_comment},
  {"getNetTransforms", &Dtool_CharacterJoint_get_net_transforms_8, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_net_transforms_8_comment},
  {"add_local_transform", &Dtool_CharacterJoint_add_local_transform_9, METH_O, (const char *)Dtool_CharacterJoint_add_local_transform_9_comment},
  {"addLocalTransform", &Dtool_CharacterJoint_add_local_transform_9, METH_O, (const char *)Dtool_CharacterJoint_add_local_transform_9_comment},
  {"remove_local_transform", &Dtool_CharacterJoint_remove_local_transform_10, METH_O, (const char *)Dtool_CharacterJoint_remove_local_transform_10_comment},
  {"removeLocalTransform", &Dtool_CharacterJoint_remove_local_transform_10, METH_O, (const char *)Dtool_CharacterJoint_remove_local_transform_10_comment},
  {"has_local_transform", &Dtool_CharacterJoint_has_local_transform_11, METH_O, (const char *)Dtool_CharacterJoint_has_local_transform_11_comment},
  {"hasLocalTransform", &Dtool_CharacterJoint_has_local_transform_11, METH_O, (const char *)Dtool_CharacterJoint_has_local_transform_11_comment},
  {"clear_local_transforms", &Dtool_CharacterJoint_clear_local_transforms_12, METH_NOARGS, (const char *)Dtool_CharacterJoint_clear_local_transforms_12_comment},
  {"clearLocalTransforms", &Dtool_CharacterJoint_clear_local_transforms_12, METH_NOARGS, (const char *)Dtool_CharacterJoint_clear_local_transforms_12_comment},
  {"get_local_transforms", &Dtool_CharacterJoint_get_local_transforms_13, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_local_transforms_13_comment},
  {"getLocalTransforms", &Dtool_CharacterJoint_get_local_transforms_13, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_local_transforms_13_comment},
  {"get_transform", &Dtool_CharacterJoint_get_transform_14, METH_VARARGS, (const char *)Dtool_CharacterJoint_get_transform_14_comment},
  {"getTransform", &Dtool_CharacterJoint_get_transform_14, METH_VARARGS, (const char *)Dtool_CharacterJoint_get_transform_14_comment},
  {"get_transform_state", &Dtool_CharacterJoint_get_transform_state_15, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_transform_state_15_comment},
  {"getTransformState", &Dtool_CharacterJoint_get_transform_state_15, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_transform_state_15_comment},
  {"get_net_transform", &Dtool_CharacterJoint_get_net_transform_16, METH_O, (const char *)Dtool_CharacterJoint_get_net_transform_16_comment},
  {"getNetTransform", &Dtool_CharacterJoint_get_net_transform_16, METH_O, (const char *)Dtool_CharacterJoint_get_net_transform_16_comment},
  {"get_character", &Dtool_CharacterJoint_get_character_17, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_character_17_comment},
  {"getCharacter", &Dtool_CharacterJoint_get_character_17, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_character_17_comment},
  {"get_class_type", &Dtool_CharacterJoint_get_class_type_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJoint_get_class_type_18_comment},
  {"getClassType", &Dtool_CharacterJoint_get_class_type_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJoint_get_class_type_18_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CharacterJoint = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CharacterJoint = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CharacterJoint = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CharacterJoint = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CharacterJoint = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CharacterJoint",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CharacterJoint,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CharacterJoint,
    &Dtool_SequenceMethods_CharacterJoint,
    &Dtool_MappingMethods_CharacterJoint,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CharacterJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents one joint of the character's animation, containing an\n"
    " * animating transform matrix.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CharacterJoint,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CharacterJoint,
    PyType_GenericAlloc,
    Dtool_new_CharacterJoint,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CharacterJoint,
  Dtool_UpcastInterface_CharacterJoint,
  Dtool_DowncastInterface_CharacterJoint,
  (CoerceFunction)Dtool_ConstCoerce_CharacterJoint,
  (CoerceFunction)Dtool_Coerce_CharacterJoint,
};

static void Dtool_PyModuleClassInit_CharacterJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_MovingPartMatrix != NULL);
    assert(Dtool_Ptr_MovingPartMatrix->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_MovingPartMatrix->_Dtool_ModuleClassInit(NULL);
    Dtool_CharacterJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_MovingPartMatrix);
    PyObject *dict = PyDict_New();
    Dtool_CharacterJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CharacterJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CharacterJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CharacterJoint);
  }
}

/**
 * Python method tables for CharacterSlider (CharacterSlider)
 */
static PyMethodDef Dtool_Methods_CharacterSlider[] = {
  {"update_internals", (PyCFunction) &Dtool_CharacterSlider_update_internals_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CharacterSlider_update_internals_22_comment},
  {"updateInternals", (PyCFunction) &Dtool_CharacterSlider_update_internals_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CharacterSlider_update_internals_22_comment},
  {"get_class_type", &Dtool_CharacterSlider_get_class_type_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterSlider_get_class_type_23_comment},
  {"getClassType", &Dtool_CharacterSlider_get_class_type_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterSlider_get_class_type_23_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CharacterSlider = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CharacterSlider = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CharacterSlider = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CharacterSlider = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CharacterSlider = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CharacterSlider",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CharacterSlider,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CharacterSlider,
    &Dtool_SequenceMethods_CharacterSlider,
    &Dtool_MappingMethods_CharacterSlider,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CharacterSlider,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a morph slider within the character.  It's simply a single\n"
    " * floating-point value that animates generally between 0 and 1, that controls\n"
    " * the effects of one or more morphs within the character.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CharacterSlider,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CharacterSlider,
    PyType_GenericAlloc,
    Dtool_new_CharacterSlider,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CharacterSlider,
  Dtool_UpcastInterface_CharacterSlider,
  Dtool_DowncastInterface_CharacterSlider,
  (CoerceFunction)Dtool_ConstCoerce_CharacterSlider,
  (CoerceFunction)Dtool_Coerce_CharacterSlider,
};

static void Dtool_PyModuleClassInit_CharacterSlider(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_MovingPartScalar != NULL);
    assert(Dtool_Ptr_MovingPartScalar->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_MovingPartScalar->_Dtool_ModuleClassInit(NULL);
    Dtool_CharacterSlider._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_MovingPartScalar);
    PyObject *dict = PyDict_New();
    Dtool_CharacterSlider._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CharacterSlider) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CharacterSlider)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CharacterSlider);
  }
}

/**
 * Python method tables for CharacterVertexSlider (CharacterVertexSlider)
 */
static PyMethodDef Dtool_Methods_CharacterVertexSlider[] = {
  {"get_char_slider", &Dtool_CharacterVertexSlider_get_char_slider_27, METH_NOARGS, (const char *)Dtool_CharacterVertexSlider_get_char_slider_27_comment},
  {"getCharSlider", &Dtool_CharacterVertexSlider_get_char_slider_27, METH_NOARGS, (const char *)Dtool_CharacterVertexSlider_get_char_slider_27_comment},
  {"get_class_type", &Dtool_CharacterVertexSlider_get_class_type_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterVertexSlider_get_class_type_28_comment},
  {"getClassType", &Dtool_CharacterVertexSlider_get_class_type_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterVertexSlider_get_class_type_28_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CharacterVertexSlider = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CharacterVertexSlider = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CharacterVertexSlider = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CharacterVertexSlider = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CharacterVertexSlider = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CharacterVertexSlider",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CharacterVertexSlider,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CharacterVertexSlider,
    &Dtool_SequenceMethods_CharacterVertexSlider,
    &Dtool_MappingMethods_CharacterVertexSlider,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CharacterVertexSlider,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization on VertexSlider that returns the slider value\n"
    " * associated with a particular CharacterSlider object.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CharacterVertexSlider,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CharacterVertexSlider,
    PyType_GenericAlloc,
    Dtool_new_CharacterVertexSlider,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CharacterVertexSlider,
  Dtool_UpcastInterface_CharacterVertexSlider,
  Dtool_DowncastInterface_CharacterVertexSlider,
  (CoerceFunction)Dtool_ConstCoerce_CharacterVertexSlider,
  (CoerceFunction)Dtool_Coerce_CharacterVertexSlider,
};

static void Dtool_PyModuleClassInit_CharacterVertexSlider(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_VertexSlider != NULL);
    assert(Dtool_Ptr_VertexSlider->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_VertexSlider->_Dtool_ModuleClassInit(NULL);
    Dtool_CharacterVertexSlider._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_VertexSlider);
    PyObject *dict = PyDict_New();
    Dtool_CharacterVertexSlider._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CharacterVertexSlider) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CharacterVertexSlider)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CharacterVertexSlider);
  }
}

/**
 * Python method tables for JointVertexTransform (JointVertexTransform)
 */
static PyMethodDef Dtool_Methods_JointVertexTransform[] = {
  {"get_joint", &Dtool_JointVertexTransform_get_joint_32, METH_NOARGS, (const char *)Dtool_JointVertexTransform_get_joint_32_comment},
  {"getJoint", &Dtool_JointVertexTransform_get_joint_32, METH_NOARGS, (const char *)Dtool_JointVertexTransform_get_joint_32_comment},
  {"get_class_type", &Dtool_JointVertexTransform_get_class_type_33, METH_NOARGS | METH_STATIC, (const char *)Dtool_JointVertexTransform_get_class_type_33_comment},
  {"getClassType", &Dtool_JointVertexTransform_get_class_type_33, METH_NOARGS | METH_STATIC, (const char *)Dtool_JointVertexTransform_get_class_type_33_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_JointVertexTransform = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_JointVertexTransform = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_JointVertexTransform = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_JointVertexTransform = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_JointVertexTransform = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.JointVertexTransform",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_JointVertexTransform,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_JointVertexTransform,
    &Dtool_SequenceMethods_JointVertexTransform,
    &Dtool_MappingMethods_JointVertexTransform,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_JointVertexTransform,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization on VertexTransform that returns the transform\n"
    " * necessary to move vertices as if they were assigned to the indicated joint.\n"
    " * The geometry itself should be parented to the scene graph at the level of\n"
    " * the character's root joint; that is, it should not be parented under a node\n"
    " * directly animated by any joints.\n"
    " *\n"
    " * Multiple combinations of these with different weights are used to implement\n"
    " * soft-skinned vertices for an animated character.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_JointVertexTransform,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_JointVertexTransform,
    PyType_GenericAlloc,
    Dtool_new_JointVertexTransform,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_JointVertexTransform,
  Dtool_UpcastInterface_JointVertexTransform,
  Dtool_DowncastInterface_JointVertexTransform,
  (CoerceFunction)Dtool_ConstCoerce_JointVertexTransform,
  (CoerceFunction)Dtool_Coerce_JointVertexTransform,
};

static void Dtool_PyModuleClassInit_JointVertexTransform(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_VertexTransform != NULL);
    assert(Dtool_Ptr_VertexTransform->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_VertexTransform->_Dtool_ModuleClassInit(NULL);
    Dtool_JointVertexTransform._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_VertexTransform);
    PyObject *dict = PyDict_New();
    Dtool_JointVertexTransform._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_JointVertexTransform) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(JointVertexTransform)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_JointVertexTransform);
  }
}

/**
 * Python method tables for Character (Character)
 */
static PyMethodDef Dtool_Methods_Character[] = {
  {"get_bundle", &Dtool_Character_get_bundle_37, METH_O, (const char *)Dtool_Character_get_bundle_37_comment},
  {"getBundle", &Dtool_Character_get_bundle_37, METH_O, (const char *)Dtool_Character_get_bundle_37_comment},
  {"merge_bundles", (PyCFunction) &Dtool_Character_merge_bundles_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Character_merge_bundles_38_comment},
  {"mergeBundles", (PyCFunction) &Dtool_Character_merge_bundles_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Character_merge_bundles_38_comment},
  {"set_lod_animation", (PyCFunction) &Dtool_Character_set_lod_animation_39, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Character_set_lod_animation_39_comment},
  {"setLodAnimation", (PyCFunction) &Dtool_Character_set_lod_animation_39, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Character_set_lod_animation_39_comment},
  {"clear_lod_animation", &Dtool_Character_clear_lod_animation_40, METH_NOARGS, (const char *)Dtool_Character_clear_lod_animation_40_comment},
  {"clearLodAnimation", &Dtool_Character_clear_lod_animation_40, METH_NOARGS, (const char *)Dtool_Character_clear_lod_animation_40_comment},
  {"find_joint", &Dtool_Character_find_joint_41, METH_O, (const char *)Dtool_Character_find_joint_41_comment},
  {"findJoint", &Dtool_Character_find_joint_41, METH_O, (const char *)Dtool_Character_find_joint_41_comment},
  {"find_slider", &Dtool_Character_find_slider_42, METH_O, (const char *)Dtool_Character_find_slider_42_comment},
  {"findSlider", &Dtool_Character_find_slider_42, METH_O, (const char *)Dtool_Character_find_slider_42_comment},
  {"write_parts", &Dtool_Character_write_parts_43, METH_O, (const char *)Dtool_Character_write_parts_43_comment},
  {"writeParts", &Dtool_Character_write_parts_43, METH_O, (const char *)Dtool_Character_write_parts_43_comment},
  {"write_part_values", &Dtool_Character_write_part_values_44, METH_O, (const char *)Dtool_Character_write_part_values_44_comment},
  {"writePartValues", &Dtool_Character_write_part_values_44, METH_O, (const char *)Dtool_Character_write_part_values_44_comment},
  {"update_to_now", &Dtool_Character_update_to_now_45, METH_NOARGS, (const char *)Dtool_Character_update_to_now_45_comment},
  {"updateToNow", &Dtool_Character_update_to_now_45, METH_NOARGS, (const char *)Dtool_Character_update_to_now_45_comment},
  {"update", &Dtool_Character_update_46, METH_NOARGS, (const char *)Dtool_Character_update_46_comment},
  {"force_update", &Dtool_Character_force_update_47, METH_NOARGS, (const char *)Dtool_Character_force_update_47_comment},
  {"forceUpdate", &Dtool_Character_force_update_47, METH_NOARGS, (const char *)Dtool_Character_force_update_47_comment},
  {"get_class_type", &Dtool_Character_get_class_type_48, METH_NOARGS | METH_STATIC, (const char *)Dtool_Character_get_class_type_48_comment},
  {"getClassType", &Dtool_Character_get_class_type_48, METH_NOARGS | METH_STATIC, (const char *)Dtool_Character_get_class_type_48_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Character = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Character = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Character = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Character = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Character = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Character",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Character,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Character,
    &Dtool_SequenceMethods_Character,
    &Dtool_MappingMethods_Character,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Character,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An animated character, with skeleton-morph animation and either soft-\n"
    " * skinned or hard-skinned vertices.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Character,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Character,
    PyType_GenericAlloc,
    Dtool_new_Character,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Character,
  Dtool_UpcastInterface_Character,
  Dtool_DowncastInterface_Character,
  (CoerceFunction)Dtool_ConstCoerce_Character,
  (CoerceFunction)Dtool_Coerce_Character,
};

static void Dtool_PyModuleClassInit_Character(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PartBundleNode != NULL);
    assert(Dtool_Ptr_PartBundleNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PartBundleNode->_Dtool_ModuleClassInit(NULL);
    Dtool_Character._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PartBundleNode);
    PyObject *dict = PyDict_New();
    Dtool_Character._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Character) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Character)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Character);
  }
}

/**
 * Python method tables for CharacterJointBundle (CharacterJointBundle)
 */
static PyMethodDef Dtool_Methods_CharacterJointBundle[] = {
  {"get_node", &Dtool_CharacterJointBundle_get_node_52, METH_O, (const char *)Dtool_CharacterJointBundle_get_node_52_comment},
  {"getNode", &Dtool_CharacterJointBundle_get_node_52, METH_O, (const char *)Dtool_CharacterJointBundle_get_node_52_comment},
  {"get_class_type", &Dtool_CharacterJointBundle_get_class_type_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJointBundle_get_class_type_53_comment},
  {"getClassType", &Dtool_CharacterJointBundle_get_class_type_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJointBundle_get_class_type_53_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CharacterJointBundle = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CharacterJointBundle = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CharacterJointBundle = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CharacterJointBundle = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CharacterJointBundle = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CharacterJointBundle",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CharacterJointBundle,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CharacterJointBundle,
    &Dtool_SequenceMethods_CharacterJointBundle,
    &Dtool_MappingMethods_CharacterJointBundle,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CharacterJointBundle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The collection of all the joints and sliders in the character.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CharacterJointBundle,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CharacterJointBundle,
    PyType_GenericAlloc,
    Dtool_new_CharacterJointBundle,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CharacterJointBundle,
  Dtool_UpcastInterface_CharacterJointBundle,
  Dtool_DowncastInterface_CharacterJointBundle,
  (CoerceFunction)Dtool_ConstCoerce_CharacterJointBundle,
  (CoerceFunction)Dtool_Coerce_CharacterJointBundle,
};

static void Dtool_PyModuleClassInit_CharacterJointBundle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PartBundle != NULL);
    assert(Dtool_Ptr_PartBundle->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PartBundle->_Dtool_ModuleClassInit(NULL);
    Dtool_CharacterJointBundle._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PartBundle);
    PyObject *dict = PyDict_New();
    Dtool_CharacterJointBundle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CharacterJointBundle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CharacterJointBundle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CharacterJointBundle);
  }
}

/**
 * Python method tables for CharacterJointEffect (CharacterJointEffect)
 */
static PyMethodDef Dtool_Methods_CharacterJointEffect[] = {
  {"make", &Dtool_CharacterJointEffect_make_56, METH_O | METH_STATIC, (const char *)Dtool_CharacterJointEffect_make_56_comment},
  {"get_character", &Dtool_CharacterJointEffect_get_character_57, METH_NOARGS, (const char *)Dtool_CharacterJointEffect_get_character_57_comment},
  {"getCharacter", &Dtool_CharacterJointEffect_get_character_57, METH_NOARGS, (const char *)Dtool_CharacterJointEffect_get_character_57_comment},
  {"get_class_type", &Dtool_CharacterJointEffect_get_class_type_58, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJointEffect_get_class_type_58_comment},
  {"getClassType", &Dtool_CharacterJointEffect_get_class_type_58, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJointEffect_get_class_type_58_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CharacterJointEffect = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CharacterJointEffect = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CharacterJointEffect = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CharacterJointEffect = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CharacterJointEffect = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CharacterJointEffect",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CharacterJointEffect,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CharacterJointEffect,
    &Dtool_SequenceMethods_CharacterJointEffect,
    &Dtool_MappingMethods_CharacterJointEffect,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CharacterJointEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This effect will be added automatically to a node by\n"
    " * CharacterJoint::add_net_transform() and\n"
    " * CharacterJoint::add_local_transform().\n"
    " *\n"
    " * The effect binds the node back to the character, so that querying the\n"
    " * relative transform of the affected node will automatically force the\n"
    " * indicated character to be updated first.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CharacterJointEffect,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CharacterJointEffect,
    PyType_GenericAlloc,
    Dtool_new_CharacterJointEffect,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CharacterJointEffect,
  Dtool_UpcastInterface_CharacterJointEffect,
  Dtool_DowncastInterface_CharacterJointEffect,
  (CoerceFunction)Dtool_ConstCoerce_CharacterJointEffect,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CharacterJointEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_RenderEffect != NULL);
    assert(Dtool_Ptr_RenderEffect->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_RenderEffect->_Dtool_ModuleClassInit(NULL);
    Dtool_CharacterJointEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_RenderEffect);
    PyObject *dict = PyDict_New();
    Dtool_CharacterJointEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CharacterJointEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CharacterJointEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CharacterJointEffect);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3char_RegisterTypes() {
  Dtool_CharacterJoint._type = CharacterJoint::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CharacterJoint);
  Dtool_CharacterSlider._type = CharacterSlider::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CharacterSlider);
  Dtool_CharacterVertexSlider._type = CharacterVertexSlider::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CharacterVertexSlider);
  Dtool_JointVertexTransform._type = JointVertexTransform::get_class_type();
  RegisterRuntimeTypedClass(Dtool_JointVertexTransform);
  Dtool_Character._type = Character::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Character);
  Dtool_CharacterJointBundle._type = CharacterJointBundle::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CharacterJointBundle);
  Dtool_CharacterJointEffect._type = CharacterJointEffect::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CharacterJointEffect);
}

void Dtool_libp3char_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_Thread = LookupRuntimeTypedClass(Thread::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_TransformState = LookupRuntimeTypedClass(TransformState::get_class_type());
  Dtool_Ptr_PartGroup = LookupRuntimeTypedClass(PartGroup::get_class_type());
  Dtool_Ptr_VertexSlider = LookupRuntimeTypedClass(VertexSlider::get_class_type());
  Dtool_Ptr_VertexTransform = LookupRuntimeTypedClass(VertexTransform::get_class_type());
  Dtool_Ptr_PartBundle = LookupRuntimeTypedClass(PartBundle::get_class_type());
  Dtool_Ptr_RenderEffect = LookupRuntimeTypedClass(RenderEffect::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_MovingPart_ACMatrixSwitchType = LookupRuntimeTypedClass(MovingPart< ACMatrixSwitchType >::get_class_type());
  Dtool_Ptr_MovingPartMatrix = LookupRuntimeTypedClass(MovingPartMatrix::get_class_type());
  Dtool_Ptr_MovingPartBase = LookupRuntimeTypedClass(MovingPartBase::get_class_type());
  Dtool_Ptr_NodePathCollection = LookupNamedClass("NodePathCollection");
  Dtool_Ptr_MovingPart_ACScalarSwitchType = LookupRuntimeTypedClass(MovingPart< ACScalarSwitchType >::get_class_type());
  Dtool_Ptr_MovingPartScalar = LookupRuntimeTypedClass(MovingPartScalar::get_class_type());
  Dtool_Ptr_PartBundleNode = LookupRuntimeTypedClass(PartBundleNode::get_class_type());
  Dtool_Ptr_PartBundleHandle = LookupNamedClass("PartBundleHandle");
#endif
}

void Dtool_libp3char_BuildInstants(PyObject *module) {
  (void) module;
  // CharacterJoint
  Dtool_PyModuleClassInit_CharacterJoint(module);
  PyModule_AddObject(module, "CharacterJoint", (PyObject *)&Dtool_CharacterJoint);
  // CharacterSlider
  Dtool_PyModuleClassInit_CharacterSlider(module);
  PyModule_AddObject(module, "CharacterSlider", (PyObject *)&Dtool_CharacterSlider);
  // CharacterVertexSlider
  Dtool_PyModuleClassInit_CharacterVertexSlider(module);
  PyModule_AddObject(module, "CharacterVertexSlider", (PyObject *)&Dtool_CharacterVertexSlider);
  // JointVertexTransform
  Dtool_PyModuleClassInit_JointVertexTransform(module);
  PyModule_AddObject(module, "JointVertexTransform", (PyObject *)&Dtool_JointVertexTransform);
  // Character
  Dtool_PyModuleClassInit_Character(module);
  PyModule_AddObject(module, "Character", (PyObject *)&Dtool_Character);
  // CharacterJointBundle
  Dtool_PyModuleClassInit_CharacterJointBundle(module);
  PyModule_AddObject(module, "CharacterJointBundle", (PyObject *)&Dtool_CharacterJointBundle);
  // CharacterJointEffect
  Dtool_PyModuleClassInit_CharacterJointEffect(module);
  PyModule_AddObject(module, "CharacterJointEffect", (PyObject *)&Dtool_CharacterJointEffect);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3char_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478212712,  /* file_identifier */
  "libp3char",  /* library_name */
  "uMZI",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3char.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  162  /* next_index */
};

Configure(_in_configure_libp3char);
ConfigureFn(_in_configure_libp3char) {
  interrogate_request_module(&_in_module_def);
}

