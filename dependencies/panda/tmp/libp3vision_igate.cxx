/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/vision -Ipanda/src/vision -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3vision_igate.cxx -od built/pandac/input/libp3vision.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/vision -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -SC:/Program Files (x86)/Microsoft DirectX SDK (June 2010)/include -Sthirdparty/win-libs-vc10/jpeg/include -Sthirdparty/win-libs-vc10/artoolkit/include -Sthirdparty/win-libs-vc10/opencv/include -Sthirdparty/win-libs-vc10/directcam/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.vision -library libp3vision arToolKit.h config_vision.h openCVTexture.h p3vision_composite1.cxx webcamVideo.h webcamVideoCursorOpenCV.h webcamVideoCursorV4L.h webcamVideoOpenCV.h webcamVideoV4L.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3vision
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "arToolKit.h"
#include "config_vision.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "openCVTexture.h"
#include "pandabase.h"
#include "texture.h"
#include "webcamVideo.h"
#include "webcamVideoCursorOpenCV.h"
#include "webcamVideoCursorV4L.h"
#include "webcamVideoOpenCV.h"
#include "webcamVideoV4L.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ARToolKit
 */
typedef ARToolKit ARToolKit_localtype;
Define_Module_Class(panda3d.vision, ARToolKit, ARToolKit_localtype, ARToolKit);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ARToolKit = &Dtool_ARToolKit;
static void Dtool_PyModuleClassInit_ARToolKit(PyObject *module);
bool Dtool_ConstCoerce_ARToolKit(PyObject *args, ARToolKit const *&coerced, bool &manage);
bool Dtool_Coerce_ARToolKit(PyObject *args, ARToolKit *&coerced, bool &manage);

/**
 * Forward declarations for top-level class WebcamVideo
 */
typedef WebcamVideo WebcamVideo_localtype;
Define_Module_ClassRef(panda3d.vision, WebcamVideo, WebcamVideo_localtype, WebcamVideo);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WebcamVideo = &Dtool_WebcamVideo;
static void Dtool_PyModuleClassInit_WebcamVideo(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// Texture
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Texture;
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// MovieVideo
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MovieVideo;
inline static bool Dtool_ConstCoerce_MovieVideo(PyObject *args, CPT(MovieVideo) &coerced) {
  nassertr(Dtool_Ptr_MovieVideo != NULL, false);
  nassertr(Dtool_Ptr_MovieVideo->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(MovieVideo) &))Dtool_Ptr_MovieVideo->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_MovieVideo(PyObject *args, PT(MovieVideo) &coerced) {
  nassertr(Dtool_Ptr_MovieVideo != NULL, false);
  nassertr(Dtool_Ptr_MovieVideo->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(MovieVideo) &))Dtool_Ptr_MovieVideo->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_MovieVideo;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieVideo = &Dtool_MovieVideo;
extern bool Dtool_ConstCoerce_MovieVideo(PyObject *args, CPT(MovieVideo) &coerced);
extern bool Dtool_Coerce_MovieVideo(PyObject *args, PT(MovieVideo) &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class ARToolKit
 */
/**
 * Python function wrapper for:
 * static ARToolKit *ARToolKit::make(NodePath camera, Filename const &paramfile, double markersize)
 */
static PyObject *Dtool_ARToolKit_make_2(PyObject *, PyObject *args) {
  // 1-static ARToolKit *ARToolKit::make(NodePath camera, Filename const &paramfile, double markersize)
  PyObject *param0;
  PyObject *param1;
  double param2;
  if (PyArg_ParseTuple(args, "OOd:make", &param0, &param1, &param2)) {
    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "ARToolKit.make", true, true);
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ARToolKit.make", "Filename");
    }
    if (param0_this != NULL) {
      ARToolKit *return_value = ARToolKit::make(*param0_this, *param1_this, (double)param2);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ARToolKit, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(NodePath camera, const Filename paramfile, double markersize)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ARToolKit_make_2_comment =
  "C++ Interface:\n"
  "make(NodePath camera, const Filename paramfile, double markersize)\n"
  "\n"
  "/**\n"
  " * Create a new ARToolKit instance.\n"
  " *\n"
  " * Camera must be the nodepath of a panda camera object.  The panda camera's\n"
  " * field of view is initialized to match the field of view of the physical\n"
  " * webcam.  Each time you call analyze, all marker nodepaths will be moved\n"
  " * into a position which is relative to this camera.  The marker_size\n"
  " * parameter indicates how large you printed the physical markers.  You should\n"
  " * use the same size units that you wish to use in the panda code.\n"
  " */";
#else
static const char *Dtool_ARToolKit_make_2_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ARToolKit::set_threshold(double n)
 */
static PyObject *Dtool_ARToolKit_set_threshold_4(PyObject *self, PyObject *arg) {
  ARToolKit *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ARToolKit, (void **)&local_this, "ARToolKit.set_threshold")) {
    return NULL;
  }
  // 1-inline void ARToolKit::set_threshold(double n)
  if (PyNumber_Check(arg)) {
    (*local_this).set_threshold(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_threshold(const ARToolKit self, double n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ARToolKit_set_threshold_4_comment =
  "C++ Interface:\n"
  "set_threshold(const ARToolKit self, double n)\n"
  "\n"
  "/**\n"
  " * As part of its analysis, the ARToolKit occasionally converts images to\n"
  " * black and white by thresholding them.  The threshold is set to 0.5 by\n"
  " * default, but you can tweak it here.\n"
  " */";
#else
static const char *Dtool_ARToolKit_set_threshold_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ARToolKit::attach_pattern(Filename const &pattern, NodePath path)
 */
static PyObject *Dtool_ARToolKit_attach_pattern_5(PyObject *self, PyObject *args, PyObject *kwds) {
  ARToolKit *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ARToolKit, (void **)&local_this, "ARToolKit.attach_pattern")) {
    return NULL;
  }
  // 1-void ARToolKit::attach_pattern(Filename const &pattern, NodePath path)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"pattern", "path", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:attach_pattern", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ARToolKit.attach_pattern", "Filename");
    }
    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "ARToolKit.attach_pattern", true, true);
    if (param2_this != NULL) {
      (*local_this).attach_pattern(*param1_this, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_pattern(const ARToolKit self, const Filename pattern, NodePath path)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ARToolKit_attach_pattern_5_comment =
  "C++ Interface:\n"
  "attach_pattern(const ARToolKit self, const Filename pattern, NodePath path)\n"
  "\n"
  "/**\n"
  " * Associates the specified glyph with the specified NodePath.  Each time you\n"
  " * call analyze, ARToolKit will update the NodePath's transform.  If the node\n"
  " * is not visible, its scale will be set to zero.\n"
  " */";
#else
static const char *Dtool_ARToolKit_attach_pattern_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ARToolKit::detach_patterns(void)
 */
static PyObject *Dtool_ARToolKit_detach_patterns_6(PyObject *self, PyObject *) {
  ARToolKit *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ARToolKit, (void **)&local_this, "ARToolKit.detach_patterns")) {
    return NULL;
  }
  // 1-void ARToolKit::detach_patterns(void)
  (*local_this).detach_patterns();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ARToolKit_detach_patterns_6_comment =
  "C++ Interface:\n"
  "detach_patterns(const ARToolKit self)\n"
  "\n"
  "/**\n"
  " * Dissociates all patterns from all NodePaths.\n"
  " */";
#else
static const char *Dtool_ARToolKit_detach_patterns_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ARToolKit::analyze(Texture *tex, bool do_flip_texture = true)
 */
static PyObject *Dtool_ARToolKit_analyze_7(PyObject *self, PyObject *args, PyObject *kwds) {
  ARToolKit *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ARToolKit, (void **)&local_this, "ARToolKit.analyze")) {
    return NULL;
  }
  // 1-void ARToolKit::analyze(Texture *tex, bool do_flip_texture = true)
  PyObject *param1;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"tex", "do_flip_texture", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:analyze", (char **)keyword_list, &param1, &param2)) {
    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "ARToolKit.analyze", false, true);
    if (param1_this != NULL) {
      (*local_this).analyze(param1_this, (PyObject_IsTrue(param2) != 0));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "analyze(const ARToolKit self, Texture tex, bool do_flip_texture)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ARToolKit_analyze_7_comment =
  "C++ Interface:\n"
  "analyze(const ARToolKit self, Texture tex, bool do_flip_texture)\n"
  "\n"
  "/**\n"
  " * Analyzes the non-pad region of the specified texture.  This causes all\n"
  " * attached nodepaths to move.  The parameter do_flip_texture is true by\n"
  " * default, because Panda's representation of textures is upside down from\n"
  " * ARToolKit.  If you already have a texture that's upside-down, however, you\n"
  " * should set it to false.\n"
  " */";
#else
static const char *Dtool_ARToolKit_analyze_7_comment = NULL;
#endif

static int Dtool_Init_ARToolKit(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ARToolKit(PyObject *args, ARToolKit const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ARToolKit, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-static ARToolKit *ARToolKit::make(NodePath camera, Filename const &paramfile, double markersize)
      PyObject *param0;
      PyObject *param1;
      double param2;
      if (PyArg_ParseTuple(args, "OOd:make", &param0, &param1, &param2)) {
        NodePath *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
        Filename const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          ARToolKit *return_value = ARToolKit::make(*param0_this, *param1_this, (double)param2);
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = (ARToolKit *) return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ARToolKit(PyObject *args, ARToolKit *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ARToolKit, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-static ARToolKit *ARToolKit::make(NodePath camera, Filename const &paramfile, double markersize)
      PyObject *param0;
      PyObject *param1;
      double param2;
      if (PyArg_ParseTuple(args, "OOd:make", &param0, &param1, &param2)) {
        NodePath *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
        Filename const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          ARToolKit *return_value = ARToolKit::make(*param0_this, *param1_this, (double)param2);
          if (_PyErr_OCCURRED()) {
            return false;
          } else {
            coerced = (ARToolKit *) return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ARToolKit(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ARToolKit) {
    printf("ARToolKit ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ARToolKit *local_this = (ARToolKit *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ARToolKit) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ARToolKit(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ARToolKit) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class WebcamVideo
 */
/**
 * Python function wrapper for:
 * static int WebcamVideo::get_num_options(void)
 */
static PyObject *Dtool_WebcamVideo_get_num_options_10(PyObject *, PyObject *) {
  // 1-static int WebcamVideo::get_num_options(void)
  int return_value = WebcamVideo::get_num_options();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_num_options_10_comment =
  "C++ Interface:\n"
  "get_num_options()\n"
  "\n"
  "/**\n"
  " * Returns the number of webcam options.  An \"option\" consists of a device\n"
  " * plus a set of configuration parameters.  For example, \"Creative Webcam Live\n"
  " * at 640x480, 30 fps\" is an option.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_num_options_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< WebcamVideo > WebcamVideo::get_option(int n)
 */
static PyObject *Dtool_WebcamVideo_get_option_11(PyObject *, PyObject *arg) {
  // 1-static PointerTo< WebcamVideo > WebcamVideo::get_option(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< WebcamVideo > return_value = WebcamVideo::get_option((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    WebcamVideo *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_WebcamVideo, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_option(int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_option_11_comment =
  "C++ Interface:\n"
  "get_option(int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth webcam option.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_option_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int WebcamVideo::get_size_x(void) const
 */
static PyObject *Dtool_WebcamVideo_get_size_x_13(PyObject *self, PyObject *) {
  WebcamVideo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WebcamVideo, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int WebcamVideo::get_size_x(void) const
  int return_value = (*(const WebcamVideo*)local_this).get_size_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_size_x_13_comment =
  "C++ Interface:\n"
  "get_size_x(WebcamVideo self)\n"
  "\n"
  "/**\n"
  " * Returns the camera's size_x.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_size_x_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int WebcamVideo::get_size_y(void) const
 */
static PyObject *Dtool_WebcamVideo_get_size_y_14(PyObject *self, PyObject *) {
  WebcamVideo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WebcamVideo, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int WebcamVideo::get_size_y(void) const
  int return_value = (*(const WebcamVideo*)local_this).get_size_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_size_y_14_comment =
  "C++ Interface:\n"
  "get_size_y(WebcamVideo self)\n"
  "\n"
  "/**\n"
  " * Returns the camera's size_y.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_size_y_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double WebcamVideo::get_fps(void) const
 */
static PyObject *Dtool_WebcamVideo_get_fps_15(PyObject *self, PyObject *) {
  WebcamVideo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WebcamVideo, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double WebcamVideo::get_fps(void) const
  double return_value = (*(const WebcamVideo*)local_this).get_fps();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_fps_15_comment =
  "C++ Interface:\n"
  "get_fps(WebcamVideo self)\n"
  "\n"
  "/**\n"
  " * Returns the camera's framerate.  This is a maximum theoretical: the actual\n"
  " * performance will depend on the speed of the hardware.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_fps_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &WebcamVideo::get_pixel_format(void) const
 */
static PyObject *Dtool_WebcamVideo_get_pixel_format_16(PyObject *self, PyObject *) {
  WebcamVideo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WebcamVideo, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &WebcamVideo::get_pixel_format(void) const
  std::string const &return_value = (*(const WebcamVideo*)local_this).get_pixel_format();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_pixel_format_16_comment =
  "C++ Interface:\n"
  "get_pixel_format(WebcamVideo self)\n"
  "\n"
  "/**\n"
  " * Returns the camera's pixel format, as a FourCC code, if known.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_pixel_format_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void WebcamVideo::output(ostream &out) const
 */
static PyObject *Dtool_WebcamVideo_output_17(PyObject *self, PyObject *arg) {
  WebcamVideo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WebcamVideo, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void WebcamVideo::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "WebcamVideo.output", false, true);
  if (arg_this != NULL) {
    (*(const WebcamVideo*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(WebcamVideo self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_output_17_comment =
  "C++ Interface:\n"
  "output(WebcamVideo self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs the WebcamVideo.  This function simply writes the name, size and\n"
  " * FPS to the output stream.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_output_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle WebcamVideo::get_class_type(void)
 */
static PyObject *Dtool_WebcamVideo_get_class_type_18(PyObject *, PyObject *) {
  // 1-static TypeHandle WebcamVideo::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(WebcamVideo::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_class_type_18_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_WebcamVideo_get_class_type_18_comment = NULL;
#endif

static int Dtool_Init_WebcamVideo(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_WebcamVideo_get_options(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)WebcamVideo::get_num_options();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_WebcamVideo_get_option_11(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_WebcamVideo(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_WebcamVideo) {
    printf("WebcamVideo ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  WebcamVideo *local_this = (WebcamVideo *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_WebcamVideo) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieVideo) {
    return (MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_WebcamVideo(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_WebcamVideo) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieVideo) {
    MovieVideo* other_this = (MovieVideo*)from_this;
    return (WebcamVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (WebcamVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (WebcamVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (WebcamVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (WebcamVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (WebcamVideo*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for ARToolKit (ARToolKit)
 */
static PyMethodDef Dtool_Methods_ARToolKit[] = {
  {"make", &Dtool_ARToolKit_make_2, METH_VARARGS | METH_STATIC, (const char *)Dtool_ARToolKit_make_2_comment},
  {"set_threshold", &Dtool_ARToolKit_set_threshold_4, METH_O, (const char *)Dtool_ARToolKit_set_threshold_4_comment},
  {"setThreshold", &Dtool_ARToolKit_set_threshold_4, METH_O, (const char *)Dtool_ARToolKit_set_threshold_4_comment},
  {"attach_pattern", (PyCFunction) &Dtool_ARToolKit_attach_pattern_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ARToolKit_attach_pattern_5_comment},
  {"attachPattern", (PyCFunction) &Dtool_ARToolKit_attach_pattern_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ARToolKit_attach_pattern_5_comment},
  {"detach_patterns", &Dtool_ARToolKit_detach_patterns_6, METH_NOARGS, (const char *)Dtool_ARToolKit_detach_patterns_6_comment},
  {"detachPatterns", &Dtool_ARToolKit_detach_patterns_6, METH_NOARGS, (const char *)Dtool_ARToolKit_detach_patterns_6_comment},
  {"analyze", (PyCFunction) &Dtool_ARToolKit_analyze_7, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ARToolKit_analyze_7_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ARToolKit = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ARToolKit = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.vision.ARToolKit",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ARToolKit,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ARToolKit,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * ARToolKit is a software library for building Augmented Reality (AR)\n"
    " * applications.  These are applications that involve the overlay of virtual\n"
    " * imagery on the real world.  It was developed by Dr.  Hirokazu Kato.  Its\n"
    " * ongoing development is being supported by the Human Interface Technology\n"
    " * Laboratory (HIT Lab) at the University of Washington, HIT Lab NZ at the\n"
    " * University of Canterbury, New Zealand, and ARToolworks, Inc, Seattle.  It\n"
    " * is available under a GPL license.  It is also possible to negotiate other\n"
    " * licenses with the copyright holders.\n"
    " *\n"
    " * This class is a wrapper around the ARToolKit library.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ARToolKit,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ARToolKit,
    PyType_GenericAlloc,
    Dtool_new_ARToolKit,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ARToolKit,
  Dtool_UpcastInterface_ARToolKit,
  Dtool_DowncastInterface_ARToolKit,
  (CoerceFunction)Dtool_ConstCoerce_ARToolKit,
  (CoerceFunction)Dtool_Coerce_ARToolKit,
};

static void Dtool_PyModuleClassInit_ARToolKit(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ARToolKit._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ARToolKit._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ARToolKit) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ARToolKit)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ARToolKit);
  }
}

/**
 * Python method tables for WebcamVideo (WebcamVideo)
 */
static PyMethodDef Dtool_Methods_WebcamVideo[] = {
  {"get_num_options", &Dtool_WebcamVideo_get_num_options_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_WebcamVideo_get_num_options_10_comment},
  {"getNumOptions", &Dtool_WebcamVideo_get_num_options_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_WebcamVideo_get_num_options_10_comment},
  {"get_option", &Dtool_WebcamVideo_get_option_11, METH_O | METH_STATIC, (const char *)Dtool_WebcamVideo_get_option_11_comment},
  {"getOption", &Dtool_WebcamVideo_get_option_11, METH_O | METH_STATIC, (const char *)Dtool_WebcamVideo_get_option_11_comment},
  {"get_size_x", &Dtool_WebcamVideo_get_size_x_13, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_size_x_13_comment},
  {"getSizeX", &Dtool_WebcamVideo_get_size_x_13, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_size_x_13_comment},
  {"get_size_y", &Dtool_WebcamVideo_get_size_y_14, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_size_y_14_comment},
  {"getSizeY", &Dtool_WebcamVideo_get_size_y_14, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_size_y_14_comment},
  {"get_fps", &Dtool_WebcamVideo_get_fps_15, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_fps_15_comment},
  {"getFps", &Dtool_WebcamVideo_get_fps_15, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_fps_15_comment},
  {"get_pixel_format", &Dtool_WebcamVideo_get_pixel_format_16, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_pixel_format_16_comment},
  {"getPixelFormat", &Dtool_WebcamVideo_get_pixel_format_16, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_pixel_format_16_comment},
  {"output", &Dtool_WebcamVideo_output_17, METH_O, (const char *)Dtool_WebcamVideo_output_17_comment},
  {"get_class_type", &Dtool_WebcamVideo_get_class_type_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_WebcamVideo_get_class_type_18_comment},
  {"getClassType", &Dtool_WebcamVideo_get_class_type_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_WebcamVideo_get_class_type_18_comment},
  {"get_options", (PyCFunction) &MakeSeq_WebcamVideo_get_options, METH_NOARGS | METH_STATIC, NULL},
  { "getOptions", (PyCFunction) &MakeSeq_WebcamVideo_get_options, METH_NOARGS | METH_STATIC, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     WebcamVideo
//////////////////
static PyObject *Dtool_Repr_WebcamVideo(PyObject *self) {
  WebcamVideo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WebcamVideo, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_WebcamVideo = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WebcamVideo = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_WebcamVideo = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_WebcamVideo = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_WebcamVideo = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.vision.WebcamVideo",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_WebcamVideo,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_WebcamVideo,
    &Dtool_NumberMethods_WebcamVideo,
    &Dtool_SequenceMethods_WebcamVideo,
    &Dtool_MappingMethods_WebcamVideo,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_WebcamVideo,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_WebcamVideo,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Allows you to open a webcam or other video capture device as a video\n"
    " * stream.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_WebcamVideo,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_WebcamVideo,
    PyType_GenericAlloc,
    Dtool_new_WebcamVideo,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WebcamVideo,
  Dtool_UpcastInterface_WebcamVideo,
  Dtool_DowncastInterface_WebcamVideo,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_WebcamVideo(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_MovieVideo != NULL);
    assert(Dtool_Ptr_MovieVideo->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_MovieVideo->_Dtool_ModuleClassInit(NULL);
    Dtool_WebcamVideo._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_MovieVideo);
    PyObject *dict = PyDict_New();
    Dtool_WebcamVideo._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WebcamVideo) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WebcamVideo)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WebcamVideo);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3vision_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ARToolKit", Dtool_ARToolKit);
#endif
  Dtool_WebcamVideo._type = WebcamVideo::get_class_type();
  RegisterRuntimeTypedClass(Dtool_WebcamVideo);
}

void Dtool_libp3vision_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_Texture = LookupRuntimeTypedClass(Texture::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_MovieVideo = LookupRuntimeTypedClass(MovieVideo::get_class_type());
#endif
}

void Dtool_libp3vision_BuildInstants(PyObject *module) {
  (void) module;
  // ARToolKit
  Dtool_PyModuleClassInit_ARToolKit(module);
  PyModule_AddObject(module, "ARToolKit", (PyObject *)&Dtool_ARToolKit);
  // WebcamVideo
  Dtool_PyModuleClassInit_WebcamVideo(module);
  PyModule_AddObject(module, "WebcamVideo", (PyObject *)&Dtool_WebcamVideo);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3vision_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478213805,  /* file_identifier */
  "libp3vision",  /* library_name */
  "nRMq",  /* library_hash_name */
  "panda3d.vision",  /* module_name */
  "libp3vision.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  52  /* next_index */
};

Configure(_in_configure_libp3vision);
ConfigureFn(_in_configure_libp3vision) {
  interrogate_request_module(&_in_module_def);
}

