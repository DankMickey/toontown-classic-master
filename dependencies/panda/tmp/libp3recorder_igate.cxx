/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/recorder -Ipanda/src/recorder -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3recorder_igate.cxx -od built/pandac/input/libp3recorder.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/recorder -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3recorder config_recorder.h mouseRecorder.h p3recorder_composite1.cxx p3recorder_composite2.cxx recorderBase.h recorderController.h recorderFrame.h recorderHeader.h recorderTable.h socketStreamRecorder.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3recorder
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "buttonEventList.h"
#include "config_recorder.h"
#include "dataNode.h"
#include "dataNodeTransmit.h"
#include "dconfig.h"
#include "linmath_events.h"
#include "mouseRecorder.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "recorderBase.h"
#include "recorderController.h"
#include "recorderFrame.h"
#include "recorderHeader.h"
#include "recorderTable.h"
#include "socketStreamRecorder.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class RecorderBase
 */
typedef RecorderBase RecorderBase_localtype;
Define_Module_Class(panda3d.core, RecorderBase, RecorderBase_localtype, RecorderBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RecorderBase = &Dtool_RecorderBase;
static void Dtool_PyModuleClassInit_RecorderBase(PyObject *module);

/**
 * Forward declarations for top-level class MouseRecorder
 */
typedef MouseRecorder MouseRecorder_localtype;
Define_Module_ClassRef(panda3d.core, MouseRecorder, MouseRecorder_localtype, MouseRecorder);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseRecorder = &Dtool_MouseRecorder;
static void Dtool_PyModuleClassInit_MouseRecorder(PyObject *module);
bool Dtool_ConstCoerce_MouseRecorder(PyObject *args, CPT(MouseRecorder) &coerced);
bool Dtool_Coerce_MouseRecorder(PyObject *args, PT(MouseRecorder) &coerced);

/**
 * Forward declarations for top-level class RecorderController
 */
typedef RecorderController RecorderController_localtype;
Define_Module_ClassRef(panda3d.core, RecorderController, RecorderController_localtype, RecorderController);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RecorderController = &Dtool_RecorderController;
static void Dtool_PyModuleClassInit_RecorderController(PyObject *module);

/**
 * Forward declarations for top-level class SocketStreamRecorder
 */
typedef SocketStreamRecorder SocketStreamRecorder_localtype;
Define_Module_ClassRef(panda3d.core, SocketStreamRecorder, SocketStreamRecorder_localtype, SocketStreamRecorder);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SocketStreamRecorder = &Dtool_SocketStreamRecorder;
static void Dtool_PyModuleClassInit_SocketStreamRecorder(PyObject *module);
bool Dtool_ConstCoerce_SocketStreamRecorder(PyObject *args, CPT(SocketStreamRecorder) &coerced);
bool Dtool_Coerce_SocketStreamRecorder(PyObject *args, PT(SocketStreamRecorder) &coerced);

/**
 * Extern declarations for imported classes
 */
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// Datagram
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Datagram;
inline static bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram const *&, bool&))Dtool_Ptr_Datagram->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram *&, bool&))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage);
extern bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage);
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// DataNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DataNode;
inline static bool Dtool_ConstCoerce_DataNode(PyObject *args, CPT(DataNode) &coerced) {
  nassertr(Dtool_Ptr_DataNode != NULL, false);
  nassertr(Dtool_Ptr_DataNode->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(DataNode) &))Dtool_Ptr_DataNode->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_DataNode(PyObject *args, PT(DataNode) &coerced) {
  nassertr(Dtool_Ptr_DataNode != NULL, false);
  nassertr(Dtool_Ptr_DataNode->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(DataNode) &))Dtool_Ptr_DataNode->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DataNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DataNode = &Dtool_DataNode;
extern bool Dtool_ConstCoerce_DataNode(PyObject *args, CPT(DataNode) &coerced);
extern bool Dtool_Coerce_DataNode(PyObject *args, PT(DataNode) &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class RecorderBase
 */
/**
 * Python function wrapper for:
 * inline bool RecorderBase::is_recording(void) const
 */
static PyObject *Dtool_RecorderBase_is_recording_3(PyObject *self, PyObject *) {
  RecorderBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RecorderBase::is_recording(void) const
  bool return_value = (*(const RecorderBase*)local_this).is_recording();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderBase_is_recording_3_comment =
  "C++ Interface:\n"
  "is_recording(RecorderBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if this recorder is presently recording data for saving to a\n"
  " * session file, false otherwise.  If this is true, record_data() will be\n"
  " * called from time to time.\n"
  " */";
#else
static const char *Dtool_RecorderBase_is_recording_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderBase::is_playing(void) const
 */
static PyObject *Dtool_RecorderBase_is_playing_4(PyObject *self, PyObject *) {
  RecorderBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RecorderBase::is_playing(void) const
  bool return_value = (*(const RecorderBase*)local_this).is_playing();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderBase_is_playing_4_comment =
  "C++ Interface:\n"
  "is_playing(RecorderBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if this recorder is presently playing back data from session\n"
  " * file, false otherwise.  If this is true, play_data() will be called from\n"
  " * time to time.\n"
  " */";
#else
static const char *Dtool_RecorderBase_is_playing_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RecorderBase::get_class_type(void)
 */
static PyObject *Dtool_RecorderBase_get_class_type_5(PyObject *, PyObject *) {
  // 1-static TypeHandle RecorderBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(RecorderBase::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RecorderBase_get_class_type_5_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RecorderBase_get_class_type_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MouseRecorder *RecorderBase::downcast_to_MouseRecorder(void)
 */
static PyObject *Dtool_RecorderBase_downcast_to_MouseRecorder_11(PyObject *self, PyObject *) {
  RecorderBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderBase, (void **)&local_this, "RecorderBase.downcast_to_MouseRecorder")) {
    return NULL;
  }
  // 1-MouseRecorder *RecorderBase::downcast_to_MouseRecorder(void)
  MouseRecorder *return_value = (MouseRecorder *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_MouseRecorder, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_RecorderBase_downcast_to_MouseRecorder_11_comment =
  "C++ Interface:\n"
  "downcast_to_MouseRecorder(const RecorderBase self)\n"
  "\n"
  "downcast from RecorderBase to MouseRecorder";
#else
static const char *Dtool_RecorderBase_downcast_to_MouseRecorder_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SocketStreamRecorder *RecorderBase::downcast_to_SocketStreamRecorder(void)
 */
static PyObject *Dtool_RecorderBase_downcast_to_SocketStreamRecorder_41(PyObject *self, PyObject *) {
  RecorderBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderBase, (void **)&local_this, "RecorderBase.downcast_to_SocketStreamRecorder")) {
    return NULL;
  }
  // 1-SocketStreamRecorder *RecorderBase::downcast_to_SocketStreamRecorder(void)
  SocketStreamRecorder *return_value = (SocketStreamRecorder *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SocketStreamRecorder, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RecorderBase_downcast_to_SocketStreamRecorder_41_comment =
  "C++ Interface:\n"
  "downcast_to_SocketStreamRecorder(const RecorderBase self)\n"
  "\n"
  "downcast from RecorderBase to SocketStreamRecorder";
#else
static const char *Dtool_RecorderBase_downcast_to_SocketStreamRecorder_41_comment = NULL;
#endif

static int Dtool_Init_RecorderBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_RecorderBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_RecorderBase) {
    printf("RecorderBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  RecorderBase *local_this = (RecorderBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_RecorderBase) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_RecorderBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_RecorderBase) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MouseRecorder
 */
/**
 * Python function wrapper for:
 * static TypeHandle MouseRecorder::get_class_type(void)
 */
static PyObject *Dtool_MouseRecorder_get_class_type_13(PyObject *, PyObject *) {
  // 1-static TypeHandle MouseRecorder::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(MouseRecorder::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseRecorder_get_class_type_13_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MouseRecorder_get_class_type_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DataNode *MouseRecorder::upcast_to_DataNode(void)
 */
static PyObject *Dtool_MouseRecorder_upcast_to_DataNode_8(PyObject *self, PyObject *) {
  MouseRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseRecorder, (void **)&local_this, "MouseRecorder.upcast_to_DataNode")) {
    return NULL;
  }
  // 1-DataNode *MouseRecorder::upcast_to_DataNode(void)
  DataNode *return_value = (DataNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DataNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_MouseRecorder_upcast_to_DataNode_8_comment =
  "C++ Interface:\n"
  "upcast_to_DataNode(const MouseRecorder self)\n"
  "\n"
  "upcast from MouseRecorder to DataNode";
#else
static const char *Dtool_MouseRecorder_upcast_to_DataNode_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * RecorderBase *MouseRecorder::upcast_to_RecorderBase(void)
 */
static PyObject *Dtool_MouseRecorder_upcast_to_RecorderBase_10(PyObject *self, PyObject *) {
  MouseRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseRecorder, (void **)&local_this, "MouseRecorder.upcast_to_RecorderBase")) {
    return NULL;
  }
  // 1-RecorderBase *MouseRecorder::upcast_to_RecorderBase(void)
  RecorderBase *return_value = (RecorderBase *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_RecorderBase, false, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseRecorder_upcast_to_RecorderBase_10_comment =
  "C++ Interface:\n"
  "upcast_to_RecorderBase(const MouseRecorder self)\n"
  "\n"
  "upcast from MouseRecorder to RecorderBase";
#else
static const char *Dtool_MouseRecorder_upcast_to_RecorderBase_10_comment = NULL;
#endif

static int Dtool_Init_MouseRecorder(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_MouseRecorder(PyObject *args, CPT(MouseRecorder) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MouseRecorder, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_MouseRecorder(PyObject *args, PT(MouseRecorder) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_MouseRecorder, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_MouseRecorder(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MouseRecorder) {
    printf("MouseRecorder ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MouseRecorder *local_this = (MouseRecorder *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MouseRecorder) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_RecorderBase) {
    return (RecorderBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MouseRecorder(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MouseRecorder) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_RecorderBase) {
    RecorderBase* other_this = (RecorderBase*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MouseRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MouseRecorder*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class RecorderController
 */
/**
 * Python function wrapper for:
 * bool RecorderController::begin_record(Filename const &filename)
 */
static PyObject *Dtool_RecorderController_begin_record_17(PyObject *self, PyObject *arg) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.begin_record")) {
    return NULL;
  }
  // 1-bool RecorderController::begin_record(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RecorderController.begin_record", "Filename");
  }
  bool return_value = (*local_this).begin_record(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_record(const RecorderController self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_begin_record_17_comment =
  "C++ Interface:\n"
  "begin_record(const RecorderController self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Begins recording data to the indicated filename.  All of the recorders in\n"
  " * use should already have been added.\n"
  " */";
#else
static const char *Dtool_RecorderController_begin_record_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool RecorderController::begin_playback(Filename const &filename)
 */
static PyObject *Dtool_RecorderController_begin_playback_18(PyObject *self, PyObject *arg) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.begin_playback")) {
    return NULL;
  }
  // 1-bool RecorderController::begin_playback(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RecorderController.begin_playback", "Filename");
  }
  bool return_value = (*local_this).begin_playback(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_playback(const RecorderController self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_begin_playback_18_comment =
  "C++ Interface:\n"
  "begin_playback(const RecorderController self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Begins playing back data from the indicated filename.  All of the recorders\n"
  " * in use should already have been added, although this may define additional\n"
  " * recorders if they are present in the file (these new recorders will not be\n"
  " * used).  This may also undefine recorders that were previously added but are\n"
  " * not present in the file.\n"
  " */";
#else
static const char *Dtool_RecorderController_begin_playback_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void RecorderController::close(void)
 */
static PyObject *Dtool_RecorderController_close_19(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.close")) {
    return NULL;
  }
  // 1-void RecorderController::close(void)
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_close_19_comment =
  "C++ Interface:\n"
  "close(const RecorderController self)\n"
  "\n"
  "/**\n"
  " * Finishes recording data to the indicated filename.\n"
  " */";
#else
static const char *Dtool_RecorderController_close_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline time_t RecorderController::get_start_time(void) const
 */
static PyObject *Dtool_RecorderController_get_start_time_20(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderController, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline time_t RecorderController::get_start_time(void) const
  time_t return_value = (*(const RecorderController*)local_this).get_start_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_start_time_20_comment =
  "C++ Interface:\n"
  "get_start_time(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns the time (and date) at which the current session was originally\n"
  " * recorded (or, in recording mode, the time at which the current session\n"
  " * began).\n"
  " */";
#else
static const char *Dtool_RecorderController_get_start_time_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RecorderController::set_random_seed(int random_seed)
 */
static PyObject *Dtool_RecorderController_set_random_seed_21(PyObject *self, PyObject *arg) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.set_random_seed")) {
    return NULL;
  }
  // 1-inline void RecorderController::set_random_seed(int random_seed)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_random_seed((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_random_seed(const RecorderController self, int random_seed)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_set_random_seed_21_comment =
  "C++ Interface:\n"
  "set_random_seed(const RecorderController self, int random_seed)\n"
  "\n"
  "/**\n"
  " * Indicates an arbitrary number to be recorded in the session file as a\n"
  " * random seed, should the application wish to take advantage of it.  This\n"
  " * must be set before begin_record() is called.\n"
  " */";
#else
static const char *Dtool_RecorderController_set_random_seed_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int RecorderController::get_random_seed(void) const
 */
static PyObject *Dtool_RecorderController_get_random_seed_22(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderController, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int RecorderController::get_random_seed(void) const
  int return_value = (*(const RecorderController*)local_this).get_random_seed();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_random_seed_22_comment =
  "C++ Interface:\n"
  "get_random_seed(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns the random seed that was set by a previous call to\n"
  " * set_random_seed(), or the number read from the session file after\n"
  " * begin_playback() has been called.\n"
  " */";
#else
static const char *Dtool_RecorderController_get_random_seed_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::is_recording(void) const
 */
static PyObject *Dtool_RecorderController_is_recording_23(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderController, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RecorderController::is_recording(void) const
  bool return_value = (*(const RecorderController*)local_this).is_recording();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_is_recording_23_comment =
  "C++ Interface:\n"
  "is_recording(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns true if the controller has been opened for output, false otherwise.\n"
  " */";
#else
static const char *Dtool_RecorderController_is_recording_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::is_playing(void) const
 */
static PyObject *Dtool_RecorderController_is_playing_24(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderController, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RecorderController::is_playing(void) const
  bool return_value = (*(const RecorderController*)local_this).is_playing();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_is_playing_24_comment =
  "C++ Interface:\n"
  "is_playing(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns true if the controller has been opened for input, false otherwise.\n"
  " */";
#else
static const char *Dtool_RecorderController_is_playing_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::is_open(void) const
 */
static PyObject *Dtool_RecorderController_is_open_25(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderController, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RecorderController::is_open(void) const
  bool return_value = (*(const RecorderController*)local_this).is_open();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_is_open_25_comment =
  "C++ Interface:\n"
  "is_open(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns true if the controller has been opened for either input or output,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_RecorderController_is_open_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &RecorderController::get_filename(void) const
 */
static PyObject *Dtool_RecorderController_get_filename_26(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderController, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &RecorderController::get_filename(void) const
  Filename const *return_value = &((*(const RecorderController*)local_this).get_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_filename_26_comment =
  "C++ Interface:\n"
  "get_filename(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns the filename that was passed to the most recent call to\n"
  " * begin_record() or begin_playback().\n"
  " */";
#else
static const char *Dtool_RecorderController_get_filename_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::is_error(void)
 */
static PyObject *Dtool_RecorderController_is_error_27(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.is_error")) {
    return NULL;
  }
  // 1-inline bool RecorderController::is_error(void)
  bool return_value = (*local_this).is_error();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_is_error_27_comment =
  "C++ Interface:\n"
  "is_error(const RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns true if the controller has been opened for input or output output\n"
  " * and there is an error on the stream, or false if the controller is closed\n"
  " * or if there is no problem.\n"
  " */";
#else
static const char *Dtool_RecorderController_is_error_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double RecorderController::get_clock_offset(void) const
 */
static PyObject *Dtool_RecorderController_get_clock_offset_28(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderController, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double RecorderController::get_clock_offset(void) const
  double return_value = (*(const RecorderController*)local_this).get_clock_offset();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_clock_offset_28_comment =
  "C++ Interface:\n"
  "get_clock_offset(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns the delta offset between the actual frame time and the frame time\n"
  " * written to the log.  This is essentially the time at which the recording\n"
  " * (or playback) started.\n"
  " */";
#else
static const char *Dtool_RecorderController_get_clock_offset_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int RecorderController::get_frame_offset(void) const
 */
static PyObject *Dtool_RecorderController_get_frame_offset_29(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderController, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int RecorderController::get_frame_offset(void) const
  int return_value = (*(const RecorderController*)local_this).get_frame_offset();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_frame_offset_29_comment =
  "C++ Interface:\n"
  "get_frame_offset(RecorderController self)\n"
  "\n"
  "/**\n"
  " * Returns the delta offset between the actual frame count and the frame count\n"
  " * written to the log.  This is essentially the frame number at which the\n"
  " * recording (or playback) started.\n"
  " */";
#else
static const char *Dtool_RecorderController_get_frame_offset_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RecorderController::add_recorder(std::string const &name, RecorderBase *recorder)
 */
static PyObject *Dtool_RecorderController_add_recorder_30(PyObject *self, PyObject *args, PyObject *kwds) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.add_recorder")) {
    return NULL;
  }
  // 1-inline void RecorderController::add_recorder(std::string const &name, RecorderBase *recorder)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "recorder", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:add_recorder", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    RecorderBase *param2_this = (RecorderBase *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_RecorderBase, 2, "RecorderController.add_recorder", false, true);
    if (param2_this != NULL) {
      (*local_this).add_recorder(std::string(param1_str, param1_len), param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_recorder(const RecorderController self, str name, RecorderBase recorder)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_add_recorder_30_comment =
  "C++ Interface:\n"
  "add_recorder(const RecorderController self, str name, RecorderBase recorder)\n"
  "\n"
  "/**\n"
  " * Adds the named recorder to the set of recorders that are in use.\n"
  " *\n"
  " * If the controller is in recording mode, the named recorder will begin\n"
  " * recording its status to the session file.  If the controller is in playback\n"
  " * mode and the name and type matches a recorder in the session file, the\n"
  " * recorder will begin receiving data.\n"
  " */";
#else
static const char *Dtool_RecorderController_add_recorder_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::has_recorder(std::string const &name) const
 */
static PyObject *Dtool_RecorderController_has_recorder_31(PyObject *self, PyObject *arg) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderController, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RecorderController::has_recorder(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const RecorderController*)local_this).has_recorder(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_recorder(RecorderController self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_has_recorder_31_comment =
  "C++ Interface:\n"
  "has_recorder(RecorderController self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if the named recorder has been added to the table by a\n"
  " * previous call to add_recorder(), false otherwise.\n"
  " *\n"
  " * If the controller is in playback mode, this will also return false for a\n"
  " * recorder that was found in the session file but was never explicitly added\n"
  " * via add_recorder(); see get_recorder().\n"
  " */";
#else
static const char *Dtool_RecorderController_has_recorder_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline RecorderBase *RecorderController::get_recorder(std::string const &name) const
 */
static PyObject *Dtool_RecorderController_get_recorder_32(PyObject *self, PyObject *arg) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderController, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline RecorderBase *RecorderController::get_recorder(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    RecorderBase *return_value = (*(const RecorderController*)local_this).get_recorder(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_RecorderBase, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_recorder(RecorderController self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_recorder_32_comment =
  "C++ Interface:\n"
  "get_recorder(RecorderController self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the recorder with the indicated name, or NULL if there is no such\n"
  " * recorder.\n"
  " *\n"
  " * If the controller is in playback mode, this may return the recorder\n"
  " * matching the indicated name as read from the session file, even if it was\n"
  " * never added to the table by the user.  In this case, has_recorder() may\n"
  " * return false, but get_recorder() will return a non-NULL value.\n"
  " */";
#else
static const char *Dtool_RecorderController_get_recorder_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::remove_recorder(std::string const &name)
 */
static PyObject *Dtool_RecorderController_remove_recorder_33(PyObject *self, PyObject *arg) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.remove_recorder")) {
    return NULL;
  }
  // 1-inline bool RecorderController::remove_recorder(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).remove_recorder(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_recorder(const RecorderController self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_remove_recorder_33_comment =
  "C++ Interface:\n"
  "remove_recorder(const RecorderController self, str name)\n"
  "\n"
  "/**\n"
  " * Removes the named recorder from the table.  Returns true if successful,\n"
  " * false if there was no such recorder.\n"
  " *\n"
  " * If the controller is in recording mode, the named recorder will stop\n"
  " * recording.  If the controller is in playback mode, the named recorder will\n"
  " * disassociate itself from the session file (but if the session file still\n"
  " * has data for this name, a default recorder will take its place to decode\n"
  " * the data from the session file).\n"
  " */";
#else
static const char *Dtool_RecorderController_remove_recorder_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void RecorderController::set_frame_tie(bool frame_tie)
 */
static PyObject *Dtool_RecorderController_set_frame_tie_34(PyObject *self, PyObject *arg) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.set_frame_tie")) {
    return NULL;
  }
  // 1-inline void RecorderController::set_frame_tie(bool frame_tie)
  (*local_this).set_frame_tie((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_tie(const RecorderController self, bool frame_tie)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_set_frame_tie_34_comment =
  "C++ Interface:\n"
  "set_frame_tie(const RecorderController self, bool frame_tie)\n"
  "\n"
  "/**\n"
  " * Sets the frame_tie flag.\n"
  " *\n"
  " * When this is true, sessions are played back frame-for-frame, based on the\n"
  " * frame count of the recorded session.  This gives the most accurate\n"
  " * playback, but the playback rate will vary according to the frame rate of\n"
  " * the playback machine.\n"
  " *\n"
  " * When this is false, sessions are played back at real time, based on the\n"
  " * clock of the recorded session.  This may introduce playback discrepencies\n"
  " * if the frames do not fall at exactly the same times as they did in the\n"
  " * original.\n"
  " */";
#else
static const char *Dtool_RecorderController_set_frame_tie_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool RecorderController::get_frame_tie(void) const
 */
static PyObject *Dtool_RecorderController_get_frame_tie_35(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RecorderController, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RecorderController::get_frame_tie(void) const
  bool return_value = (*(const RecorderController*)local_this).get_frame_tie();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_frame_tie_35_comment =
  "C++ Interface:\n"
  "get_frame_tie(RecorderController self)\n"
  "\n"
  "/**\n"
  " * See set_frame_tie().\n"
  " */";
#else
static const char *Dtool_RecorderController_get_frame_tie_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void RecorderController::record_frame(void)
 */
static PyObject *Dtool_RecorderController_record_frame_36(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.record_frame")) {
    return NULL;
  }
  // 1-void RecorderController::record_frame(void)
  (*local_this).record_frame();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_record_frame_36_comment =
  "C++ Interface:\n"
  "record_frame(const RecorderController self)\n"
  "\n"
  "/**\n"
  " * Gets the next frame of data from all of the active recorders and adds it to\n"
  " * the output file.\n"
  " */";
#else
static const char *Dtool_RecorderController_record_frame_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void RecorderController::play_frame(void)
 */
static PyObject *Dtool_RecorderController_play_frame_37(PyObject *self, PyObject *) {
  RecorderController *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecorderController, (void **)&local_this, "RecorderController.play_frame")) {
    return NULL;
  }
  // 1-void RecorderController::play_frame(void)
  (*local_this).play_frame();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_play_frame_37_comment =
  "C++ Interface:\n"
  "play_frame(const RecorderController self)\n"
  "\n"
  "/**\n"
  " * Gets the next frame of data from all of the active recorders and adds it to\n"
  " * the output file.\n"
  " */";
#else
static const char *Dtool_RecorderController_play_frame_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RecorderController::get_class_type(void)
 */
static PyObject *Dtool_RecorderController_get_class_type_38(PyObject *, PyObject *) {
  // 1-static TypeHandle RecorderController::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(RecorderController::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RecorderController_get_class_type_38_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RecorderController_get_class_type_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * RecorderController::RecorderController(void)
 */
static int Dtool_Init_RecorderController(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RecorderController() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-RecorderController::RecorderController(void)
  RecorderController *return_value = new RecorderController();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RecorderController, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RecorderController()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RecorderController(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_RecorderController) {
    printf("RecorderController ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  RecorderController *local_this = (RecorderController *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_RecorderController) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_RecorderController(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_RecorderController) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RecorderController*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RecorderController*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (RecorderController*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SocketStreamRecorder
 */
/**
 * Python function wrapper for:
 * bool SocketStreamRecorder::receive_datagram(Datagram &dg)
 */
static PyObject *Dtool_SocketStreamRecorder_receive_datagram_46(PyObject *self, PyObject *arg) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.receive_datagram")) {
    return NULL;
  }
  // 1-bool SocketStreamRecorder::receive_datagram(Datagram &dg)
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SocketStreamRecorder.receive_datagram", "Datagram");
  }
  bool return_value = (*local_this).receive_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_datagram(const SocketStreamRecorder self, Datagram dg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_receive_datagram_46_comment =
  "C++ Interface:\n"
  "receive_datagram(const SocketStreamRecorder self, Datagram dg)\n"
  "\n"
  "/**\n"
  " * Receives a datagram over the socket by expecting a little-endian 16-bit\n"
  " * byte count as a prefix.  If the socket stream is non-blocking, may return\n"
  " * false if the data is not available; otherwise, returns false only if the\n"
  " * socket closes.\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_receive_datagram_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SocketStreamRecorder::send_datagram(Datagram const &dg)
 */
static PyObject *Dtool_SocketStreamRecorder_send_datagram_47(PyObject *self, PyObject *arg) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.send_datagram")) {
    return NULL;
  }
  // 1-inline bool SocketStreamRecorder::send_datagram(Datagram const &dg)
  Datagram const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SocketStreamRecorder.send_datagram", "Datagram");
  }
  bool return_value = (*local_this).send_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send_datagram(const SocketStreamRecorder self, const Datagram dg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_send_datagram_47_comment =
  "C++ Interface:\n"
  "send_datagram(const SocketStreamRecorder self, const Datagram dg)\n"
  "\n"
  "/**\n"
  " * See SocketStream::send_datagram().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_send_datagram_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SocketStreamRecorder::is_closed(void)
 */
static PyObject *Dtool_SocketStreamRecorder_is_closed_48(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.is_closed")) {
    return NULL;
  }
  // 1-inline bool SocketStreamRecorder::is_closed(void)
  bool return_value = (*local_this).is_closed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_is_closed_48_comment =
  "C++ Interface:\n"
  "is_closed(const SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::is_closed().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_is_closed_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SocketStreamRecorder::close(void)
 */
static PyObject *Dtool_SocketStreamRecorder_close_49(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.close")) {
    return NULL;
  }
  // 1-inline void SocketStreamRecorder::close(void)
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_close_49_comment =
  "C++ Interface:\n"
  "close(const SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::close().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_close_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SocketStreamRecorder::set_collect_tcp(bool collect_tcp)
 */
static PyObject *Dtool_SocketStreamRecorder_set_collect_tcp_50(PyObject *self, PyObject *arg) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.set_collect_tcp")) {
    return NULL;
  }
  // 1-inline void SocketStreamRecorder::set_collect_tcp(bool collect_tcp)
  (*local_this).set_collect_tcp((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collect_tcp(const SocketStreamRecorder self, bool collect_tcp)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_set_collect_tcp_50_comment =
  "C++ Interface:\n"
  "set_collect_tcp(const SocketStreamRecorder self, bool collect_tcp)\n"
  "\n"
  "/**\n"
  " * See SocketStream::set_collect_tcp().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_set_collect_tcp_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SocketStreamRecorder::get_collect_tcp(void) const
 */
static PyObject *Dtool_SocketStreamRecorder_get_collect_tcp_51(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SocketStreamRecorder, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SocketStreamRecorder::get_collect_tcp(void) const
  bool return_value = (*(const SocketStreamRecorder*)local_this).get_collect_tcp();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_get_collect_tcp_51_comment =
  "C++ Interface:\n"
  "get_collect_tcp(SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::get_collect_tcp().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_get_collect_tcp_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SocketStreamRecorder::set_collect_tcp_interval(double interval)
 */
static PyObject *Dtool_SocketStreamRecorder_set_collect_tcp_interval_52(PyObject *self, PyObject *arg) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.set_collect_tcp_interval")) {
    return NULL;
  }
  // 1-inline void SocketStreamRecorder::set_collect_tcp_interval(double interval)
  if (PyNumber_Check(arg)) {
    (*local_this).set_collect_tcp_interval(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collect_tcp_interval(const SocketStreamRecorder self, double interval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_set_collect_tcp_interval_52_comment =
  "C++ Interface:\n"
  "set_collect_tcp_interval(const SocketStreamRecorder self, double interval)\n"
  "\n"
  "/**\n"
  " * See SocketStream::set_collect_tcp_interval().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_set_collect_tcp_interval_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double SocketStreamRecorder::get_collect_tcp_interval(void) const
 */
static PyObject *Dtool_SocketStreamRecorder_get_collect_tcp_interval_53(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SocketStreamRecorder, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double SocketStreamRecorder::get_collect_tcp_interval(void) const
  double return_value = (*(const SocketStreamRecorder*)local_this).get_collect_tcp_interval();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_get_collect_tcp_interval_53_comment =
  "C++ Interface:\n"
  "get_collect_tcp_interval(SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::get_collect_tcp_interval().\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_get_collect_tcp_interval_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SocketStreamRecorder::consider_flush(void)
 */
static PyObject *Dtool_SocketStreamRecorder_consider_flush_54(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.consider_flush")) {
    return NULL;
  }
  // 1-inline bool SocketStreamRecorder::consider_flush(void)
  bool return_value = (*local_this).consider_flush();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_consider_flush_54_comment =
  "C++ Interface:\n"
  "consider_flush(const SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::consider_flush()\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_consider_flush_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SocketStreamRecorder::flush(void)
 */
static PyObject *Dtool_SocketStreamRecorder_flush_55(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.flush")) {
    return NULL;
  }
  // 1-inline bool SocketStreamRecorder::flush(void)
  bool return_value = (*local_this).flush();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_flush_55_comment =
  "C++ Interface:\n"
  "flush(const SocketStreamRecorder self)\n"
  "\n"
  "/**\n"
  " * See SocketStream::flush()\n"
  " */";
#else
static const char *Dtool_SocketStreamRecorder_flush_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SocketStreamRecorder::get_class_type(void)
 */
static PyObject *Dtool_SocketStreamRecorder_get_class_type_56(PyObject *, PyObject *) {
  // 1-static TypeHandle SocketStreamRecorder::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(SocketStreamRecorder::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_get_class_type_56_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SocketStreamRecorder_get_class_type_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * RecorderBase *SocketStreamRecorder::upcast_to_RecorderBase(void)
 */
static PyObject *Dtool_SocketStreamRecorder_upcast_to_RecorderBase_40(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.upcast_to_RecorderBase")) {
    return NULL;
  }
  // 1-RecorderBase *SocketStreamRecorder::upcast_to_RecorderBase(void)
  RecorderBase *return_value = (RecorderBase *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_RecorderBase, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_upcast_to_RecorderBase_40_comment =
  "C++ Interface:\n"
  "upcast_to_RecorderBase(const SocketStreamRecorder self)\n"
  "\n"
  "upcast from SocketStreamRecorder to RecorderBase";
#else
static const char *Dtool_SocketStreamRecorder_upcast_to_RecorderBase_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *SocketStreamRecorder::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_43(PyObject *self, PyObject *) {
  SocketStreamRecorder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStreamRecorder, (void **)&local_this, "SocketStreamRecorder.upcast_to_ReferenceCount")) {
    return NULL;
  }
  // 1-ReferenceCount *SocketStreamRecorder::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_43_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const SocketStreamRecorder self)\n"
  "\n"
  "upcast from SocketStreamRecorder to ReferenceCount";
#else
static const char *Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_43_comment = NULL;
#endif

static int Dtool_Init_SocketStreamRecorder(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_SocketStreamRecorder(PyObject *args, CPT(SocketStreamRecorder) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SocketStreamRecorder, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_SocketStreamRecorder(PyObject *args, PT(SocketStreamRecorder) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SocketStreamRecorder, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_SocketStreamRecorder(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SocketStreamRecorder) {
    printf("SocketStreamRecorder ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SocketStreamRecorder *local_this = (SocketStreamRecorder *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SocketStreamRecorder) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_RecorderBase) {
    return (RecorderBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SocketStreamRecorder(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SocketStreamRecorder) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_RecorderBase) {
    RecorderBase* other_this = (RecorderBase*)from_this;
    return (SocketStreamRecorder*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SocketStreamRecorder*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for RecorderBase (RecorderBase)
 */
static PyMethodDef Dtool_Methods_RecorderBase[] = {
  {"is_recording", &Dtool_RecorderBase_is_recording_3, METH_NOARGS, (const char *)Dtool_RecorderBase_is_recording_3_comment},
  {"isRecording", &Dtool_RecorderBase_is_recording_3, METH_NOARGS, (const char *)Dtool_RecorderBase_is_recording_3_comment},
  {"is_playing", &Dtool_RecorderBase_is_playing_4, METH_NOARGS, (const char *)Dtool_RecorderBase_is_playing_4_comment},
  {"isPlaying", &Dtool_RecorderBase_is_playing_4, METH_NOARGS, (const char *)Dtool_RecorderBase_is_playing_4_comment},
  {"get_class_type", &Dtool_RecorderBase_get_class_type_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_RecorderBase_get_class_type_5_comment},
  {"getClassType", &Dtool_RecorderBase_get_class_type_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_RecorderBase_get_class_type_5_comment},
  {"downcast_to_MouseRecorder", &Dtool_RecorderBase_downcast_to_MouseRecorder_11, METH_NOARGS, (const char *)Dtool_RecorderBase_downcast_to_MouseRecorder_11_comment},
  {"downcastToMouseRecorder", &Dtool_RecorderBase_downcast_to_MouseRecorder_11, METH_NOARGS, (const char *)Dtool_RecorderBase_downcast_to_MouseRecorder_11_comment},
  {"downcast_to_SocketStreamRecorder", &Dtool_RecorderBase_downcast_to_SocketStreamRecorder_41, METH_NOARGS, (const char *)Dtool_RecorderBase_downcast_to_SocketStreamRecorder_41_comment},
  {"downcastToSocketStreamRecorder", &Dtool_RecorderBase_downcast_to_SocketStreamRecorder_41, METH_NOARGS, (const char *)Dtool_RecorderBase_downcast_to_SocketStreamRecorder_41_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_RecorderBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_RecorderBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.RecorderBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_RecorderBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_RecorderBase,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class to a number of objects that record particular kinds\n"
    " * of user input (like a MouseRecorder) to use in conjunction with a\n"
    " * RecorderController to record the user's inputs for a session.\n"
    " *\n"
    " * Note that RecorderBase does not actually inherit from TypedObject, even\n"
    " * though it defines get_type().  The assumption is that the classes that\n"
    " * derive from RecorderBase might also inherit independently from TypedObject.\n"
    " *\n"
    " * It also does not inherit from TypedWritable, but it defines a method called\n"
    " * write_recorder() which is very similar to a TypedWritable's\n"
    " * write_datagram(). Classes that derive from RecorderBase and also inherit\n"
    " * from TypedWritable may choose to remap write_recorder() to do exactly the\n"
    " * same thing as write_datagram(), or they may choose to write something\n"
    " * slightly different.\n"
    " *\n"
    " * Most types of recorders should derive from Recorder, as it derives from\n"
    " * ReferenceCount, except for MouseRecorder, which would otherwise doubly\n"
    " * inherit from ReferenceCount.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_RecorderBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_RecorderBase,
    PyType_GenericAlloc,
    Dtool_new_RecorderBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RecorderBase,
  Dtool_UpcastInterface_RecorderBase,
  Dtool_DowncastInterface_RecorderBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_RecorderBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_RecorderBase._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_RecorderBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RecorderBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RecorderBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RecorderBase);
  }
}

/**
 * Python method tables for MouseRecorder (MouseRecorder)
 */
static PyMethodDef Dtool_Methods_MouseRecorder[] = {
  {"get_class_type", &Dtool_MouseRecorder_get_class_type_13, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseRecorder_get_class_type_13_comment},
  {"getClassType", &Dtool_MouseRecorder_get_class_type_13, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseRecorder_get_class_type_13_comment},
  {"upcast_to_DataNode", &Dtool_MouseRecorder_upcast_to_DataNode_8, METH_NOARGS, (const char *)Dtool_MouseRecorder_upcast_to_DataNode_8_comment},
  {"upcastToDataNode", &Dtool_MouseRecorder_upcast_to_DataNode_8, METH_NOARGS, (const char *)Dtool_MouseRecorder_upcast_to_DataNode_8_comment},
  {"upcast_to_RecorderBase", &Dtool_MouseRecorder_upcast_to_RecorderBase_10, METH_NOARGS, (const char *)Dtool_MouseRecorder_upcast_to_RecorderBase_10_comment},
  {"upcastToRecorderBase", &Dtool_MouseRecorder_upcast_to_RecorderBase_10, METH_NOARGS, (const char *)Dtool_MouseRecorder_upcast_to_RecorderBase_10_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MouseRecorder = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MouseRecorder = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MouseRecorder = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MouseRecorder = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MouseRecorder = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MouseRecorder",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseRecorder,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MouseRecorder,
    &Dtool_SequenceMethods_MouseRecorder,
    &Dtool_MappingMethods_MouseRecorder,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MouseRecorder,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object records any data generated by a particular MouseAndKeyboard\n"
    " * node on the datagraph for a session for eventual playback via a\n"
    " * DataGraphPlayback (and a PlaybackController).  To use it, make it a child\n"
    " * of the node you wish to record.  It also serves as a pass-through, so that\n"
    " * additional child nodes may be parented directly to it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MouseRecorder,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MouseRecorder,
    PyType_GenericAlloc,
    Dtool_new_MouseRecorder,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseRecorder,
  Dtool_UpcastInterface_MouseRecorder,
  Dtool_DowncastInterface_MouseRecorder,
  (CoerceFunction)Dtool_ConstCoerce_MouseRecorder,
  (CoerceFunction)Dtool_Coerce_MouseRecorder,
};

static void Dtool_PyModuleClassInit_MouseRecorder(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != NULL);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(NULL);
    Dtool_PyModuleClassInit_RecorderBase(NULL);
    Dtool_MouseRecorder._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_DataNode, (PyTypeObject *)&Dtool_RecorderBase);
    PyObject *dict = PyDict_New();
    Dtool_MouseRecorder._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseRecorder) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseRecorder)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseRecorder);
  }
}

/**
 * Python method tables for RecorderController (RecorderController)
 */
static PyMethodDef Dtool_Methods_RecorderController[] = {
  {"begin_record", &Dtool_RecorderController_begin_record_17, METH_O, (const char *)Dtool_RecorderController_begin_record_17_comment},
  {"beginRecord", &Dtool_RecorderController_begin_record_17, METH_O, (const char *)Dtool_RecorderController_begin_record_17_comment},
  {"begin_playback", &Dtool_RecorderController_begin_playback_18, METH_O, (const char *)Dtool_RecorderController_begin_playback_18_comment},
  {"beginPlayback", &Dtool_RecorderController_begin_playback_18, METH_O, (const char *)Dtool_RecorderController_begin_playback_18_comment},
  {"close", &Dtool_RecorderController_close_19, METH_NOARGS, (const char *)Dtool_RecorderController_close_19_comment},
  {"get_start_time", &Dtool_RecorderController_get_start_time_20, METH_NOARGS, (const char *)Dtool_RecorderController_get_start_time_20_comment},
  {"getStartTime", &Dtool_RecorderController_get_start_time_20, METH_NOARGS, (const char *)Dtool_RecorderController_get_start_time_20_comment},
  {"set_random_seed", &Dtool_RecorderController_set_random_seed_21, METH_O, (const char *)Dtool_RecorderController_set_random_seed_21_comment},
  {"setRandomSeed", &Dtool_RecorderController_set_random_seed_21, METH_O, (const char *)Dtool_RecorderController_set_random_seed_21_comment},
  {"get_random_seed", &Dtool_RecorderController_get_random_seed_22, METH_NOARGS, (const char *)Dtool_RecorderController_get_random_seed_22_comment},
  {"getRandomSeed", &Dtool_RecorderController_get_random_seed_22, METH_NOARGS, (const char *)Dtool_RecorderController_get_random_seed_22_comment},
  {"is_recording", &Dtool_RecorderController_is_recording_23, METH_NOARGS, (const char *)Dtool_RecorderController_is_recording_23_comment},
  {"isRecording", &Dtool_RecorderController_is_recording_23, METH_NOARGS, (const char *)Dtool_RecorderController_is_recording_23_comment},
  {"is_playing", &Dtool_RecorderController_is_playing_24, METH_NOARGS, (const char *)Dtool_RecorderController_is_playing_24_comment},
  {"isPlaying", &Dtool_RecorderController_is_playing_24, METH_NOARGS, (const char *)Dtool_RecorderController_is_playing_24_comment},
  {"is_open", &Dtool_RecorderController_is_open_25, METH_NOARGS, (const char *)Dtool_RecorderController_is_open_25_comment},
  {"isOpen", &Dtool_RecorderController_is_open_25, METH_NOARGS, (const char *)Dtool_RecorderController_is_open_25_comment},
  {"get_filename", &Dtool_RecorderController_get_filename_26, METH_NOARGS, (const char *)Dtool_RecorderController_get_filename_26_comment},
  {"getFilename", &Dtool_RecorderController_get_filename_26, METH_NOARGS, (const char *)Dtool_RecorderController_get_filename_26_comment},
  {"is_error", &Dtool_RecorderController_is_error_27, METH_NOARGS, (const char *)Dtool_RecorderController_is_error_27_comment},
  {"isError", &Dtool_RecorderController_is_error_27, METH_NOARGS, (const char *)Dtool_RecorderController_is_error_27_comment},
  {"get_clock_offset", &Dtool_RecorderController_get_clock_offset_28, METH_NOARGS, (const char *)Dtool_RecorderController_get_clock_offset_28_comment},
  {"getClockOffset", &Dtool_RecorderController_get_clock_offset_28, METH_NOARGS, (const char *)Dtool_RecorderController_get_clock_offset_28_comment},
  {"get_frame_offset", &Dtool_RecorderController_get_frame_offset_29, METH_NOARGS, (const char *)Dtool_RecorderController_get_frame_offset_29_comment},
  {"getFrameOffset", &Dtool_RecorderController_get_frame_offset_29, METH_NOARGS, (const char *)Dtool_RecorderController_get_frame_offset_29_comment},
  {"add_recorder", (PyCFunction) &Dtool_RecorderController_add_recorder_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RecorderController_add_recorder_30_comment},
  {"addRecorder", (PyCFunction) &Dtool_RecorderController_add_recorder_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RecorderController_add_recorder_30_comment},
  {"has_recorder", &Dtool_RecorderController_has_recorder_31, METH_O, (const char *)Dtool_RecorderController_has_recorder_31_comment},
  {"hasRecorder", &Dtool_RecorderController_has_recorder_31, METH_O, (const char *)Dtool_RecorderController_has_recorder_31_comment},
  {"get_recorder", &Dtool_RecorderController_get_recorder_32, METH_O, (const char *)Dtool_RecorderController_get_recorder_32_comment},
  {"getRecorder", &Dtool_RecorderController_get_recorder_32, METH_O, (const char *)Dtool_RecorderController_get_recorder_32_comment},
  {"remove_recorder", &Dtool_RecorderController_remove_recorder_33, METH_O, (const char *)Dtool_RecorderController_remove_recorder_33_comment},
  {"removeRecorder", &Dtool_RecorderController_remove_recorder_33, METH_O, (const char *)Dtool_RecorderController_remove_recorder_33_comment},
  {"set_frame_tie", &Dtool_RecorderController_set_frame_tie_34, METH_O, (const char *)Dtool_RecorderController_set_frame_tie_34_comment},
  {"setFrameTie", &Dtool_RecorderController_set_frame_tie_34, METH_O, (const char *)Dtool_RecorderController_set_frame_tie_34_comment},
  {"get_frame_tie", &Dtool_RecorderController_get_frame_tie_35, METH_NOARGS, (const char *)Dtool_RecorderController_get_frame_tie_35_comment},
  {"getFrameTie", &Dtool_RecorderController_get_frame_tie_35, METH_NOARGS, (const char *)Dtool_RecorderController_get_frame_tie_35_comment},
  {"record_frame", &Dtool_RecorderController_record_frame_36, METH_NOARGS, (const char *)Dtool_RecorderController_record_frame_36_comment},
  {"recordFrame", &Dtool_RecorderController_record_frame_36, METH_NOARGS, (const char *)Dtool_RecorderController_record_frame_36_comment},
  {"play_frame", &Dtool_RecorderController_play_frame_37, METH_NOARGS, (const char *)Dtool_RecorderController_play_frame_37_comment},
  {"playFrame", &Dtool_RecorderController_play_frame_37, METH_NOARGS, (const char *)Dtool_RecorderController_play_frame_37_comment},
  {"get_class_type", &Dtool_RecorderController_get_class_type_38, METH_NOARGS | METH_STATIC, (const char *)Dtool_RecorderController_get_class_type_38_comment},
  {"getClassType", &Dtool_RecorderController_get_class_type_38, METH_NOARGS | METH_STATIC, (const char *)Dtool_RecorderController_get_class_type_38_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_RecorderController = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RecorderController = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_RecorderController = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_RecorderController = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_RecorderController = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.RecorderController",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_RecorderController,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_RecorderController,
    &Dtool_SequenceMethods_RecorderController,
    &Dtool_MappingMethods_RecorderController,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_RecorderController,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object manages the process of recording the user's runtime inputs to a\n"
    " * bam file so that the session can be recreated later.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_RecorderController,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_RecorderController,
    PyType_GenericAlloc,
    Dtool_new_RecorderController,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RecorderController,
  Dtool_UpcastInterface_RecorderController,
  Dtool_DowncastInterface_RecorderController,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_RecorderController(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_RecorderController._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_RecorderController._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RecorderController) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RecorderController)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RecorderController);
  }
}

/**
 * Python method tables for SocketStreamRecorder (SocketStreamRecorder)
 */
static PyMethodDef Dtool_Methods_SocketStreamRecorder[] = {
  {"receive_datagram", &Dtool_SocketStreamRecorder_receive_datagram_46, METH_O, (const char *)Dtool_SocketStreamRecorder_receive_datagram_46_comment},
  {"receiveDatagram", &Dtool_SocketStreamRecorder_receive_datagram_46, METH_O, (const char *)Dtool_SocketStreamRecorder_receive_datagram_46_comment},
  {"send_datagram", &Dtool_SocketStreamRecorder_send_datagram_47, METH_O, (const char *)Dtool_SocketStreamRecorder_send_datagram_47_comment},
  {"sendDatagram", &Dtool_SocketStreamRecorder_send_datagram_47, METH_O, (const char *)Dtool_SocketStreamRecorder_send_datagram_47_comment},
  {"is_closed", &Dtool_SocketStreamRecorder_is_closed_48, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_is_closed_48_comment},
  {"isClosed", &Dtool_SocketStreamRecorder_is_closed_48, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_is_closed_48_comment},
  {"close", &Dtool_SocketStreamRecorder_close_49, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_close_49_comment},
  {"set_collect_tcp", &Dtool_SocketStreamRecorder_set_collect_tcp_50, METH_O, (const char *)Dtool_SocketStreamRecorder_set_collect_tcp_50_comment},
  {"setCollectTcp", &Dtool_SocketStreamRecorder_set_collect_tcp_50, METH_O, (const char *)Dtool_SocketStreamRecorder_set_collect_tcp_50_comment},
  {"get_collect_tcp", &Dtool_SocketStreamRecorder_get_collect_tcp_51, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_get_collect_tcp_51_comment},
  {"getCollectTcp", &Dtool_SocketStreamRecorder_get_collect_tcp_51, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_get_collect_tcp_51_comment},
  {"set_collect_tcp_interval", &Dtool_SocketStreamRecorder_set_collect_tcp_interval_52, METH_O, (const char *)Dtool_SocketStreamRecorder_set_collect_tcp_interval_52_comment},
  {"setCollectTcpInterval", &Dtool_SocketStreamRecorder_set_collect_tcp_interval_52, METH_O, (const char *)Dtool_SocketStreamRecorder_set_collect_tcp_interval_52_comment},
  {"get_collect_tcp_interval", &Dtool_SocketStreamRecorder_get_collect_tcp_interval_53, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_get_collect_tcp_interval_53_comment},
  {"getCollectTcpInterval", &Dtool_SocketStreamRecorder_get_collect_tcp_interval_53, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_get_collect_tcp_interval_53_comment},
  {"consider_flush", &Dtool_SocketStreamRecorder_consider_flush_54, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_consider_flush_54_comment},
  {"considerFlush", &Dtool_SocketStreamRecorder_consider_flush_54, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_consider_flush_54_comment},
  {"flush", &Dtool_SocketStreamRecorder_flush_55, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_flush_55_comment},
  {"get_class_type", &Dtool_SocketStreamRecorder_get_class_type_56, METH_NOARGS | METH_STATIC, (const char *)Dtool_SocketStreamRecorder_get_class_type_56_comment},
  {"getClassType", &Dtool_SocketStreamRecorder_get_class_type_56, METH_NOARGS | METH_STATIC, (const char *)Dtool_SocketStreamRecorder_get_class_type_56_comment},
  {"upcast_to_RecorderBase", &Dtool_SocketStreamRecorder_upcast_to_RecorderBase_40, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_upcast_to_RecorderBase_40_comment},
  {"upcastToRecorderBase", &Dtool_SocketStreamRecorder_upcast_to_RecorderBase_40, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_upcast_to_RecorderBase_40_comment},
  {"upcast_to_ReferenceCount", &Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_43, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_43_comment},
  {"upcastToReferenceCount", &Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_43, METH_NOARGS, (const char *)Dtool_SocketStreamRecorder_upcast_to_ReferenceCount_43_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SocketStreamRecorder = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SocketStreamRecorder = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SocketStreamRecorder = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SocketStreamRecorder = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SocketStreamRecorder = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SocketStreamRecorder",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SocketStreamRecorder,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SocketStreamRecorder,
    &Dtool_SequenceMethods_SocketStreamRecorder,
    &Dtool_MappingMethods_SocketStreamRecorder,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SocketStreamRecorder,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Records any data received from the indicated socket stream.  On playback,\n"
    " * it will act as if the incoming data is coming over the wire again even if\n"
    " * an actual connection is not available.\n"
    " *\n"
    " * Outbound data will not be recorded, but will be sent straight through to\n"
    " * the socket if it is connected, or silently ignored if it is not.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SocketStreamRecorder,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SocketStreamRecorder,
    PyType_GenericAlloc,
    Dtool_new_SocketStreamRecorder,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SocketStreamRecorder,
  Dtool_UpcastInterface_SocketStreamRecorder,
  Dtool_DowncastInterface_SocketStreamRecorder,
  (CoerceFunction)Dtool_ConstCoerce_SocketStreamRecorder,
  (CoerceFunction)Dtool_Coerce_SocketStreamRecorder,
};

static void Dtool_PyModuleClassInit_SocketStreamRecorder(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RecorderBase(NULL);
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_SocketStreamRecorder._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_RecorderBase, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_SocketStreamRecorder._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SocketStreamRecorder) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SocketStreamRecorder)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SocketStreamRecorder);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3recorder_RegisterTypes() {
  Dtool_RecorderBase._type = RecorderBase::get_class_type();
  RegisterRuntimeTypedClass(Dtool_RecorderBase);
  Dtool_MouseRecorder._type = MouseRecorder::get_class_type();
  RegisterRuntimeTypedClass(Dtool_MouseRecorder);
  Dtool_RecorderController._type = RecorderController::get_class_type();
  RegisterRuntimeTypedClass(Dtool_RecorderController);
  Dtool_SocketStreamRecorder._type = SocketStreamRecorder::get_class_type();
  RegisterRuntimeTypedClass(Dtool_SocketStreamRecorder);
}

void Dtool_libp3recorder_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_Datagram = LookupRuntimeTypedClass(Datagram::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_DataNode = LookupRuntimeTypedClass(DataNode::get_class_type());
#endif
}

void Dtool_libp3recorder_BuildInstants(PyObject *module) {
  (void) module;
  // RecorderBase
  Dtool_PyModuleClassInit_RecorderBase(module);
  PyModule_AddObject(module, "RecorderBase", (PyObject *)&Dtool_RecorderBase);
  // MouseRecorder
  Dtool_PyModuleClassInit_MouseRecorder(module);
  PyModule_AddObject(module, "MouseRecorder", (PyObject *)&Dtool_MouseRecorder);
  // RecorderController
  Dtool_PyModuleClassInit_RecorderController(module);
  PyModule_AddObject(module, "RecorderController", (PyObject *)&Dtool_RecorderController);
  // SocketStreamRecorder
  Dtool_PyModuleClassInit_SocketStreamRecorder(module);
  PyModule_AddObject(module, "SocketStreamRecorder", (PyObject *)&Dtool_SocketStreamRecorder);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3recorder_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478213636,  /* file_identifier */
  "libp3recorder",  /* library_name */
  "ayCl",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3recorder.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  131  /* next_index */
};

Configure(_in_configure_libp3recorder);
ConfigureFn(_in_configure_libp3recorder) {
  interrogate_request_module(&_in_module_def);
}

